<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="从零实现标准库 net&amp;#x2F;rpc，新增了协议交换、注册中心、服务发现、负载均衡、超时处理等特性。"><title>从零实现系列｜RPC - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/post_banner.webp-ss) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="从零实现系列｜RPC"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-10-18 22:36" pubdate>2024-10-18 PM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 109k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 82 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">从零实现系列｜RPC</h1><div class="markdown-body"><h2 id="0-序言">0.序言</h2><h3 id="为什么需要-RPC">为什么需要 RPC</h3><p>最直观得是，客户端可以像调用本地程序一样，进行远程调用，使用者无需关注内部的实现细节。</p><p>另外一种广泛使用的调用方式是基于 HTTP 协议得 Restful API，让 gpt 总结一下。</p><table><thead><tr><th style="text-align:center">对比维度</th><th style="text-align:center">Restful API</th><th style="text-align:center">RPC</th></tr></thead><tbody><tr><td style="text-align:center"><strong>协议</strong></td><td style="text-align:center">基于 HTTP 协议（如 HTTPS）</td><td style="text-align:center">通常使用自定义协议（如 TCP 或高效二进制协议）</td></tr><tr><td style="text-align:center"><strong>通信方式</strong></td><td style="text-align:center">基于 HTTP 的请求-响应模型（如 GET/POST）</td><td style="text-align:center">类似本地方法调用的请求-响应模型（对开发者透明）</td></tr><tr><td style="text-align:center"><strong>报文格式</strong></td><td style="text-align:center">文本格式（JSON/XML），冗余较多</td><td style="text-align:center">二进制编码（如 Protobuf），精简高效</td></tr><tr><td style="text-align:center"><strong>性能</strong></td><td style="text-align:center">较低（文本解析、冗余数据）</td><td style="text-align:center">较高（二进制压缩、高效序列化）</td></tr><tr><td style="text-align:center"><strong>使用场景</strong></td><td style="text-align:center">通用性强，适合跨语言、对外的开放接口</td><td style="text-align:center">高性能要求高，适合内部服务间通信</td></tr><tr><td style="text-align:center"><strong>可扩展性</strong></td><td style="text-align:center">扩展依赖网关等中间件，功能相对固定</td><td style="text-align:center">原生支持注册中心、负载均衡、超时处理等扩展功能</td></tr><tr><td style="text-align:center"><strong>抽象模型</strong></td><td style="text-align:center"><strong>面向资源</strong>的抽象，通过 URI 唯一标识资源，通过 HTTP 方法定义操作</td><td style="text-align:center"><strong>面向过程</strong>的抽象，客户端直接调用服务端的函数或方法</td></tr></tbody></table><h3 id="RPC-框架需要解决哪些问题">RPC 框架需要解决哪些问题</h3><ul><li><p>通信协议：如何选择传输协议（TCP/HTTP/Unix Socket）？如何设计协议格式（如报文头、体结构）？</p></li><li><p>编码方式：如何高效编码/解码数据？如何压缩报文？</p></li><li><p>可用性问题</p><ul><li>超时处理：超时控制（如客户端连接超时、服务端处理超时）避免资源阻塞。</li><li>请求管理：如何支持并发请求、异步请求？</li></ul></li><li><p>服务治理组件</p><ul><li>注册中心：服务动态注册与发现，健康检查（心跳机制）</li><li>负载均衡：如何分配请求到多个服务实例？</li></ul></li></ul><p>以上种种，业务之外的公共能力，RPC 框架均需具备。</p><p><strong>注意</strong>：RPC 框架主要实现的是 client stub、server stub，为用户封装细节。</p><blockquote><p>对于 stub 不了解，可以看了解：<a href="https://www.aimtao.net/rpc#1-4-RPC-%E5%BC%80%E5%8F%91%E7%9A%84%E8%A6%81%E7%B4%A0">RPC 开发的四大要素</a></p></blockquote><p><img src="https://hutu.aimtao.net/mark/2022-07-03-CaL2S1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="市面上的-RPC-框架-有哪些">市面上的 RPC 框架 有哪些</h3><table><thead><tr><th style="text-align:center">框架名称</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>net/rpc</strong></td><td style="text-align:center">Go 标准库，轻量级，支持 TCP/HTTP 协议，默认使用 Gob 编码</td></tr><tr><td style="text-align:center"><strong>gRPC</strong></td><td style="text-align:center">Google 开源，基于 HTTP/2 和 Protobuf，跨语言，高性能，支持流式通信</td></tr><tr><td style="text-align:center"><strong>rpcx</strong></td><td style="text-align:center">高性能、支持多种编码（JSON/Protobuf），集成注册中心、负载均衡</td></tr><tr><td style="text-align:center"><strong>go-micro</strong></td><td style="text-align:center">微服务框架，包含 RPC 模块，支持插件化（注册中心、编码协议等）</td></tr></tbody></table><h3 id="本文如何从零实现-RPC-框架">本文如何从零实现 RPC 框架</h3><ol><li>从零实现标准库 <code>net/rpc</code></li><li>新增了协议交换（protocol exchange）、注册中心（registry）、服务发现（service discovery）、负载均衡（load balance）、超时处理（timeout processing）等特性</li></ol><h2 id="1-服务端与消息编码">1.服务端与消息编码</h2><h3 id="如何设计一个-RPC-请求">如何设计一个 RPC 请求</h3><p>这个问题也可以问成：一个 RPC 请求，应该传入传出什么数据，选择使用什么数据结构？</p><p>举个例子：一个典型的 RPC 调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err = client.Call(<span class="hljs-string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply)<br></code></pre></td></tr></table></figure><ul><li><code>Arith.Multiply</code>：服务名 <code>Arith</code> 和方法名 <code>Multipy</code>。</li><li><code>args</code>：传入参数</li><li><code>reply</code>：传出参数</li></ul><p>我们将服务名、方法名放在请求的 header 中，传输传出参数放在 body 中。</p><p>其中 header 定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>    ServiceMethod <span class="hljs-type">string</span> <span class="hljs-comment">// 服务名和方法名</span><br>    Seq           <span class="hljs-type">uint64</span> <span class="hljs-comment">// 请求序号</span><br>    Error         <span class="hljs-type">string</span> <span class="hljs-comment">// 客户端置为空，服务端如何出现错误，将错误信息写入Error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用什么编解码方式进行编解码">用什么编解码方式进行编解码</h3><p>编码方式可以选择 json、gob、protobuf 等等，为了更好的兼容性，我们抽象出来 Codec 的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-comment">// Codec 接口：对消息体进行编码，比如 Gob、Json 会实现该接口，代表两种编码方式</span><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">interface</span> &#123;<br>    io.Closer<br>    ReadHeader(*Header) <span class="hljs-type">error</span><br>    ReadBody(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>    Write(*Header, <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后想使用哪个编码方式都可以，只要实现了 Codec 接口即可。</p><p>将各个编解码方式名称硬编码保存下来，并使用 map 保存各个编解码方式的构造函数。所以使用的流程是，通过编解码方式名称获取到该编解码方式的构造函数，调用该构造函数，创建编解码的实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-keyword">type</span> Type <span class="hljs-type">string</span><br><span class="hljs-keyword">const</span> (<br>    GobType  Type = <span class="hljs-string">&quot;application/gob&quot;</span><br>    JsonType Type = <span class="hljs-string">&quot;application/json&quot;</span><br>)<br><br><span class="hljs-comment">// NewCodecFunc Codec 接口类型的构造函数</span><br><span class="hljs-keyword">type</span> NewCodecFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(io.ReadWriteCloser)</span></span> Codec<br><br><span class="hljs-comment">// NewCodecFuncMap 通过 type 来选择对应的 codec 的构造函数</span><br><span class="hljs-keyword">var</span> NewCodecFuncMap <span class="hljs-keyword">map</span>[Type]NewCodecFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    NewCodecFuncMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]NewCodecFunc)<br>    NewCodecFuncMap[GobType] = NewGobCodec <span class="hljs-comment">// 赋值为 Gob codec 的构造函数（NewGobCodec 为 Gob codec 的构造函数，在 codec/gob.go 实现。）</span><br>    <span class="hljs-comment">//NewCodecFuncMap[JsonType] = NewJsonCodec  // 赋值为 Json codec 的构造函数, 暂不实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现编解码方式的接口">如何实现编解码方式的接口</h3><p>下面将以 Gob 为例，说明如何实现 Codec 接口。先定义 Gob 编解码的结构体 GobCodec 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-keyword">type</span> GobCodec <span class="hljs-keyword">struct</span> &#123;<br>    conn io.ReadWriteCloser<br>    buf  *bufio.Writer <span class="hljs-comment">// 使用缓冲流来提高性能，防止阻塞</span><br>    dec  *gob.Decoder<br>    enc  *gob.Encoder<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 Codec 的接口函数，主要是封装 encoding/gob 的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-comment">// ReadHeader 封装了 encoding/gob 的 Decode 方法，从连接中读取 Header 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadHeader(header *Header) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(header)<br>&#125;<br><br><span class="hljs-comment">// ReadBody 封装了 encoding/gob 的 Decode 方法，从连接中读取 Body 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadBody(body <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(body)<br>&#125;<br><br><span class="hljs-comment">// Write 封装了 encoding/gob 的 Encode 方法，将 Header 和 Body 信息写入连接中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Write(header *Header, body <span class="hljs-keyword">interface</span>&#123;&#125;) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 关闭前，先将 buf 中的数据写入连接中</span><br>        _ = c.buf.Flush()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            _ = c.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(header); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding header: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding body: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Close 封装了 io.ReadWriteCloser 的 Close 方法，关闭连接</span><br><span class="hljs-comment">// io.ReadWriteCloser 包含 io.Closer 类型，io.Closer 类型包含 Close 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.conn.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再实现 GobCodec 的构造函数，方便初始化时，传给 Codec 接口变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGobCodec</span><span class="hljs-params">(conn io.ReadWriteCloser)</span></span> Codec &#123;<br>    buf := bufio.NewWriter(conn)<br>    <span class="hljs-keyword">return</span> &amp;GobCodec&#123;<br>        conn: conn,<br>        buf:  buf,<br>        dec:  gob.NewDecoder(conn),<br>        enc:  gob.NewEncoder(buf),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>P.S. <strong>为什么 GobCodec 需要加一个 buf ？</strong></p><p>用于缓冲写入操作，减少系统调用次数。如果没有 buf，每次小数据写入直接触发系统调用，增加延迟；频繁的 I/O 操作，影响性能。</p><h3 id="通信过程如何协商编码方式">通信过程如何协商编码方式</h3><p>以 HTTP 报文为例，HTTP 报文分为 header 和 body 两个部分。客户端和服务端收发消息时，只需要先解析 header 部分，就知道 body 的格式 Content-Type、长度 Content-Length。</p><p>在 RPC 协议的报文里，为了提升性能，仅在报文最开始规划固定的字节，来协商编码方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span>  <span class="hljs-comment">// 验证连接的合法性，确保客户端和服务端使用同一协议</span><br>    CodecType   codec.Type  <span class="hljs-comment">// 编码方式的名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以实际的报文是这样的。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Option </span>|<span class="hljs-string"> Header1 </span>|<span class="hljs-string"> Body1 </span>|<span class="hljs-string"> Header2 </span>|<span class="hljs-string"> Body2 </span>|<span class="hljs-string"> ...</span><br></code></pre></td></tr></table></figure><p>那 Option 使用什么编码方式呢？</p><p>为了方便，我们可以规定，Option 使用 JSON 编码，后面的 header、body 使用 Option 规定的编解码方式编解码。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">| <span class="hljs-type">Option</span>&#123;MagicNumber: xxx, CodecType: xxx&#125; | <span class="hljs-type">Header</span>&#123;ServiceMethod ...&#125; | <span class="hljs-type">Body</span> interface&#123;&#125; |<br><span class="hljs-type">| &lt;------    Option</span> 固定使用 JSON 编码      ------&gt;  | <span class="hljs-type">&lt;-------   Header</span>/Body 编码方式由 CodeType 决定   -------&gt;|<span class="hljs-type"></span><br></code></pre></td></tr></table></figure><h3 id="如何实现一个服务端">如何实现一个服务端</h3><p>先看一下，服务端要做什么，要实现哪些功能。</p><ul><li>建立连接：实现 Accept 方法，等待 socket 连接，并开启协程处理请求。</li><li>处理请求：<ul><li>解析 Option 信息，检查 Option.MagicNumber 是匹配，根据 Option.CodecType 实例化编解码器。</li><li>读取请求：使用编解码器实例解码 header 和 body。</li><li>处理请求。</li><li>回复请求。</li></ul></li></ul><p>搞清楚需要实现哪些功能，就可以开始具体实现了。（可以先看主要的调用流程，具体实现实现细节晚点再看）</p><ul><li>服务器实例的构造函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;  <span class="hljs-comment">// 肚子里没什么要放的</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</p><ul><li><code>json.NewDecoder(conn).Decode(&amp;opt)</code> 的含义？<ul><li><code>json.NewDecoder(conn)</code> 创建一个从连接读取JSON数据的解码器 <code>*Decoder</code>；</li><li><code>*Decoder.Decode(&amp;opt)</code> 将JSON数据解码到 opt 结构体中，一次只读一个 JSON。</li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>       log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;  <span class="hljs-comment">// 验证 MagicNumber，证明请求合法</span><br>       log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]  <span class="hljs-comment">// 获取编解码器的构造函数</span><br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>       log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求。<ul><li>使用协程来并发处理请求。</li><li>使用 <code>sync.WaitGroup</code> 保证即使因为读请求出错退出循环，也等待所有协程请求处理完成再关闭连接，优雅终止。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg) <span class="hljs-comment">// 使用协程来并发处理请求。</span><br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 即使因为读请求出错退出循环，也需要等待所有协程请求处理完成再关闭连接，优雅终止。</span><br>    _ = cc.Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>readRequest 读取请求：调用 readRequestHeader 方法读取请求头，再调用 ReadBody 方法读取请求参数，返回 request 结构体</p><ul><li>这里定义了请求体的结构体 request，其中，h 储存 header，argv 储存传入参数，replyValue 储存传出参数，也就是返回值。</li><li>readRequestHeader 就是进一步调用 编解码器 的 ReadHeader 方法，这里的编解码器是 gob。gob 的 ReadHeader 方法是封装的 encoding/gob 的 Decode 方法。ReadBody 同理。</li></ul></li><li><p>什么是 <code>reflect.Value</code> 类型？</p><ul><li>两个前置知识：具体看 <a href="https://www.aimtao.net/go#11-reflect">reflect</a><ul><li>每个 <code>interface&#123;&#125;</code> 类型的变量都包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</li><li><strong>反射就是把 <code>interface&#123;&#125;</code> 类型变量转化为 reflect.Value 或 reflect.Type 类型变量，随后用 reflect 包中的方法对它们进行各种操作</strong>。</li></ul></li><li><code>reflect.Value</code> 是反射值，是描述值的一个容器。</li></ul></li><li><p>argv 和 replyValue 为什么都是 <code>reflect.Value</code> 类型呢？</p><ul><li>因为对于服务端来说，他并不知道客户端会调用哪个具体的方法、要传入什么类型的参数、要传出什么类型的参数。</li><li>所以需要在运行时，动态地获取参数类型和返回值类型，并取指和赋值。</li></ul></li><li><p><code>req.argv = reflect.New(reflect.TypeOf(&quot;&quot;))</code> 的含义？</p><ul><li><code>reflect.TypeOf(&quot;&quot;)</code> 获取空字符串的类型信息，得到 reflect.Type 类型变量，描述 string 类型。</li><li><code>reflect.New(t)</code> 创建一个该类型 t 的指针值，返回一个 <code>reflect.Value</code> 对象，实际内部是一个指针类型，指针类型为 *t，这里也就是描述 *string 类型的容器。（相当于 <code>new(string)</code> ）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 举个例子</span><br>v := reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))  <span class="hljs-comment">// v 是 reflect.Value, 类型是 *string</span><br>fmt.Println(v.Type())                 <span class="hljs-comment">// 输出 *string</span><br>fmt.Println(v.Elem().Type())          <span class="hljs-comment">// 输出 string</span><br>v.Elem().SetString(<span class="hljs-string">&quot;hello&quot;</span>)           <span class="hljs-comment">// 设置值</span><br>fmt.Println(v.Elem().Interface())     <span class="hljs-comment">// 输出 hello</span><br><br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>      <span class="hljs-comment">// 声明字符串变量</span><br>ptr := &amp;s         <span class="hljs-comment">// 获取指针</span><br>v = reflect.ValueOf(ptr)  <span class="hljs-comment">// 包装为 reflect.Value</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h                *codec.Header <span class="hljs-comment">// 读到的请求头</span><br>    argv, replyValue reflect.Value <span class="hljs-comment">// argv 储存传入参数，replyValue 储存传出参数。reflect.Value 是反射值，是描述值的一个容器。</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    req := request&#123;<br>        h: h,<br>    &#125;<br><br>    req.argv = reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))               <span class="hljs-comment">// 初始化传入参数，使用 New 方法创建一个表示 *string 类型值的反射值。reflect.Value 是描述值的一个容器。</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(req.argv.Interface()); err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 读取请求参数，ReadBody 函数的参数类型是 interface&#123;&#125;，需要使用 Interface() 方法，将 reflect.Value 转化为 interface&#123;&#125; 类型</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: read body error: &quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>handleRequest 处理请求：这部分目前处理的比较简单，主要是根据请求，构造请求的响应信息，并通过 sendResponse 发送给请求方。<ul><li>为什么要加锁？处理请求可以并发的读，但是发送数据不能并发写入链接，否则多个回复报文交织在一起，影响客户端解析。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    log.Println(<span class="hljs-string">&quot;handleRequest: &quot;</span>, req.h, req.argv.Elem())<br>    req.replyValue = reflect.ValueOf(fmt.Sprintf(<span class="hljs-string">&quot;geerpc resp %d&quot;</span>, req.h.Seq)) <span class="hljs-comment">// 构造请求的响应信息</span><br>    server.sendResponse(cc, req.h, req.replyValue.Interface(), sending)        <span class="hljs-comment">// 发送响应</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现一个客户端">如何实现一个客户端</h3><p>这里在 main 函数中实现一个简易的客户端，验证一下 server 的功能。</p><p>客户端主要做的事：</p><ul><li>连接到服务器</li><li>构造 header 和 body，发送请求</li><li>接收请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main/main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-comment">// 启动服务端</span><br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    <span class="hljs-comment">// 以下是客户端的逻辑</span><br>    addrString := &lt;-addr<br>    fmt.Println(addrString)<br>    conn, _ := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addrString) <span class="hljs-comment">// 建立到服务端的连接</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    time.Sleep(time.Second)<br><br>    _ = json.NewEncoder(conn).Encode(geerpc.DefaultOption)            <span class="hljs-comment">// 将 DefaultOption 以 JSON 格式编码，并发给服务端，用于协商 RPC 通信参数</span><br>    cc := codec.NewCodecFuncMap[geerpc.DefaultOption.CodecType](conn) <span class="hljs-comment">// 根据 DefaultOption 中的 CodecType 选择对应的 codec</span><br><br>    <span class="hljs-comment">// 发送 5 个请求并接收响应</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        h := &amp;codec.Header&#123; <span class="hljs-comment">// 构造请求头</span><br>            ServiceMethod: <span class="hljs-string">&quot;Foo.Sum&quot;</span>,<br>            Seq:           <span class="hljs-type">uint64</span>(i),<br>        &#125;<br><br>        <span class="hljs-comment">// 发送 header 和 body，其中 body 是一个字符串，格式为 &quot;geerpc req %d&quot;</span><br>        _ = cc.Write(h, fmt.Sprintf(<span class="hljs-string">&quot;geerpc req %d&quot;</span>, h.Seq))<br><br>        <span class="hljs-keyword">var</span> replyHeader codec.Header<br>        _ = cc.ReadHeader(&amp;replyHeader) <span class="hljs-comment">// 读取响应头</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>        _ = cc.ReadBody(&amp;reply) <span class="hljs-comment">// 读取响应体</span><br>        log.Println(<span class="hljs-string">&quot;main: reply: &quot;</span>, replyHeader, reply)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 监听随机可以用的端口</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;startServer: start rpc server on&quot;</span>, listen.Addr())<br><br>    <span class="hljs-comment">// 将监听地址返回给主协程</span><br>    addr &lt;- listen.Addr().String()<br>    geerpc.Accept(listen) <span class="hljs-comment">// 开始处理连接</span><br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">[::]:43017</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 0 &#125; geerpc req 0</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 0 &#125; geerpc resp 0</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 1 &#125; geerpc req 1</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 1 &#125; geerpc resp 1</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 2 &#125; geerpc req 2</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 2 &#125; geerpc resp 2</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 3 &#125; geerpc req 3</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 3 &#125; geerpc resp 3</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 4 &#125; geerpc req 4</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 4 &#125; geerpc resp 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_1_codec<br>├── codec<br>│   ├── codec.go  <span class="hljs-comment"># 编码方式的抽象接口</span><br>│   └── gob.go  <span class="hljs-comment"># 实现 Codec 接口</span><br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 简易客户端，发送请求</span><br>└── server.go  <span class="hljs-comment"># 服务端 stub，接受请求</span><br></code></pre></td></tr></table></figure><div class="fold collapsed"><div class="fold-title">codec/codec.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个抽象的 Codec 接口，Codec 接口包含了对消息体的编码和解码操作</span><br><span class="hljs-comment">// 具体的编码方式（如 Gob、Json）会来实现该接口</span><br><br><span class="hljs-keyword">package</span> codec<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;io&quot;</span><br><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>    ServiceMethod <span class="hljs-type">string</span> <span class="hljs-comment">// 服务名和方法名</span><br>    Seq           <span class="hljs-type">uint64</span> <span class="hljs-comment">// 请求序号</span><br>    Error         <span class="hljs-type">string</span> <span class="hljs-comment">// 客户端置为空，服务端如何出现错误，将错误信息写入Error</span><br>&#125;<br><br><span class="hljs-comment">// Codec 接口：对消息体进行编码，比如 Gob、Json 会实现该接口，代表两种编码方式</span><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">interface</span> &#123;<br>    io.Closer<br>    ReadHeader(*Header) <span class="hljs-type">error</span><br>    ReadBody(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>    Write(*Header, <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Type <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>    GobType  Type = <span class="hljs-string">&quot;application/gob&quot;</span><br>    JsonType Type = <span class="hljs-string">&quot;application/json&quot;</span><br>)<br><br><span class="hljs-comment">// NewCodecFunc Codec 接口类型的构造函数</span><br><span class="hljs-keyword">type</span> NewCodecFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(io.ReadWriteCloser)</span></span> Codec<br><br><span class="hljs-comment">// NewCodecFuncMap 通过 type 来选择对应的 codec 的构造函数</span><br><span class="hljs-keyword">var</span> NewCodecFuncMap <span class="hljs-keyword">map</span>[Type]NewCodecFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    NewCodecFuncMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]NewCodecFunc)<br>    NewCodecFuncMap[GobType] = NewGobCodec <span class="hljs-comment">// 赋值为 Gob codec 的构造函数</span><br>    <span class="hljs-comment">//NewCodecFuncMap[JsonType] = NewJsonCodec  // 赋值为 Json codec 的构造函数, 暂不实现</span><br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">codec/gob.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 Gob 编码方式的结构体，对 encoding/gob 进行了封装，实现了 Codec 接口</span><br><br><span class="hljs-keyword">package</span> codec<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;encoding/gob&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> GobCodec <span class="hljs-keyword">struct</span> &#123;<br>    conn io.ReadWriteCloser<br>    buf  *bufio.Writer <span class="hljs-comment">// 使用缓冲流来提高性能，防止阻塞</span><br>    dec  *gob.Decoder<br>    enc  *gob.Encoder<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGobCodec</span><span class="hljs-params">(conn io.ReadWriteCloser)</span></span> Codec &#123;<br>    buf := bufio.NewWriter(conn)<br>    <span class="hljs-keyword">return</span> &amp;GobCodec&#123;<br>        conn: conn,<br>        buf:  buf,<br>        dec:  gob.NewDecoder(conn),<br>        enc:  gob.NewEncoder(buf),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ReadHeader 封装了 encoding/gob 的 Decode 方法，从连接中读取 Header 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadHeader(header *Header) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(header)<br>&#125;<br><br><span class="hljs-comment">// ReadBody 封装了 encoding/gob 的 Decode 方法，从连接中读取 Body 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadBody(body <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(body)<br>&#125;<br><br><span class="hljs-comment">// Write 封装了 encoding/gob 的 Encode 方法，将 Header 和 Body 信息写入连接中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Write(header *Header, body <span class="hljs-keyword">interface</span>&#123;&#125;) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 关闭前，先将 buf 中的数据写入连接中</span><br>        _ = c.buf.Flush()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            _ = c.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(header); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding header: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding body: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Close 封装了 io.ReadWriteCloser 的 Close 方法，关闭连接</span><br><span class="hljs-comment">// io.ReadWriteCloser 包含 io.Closer 类型，io.Closer 类型包含 Close 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.conn.Close()<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">server.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span> <span class="hljs-comment">// 验证连接的合法性，确保客户端和服务端使用同一协议</span><br>    CodecType   codec.Type<br>&#125;<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg) <span class="hljs-comment">// 使用协程来并发处理请求。</span><br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 即使因为读请求出错退出循环，也需要等待所有协程请求处理完成再关闭连接，优雅终止。</span><br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h                *codec.Header <span class="hljs-comment">// 读到的请求头</span><br>    argv, replyValue reflect.Value <span class="hljs-comment">// argv 储存传入参数，replyValue 储存传出参数。reflect.Value 是反射值，是描述值的一个容器。</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    req := request&#123;<br>        h: h,<br>    &#125;<br><br>    req.argv = reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))               <span class="hljs-comment">// 初始化传入参数，使用 New 方法创建一个表示 *string 类型值的反射值。reflect.Value 是描述值的一个容器。</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(req.argv.Interface()); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 读取请求参数，ReadBody 函数的参数类型是 interface&#123;&#125;，需要使用 Interface() 方法，将 reflect.Value 转化为 interface&#123;&#125; 类型</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: read body error: &quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    log.Println(<span class="hljs-string">&quot;handleRequest: &quot;</span>, req.h, req.argv.Elem())<br>    req.replyValue = reflect.ValueOf(fmt.Sprintf(<span class="hljs-string">&quot;geerpc resp %d&quot;</span>, req.h.Seq)) <span class="hljs-comment">// 构造请求的响应信息</span><br>    server.sendResponse(cc, req.h, req.replyValue.Interface(), sending)        <span class="hljs-comment">// 发送响应</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber: MagicNumber,<br>    CodecType:   codec.GobType,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">main/main.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-comment">// 启动服务端</span><br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    <span class="hljs-comment">// 以下是客户端的逻辑</span><br>    addrString := &lt;-addr<br>    fmt.Println(addrString)<br>    conn, _ := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addrString) <span class="hljs-comment">// 建立到服务端的连接</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    time.Sleep(time.Second)<br><br>    _ = json.NewEncoder(conn).Encode(geerpc.DefaultOption)            <span class="hljs-comment">// 将 DefaultOption 以 JSON 格式编码，并发给服务端，用于协商 RPC 通信参数</span><br>    cc := codec.NewCodecFuncMap[geerpc.DefaultOption.CodecType](conn) <span class="hljs-comment">// 根据 DefaultOption 中的 CodecType 选择对应的 codec</span><br><br>    <span class="hljs-comment">// 发送 5 个请求并接收响应</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        h := &amp;codec.Header&#123; <span class="hljs-comment">// 构造请求头</span><br>            ServiceMethod: <span class="hljs-string">&quot;Foo.Sum&quot;</span>,<br>            Seq:           <span class="hljs-type">uint64</span>(i),<br>        &#125;<br><br>        <span class="hljs-comment">// 发送 header 和 body，其中 body 是一个字符串，格式为 &quot;geerpc req %d&quot;</span><br>        _ = cc.Write(h, fmt.Sprintf(<span class="hljs-string">&quot;geerpc req %d&quot;</span>, h.Seq))<br><br>        <span class="hljs-keyword">var</span> replyHeader codec.Header<br>        _ = cc.ReadHeader(&amp;replyHeader) <span class="hljs-comment">// 读取响应头</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>        _ = cc.ReadBody(&amp;reply) <span class="hljs-comment">// 读取响应体</span><br>        log.Println(<span class="hljs-string">&quot;main: reply: &quot;</span>, replyHeader, reply)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 监听随机可以用的端口</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;startServer: start rpc server on&quot;</span>, listen.Addr())<br><br>    <span class="hljs-comment">// 将监听地址返回给主协程</span><br>    addr &lt;- listen.Addr().String()<br>    geerpc.Accept(listen) <span class="hljs-comment">// 开始处理连接</span><br>&#125;<br></code></pre></td></tr></table></figure></div></div><h2 id="2-高性能客户端">2.高性能客户端</h2><p>虽然这章节叫高性能客户端，实际上具体来说，应该是 client stub，为真正的 client （具体的业务代码）提供基础设施。</p><h3 id="客户端需要提供哪些能力">客户端需要提供哪些能力</h3><p>首先我们期望用户可以怎么用我们这个框架。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化客户端，连接到服务器</span><br>client, err := geerpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>)<br><br><span class="hljs-comment">// 发送请求</span><br><span class="hljs-keyword">var</span> args, reply <span class="hljs-type">string</span><br>err = client.Call(<span class="hljs-string">&quot;methodName&quot;</span>, args, &amp;reply)<br></code></pre></td></tr></table></figure><p>所以肯定需要提供 Dial、Call 这两个方法给用户使用。但在这背后的能力，应该有这些：</p><ul><li><p>连接管理的能力：</p><ul><li>网络连接建立：通过 Dial 方法连接到服务器。</li><li>协议协商：在建立连接后，完成协议交换（通过发送 option 协商）。</li><li>连接状态管理：当用户主动关闭连接或者程序出现异常时，关闭连接并释放资源。</li></ul></li><li><p>请求管理的能力：</p><ul><li>请求封装：将单次的请求信息封装在一个结构体中。</li><li>唯一标识：为每个请求生成一个唯一的序例号。</li></ul></li><li><p>通信能力：</p><ul><li>请求发送：<ul><li>序例化 header 和 body。</li><li>发送请求（通过锁来保证原子性）。</li><li>并发的处理多个请求。</li></ul></li><li>响应接收：<ul><li>持续接收响应。</li><li>异常处理：服务出错、请求不存在（已移除）。</li></ul></li></ul></li></ul><p>虽然这些能力看着很多，但大多是细节。接下来，我们自顶向下地实现 Dial、Call 这两个核心方法。</p><h3 id="如何实现-Dial-方法">如何实现 Dial 方法</h3><p>从主流程来看，Dial 有三件事：</p><ul><li>确定编码方式</li><li>连接服务器</li><li>返回一个 Client 实例，用户使用这个 Client 实例进行远程调用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Dial connects to an RPC server at the specified network address</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*geerpc.Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 真正拨号建立连接</span><br>    conn, err := net.Dial(network, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>            _ = conn.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 返回 Client 实例</span><br>    <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>确定编码方式</strong>：根据用户传入的 Option 来实例化 Codec，如果没有传入，则默认使用 gob 编码，所以这里是可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*geerpc.Option)</span></span> (*geerpc.Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> geerpc.DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = geerpc.DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = geerpc.DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>连接服务器</strong>：使用 net 包得 Dial 方法，获得一个 <code>net.Conn</code> 接口类型，表示面向流的网络连接。 GobCodec 会对 conn 进一步封装，向外提供读/写/关闭的能力。</p><p><strong>返回 client 实例</strong>：这里是 Dail 的重中之重，很多特性都需要通过 client 的设计来实现。</p><h3 id="如何抽象一个请求">如何抽象一个请求</h3><p>用户拿着 Client 实例，可以和服务端进行多次请求的发送和接收，也就是 Client 需要管理多个请求。所以在设计 Client 之前，需要将请求抽象出来。</p><ul><li>Args、Reply：请求的参数是 interface{} 类型，因为 codec 读写方法参数都是 interface{}。</li><li>Done：是一个 channel，请求结束时，调用 done 方法，给 Done chanel 写值，Client 拿着这个 channel 就可以知道请求结束了。（正常结束或者异常结束）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123; <br>    call.Done &lt;- call<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何设计一个-Client">如何设计一个 Client</h3><p><strong>（1）基础的收发消息</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>opt      *geerpc.Option   <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br></code></pre></td></tr></table></figure><p><strong>（2）发送请求提前准备的信息</strong>：多个请求共用一个 header，放在 Client 里，避免每次构造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br></code></pre></td></tr></table></figure><p><strong>（3）处理并发请求的工具</strong>：因为请求时并发的，会存在两个问题：不知道什么时候收到响应？不知道收到的响应是哪个请求的？</p><ul><li>seq：Client 发的每个请求和接收的每个响应的 header 中，都有一个序号，保证请求的顺序和唯一性。</li><li>pending：未处理完的请求，比如还未发送的请求、已经发送还未回复的请求。<ul><li>对于未处理完的请求，调用者一直在阻塞，等待响应。当我收到响应后，可以根据序号，拿到该请求的 channel，告知调用者已经收到结果，并将响应结果储存在对应 call 的 reply 变量中。</li><li>如果没有这个 map，一无法通知，二也不知道通知谁，结果储存给谁。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br></code></pre></td></tr></table></figure><p><strong>（4）保证并发读写的锁</strong>：</p><ul><li>sending：保证每次发送给服务器，只有一个请求在发，否则服务端交叉收到不好解析。</li><li>mu：保护 seq、pending 、shutdown、closing 字段，防止并发读写。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending、shutdown、closing 字段，防止并发读写</span><br></code></pre></td></tr></table></figure><p><strong>（5）异常处理的标志位</strong>：为什么要设计两个字段？</p><ul><li>closing：表示用户正在主动关闭 Client，避免多次关闭客户端，还可以做优雅退出。</li><li>shutdown：表示因为异常错误，Client 无法发送接收了，快速失败，对于没处理完的请求返回错误，避免调用者长时间阻塞等待响应。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br></code></pre></td></tr></table></figure><p>整体如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *geerpc.Option   <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending 、shutdown字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于上面这些，我们要提供几个基础的方法。</p><p><strong>（1）创建客户端</strong></p><ul><li>确定编码方式</li><li>根据编码方式实例化 Codec</li><li>根据 Codec 实例化 Client</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *geerpc.Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *geerpc.Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()  <span class="hljs-comment">// 启动协程持续接收响应</span><br>    <span class="hljs-keyword">return</span> client<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）启动协程持续接收响应</strong></p><ul><li>接收请求，先读取 header，其中有序号。</li><li>请求已经收到响应，表示已经处理完了，该序号的请求就可以在 pending 中移出，并拿到该请求的实例 call。</li><li>读取 body，并将响应储存在 <code>call.Reply</code> 中。（在此之前要处理两种错误）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>            <span class="hljs-comment">//fmt.Println(call.Reply)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）异常处理，快速失败</strong></p><p>如果发生错误（如连接断开），调用 <code>terminateCalls</code> 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）优雅退出</strong></p><p>提供 Close 方法，给用户主动关闭 Client。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）可用性</strong></p><p>暴露给用户。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）注册/移出请求</strong></p><p>主要是将请求保存在 pending 中管理，根据 seq 快速拿到请求实例 call。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何设计异步-同步调用方法">如何设计异步/同步调用方法</h3><p>基础设施已经有了，万事俱备，就差发送请求了。</p><p><strong>异步调用方法</strong>：流程很明确，主要有三步。</p><ul><li>构造 Call 请求实例</li><li><code>registerCall</code> 注册请求</li><li><code>Codec.Write</code> 发送请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个调用的方式是异步的，调完就完了，也不需要等待结果，因为有 receive 协程专门在接收数据。</p><p>举个例子，用户可以批量的调用，再统一的等待结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">done1 := client.Go(<span class="hljs-string">&quot;Arith.Add&quot;</span>, args1, &amp;reply1, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br>done2 := client.Go(<span class="hljs-string">&quot;Arith.Mul&quot;</span>, args2, &amp;reply2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>call1 := &lt;-done1<br>call2 := &lt;-done2<br></code></pre></td></tr></table></figure><p>也可以不关心返回的结果。（比如打日志、异步上报）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">client.Go(<span class="hljs-string">&quot;LogService.Log&quot;</span>, args, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 不需要 reply</span><br></code></pre></td></tr></table></figure><p><strong>同步调用方法</strong>：</p><p>用户想调用完，等待结果再继续。我们可以在 <code>Client.Go</code> 方法的基础上，简单封装一个同步调用的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := &lt;-client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>)).Done <span class="hljs-comment">// 读 Done 的数据，阻塞等待 receive() 处理完响应结果，对 Done 写值</span><br>    <span class="hljs-keyword">return</span> call.Error<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-2">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_2_client<br>├── client.go  <span class="hljs-comment"># 新增：封装 RPC 请求，设计 client stub</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main <span class="hljs-comment"># 改动：使用 client stub 发起连接和请求</span><br>│   └── main.go<br>└── server.go<br></code></pre></td></tr></table></figure><div class="fold collapsed"><div class="fold-title">client.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 client 对连接、发送请求、接受请求进行封装，并对用户提供 Dial、Call 方法。</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending 、shutdown、closing字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Dial connects to an RPC server at the specified network address</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 真正拨号建立连接</span><br>    conn, err := net.Dial(network, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>            _ = conn.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 返回 Client 实例</span><br>    <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>            <span class="hljs-comment">//fmt.Println(call.Reply)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := &lt;-client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>)).Done <span class="hljs-comment">// 读 Done 的数据，阻塞等待 receive() 处理完响应结果，对 Done 写值</span><br>    <span class="hljs-keyword">return</span> call.Error<br>&#125;<br></code></pre></td></tr></table></figure></div></div><h2 id="3-服务注册">3.服务注册</h2><p>前面两章，我们都在假装调用 Foo 类型的 Sum 方法，获取到了方法名和参数返回了，没有真正去调用方法。要想真正可以调用，那就需要 client stub 把 Foo 类型（其实也是一种服务）注册到 server stub 中，这就是服务注册，下面来看细节。</p><h3 id="这一章是干什么的">这一章是干什么的</h3><p>服务端的主要工作：</p><ul><li>监听端口</li><li>响应请求<ul><li>解析请求</li><li>处理请求<ul><li>从请求中获取方法名、参数</li><li>获取方法</li><li>调用方法</li></ul></li><li>返回结果</li></ul></li></ul><p>这一章主要完成处理请求部分，其中，从请求中获取方法名、参数在上一章已完成。client 在发送请求时，方法名在请求头里 <code>client.header.ServiceMethod</code>，参数在请求体里 <code>call.Args</code>。</p><p>所以我们重点关注</p><ul><li>获取方法（获取方法的重点在于，事前将可调用的方法注册到服务中）</li><li>调用方法</li></ul><h3 id="如何获取方法">如何获取方法</h3><p>服务端通过方法名获取实际的方法，需要两步：</p><ol><li>在启动服务端服务时，我们可以将所有可调用的方法都加到一个 map 中。</li><li>当 client 调用 hello 时，我们从 map 中找到对应的方法皆可。</li></ol><p>由于不同类型的结构体，可能有同名的结构体方法。我们的方法名，使用 <code>结构体实例名.方法名</code> 来作为方法名。比如上一章中的，结构体类型 <code>Foo</code> ，有 <code>Sum</code> 方法，客户端实例化 <code>foo</code> 对象后，远程调用 Client.Call 时，传入的就是 <code>foo.Sum</code>。</p><h3 id="如何方法注册到-map-中">如何方法注册到 map 中</h3><p>首先，先说数据存储方式，简单来说是这样的，</p><pre><code class="mermaid">graph LR
    A[Server.serviceMap] --&gt;|map储存多个service| B[Service&lt;br&gt;一个 service 表示一个变量类型]
    B --&gt;|service包含一个 map 变量| C[service.method]
    C --&gt;|map 储存多个方法| D[methodType&lt;br&gt;一个 methodType 表示一个该变量类型的方法]
 
</code></pre><p>具体数据存储方式设计如下：</p><p>服务端保存着一个 serviceMap。使用 serviceMap 保存变量类型及其方法。key 是变量类型名，value 是 service 类型实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br></code></pre></td></tr></table></figure><p>service 类型定义如下，一个 service 表示一个变量类型。其中，也包含一个 map，保存着这个变量的方法。key 是方法名，value 是 methodType 类型实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// 一个 service 表示一个变量类型</span><br><span class="hljs-keyword">type</span> service <span class="hljs-keyword">struct</span> &#123;<br>    name   <span class="hljs-type">string</span>                 <span class="hljs-comment">// 变量类型名，用来打 log，例如字符串 &quot;Foo&quot;</span><br>    typ    reflect.Type           <span class="hljs-comment">// 变量类型，通过变量的类型，可以直接获取变量的方法，例如 Foo 类型，可获取到方法 Sum</span><br>    rcvr   reflect.Value          <span class="hljs-comment">// 变量的值，通过变量的值，可以调用变量的方法，例如 &amp;foo，调用 Sum</span><br>    method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType <span class="hljs-comment">//  map 储存变量的方法中所有可调用的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>methodType 类型定义如下，一个 methodType 表示一个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// 一个 methodType 表示一个方法</span><br><span class="hljs-keyword">type</span> methodType <span class="hljs-keyword">struct</span> &#123;<br>    method    reflect.Method <span class="hljs-comment">// 方法本身，用于调用方法，例如 Foo.Sum</span><br>    ArgType   reflect.Type   <span class="hljs-comment">// 参数的类型，用于判断参数是否正确</span><br>    ReplyType reflect.Type   <span class="hljs-comment">// 返回的类型，用于判断返回值是否正确</span><br>    numCalls  <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 方法调用次数，用于统计方法调用次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，下面将以一个实际例子，演示如何将方法注册到 map 中。</p><pre><code class="mermaid">graph LR
    A[startServer, 启动服务器] --&gt; B[Server.Register , 为 Foo 类型注册服务]
    B --&gt; C[newService, 为 Foo 类型创建 service 结构体]
    C --&gt; D[获取 rcvr 值, 类型名和类型]
    C --&gt; G[service.registerMethods, 获取方法列表]
    G --&gt; K[检查方法的参数和返回值]
    K --&gt; L[保存方法到 map 变量 service.method]

</code></pre><ol><li>启动服务，将 Foo 类型注册到 rpc server 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    addr &lt;- l.Addr().String()<br>    geerpc.Accept(l)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>为 Foo 类型创建 service 对象，并保存到 server 的 map 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建 service 对象、获取对象的方法、检查方法参数和返回值，最后将方法保存到 map 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// newService 通过发射获取 rcvr 变量的类型及其方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newService</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *service &#123;<br>    s := <span class="hljs-built_in">new</span>(service)<br>    s.rcvr = reflect.ValueOf(rcvr)                  <span class="hljs-comment">// 获取 rcvr 变量的值，例如 &amp;foo</span><br>    s.name = reflect.Indirect(s.rcvr).Type().Name() <span class="hljs-comment">// 获取 rcvr 变量的类型名，例如 &quot;Foo&quot;</span><br>    s.typ = reflect.TypeOf(rcvr)                    <span class="hljs-comment">// 获取 rcvr 变量的类型，例如 Foo</span><br>    <span class="hljs-keyword">if</span> !ast.IsExported(s.name) &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;rpc server: %s is not a valid service name&quot;</span>, s.name)<br>    &#125;<br>    s.registerMethods() <span class="hljs-comment">// 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// registerMethods 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> registerMethods() &#123;<br>    s.method = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.typ.NumMethod(); i++ &#123; <span class="hljs-comment">// 遍历 rcvr 变量的方法列表</span><br>        method := s.typ.Method(i) <span class="hljs-comment">// 获取 rcvr 变量，第 i 个方法</span><br>        mType := method.Type      <span class="hljs-comment">// 获取 rcvr 变量的方法的类型</span><br><br>        <span class="hljs-comment">// 检查方法的参数是否正确。rpc 的方法必须满足以下条件：</span><br>        <span class="hljs-comment">// 1. 方法有 3 个参数，第 1 个参数是 rcvr 变量(相当于 python 的 self，java 的 this)，第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>        <span class="hljs-comment">// 2. 第 2 个参数和第 3 个参数都是导出的类型</span><br>        <span class="hljs-comment">// 3. 返回值只有一个，是 error 类型</span><br>        <span class="hljs-comment">// 例如这样 func (t *T) MethodName(argType T1, replyType *T2) error</span><br>        <span class="hljs-keyword">if</span> mType.NumIn() != <span class="hljs-number">3</span> || mType.NumOut() != <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 检查参数个数</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> mType.Out(<span class="hljs-number">0</span>) != reflect.TypeOf((*<span class="hljs-type">error</span>)(<span class="hljs-literal">nil</span>)).Elem() &#123; <span class="hljs-comment">// 检测返回值个数和类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        argType, replyType := mType.In(<span class="hljs-number">1</span>), mType.In(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123; <span class="hljs-comment">// 检查参数类型是否是导出的类型或者内置类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查完毕，将方法保存到 service 的方法 map 中</span><br>        s.method[method.Name] = &amp;methodType&#123;<br>            method:    method,<br>            ArgType:   argType,<br>            ReplyType: replyType,<br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: register %s.%s\n&quot;</span>, s.name, method.Name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// isExportedOrBuiltinType 检查类型是否是导出的类型或者内置类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExportedOrBuiltinType</span><span class="hljs-params">(t reflect.Type)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> ast.IsExported(t.Name()) || t.PkgPath() == <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何从-map-获取方法">如何从 map 获取方法</h3><p>在 readRequest 时，从请求头中，获取方法名；根据方法名在对应的 service 的 map 中获取到方法、传入参数、传出参数。</p><pre><code class="mermaid">graph LR
    A[Server.readRequest] --&gt;|解析请求头| B[Server.readRequestHeader]
    B--&gt;|返回请求头,包含方法名| A
    A --&gt;|获取方法| C[Server.findService]
    A --&gt;|获取方法传入参数,传出参数| D[GobCodec.ReadBody]
    E[request]
    C--&gt;|方法保存到 request| E
    D--&gt;|传入参数,传出参数保存到 request| E
</code></pre><ol><li>request 储存了一次远程调用请求的信息，方法、传入参数、传出参数指针。它的定义如下。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>readRequest 获取方法名、方法、传入参数、传出参数，并储存在 request 实例中，为方法调用做准备。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，需要注意一下，</p><ul><li>创建传入参数时，需区分值类型还是指针类型。</li><li>创建传出参数时，需对 map、slice 特殊处理。（因为 reflect.New 初始化时，map、slice 都是 nil）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// newArgv 创建一个参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newArgv() reflect.Value &#123;<br>    <span class="hljs-keyword">var</span> argv reflect.Value<br>    <span class="hljs-comment">// 参数可能是指针类型也可能是值类型</span><br>    <span class="hljs-keyword">if</span> m.ArgType.Kind() == reflect.Ptr &#123;<br>        argv = reflect.New(m.ArgType.Elem()) <span class="hljs-comment">// 指针类型，则创建指针类型变量</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argv = reflect.New(m.ArgType).Elem() <span class="hljs-comment">// 值类型，则创建值类型变量</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> argv<br>&#125;<br><br><span class="hljs-comment">// newReplyv 创建一个传出参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newReplyv() reflect.Value &#123;<br>    <span class="hljs-comment">// 传出参数必须是指针类型</span><br>    replyv := reflect.New(m.ReplyType.Elem())<br><br>    <span class="hljs-comment">// 为什么需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// reflect.New 创建的 map 和 slice 都是 nil，需要先初始化，再使用。</span><br>    <span class="hljs-comment">// 为什么 newArgv 方法不需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// 因为 argv 是用于接收调用方传入的参数，这些参数由调用方提供且已经初始化。</span><br>    <span class="hljs-keyword">switch</span> m.ReplyType.Elem().Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Map:<br>        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))<br>    <span class="hljs-keyword">case</span> reflect.Slice:<br>        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> replyv<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何调用方法">如何调用方法</h3><p>在 handleRequest 时，通过 service.call 利用反射来调用函数。这里主要学习这个用法。</p><pre><code class="mermaid">graph LR
    A[Server.serveCodec]--&gt;|获取请求信息| B[Server.readRequest] 
    A --&gt;|调用方法| C[Server.handleRequest]
    C --&gt; D[request.svc.call, 也就是 Service.call]
    D --&gt;|使用反射调用| E[methodType.method.Func.Call]
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        req.h.Error = err.Error()<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// call 调用 rcvr 变量的方法，例如 Foo.Sum</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> call(m *methodType, argv, replyv reflect.Value) <span class="hljs-type">error</span> &#123;<br>    atomic.AddUint64(&amp;m.numCalls, <span class="hljs-number">1</span>)<br>    f := m.method.Func<br>    <span class="hljs-comment">// 用反射的方式调用方法</span><br>    <span class="hljs-comment">// 第一个参数是 rcvr 变量，例如 &amp;foo，类似于 java 的 this，python 的 self</span><br>    <span class="hljs-comment">// 第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>    returnValues := f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)<br>    <span class="hljs-keyword">if</span> errInter := returnValues[<span class="hljs-number">0</span>].Interface(); errInter != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errInter.(<span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更深入了解反射">更深入了解反射</h3><p>请看这篇 <a href="https://www.aimtao.net/go#11-reflect">https://www.aimtao.net/go#11-reflect</a></p><h3 id="完整代码-3">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_3_service<br>├── client.go<br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 改动：增加真正将服务注册到 server stub 的步骤</span><br>├── server.go  <span class="hljs-comment"># 改动：增加 serviceMap 保存所有可以调用的方法，并对用户暴露服务注册的方法</span><br>├── service.go  <span class="hljs-comment"># 新增：将每个变量抽象成一个 service，并储存该变量的方法</span><br>└── service_test.go  <span class="hljs-comment"># 新增：测试 service 方法</span><br></code></pre></td></tr></table></figure><div class="fold collapsed"><div class="fold-title">main/main.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    geerpc <span class="hljs-string">&quot;GeeRPC&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    addr &lt;- l.Addr().String()<br>    geerpc.Accept(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    log.SetFlags(<span class="hljs-number">0</span>)<br><br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    client, _ := geerpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addr)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(<span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">server.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;GeeRPC/codec&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span><br>    CodecType   codec.Type<br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        req.h.Error = err.Error()<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber: MagicNumber,<br>    CodecType:   codec.GobType,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">service.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义 service 类型，一个 service 表示一个变量类型，每个 service 储存了该变量的所有方法。（方法名、参数、返回值）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;go/ast&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> methodType <span class="hljs-keyword">struct</span> &#123;<br>    method    reflect.Method <span class="hljs-comment">// 方法本身，用于调用方法，例如 Foo.Sum</span><br>    ArgType   reflect.Type   <span class="hljs-comment">// 参数的类型，用于判断参数是否正确</span><br>    ReplyType reflect.Type   <span class="hljs-comment">// 返回的类型，用于判断返回值是否正确</span><br>    numCalls  <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 方法调用次数，用于统计方法调用次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> NumCalls() <span class="hljs-type">uint64</span> &#123;<br>    <span class="hljs-keyword">return</span> atomic.LoadUint64(&amp;m.numCalls)<br>&#125;<br><br><span class="hljs-comment">// newArgv 创建一个参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newArgv() reflect.Value &#123;<br>    <span class="hljs-keyword">var</span> argv reflect.Value<br>    <span class="hljs-comment">// 参数可能是指针类型也可能是值类型</span><br>    <span class="hljs-keyword">if</span> m.ArgType.Kind() == reflect.Ptr &#123;<br>        argv = reflect.New(m.ArgType.Elem()) <span class="hljs-comment">// 指针类型，则创建指针类型变量</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argv = reflect.New(m.ArgType).Elem() <span class="hljs-comment">// 值类型，则创建值类型变量</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> argv<br>&#125;<br><br><span class="hljs-comment">// newReplyv 创建一个传出参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newReplyv() reflect.Value &#123;<br>    <span class="hljs-comment">// 传出参数必须是指针类型</span><br>    replyv := reflect.New(m.ReplyType.Elem())<br><br>    <span class="hljs-comment">// 为什么需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// reflect.New 创建的 map 和 slice 都是 nil，需要先初始化，再使用。</span><br>    <span class="hljs-keyword">switch</span> m.ReplyType.Elem().Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Map:<br>        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))<br>    <span class="hljs-keyword">case</span> reflect.Slice:<br>        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> replyv<br>&#125;<br><br><span class="hljs-keyword">type</span> service <span class="hljs-keyword">struct</span> &#123;<br>    name   <span class="hljs-type">string</span>                 <span class="hljs-comment">// 变量类型名，用来打 log，例如字符串 &quot;Foo&quot;</span><br>    typ    reflect.Type           <span class="hljs-comment">// 变量类型，通过变量的类型，可以直接获取变量的方法，例如 Foo 类型，可获取到方法 Sum</span><br>    rcvr   reflect.Value          <span class="hljs-comment">// 变量的值，通过变量的值，可以调用变量的方法，例如 &amp;foo，调用 Sum</span><br>    method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType <span class="hljs-comment">//  map 储存变量的方法中所有可调用的方法</span><br>&#125;<br><br><span class="hljs-comment">// newService 通过发射获取 rcvr 变量的类型及其方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newService</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *service &#123;<br>    s := <span class="hljs-built_in">new</span>(service)<br>    s.rcvr = reflect.ValueOf(rcvr)                  <span class="hljs-comment">// 获取 rcvr 变量的值，例如 &amp;foo</span><br>    s.name = reflect.Indirect(s.rcvr).Type().Name() <span class="hljs-comment">// 获取 rcvr 变量的类型名，例如 &quot;Foo&quot;</span><br>    s.typ = reflect.TypeOf(rcvr)                    <span class="hljs-comment">// 获取 rcvr 变量的类型，例如 Foo</span><br>    <span class="hljs-keyword">if</span> !ast.IsExported(s.name) &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;rpc server: %s is not a valid service name&quot;</span>, s.name)<br>    &#125;<br>    s.registerMethods() <span class="hljs-comment">// 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// registerMethods 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> registerMethods() &#123;<br>    s.method = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.typ.NumMethod(); i++ &#123; <span class="hljs-comment">// 遍历 rcvr 变量的方法列表</span><br>        method := s.typ.Method(i) <span class="hljs-comment">// 获取 rcvr 变量，第 i 个方法</span><br>        mType := method.Type      <span class="hljs-comment">// 获取 rcvr 变量的方法的类型</span><br><br>        <span class="hljs-comment">// 检查方法的参数是否正确。rpc 的方法必须满足以下条件：</span><br>        <span class="hljs-comment">// 1. 方法有 3 个参数，第 1 个参数是 rcvr 变量(相当于 python 的 self，java 的 this)，第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>        <span class="hljs-comment">// 2. 第 2 个参数和第 3 个参数都是导出的类型</span><br>        <span class="hljs-comment">// 3. 返回值只有一个，是 error 类型</span><br>        <span class="hljs-comment">// 例如这样 func (t *T) MethodName(argType T1, replyType *T2) error</span><br>        <span class="hljs-keyword">if</span> mType.NumIn() != <span class="hljs-number">3</span> || mType.NumOut() != <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 检查参数个数</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> mType.Out(<span class="hljs-number">0</span>) != reflect.TypeOf((*<span class="hljs-type">error</span>)(<span class="hljs-literal">nil</span>)).Elem() &#123; <span class="hljs-comment">// 检测返回值个数和类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        argType, replyType := mType.In(<span class="hljs-number">1</span>), mType.In(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123; <span class="hljs-comment">// 检查参数类型是否是导出的类型或者内置类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查完毕，将方法保存到 service 的方法 map 中</span><br>        s.method[method.Name] = &amp;methodType&#123;<br>            method:    method,<br>            ArgType:   argType,<br>            ReplyType: replyType,<br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: register %s.%s\n&quot;</span>, s.name, method.Name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// isExportedOrBuiltinType 检查类型是否是导出的类型或者内置类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExportedOrBuiltinType</span><span class="hljs-params">(t reflect.Type)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> ast.IsExported(t.Name()) || t.PkgPath() == <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// call 调用 rcvr 变量的方法，例如 Foo.Sum</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> call(m *methodType, argv, replyv reflect.Value) <span class="hljs-type">error</span> &#123;<br>    atomic.AddUint64(&amp;m.numCalls, <span class="hljs-number">1</span>)<br>    f := m.method.Func<br>    <span class="hljs-comment">// 用反射的方式调用方法</span><br>    <span class="hljs-comment">// 第一个参数是 rcvr 变量，例如 &amp;foo，类似于 java 的 this，python 的 self</span><br>    <span class="hljs-comment">// 第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>    returnValues := f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)<br>    <span class="hljs-keyword">if</span> errInter := returnValues[<span class="hljs-number">0</span>].Interface(); errInter != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errInter.(<span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">service_test.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span><br><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// it&#x27;s not a exported Method</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">assert</span><span class="hljs-params">(condition <span class="hljs-type">bool</span>, msg <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !condition &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;assertion failed: &quot;</span>+msg, v...))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    _assert(<span class="hljs-built_in">len</span>(s.method) == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;wrong service Method, expect 1, but got %d&quot;</span>, <span class="hljs-built_in">len</span>(s.method))<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br>    _assert(mType != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;wrong Method, Sum shouldn&#x27;t nil&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMethodType_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br><br>    argv := mType.newArgv()<br>    replyv := mType.newReplyv()<br>    argv.Set(reflect.ValueOf(Args&#123;Num1: <span class="hljs-number">1</span>, Num2: <span class="hljs-number">3</span>&#125;))<br>    err := s.call(mType, argv, replyv)<br>    _assert(err == <span class="hljs-literal">nil</span> &amp;&amp; *replyv.Interface().(*<span class="hljs-type">int</span>) == <span class="hljs-number">4</span> &amp;&amp; mType.NumCalls() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;failed to call Foo.Sum&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><h2 id="4-超时处理">4.超时处理</h2><h3 id="哪些地方需要超时处理">哪些地方需要超时处理</h3><p>简单来看整个流程：</p><ul><li><p>客户端：</p><ol><li>拨号连接 ✓</li><li>远程调用（发送数据）✓</li><li>等待服务端处理 ✓</li><li>接收返回的结果（接收数据）✓</li></ol></li><li><p>服务端：</p><ol><li>端口监听</li><li>接收请求信息（接收数据）✓</li><li>调用方法处理请求信息（处理数据）✓</li><li>返回请求结果（发送数据）✓</li></ol></li></ul><p>以上打 ✓ 的步骤，均可能出现超时，主要为，</p><ul><li>客户端建立连接超时</li><li>发送数据<ul><li>客户端/服务端写报文时超时</li></ul></li><li>处理数据<ul><li>服务端调用方法超时</li></ul></li><li>接收数据<ul><li>客户端等待服务端响应超时</li><li>客户端/服务端读取报文超时</li></ul></li></ul><p>基于这个超时的情景，我们可以在以下三个地方设置超时处理机制。</p><p>客户端：</p><ul><li>建立连接</li><li><code>Client.call()</code> 的整个过程（包含发送数据、等待处理、接收数据）</li></ul><p>服务端：</p><ul><li><code>Server.handleRequest()</code> 的整个过程（包括处理数据、发送数据，接收数据先不管了）</li></ul><h3 id="建立连接的超时处理">建立连接的超时处理</h3><p>启动一个 goroutine 来拨号建立连接，使用 select 设置超时器，阻塞等待拨号结果，如果在接收拨号结果之前，先收到了超时信号，则进行超时处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult)<br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时的时长，设置在 Option struct 内，便于用户自定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Call-的超时处理">Call 的超时处理</h3><p>把选择权交给用户。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户如何使用？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx, _ := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>err := client.Call(ctx, <span class="hljs-string">&quot;Foo.Sum&quot;</span>, &amp;Args&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &amp;reply)<br></code></pre></td></tr></table></figure><h3 id="handleRequest-超时处理">handleRequest 超时处理</h3><p>这里先不管读取数据了，仅对 handleRequest 做超时处理。handleRequest 其中又分为两个步骤，处理数据、发送数据，仅对处理数据做超时处理。</p><p>设置两个 channel，一个表示 <code>req.svc.call</code> 完成，一个表示 <code>server.sendResponse</code> 完成。当 <code>req.svc.call</code> 完成后，就不用管超时时间是否到达，继续让 server.sendResponse 发送数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试代码">测试代码</h3><p>测试客户端处理连接超时的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_dialTimeout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel() <span class="hljs-comment">// 设置测试项并行执行</span><br><br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>        _ = conn.Close()<br>        time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 模拟了一个没有错误的客户端连接</span><br>    &#125;<br><br>    l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br><br>    <span class="hljs-comment">// 测试客户端连接有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;connect timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)<br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;connect timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试客户端连接没有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: <span class="hljs-number">0</span>&#125;)<br>        _assert(err == <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;0 means no limit&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试客户端处理调用超时和服务端处理超时的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server_test.go</span><br><span class="hljs-keyword">type</span> ServiceTemp <span class="hljs-type">int</span><br><br><span class="hljs-comment">// ServiceTemp 有一个方法 Timeout，该方法耗时2s</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s ServiceTemp)</span></span> Timeout(args <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    time.Sleep(time.Second * time.Duration(args))<br>    *reply = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel()<br><br>    addrCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123; <span class="hljs-comment">// 启动一个服务器，监听 0 端口，注册 ServiceTemp 类型的对象，然后启动 Accept 方法，等待客户端连接</span><br>        <span class="hljs-keyword">var</span> s ServiceTemp<br>        _ = Register(&amp;s)<br>        l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>        addrCh &lt;- l.Addr().String()<br>        Accept(l)<br>    &#125;(addrCh)<br>    addr := &lt;-addrCh<br><br>    <span class="hljs-comment">// 测试客户端处理调用超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;client call timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br><br>        ctx, _ := context.WithTimeout(context.Background(), time.Second) <span class="hljs-comment">// 创建一个超时的 context，如果 1s 内没有返回结果，context.Done() 会传出信号 struct&#123;&#125;&#123;&#125;</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(ctx, <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，Call 发生超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试服务端处理超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;server handle timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr, &amp;Option&#123;HandleTimeout: time.Second&#125;)<br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(context.Background(), <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，服务端处理超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;handle timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-4">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_4_timeout<br>├── client.go  <span class="hljs-comment"># 改动：增加客户端端超时处理的逻辑</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main<br>│   └── main.go<br>├── server.go  <span class="hljs-comment"># 改动：增加服务端超时处理的逻辑</span><br>├── service.go<br>└── service_test.go<br></code></pre></td></tr></table></figure><div class="fold collapsed"><div class="fold-title">server.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn), &amp;opt)<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec, opt *Option) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                                 <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        req.h.Error = fmt.Sprintf(<span class="hljs-string">&quot;rpc server: request handle timeout: expect within %s&quot;</span>, timeout)<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">client.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 client 对连接、发送请求、接受请求进行封装，并对用户提供 Dial、Call 方法。</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 pending 和 shutdown 字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 如果超时时间为 0，表示没限制，直接等待 result 通道返回结果</span><br>    <span class="hljs-keyword">if</span> opt.ConnectTimeout == <span class="hljs-number">0</span> &#123;<br>        result := &lt;-result<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">server_test.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span><br><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// it&#x27;s not a exported Method</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">assert</span><span class="hljs-params">(condition <span class="hljs-type">bool</span>, msg <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !condition &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;assertion failed: &quot;</span>+msg, v...))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    _assert(<span class="hljs-built_in">len</span>(s.method) == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;wrong service Method, expect 1, but got %d&quot;</span>, <span class="hljs-built_in">len</span>(s.method))<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br>    _assert(mType != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;wrong Method, Sum shouldn&#x27;t nil&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMethodType_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br><br>    argv := mType.newArgv()<br>    replyv := mType.newReplyv()<br>    argv.Set(reflect.ValueOf(Args&#123;Num1: <span class="hljs-number">1</span>, Num2: <span class="hljs-number">3</span>&#125;))<br>    err := s.call(mType, argv, replyv)<br>    _assert(err == <span class="hljs-literal">nil</span> &amp;&amp; *replyv.Interface().(*<span class="hljs-type">int</span>) == <span class="hljs-number">4</span> &amp;&amp; mType.NumCalls() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;failed to call Foo.Sum&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> ServiceTemp <span class="hljs-type">int</span><br><br><span class="hljs-comment">// ServiceTemp 有一个方法 Timeout，该方法耗时2s</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s ServiceTemp)</span></span> Timeout(args <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    time.Sleep(time.Second * time.Duration(args))<br>    *reply = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel()<br><br>    addrCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123; <span class="hljs-comment">// 启动一个服务器，监听 0 端口，注册 ServiceTemp 类型的对象，然后启动 Accept 方法，等待客户端连接</span><br>        <span class="hljs-keyword">var</span> s ServiceTemp<br>        _ = Register(&amp;s)<br>        l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>        addrCh &lt;- l.Addr().String()<br>        Accept(l)<br>    &#125;(addrCh)<br>    addr := &lt;-addrCh<br><br>    <span class="hljs-comment">// 测试客户端处理调用超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;client call timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br><br>        ctx, _ := context.WithTimeout(context.Background(), time.Second) <span class="hljs-comment">// 创建一个超时的 context，如果 1s 内没有返回结果，context.Done() 会传出信号 struct&#123;&#125;&#123;&#125;</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(ctx, <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，Call 发生超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试服务端处理超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;server handle timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr, &amp;Option&#123;HandleTimeout: time.Second&#125;)<br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(context.Background(), <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，服务端处理超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;handle timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">client_test.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_dialTimeout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel() <span class="hljs-comment">// 设置测试项并行执行</span><br><br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>        _ = conn.Close()<br>        time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 模拟了一个没有错误的客户端连接</span><br>    &#125;<br><br>    l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br><br>    <span class="hljs-comment">// 测试客户端连接有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;connect timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)<br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;connect timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试客户端连接没有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: <span class="hljs-number">0</span>&#125;)<br>        _assert(err == <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;0 means no limit&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><h2 id="5-支持-HTTP-协议">5.支持 HTTP 协议</h2><h3 id="什么是支持-HTTP-协议">什么是支持 HTTP 协议</h3><p>当前我们 RPC 框架是基于 TCP 协议的。通过监听端口，建立 TCP socket 连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br>l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9999&quot;</span>)    <span class="hljs-comment">// 使用 TCP 协议</span><br>geerpc.Accept(l)  <span class="hljs-comment">// 等待建立连接</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，客户端只能通过建立 socket 连接与服务端通信。如果支持了 HTTP 协议是什么样子呢？</p><p>用户在浏览器访问 <code>http://ip:port/xxx</code> 就可以访问服务端的服务。</p><h3 id="为什么需要支持-HTTP-协议">为什么需要支持 HTTP 协议</h3><ul><li>兼容性：很多应用是基于 HTTP 协议的，RPC 框架支持 HTTP，便于兼容。</li><li>方便调试：通过 HTTP 提供调试界面，可以实时监控RPC服务的状态和调用统计，方便开发和运维。</li><li>安全性：HTTP 可以和 TLS/SSL 结合，提供安全的通信方式。</li></ul><h3 id="如何支持-HTTP-协议">如何支持 HTTP 协议</h3><p>这一块非常关键，决定你是否真正理解服务端这块的核心逻辑。（为了便于理解，我尽可以使用冗余的语言来描述）</p><ol><li>首先要明确需求，我们支持 HTTP 协议，并不是要用 HTTP 替换掉之前的 TCP socket 的连接方式，而是要兼容二者。</li><li>其次要明确原理，HTTP 协议是基于 TCP 协议的，HTTP 是应用层协议，TCP 是传输层协议。HTTP 是在 TCP 上的一层封装。</li></ol><p>所以，需要兼容二者，我既需要完成 HTTP 请求和响应，又需要拿到底层的 TCP socket 连接。 该怎么做呢？</p><p>对于 HTTP 请求和响应，</p><ul><li>客户端：客户端通过 <code>net.DialTimeout</code> 建立 TCP 连接，得到 <code>net.Conn</code> ，然后通过 <code>net.Conn</code> 向 RPC 服务器，发送 HTTP CONNECT 请求，并接收 HTTP 响应，确认连接成功。</li><li>服务端：对于 HTTP 请求的监听，我们很熟悉，在 <a href="https://www.aimtao.net/7days-web/#%E5%A6%82%E4%BD%95%E6%8E%A5%E7%AE%A1-HTTP-%E8%AF%B7%E6%B1%82">如何接管 HTTP 请求</a> 中介绍过，我们的 Server 只需要实现 <code>ServeHTTP(ResponseWriter, *Request)</code> 方法就可以实现 <code>Handler</code> 接口，最后用 <code>http.Handle()</code> 方法将 Server 注册到对应的路由上，Server 就可以接管部分 HTTP 请求了（细节后面再讨论）。</li></ul><p>对于 TCP 连接，</p><ul><li><p>客户端：无需额外做什么，使用 <code>net.DialTimeout</code> 建立的已经就是 TCP 连接。</p></li><li><p>服务端：</p><ul><li><p>在之前我们是通过 <code>net.Listen()</code> 监听端口、 <code>net.Listener.Accept()</code> 阻塞等待连接完成的，最关键的是最后每个连接都返回一个 <code>net.Conn</code> 用来传输数据，这是建立的 TCP 连接。</p></li><li><p>现在是监听 TCP 端口，并启动 HTTP 服务器，服务端只能响应 HTTP 请求，无法获得 TCP 连接。</p></li><li><p>既然 HTTP 是基于 TCP 封装的，那 HTTP 请求能否拿到底层 TCP 的 <code>net.Conn</code> 呢？如果可以拿到，我们就可以根据请求类型，来选择是响应 HTTP 请求，还是建立 TCP 连接。</p></li><li><p>答案是当然可以拿到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *response)</span></span> Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>最后梳理一下，基于通信流程梳理需要做哪些事情：</p><ol><li>服务端监听端口，并启动 HTTP 服务器。</li><li>客户端 Dial 建立 TCP 连接，获得 <code>net.conn</code>，并向 RPC 服务器，发送 HTTP CONNECT 方法请求</li><li>服务端响应 HTTP CONNECT 方法请求，并通过 <code>Hijack</code> 劫持 HTTP 底层的 TCP 连接。</li><li>客户端使用建立的连接，发送 RPC 报文（先发送 option，再发送 RPC 报文）</li><li>服务端处理 RPC 请求，并同时可以响应 HTTP 请求。</li></ol><h3 id="服务端支持-HTTP-协议">服务端支持 HTTP 协议</h3><p>实现 ServeHTTP 函数接管 <code>/_geeprc_</code> 路由的 HTTP 请求处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>)<br><br><span class="hljs-comment">// Server 实现 ServeHTTP，并使用 http.Handle 注册到对应路由中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> r.Method != <span class="hljs-string">&quot;CONNECT&quot;</span> &#123; <span class="hljs-comment">// &quot;/_geeprc_&quot; 理由地址只响应 CONNECT 请求</span><br>        w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>)<br>        w.WriteHeader(http.StatusMethodNotAllowed)<br>        _, _ = io.WriteString(w, <span class="hljs-string">&quot;405 must CONNECT\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从 HTTP 请求中，劫持底层的 TCP 连接</span><br>    conn, _, err := w.(http.Hijacker).Hijack()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;rpc hijacking &quot;</span>, r.RemoteAddr, <span class="hljs-string">&quot;: &quot;</span>, err.Error())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, _ = io.WriteString(conn, <span class="hljs-string">&quot;HTTP/1.0 &quot;</span>+connected+<span class="hljs-string">&quot;\n\n&quot;</span>)<br>    server.ServeConn(conn) <span class="hljs-comment">// 处理 TCP 连接的 RPC 报文</span><br>&#125;<br><br><span class="hljs-comment">// HandleHTTP 将 Server 注册到  defaultRPCPath 路由上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server) <span class="hljs-comment">// 使用 Server.ServeHTTP 方法处理 defaultRPCPath 路由</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHTTP</span><span class="hljs-params">()</span></span> &#123;<br>    DefaultServer.HandleHTTP()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户如何启动-HTTP-服务">用户如何启动 HTTP 服务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    geerpc.HandleHTTP() <span class="hljs-comment">// 注册静态路由</span><br>    addr &lt;- l.Addr().String()<br>    _ = http.Serve(l, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 启动 HTTP 服务，不使用 accpet</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端支持-HTTP-协议">客户端支持 HTTP 协议</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>   <span class="hljs-comment">//...</span><br>   conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>   <span class="hljs-comment">//...</span><br>   client, err = f(conn, opt)<br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 dialTimeout 过程中，先会获得了一个 TCP 连接 <code>net.conn</code>，原本的逻辑调会用 NewClient，利用该连接，生成一个 Client 使用。</p><p>但是现在服务端想同时响应 HTTP 请求和TCP 连接，服务端只启动 HTTP 服务，不进行 Accpet，所以需要利用该 TCP 连接，向服务端发送一条 HTTP 请求，让服务端有机会从 HTTP 请求中，拿到底层的 TCP 连接。</p><p>什么时候发送呢？在 NewClient 之前。发送请求并接收响应后，再正常调用 NewClient 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// NewHTTPClient 做所的事，就是在 NewClient 之前，向 conn 发送一条 HTTP 请求 “CONNECT /_geeprc_ HTTP/1.0”，并获得响应</span><br><span class="hljs-comment">// 服务端 收到这条 HTTP CONNECT 请求后，会做出回复，并拿到 HTTP 底层的 conn 连接。所以服务器可以响应 HTTP 请求，又可以通过 conn 这个 tcp socket 通信</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    _, _ = io.WriteString(conn, fmt.Sprintf(<span class="hljs-string">&quot;CONNECT %s HTTP/1.0\n\n&quot;</span>, defaultRPCPath))<br><br>    response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;) <span class="hljs-comment">// 读取服务端响应</span><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; response.Status == connected &#123;<br>        <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;unexpected HTTP response: &quot;</span> + response.Status)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>为了用户更方便的调用，为 NewHTTPClient 封装两个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialHTTP</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewHTTPClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">XDial</span><span class="hljs-params">(rpcAddr <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    parts := strings.Split(rpcAddr, <span class="hljs-string">&quot;@&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client err: wrong format &#x27;%s&#x27;, expect protocol@addr&quot;</span>, rpcAddr)<br>    &#125;<br>    protocol, addr := parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">switch</span> protocol &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;http&quot;</span>:<br>        <span class="hljs-keyword">return</span> DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, addr, opts...)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// tcp, unix or other transport protocol</span><br>        <span class="hljs-keyword">return</span> Dial(protocol, addr, opts...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户如何使用客户端">用户如何使用客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(addrCh <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    client, _ := geerpc.DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addrCh)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(context.Background(), <span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些问题">一些问题</h3><ul><li><p>客户端只想建立 TCP 连接，还需发送 HTTP 请求吗？</p><ul><li>需要的。为什么？客户端通过 Dial 就可以拿到 TCP 连接，但是这个 TCP 连接如果没有服务器 Accept，是没有办法和服务器进行通信的（这是因为什么下面会讲）。所以是否需要发送 HTTP 请求，这取决于服务端使用什么样的监听方式。</li><li><code>http.Serve(l, nil)</code> 如果服务端启动 HTTP 服务器，就需要使用 DialHTTP 方法去拨号，在这个过程中，客户端会自动帮用户发送 HTTP CONNECT 请求，服务端会通过 HTTP 劫持到底层 TCP 连接。</li><li><code>geerpc.Accept(l)</code> 如果服务端启动 TCP socket 监听，就可以直接 Dial 拨号，建立 TCP 连接。</li></ul></li><li><p>为什么通过 Dial 可以拿到 TCP 连接，服务器不 Accept 二者无法通信？</p><ul><li>TCP 连接的本质：<ul><li>内核层连接 Dial 成功 = TCP 三次握手完成</li><li>连接在内核层面进入 ESTABLISHED 状态</li><li>但应用层无法直接使用该连接</li></ul></li><li>应用层通信必备条件：<ul><li>服务端必须调用 Accept</li></ul></li><li>Accept 的作用：<ul><li>将内核连接转交应用层</li><li>创建应用层 socket</li><li>分配通信资源（缓冲区等）</li></ul></li></ul></li><li><p>为什么 <code>http.ReadResponse</code> 可以读出数据？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>bufio.NewReader(conn)</code> 创建缓冲读取器包装原始连接，读到服务端给客户端 HTTP CONNECT 请求的回复。</p></li></ul><h3 id="一个实例">一个实例</h3><p>上面这一些操作仅服务端仅实现了响应 “/<em>geeprc</em>” 路由的 CONNECT 请求。</p><p>下面实现一个用于客户端 debug 用的路由 “/debug/geerpc”。</p><p>（1）创建 debugHTTP，结构体中嵌入 Server。</p><p>为什么要嵌入：这样 debugHTTP 就可以拿到 Server 实例里的方法名和方法的调用次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// debug.go</span><br><br><span class="hljs-keyword">type</span> debugHTTP <span class="hljs-keyword">struct</span> &#123;<br>    *Server<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）实现 debugHTTP 的 ServeHTTP，来处理 HTTP 请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// debug.go</span><br><br><span class="hljs-keyword">const</span> debugText = <span class="hljs-string">`&lt;html&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;title&gt;GeeRPC Services&lt;/title&gt;</span><br><span class="hljs-string">    &#123;&#123;range .&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">    Service &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">        &lt;table&gt;</span><br><span class="hljs-string">        &lt;th align=center&gt;Method&lt;/th&gt;&lt;th align=center&gt;Calls&lt;/th&gt;</span><br><span class="hljs-string">        &#123;&#123;range $name, $mtype := .Method&#125;&#125;</span><br><span class="hljs-string">            &lt;tr&gt;</span><br><span class="hljs-string">            &lt;td align=left font=fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td align=center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;/tr&gt;</span><br><span class="hljs-string">        &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">        &lt;/table&gt;</span><br><span class="hljs-string">    &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;`</span><br><br><span class="hljs-keyword">var</span> debug = template.Must(template.New(<span class="hljs-string">&quot;RPC debug&quot;</span>).Parse(debugText))<br><br><span class="hljs-keyword">type</span> debugService <span class="hljs-keyword">struct</span> &#123;<br>    Name   <span class="hljs-type">string</span><br>    Method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType<br>&#125;<br><br><span class="hljs-comment">// Runs at /debug/geerpc</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server debugHTTP)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    <span class="hljs-comment">// Build a sorted version of the data.</span><br>    <span class="hljs-keyword">var</span> services []debugService<br>    server.serviceMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namei, svci <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>        svc := svci.(*service)<br>        services = <span class="hljs-built_in">append</span>(services, debugService&#123;<br>            Name:   namei.(<span class="hljs-type">string</span>),<br>            Method: svc.method,<br>        &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>    err := debug.Execute(w, services)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        _, _ = fmt.Fprintln(w, <span class="hljs-string">&quot;rpc: error executing template:&quot;</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）注册静态路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>    defaultDebugPath = <span class="hljs-string">&quot;/debug/geerpc&quot;</span>  <span class="hljs-comment">// debug 的路由地址</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server)<br>    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)  <span class="hljs-comment">// 注册 debug 路由</span><br>    log.Println(<span class="hljs-string">&quot;rpc server debug path:&quot;</span>, defaultDebugPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）在 main.go 执行后，可以访问目标端口的“/debug/geerpc”，可以看到各个方法被远程调用了多少次。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Service Foo<br>-------------------------------<br><span class="hljs-keyword">Method</span>                        <span class="hljs-title function_">Calls</span><br><span class="hljs-title function_">Sum</span><span class="hljs-params">(main.Args, *int)</span> <span class="hljs-title function_">error</span>    5<br></code></pre></td></tr></table></figure><h3 id="完整代码-5">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_5_http<br>├── client.go  <span class="hljs-comment"># 改动：增加 DialHTTP 方法（发送 HTTP CONNECT 请求）</span><br>├── client_test.go <span class="hljs-comment"># 新增：增加测试 XDial 的测试</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── debug.go  <span class="hljs-comment"># 新增：增加 debugHTTP，并接管部分请求</span><br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 改动：服务端使用 HTTP 服务器，客户端使用 DialHTTP 拨号</span><br>├── server.go  <span class="hljs-comment"># 改动：ServeHTTP 接管 HTTP 请求，使用 HTTP 请求劫持 TCP 连接</span><br>├── service.go<br>└── service_test.go<br></code></pre></td></tr></table></figure><div class="fold collapsed"><div class="fold-title">client.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 pending 和 shutdown 字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 如果超时时间为 0，表示没限制，直接等待 result 通道返回结果</span><br>    <span class="hljs-keyword">if</span> opt.ConnectTimeout == <span class="hljs-number">0</span> &#123;<br>        result := &lt;-result<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// NewHTTPClient 做所的事，就是在 NewClient 前面，向 conn 发送一条 HTTP 请求 “CONNECT /_geeprc_ HTTP/1.0”，并获得响应</span><br><span class="hljs-comment">// 服务端 收到这条 HTTP CONNECT 请求后，会做出回复，并拿到 HTTP 底层的 conn 连接。所以服务器可以响应 HTTP 请求，又可以通过 conn 这个 tcp socket 通信</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    _, _ = io.WriteString(conn, fmt.Sprintf(<span class="hljs-string">&quot;CONNECT %s HTTP/1.0\n\n&quot;</span>, defaultRPCPath))<br><br>    response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;) <span class="hljs-comment">// 读取服务端响应</span><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; response.Status == connected &#123;<br>        <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;unexpected HTTP response: &quot;</span> + response.Status)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialHTTP</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewHTTPClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">XDial</span><span class="hljs-params">(rpcAddr <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    parts := strings.Split(rpcAddr, <span class="hljs-string">&quot;@&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client err: wrong format &#x27;%s&#x27;, expect protocol@addr&quot;</span>, rpcAddr)<br>    &#125;<br>    protocol, addr := parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">switch</span> protocol &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;http&quot;</span>:<br>        <span class="hljs-keyword">return</span> DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, addr, opts...)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// tcp, unix or other transport protocol</span><br>        <span class="hljs-keyword">return</span> Dial(protocol, addr, opts...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">server.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn), &amp;opt)<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec, opt *Option) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                                 <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        req.h.Error = fmt.Sprintf(<span class="hljs-string">&quot;rpc server: request handle timeout: expect within %s&quot;</span>, timeout)<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>    defaultDebugPath = <span class="hljs-string">&quot;/debug/geerpc&quot;</span><br>)<br><br><span class="hljs-comment">// Server 实现 ServeHTTP，并使用 http.Handle 注册到对应路由中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> r.Method != <span class="hljs-string">&quot;CONNECT&quot;</span> &#123; <span class="hljs-comment">// &quot;/_geeprc_&quot; 理由地址只响应 CONNECT 请求</span><br>        w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>)<br>        w.WriteHeader(http.StatusMethodNotAllowed)<br>        _, _ = io.WriteString(w, <span class="hljs-string">&quot;405 must CONNECT\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从 HTTP 请求中，劫持底层的 TCP 连接</span><br>    conn, _, err := w.(http.Hijacker).Hijack()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;rpc hijacking &quot;</span>, r.RemoteAddr, <span class="hljs-string">&quot;: &quot;</span>, err.Error())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, _ = io.WriteString(conn, <span class="hljs-string">&quot;HTTP/1.0 &quot;</span>+connected+<span class="hljs-string">&quot;\n\n&quot;</span>)<br>    server.ServeConn(conn) <span class="hljs-comment">// 处理 TCP 连接的 RPC 报文</span><br>&#125;<br><br><span class="hljs-comment">// HandleHTTP 将 Server 注册到  defaultRPCPath 路由上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server) <span class="hljs-comment">// 使用 Server.ServeHTTP 方法处理 defaultRPCPath 路由</span><br>    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)<br>    log.Println(<span class="hljs-string">&quot;rpc server debug path:&quot;</span>, defaultDebugPath)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHTTP</span><span class="hljs-params">()</span></span> &#123;<br>    DefaultServer.HandleHTTP()<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">debug.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> debugText = <span class="hljs-string">`&lt;html&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;title&gt;GeeRPC Services&lt;/title&gt;</span><br><span class="hljs-string">    &#123;&#123;range .&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">    Service &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">        &lt;table&gt;</span><br><span class="hljs-string">        &lt;th align=center&gt;Method&lt;/th&gt;&lt;th align=center&gt;Calls&lt;/th&gt;</span><br><span class="hljs-string">        &#123;&#123;range $name, $mtype := .Method&#125;&#125;</span><br><span class="hljs-string">            &lt;tr&gt;</span><br><span class="hljs-string">            &lt;td align=left font=fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td align=center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;/tr&gt;</span><br><span class="hljs-string">        &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">        &lt;/table&gt;</span><br><span class="hljs-string">    &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;`</span><br><br><span class="hljs-keyword">var</span> debug = template.Must(template.New(<span class="hljs-string">&quot;RPC debug&quot;</span>).Parse(debugText))<br><br><span class="hljs-keyword">type</span> debugHTTP <span class="hljs-keyword">struct</span> &#123;<br>    *Server<br>&#125;<br><span class="hljs-keyword">type</span> debugService <span class="hljs-keyword">struct</span> &#123;<br>    Name   <span class="hljs-type">string</span><br>    Method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType<br>&#125;<br><br><span class="hljs-comment">// Runs at /debug/geerpc</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server debugHTTP)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    <span class="hljs-comment">// Build a sorted version of the data.</span><br>    <span class="hljs-keyword">var</span> services []debugService<br>    server.serviceMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namei, svci <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>        svc := svci.(*service)<br>        services = <span class="hljs-built_in">append</span>(services, debugService&#123;<br>            Name:   namei.(<span class="hljs-type">string</span>),<br>            Method: svc.method,<br>        &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>    err := debug.Execute(w, services)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        _, _ = fmt.Fprintln(w, <span class="hljs-string">&quot;rpc: error executing template:&quot;</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div></div><div class="fold collapsed"><div class="fold-title">main.go</div><div class="fold-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;geerpc&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    geerpc.HandleHTTP() <span class="hljs-comment">// 注册静态路由</span><br>    addr &lt;- l.Addr().String()<br>    _ = http.Serve(l, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 启动 HTTP 服务，不使用 accpet</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(addrCh <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    client, _ := geerpc.DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addrCh)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(context.Background(), <span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    log.SetFlags(<span class="hljs-number">0</span>)<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> call(ch)<br>    startServer(ch)<br>&#125;<br></code></pre></td></tr></table></figure></div></div><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Implement-From-Scratch/" class="category-chain-item">Implement From Scratch</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Go/">#Go</a> <a href="/tags/RPC/">#RPC</a> <a href="/tags/Framework/">#Framework</a></div></div><div class="license-box my-3"><div class="license-title"><div>从零实现系列｜RPC</div><div>https://www.aimtao.net/7days-rpc/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2024-10-18</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/docker-network/" title="指定 docker 容器的网段和IP"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">指定 docker 容器的网段和IP</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/copy-lock-value/" title="Golang 中返回含锁对象的风险"><span class="hidden-mobile">Golang 中返回含锁对象的风险</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>