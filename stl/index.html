<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="STL 是 C++ 的标准模版库，Standard Template Library。其中包含4个组件，分别为算法、容器、函数、迭代器。"><title>学习笔记｜STL - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2020-06-17-stl.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="学习笔记｜STL"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-06-17 17:04" pubdate>2020-06-17 PM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 57k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 44 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">学习笔记｜STL</h1><p class="note note-info">本文最后更新于：5 years ago</p><div class="markdown-body"><blockquote><p>STL 是 C++ 的标准模版库，<strong>Standard Template Library</strong>。其中包含4个组件，分别为算法、容器、函数、迭代器。</p></blockquote><span id="more"></span><h2 id="一、函数模版">一、函数模版</h2><h3 id="1-基本语法">1.基本语法</h3><p>编写代码时，可以忽略类型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// template&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MySwap</span><span class="hljs-params">(T1 &amp;a, T2 &amp;b)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以定义多个虚拟类型，T1，T2…</li><li>为了让编译器区分函数模版、普通函数，需要在函数模版前面写 <code>template&lt;class T&gt;</code> 。</li></ul><h3 id="2-自动类型推导和显式指定类型">2.自动类型推导和显式指定类型</h3><p>调用函数模版时，函数模版自动推导类型和显式指定类型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 自动类型推导</span><br>    <span class="hljs-built_in">MySwap</span>(a, b);<br>    <span class="hljs-comment">// 显式指定类型</span><br>    <span class="hljs-built_in">MySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-函数模版和普通函数的区别">3.函数模版和普通函数的区别</h3><ul><li>函数模版不提供隐式转换</li><li>普通函数会进行隐式转换，</li></ul><p><strong>情境一</strong>：当普通函数和函数模版重载，<strong>优先</strong> 调用普通函数。</p><p><strong>情境二</strong>：当需要发生隐式转换时，<strong>只能</strong> 调用普通函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &lt;T, T&gt; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &lt;int, int&gt; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">97</span>, b =<span class="hljs-number">98</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-built_in">Fun</span>(a, b);     <span class="hljs-comment">// &lt;int, int&gt; 存在满足要求的普通函数，优先调用普通函数。</span><br>    <span class="hljs-built_in">Fun</span>(c, a);    <span class="hljs-comment">// &lt;char, int&gt; 需要隐式转换的，必须调用普通函数。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>情境三</strong>：若要显式调用函数模版时，加 <code>&lt;&gt;</code> 。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">Fun&lt;&gt;(a, b);<br></code></pre></td></tr></table></figure><h3 id="4-模版函数的实现原理">4.模版函数的实现原理</h3><p><strong>过程</strong>：</p><p><img src="https://hutu.aimtao.net/mark/2020-06-19-l0ZhlS.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>注意</strong>：</p><ul><li>编译器不能直接调用函数模版。编译器不是把函数模板处理成能够处理任意类的函数。</li><li>编译器根据具体的函数类型，生成模版函数。</li><li><strong>编译器对函数模版进行两次编译</strong>：<ol><li>在声明函数模版的地方，对函数模版本身进行编译。</li><li>在调用模版函数的地方，替换参数后，进行编译。</li></ol></li></ul><h2 id="二、类模版">二、类模版</h2><h3 id="1-基本格式">1.基本格式</h3><ul><li>定义类时，要写 <code>template&lt;class T&gt;</code> 。</li><li>实例化对象时，必须显式提供所泛化的具体类型。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(T id, T age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id_ = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;id = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;id_ &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T id_;           <span class="hljs-comment">// 类中成员变量可用 T 表示。</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">97</span>, <span class="hljs-number">98</span>)</span></span>;    <span class="hljs-comment">// 实例化对象时，必须显式提供所泛化的具体类型。</span><br>    a.<span class="hljs-built_in">Show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-类模版的派生">2.类模版的派生</h3><h4 id="（1）模版类派生普通类">（1）模版类派生普通类</h4><p>若派生类是普通类，需要显式提供基类的类型。</p><p>派生类从基类继承，需要让编译器知道，父类的数据类型具体是什么。<strong>（数据类型的本质：固定大小内存块的别名。）</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T age_;<br>    <span class="hljs-built_in">Animal</span>(T age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; age_ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&lt;<span class="hljs-type">int</span>&gt;&#123;    <span class="hljs-comment">// 【显式地提供参数类型】</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(<span class="hljs-type">int</span> age) : <span class="hljs-built_in">Animal</span>(age)&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am Cat!&quot;</span> &lt;&lt; endl;<br>        Animal::<span class="hljs-built_in">Print</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Cat <span class="hljs-title">cat</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cat.<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）模版类派生模版类">（2）模版类派生模版类</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 若子类是类模版，父类类型可以用 T 表示。</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T age_;<br>    <span class="hljs-built_in">Animal</span>(T age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; age_ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;      <span class="hljs-comment">// 【派生类也需要写明 &quot;template&lt;class T&gt; &quot;】</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&lt;T&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(T age) : <span class="hljs-built_in">Animal</span>&lt;T&gt;(age)&#123; &#125;   <span class="hljs-comment">// 【调用基类构造时，需要写明 泛型&lt;T&gt;】</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am Cat!&quot;</span> &lt;&lt; endl;<br>      Animal&lt;T&gt;::<span class="hljs-built_in">Print</span>();          <span class="hljs-comment">// 【使用类的限定符时，需要写明泛型&lt;T&gt;】</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Cat&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cat</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cat.<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-类模版-友元函数">3.类模版+友元函数</h3><h4 id="（1）类模版-普通-友元-类内定义">（1）类模版+普通/友元+类内定义</h4><p>和 <strong>普通类+普通/友元</strong> 相比，没有什么特殊的，一切正常。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, T age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;name_ = name;<br>        <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;                                            <span class="hljs-comment">// 普通函数的类内定义</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name_ &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age_ &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Person&lt;T&gt; &amp;person)&#123;    <span class="hljs-comment">// 友元函数的类内定义</span><br>        os &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; person.name_ &lt;&lt; endl;<br>        os &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; person.age_ &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    string name_;<br>    T age_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">person_01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">13</span>)</span></span>;<br>    person_<span class="hljs-number">01.</span><span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; person_01;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）类模版-普通函数-类外定义">（2）类模版+普通函数+类外定义</h4><p>类模版+普通函数+类外定义时，需要注意一下两点：</p><ol><li><p>类外实现类成员函数时，需要写明 <code>template &lt;class T&gt;</code> 。</p></li><li><p>使用 <strong>类作用域符</strong> 时，需要写明泛型。</p></li></ol><ul><li>person.h</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, T age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    string name_;<br>    T age_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://person.cc">person.cc</a></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;          <span class="hljs-comment">// 类成员函数，类外实现时，需要用 template &lt;class T&gt;</span><br>Person&lt;T&gt;::<span class="hljs-built_in">Person</span>(string name, T age)&#123;    <span class="hljs-comment">// 使用 类作用域符 时，需要写明泛型&lt;T&gt;</span><br>    <span class="hljs-keyword">this</span>-&gt;name_ = name;<br>    <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T&gt;::<span class="hljs-built_in">Print</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name_ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age_ &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p_01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">11</span>)</span></span>;<br>    p_<span class="hljs-number">01.</span><span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="（3）分文件编程报错">（3）分文件编程报错</h4><p>按照 <strong>类模版+普通函数+类外定义</strong> 的方式，会报错如下，原因是无法正确链接文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Undefined symbols <span class="hljs-keyword">for</span> architecture x86_64:<br>  <span class="hljs-string">&quot;Person&lt;int&gt;::Print()&quot;</span>, referenced from:<br>      _main <span class="hljs-keyword">in</span> main-02af6c.o<br>  <span class="hljs-string">&quot;Person&lt;int&gt;::Person(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, int)&quot;</span>, referenced from:<br>      _main <span class="hljs-keyword">in</span> main-02af6c.o<br>ld: symbol(s) not found <span class="hljs-keyword">for</span> architecture x86_64<br>clang: error: linker <span class="hljs-built_in">command</span> failed with <span class="hljs-built_in">exit</span> code 1 (use -v to see invocation)<br></code></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><p>将 <code>person.cc</code> 改为 <code>person.hpp</code> ，并在 <code>main.cc</code> 中 引用 <code>#include &quot;person.hpp&quot;</code> 。</p><ul><li>person.h</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, T age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    string name_;<br>    T age_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>person.hpp</li></ul><blockquote><p>将 <a target="_blank" rel="noopener" href="http://person.cc">person.cc</a> 改为 person.hpp 。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;          <span class="hljs-comment">// 类成员函数，类外实现时，需要用 template &lt;class T&gt;</span><br>Person&lt;T&gt;::<span class="hljs-built_in">Person</span>(string name, T age)&#123;    <span class="hljs-comment">// 使用 类作用域符 时，需要写明泛型&lt;T&gt;</span><br>    <span class="hljs-keyword">this</span>-&gt;name_ = name;<br>    <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T&gt;::<span class="hljs-built_in">Print</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name_ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age_ &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span>   <span class="hljs-comment">// 由 #include &quot;person.h&quot; 改为  #include &quot;person.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p_01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">11</span>)</span></span>;<br>    p_<span class="hljs-number">01.</span><span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="（4）C-编译机制">（4）C++编译机制</h4><p><strong>独立编译</strong>：当分文件编程时，每个文件都是单独编译，生成若干个 <code>.o</code> 文件，并用链接器寻找相关文件，完成运行。</p><p><strong>二次编译</strong>：类模版先编译一次，检测语法错误，分析语义，再根据实际的类型，生成模版函数，进行第二次编译。</p><p><strong>冲突</strong>：独立编译后，才进行二次编译，所以链接器找不到类外定义的函数模版 所生成的 模版函数。容易发生的错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-string">&quot;operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, Person&lt;int&gt;&amp;)&quot;</span>, referenced from:<br>      _main <span class="hljs-keyword">in</span> 友元+类模版+友元+重载左移动-c601b9.o<br>ld: symbol(s) not found <span class="hljs-keyword">for</span> architecture x86_64<br>clang: error: linker <span class="hljs-built_in">command</span> failed with <span class="hljs-built_in">exit</span> code 1 (use -v to see invocation)<br></code></pre></td></tr></table></figure><h4 id="（5）类模版-友元函数-类外定义">（5）类模版+友元函数+类外定义</h4><h5 id="第一种格式：二重模版">第一种格式：二重模版</h5><p>定义友元函数时，使用一个新的泛型 T2 表示。</p><ul><li>person.h</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, T age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;                    <span class="hljs-comment">// 定义一个泛型 T2</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Person&lt;T2&gt; &amp;person);<br><br><span class="hljs-keyword">public</span>:<br>    string name_;<br>    T age_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>person.hpp</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>Person&lt;T&gt;::<span class="hljs-built_in">Person</span>(string name, T age)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;name_ = name;<br>    <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T&gt;::<span class="hljs-built_in">Print</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name_ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age_ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;           <span class="hljs-comment">// 函数实现时，也需要声明泛型 T2</span><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Person&lt;T2&gt; &amp;person)&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; person.name_ &lt;&lt; endl;<br>    os &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; person.age_ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">person_01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">13</span>)</span></span>;<br>    person_<span class="hljs-number">01.</span><span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; person_01;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第二种格式：声明前置">第二种格式：声明前置</h5><p>在类的定义和友元函数的定义前面，加上二者的声明。</p><ul><li>person.h</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 前置声明 类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-comment">// 前置声明 友元函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Person&lt;T&gt; &amp;person);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, T age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 在 函数名和参数列表之间 声明泛型 &lt;T&gt;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt; &lt;T&gt; (ostream &amp;os, Person&lt;T&gt; &amp;person);<br><br><span class="hljs-keyword">public</span>:<br>    string name_;<br>    T age_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>person.hpp</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>Person&lt;T&gt;::<span class="hljs-built_in">Person</span>(string name, T age)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;name_ = name;<br>    <span class="hljs-keyword">this</span>-&gt;age_ = age;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T&gt;::<span class="hljs-built_in">Print</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name_ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age_ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Person&lt;T&gt; &amp;person)&#123;   <span class="hljs-comment">// 函数实现时，无需添加 泛型&lt;T&gt;</span><br>    os &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; person.name_ &lt;&lt; endl;<br>    os &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; person.age_ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">person_01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">13</span>)</span></span>;<br>    person_<span class="hljs-number">01.</span><span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; person_01;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-类模版-static成员">4.类模版+static成员</h3><p>static 变量属于 <strong>实际的类</strong>，而不属于 类模版。</p><p><strong>实际的类</strong> 由实际的 <strong>泛型 <code>&lt;T&gt;</code></strong> 最后的值决定。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> Person&lt;T&gt;::a = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 类外初始化 static 变量。</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person&lt;<span class="hljs-type">int</span>&gt; p1, p2;    <span class="hljs-comment">// 类模版为 int 的类，共用 static 变量。</span><br>      Person&lt;<span class="hljs-type">int</span>&gt; p3, p4;<br>  <br>      Person&lt;<span class="hljs-type">char</span>&gt; c1, c2;   <span class="hljs-comment">// 类模版为 char 的类，共用 static 变量。</span><br>      <br>    p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; p<span class="hljs-number">4.</span>a;         <span class="hljs-comment">// 10</span><br>      cout &lt;&lt; c<span class="hljs-number">1.</span>a;         <span class="hljs-comment">// 0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-实例：MyArray">5.实例：MyArray</h3><p>自定义一个数组的模版类。</p><ul><li><code>&lt;T&gt;</code> 对象元素必须能够被拷贝。</li><li>容器都是值寓意，而非引用寓意，放入容器的元素，都是拷贝份。</li><li>元素成员有指针，注意深拷贝。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> max_size);<br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> MyArray&lt;T&gt; &amp;another);<br>    T &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;index);<br>    MyArray&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyArray&lt;T&gt; &amp;another);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushBack</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;data)</span></span>;    <span class="hljs-comment">// 用 const 引用，来接收 变量、常量。</span><br>    ~<span class="hljs-built_in">MyArray</span>();<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 数组大小</span><br>    <span class="hljs-type">int</span> max_size_;<br>    <span class="hljs-comment">// 数组当前元素个数</span><br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-comment">// 数组头指针</span><br>    T *arr_ptr_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>MyArray&lt;T&gt;::<span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> max_size)&#123;       <span class="hljs-comment">// 使用 类作用域符 时，需要写 泛型&lt;T&gt;</span><br>    <span class="hljs-keyword">this</span>-&gt;max_size_ = max_size;<br>    <span class="hljs-keyword">this</span>-&gt;arr_ptr_ = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;max_size_];<br>    <span class="hljs-keyword">this</span>-&gt;size_ = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>MyArray&lt;T&gt;::<span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> MyArray&lt;T&gt; &amp;another)&#123;<br>    <span class="hljs-comment">//【拷贝构造】，不需要判断指针是否为空，【等号操作符】需要。</span><br>    <span class="hljs-keyword">this</span>-&gt;max_size_ = another.max_size_;<br>    <span class="hljs-keyword">this</span>-&gt;size_ = another.size_;<br>    <span class="hljs-keyword">this</span>-&gt;arr_ptr_ = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;max_size_];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;size_; i++) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;arr_ptr_[i] = another.arr_ptr_[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T &amp;MyArray&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;index)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;size_ &lt;= index)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;索引越界！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;arr_ptr_[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;arr_ptr_[index];<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>MyArray&lt;T&gt; &amp;MyArray&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyArray&lt;T&gt; &amp;another)&#123;<br>    <span class="hljs-comment">// 【等号操作符】，需要先判断数组指针是否为空，而不是判断 size 大小。</span><br>    <span class="hljs-comment">//【拷贝构造】，不需要判断指针是否为空。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;arr_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;arr_ptr_;<br>        <span class="hljs-keyword">this</span>-&gt;arr_ptr_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;max_size_ = another.max_size_;    <span class="hljs-comment">// 类的三个成员变量 都需要考虑到，不要只拷贝数组。</span><br>    <span class="hljs-keyword">this</span>-&gt;size_ = another.size_;<br>    <span class="hljs-keyword">this</span>-&gt;arr_ptr_ = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;max_size_];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;size_; i++) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;arr_ptr_[i] = another.arr_ptr_[i]; <br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> MyArray&lt;T&gt;::<span class="hljs-built_in">Print</span>()&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;size_; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;arr_ptr_[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> MyArray&lt;T&gt;::<span class="hljs-built_in">PushBack</span>(<span class="hljs-type">const</span> T &amp;data)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;size_ == <span class="hljs-keyword">this</span>-&gt;max_size_) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;数组已满！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;arr_ptr_[<span class="hljs-keyword">this</span>-&gt;size_] = data;<br>    <span class="hljs-keyword">this</span>-&gt;size_ ++;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>MyArray&lt;T&gt;::~<span class="hljs-built_in">MyArray</span>()&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;arr_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;arr_ptr_;<br>        <span class="hljs-keyword">this</span>-&gt;arr_ptr_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>, <span class="hljs-title">arr2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    arr<span class="hljs-number">1.</span><span class="hljs-built_in">PushBack</span>(<span class="hljs-number">10</span>);<br>    arr<span class="hljs-number">1.</span><span class="hljs-built_in">PushBack</span>(<span class="hljs-number">9</span>);<br>    arr<span class="hljs-number">1.</span><span class="hljs-built_in">PushBack</span>(<span class="hljs-number">8</span>);<br>    arr<span class="hljs-number">1.</span><span class="hljs-built_in">PushBack</span>(<span class="hljs-number">7</span>);<br>    arr<span class="hljs-number">1.</span><span class="hljs-built_in">PushBack</span>(<span class="hljs-number">6</span>);<br>    arr2 = arr1;<br>    MyArray&lt;<span class="hljs-type">int</span>&gt; arr4 = arr2;<br>    arr<span class="hljs-number">4.</span><span class="hljs-built_in">Print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、类型转换">三、类型转换</h2><table><thead><tr><th>static_cast</th><th>内置的数据类型转换，以及具有继承关系的指针和引用的转换。【父类转换为子类时，不安全】</th><th>不会进行安全检查。</th></tr></thead><tbody><tr><td>dynamic_cast</td><td>具有继承关系的指针和引用的转换。【<strong>只能从子类转换为父类</strong>】</td><td>转换之前，进行对象类型的安全检查</td></tr><tr><td>const_cas</td><td>增加或去除 const 。</td><td></td></tr><tr><td>reinterpret_cast</td><td>无关的指针类型的转换，或者函数指针之间的转换。</td><td></td></tr></tbody></table><h3 id="1-static-cast">1.static_cast</h3><p><code>static_cast&lt;目的类型&gt;(待转换变量)</code></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 基础类型</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(a);<br><br><span class="hljs-comment">// 基础数据类型指针【报错！】</span><br><span class="hljs-comment">// int *p1 = nullptr;</span><br><span class="hljs-comment">// char *p2 = static_cast&lt;char *&gt;(p1);</span><br><br><span class="hljs-comment">// 非继承关系的指针和引用【报错！】</span><br><span class="hljs-comment">// class ObjA &#123;&#125;;</span><br><span class="hljs-comment">// class ObjB &#123;&#125;;</span><br><span class="hljs-comment">// ObjA *p1 = nullptr;</span><br><span class="hljs-comment">// ObjB *p2 = static_cast&lt;ObjB *&gt;(p1);</span><br><br><span class="hljs-comment">// 具有继承关系的指针和引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjB</span> : <span class="hljs-keyword">public</span> ObjA &#123;&#125;;<br>    <span class="hljs-comment">// 1.父类指针转化为子类指针</span><br>ObjA *p1 = <span class="hljs-literal">nullptr</span>;<br>ObjB *p2 = <span class="hljs-built_in">static_cast</span>&lt;ObjB *&gt;(p1);<br>    <span class="hljs-comment">// 2.子类指针转化为父类指针</span><br>ObjB *p3 = <span class="hljs-literal">nullptr</span>;<br>ObjA *p4 = <span class="hljs-built_in">static_cast</span>&lt;ObjA *&gt;(p3);<br>    <span class="hljs-comment">// 3.父类引用转化为子类引用</span><br>ObjA obj_a_1;<br>ObjA &amp;obj_aaa_1 = obj_a_1;<br>ObjB &amp;obj_bbb_1 = <span class="hljs-built_in">static_cast</span>&lt;ObjB &amp;&gt;(obj_aaa_1);<br>    <span class="hljs-comment">// 4.子类引用转化为父类引用</span><br>ObjB obj_b_2;<br>ObjB &amp;obj_bbb_2 = obj_b_2;<br>ObjA &amp;obj_aaa_2 = <span class="hljs-built_in">static_cast</span>&lt;ObjA &amp;&gt;(obj_bbb_2);<br></code></pre></td></tr></table></figure><h3 id="2-dynamic-cast">2.dynamic_cast</h3><p>转换之前，进行对象类型的安全检查，所以只能从子类转换到父类。避免父类指针转化为子类指针，操作安全区域之外的内存。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 基础数据类型【报错！】</span><br><span class="hljs-comment">// int a = 100;</span><br><span class="hljs-comment">// char c = dynamic_cast&lt;char&gt;(a);</span><br><br><span class="hljs-comment">// 非继承关系的指针和引用【报错！】</span><br><span class="hljs-comment">// class ObjA &#123;&#125;;</span><br><span class="hljs-comment">// class ObjB &#123;&#125;;</span><br><span class="hljs-comment">// ObjA *p1 = nullptr;</span><br><span class="hljs-comment">// ObjB *p2 = dynamic_cast&lt;ObjB *&gt;(p1);</span><br><br><span class="hljs-comment">// 具有继承关系的指针和引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjB</span> : <span class="hljs-keyword">public</span> ObjA &#123;&#125;;<br>    <span class="hljs-comment">// 1.父类指针转化为子类指针【报错！】</span><br><span class="hljs-comment">// ObjA *p1 = nullptr;</span><br><span class="hljs-comment">// ObjB *p2 = dynamic_cast&lt;ObjB *&gt;(p1);</span><br>    <span class="hljs-comment">// 2.子类指针转化为父类指针</span><br>ObjB *p3 = <span class="hljs-literal">nullptr</span>;<br>ObjA *p4 = <span class="hljs-built_in">dynamic_cast</span>&lt;ObjA *&gt;(p3);<br>    <span class="hljs-comment">// 3.父类引用转化为子类引用【报错！】</span><br><span class="hljs-comment">// ObjA obj_a_1;</span><br><span class="hljs-comment">// ObjA &amp;obj_aa_1 = obj_a_1;</span><br><span class="hljs-comment">// ObjB &amp;obj_bb_1 = dynamic_cast&lt;ObjB &amp;&gt;(obj_aa_1);</span><br>    <span class="hljs-comment">// 4.子类引用转化为父类引用</span><br>ObjB obj_b_2;<br>ObjB &amp;obj_bb_2 = obj_b_2;<br>ObjA &amp;obj_aa_2 = <span class="hljs-built_in">dynamic_cast</span>&lt;ObjA &amp;&gt;(obj_bb_2);<br></code></pre></td></tr></table></figure><h3 id="3-const-cast">3.const_cast</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 基础数据类型的引用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = a;<br><span class="hljs-type">int</span> &amp;c = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(b);<br><br><span class="hljs-comment">// 普通指针类型</span><br>    <span class="hljs-comment">// 去 const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(p1);<br>    <span class="hljs-comment">// 加 const</span><br><span class="hljs-type">int</span> *p3 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p4 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *&gt;(p3);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p5 = p3;<br></code></pre></td></tr></table></figure><h3 id="4-reinterpret-cast">4.reinterpret_cast</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*FUN_P_1)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*FUN_P_2)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 无关的指针类型</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjA</span> &#123;&#125;;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjB</span> &#123;&#125;;<br>    ObjA *p_a = <span class="hljs-literal">nullptr</span>;<br>    ObjB *p_b = <span class="hljs-built_in">reinterpret_cast</span>&lt;ObjB *&gt;(p_a);<br><br>    <span class="hljs-comment">// 函数指针的转换</span><br>    FUN_P_1 fun01;<br>    FUN_P_2 fun02 = <span class="hljs-built_in">reinterpret_cast</span>&lt;FUN_P_2&gt;(fun01);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-建议">5.建议</h3><ul><li><p>转换前应该知道，转换前后的类型是什么，后果是什么。（尤其是，指针转换前后，可操作的内存区域的变化）。</p></li><li><p>不建议使用。</p></li></ul><h2 id="四、异常">四、异常</h2><h3 id="1-异常的好处">1.异常的好处</h3><blockquote><p>在c语言中，我们使用函数返回值来表示异常。</p></blockquote><p>例如以下程序：当发生异常（b 等于 0），返回 -1 表示错误。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">// 返回 -1 表示错误</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)a/b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>函数返回值可以忽略；但异常不能忽略。如果程序出现异常，但未被捕获，程序就会终止。</p></li><li><p>整型返回值没有任何语义；而异常可以包含语义（比如类名）。</p></li><li><p>整型返回值没有上下文；而异常作为一个类，可以拥有自己的成员，传递足够完整的信息。</p></li><li><p>对于函数的多级调用，使用整型返回值，需要每一级函数都进行处理；而异常是跨函数的，使用异常处理的栈展开机制，只需在其中一级函数中处理就可以。</p></li></ul><h3 id="2-基础语法">2.基础语法</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> b;          <span class="hljs-comment">// 抛出异常</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;                  <span class="hljs-comment">// 尝试捕获异常</span><br>        <span class="hljs-built_in">Division</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;        <span class="hljs-comment">// 捕获异常</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;除数为&quot;</span> &lt;&lt; e &lt;&lt; endl;<br>    &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-跨函数-和-不可忽略">3.跨函数 和 不可忽略</h3><p>【<strong>跨函数性</strong>】</p><p>执行（入栈）顺序：main -&gt; Fun01 -&gt; Fun02 -&gt; divison。</p><p>divison 抛出异常，Fun02 没处理，往顶层抛，抛给 Fun01，Fun01 处理异常。</p><p>【<strong>不可忽略，必须处理</strong>】</p><p>若在顶层也没有处理异常，程序就会终止。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;         <span class="hljs-comment">// 抛出异常</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun02</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;            <span class="hljs-comment">// 没有处理异常</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Division</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun01</span><span class="hljs-params">()</span></span>&#123;                        <span class="hljs-comment">// 处理异常</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123; <br>        res = <span class="hljs-built_in">Fun02</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;除数为&quot;</span> &lt;&lt; e &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">Fun01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-栈解旋（unwinding）">4.栈解旋（unwinding）</h3><p>异常抛出后，从进入 try 块，到异常被抛出之前，此期间，栈上构造的所有对象，都会被自动析构。</p><p>跑异常的过程中，注意两个不执行：</p><ul><li>throw 后的代码并不执行。</li><li>try中，抛出异常后的代码并不执行。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Obj</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;num = num;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; 正在构造..&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Obj</span>()&#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; 正在析构...&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Devision</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-function">Obj <span class="hljs-title">obj_1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;      <span class="hljs-comment">// 栈解旋</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> b;<br>        <span class="hljs-function">Obj <span class="hljs-title">obj_2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// throw 后的代码并不执行。 </span><br>    &#125;<br>    <span class="hljs-function">Obj <span class="hljs-title">obj_2_1</span><span class="hljs-params">(<span class="hljs-number">21</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">Obj <span class="hljs-title">obj_3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;       <span class="hljs-comment">// 栈解旋</span><br>        <span class="hljs-built_in">Devision</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 抛出异常</span><br>        <span class="hljs-function">Obj <span class="hljs-title">obj_4</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;       <span class="hljs-comment">// try中，抛出异常后，代码并不执行。</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获异常&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-异常接口的声明">5.异常接口的声明</h3><ul><li>只能抛出 int, float, char 三种类型异常。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun01</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-type">char</span>)</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;abc&quot;</span>;      <span class="hljs-comment">// 抛出不是以上三种类型时，【程序报错】。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不能抛出任何类型的异常</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun02</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">// 抛出了异常，【程序报错】。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以抛出所有类型异常</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fun03</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>捕获多种类型的方式</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">Fun01</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;           <span class="hljs-comment">// 捕获 int，没捕获到继续执行</span><br>        cout &lt;&lt; e &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">char</span> e) &#123;          <span class="hljs-comment">// 捕获 char，没捕获到继续执行</span><br>        cout &lt;&lt; e &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...) &#123;             <span class="hljs-comment">// 省略号，可以捕获所有类型异常。</span><br>        cout &lt;&lt; “未知类型异常”  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-对象做异常类型">6.对象做异常类型</h3><p>抛对象异常<code>throw Exception(&quot;此处出现异象的原因是......&quot;);</code>和捕捉对象异常<code>catch (Exception e)</code>的中间，有一个拷贝构构造存在。（如果 e 是引用，见 <a href="#异常对象的生命周期">异常对象的生命周期</a>）</p><p>抛出的对象，不适用于 <a href="https://www.aimtao.net/copy-elision/" rel="nofollow noopener" target="_blank">拷贝省略</a>。</p><p>所以，如果对象中有指向堆区的指针，类中要写清楚拷贝构造函数（深拷贝），不能使用默认的拷贝构造（浅拷贝）。浅拷贝导致两个指针指向一个堆区空间，析构时会产生错误。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 异常类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;开始构造！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">this</span>-&gt;error = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(error, str);<br>    &#125;<br>    <span class="hljs-comment">// 必须写拷贝构造，不可以用默认拷贝构造（浅拷贝）</span><br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> Exception &amp;e)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;开始拷贝！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">this</span>-&gt;error = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(e.error) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;error, e.error);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;error &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Exception</span>()&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;error != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;error;<br>            <span class="hljs-keyword">this</span>-&gt;error = <span class="hljs-literal">nullptr</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;开始析构!&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> *error;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;此处出现异象的原因是......&quot;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">Fun</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (Exception e) &#123;    <span class="hljs-comment">// 捕捉异常后，调用类中函数。</span><br>        e.<span class="hljs-built_in">Show</span>();<br>        e.~<span class="hljs-built_in">Exception</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">开始构造！                  // throw Exception(&quot;此处出现异象的原因是......&quot;);</span><br><span class="hljs-comment">开始拷贝！                  // catch (Exception e)</span><br><span class="hljs-comment">此处出现异象的原因是......    // e.Show();</span><br><span class="hljs-comment">开始析构!                   // e.~Exception();</span><br><span class="hljs-comment">开始析构!                   // Exception().~Exception()  //  catch 处理完异常对象，析构。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><a name="异常对象的生命周期"></a></p><h3 id="7-异常对象的生命周期">7.异常对象的生命周期</h3><ul><li>普通类型</li></ul><p>普通类型，异常对象，在 catch 大括号处理完之后，析构。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始构造！&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> Exception &amp;e)&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始拷贝！&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始析构!&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>();<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">Fun</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (Exception e <span class="hljs-comment">/*【此处普通类型】*/</span>) &#123;         <span class="hljs-comment">// e 的生命周期：catch 大括号结束。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获异常&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">开始构造！                  // throw Exception();</span><br><span class="hljs-comment">开始拷贝！                  // catch (Exception e)</span><br><span class="hljs-comment">此处出现异象的原因是......    // cout &lt;&lt; &quot;捕获异常&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">开始析构!                   // e.~Exception();</span><br><span class="hljs-comment">开始析构!                   // Exception().~Exception()  //  catch 处理完异常对象，析构。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>引用</li></ul><p>引用，不用调用拷贝构造，异常对象 catch 处理完之后，析构。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始构造！&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> Exception &amp;e)&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始拷贝！&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始析构!&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>();<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">Fun</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (Exception &amp;e<span class="hljs-comment">/*【此处引用】*/</span>) &#123;         <span class="hljs-comment">// e 的生命周期：catch 大括号结束。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获异常&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">开始构造！    // throw Exception();</span><br><span class="hljs-comment">捕获异常      // cout &lt;&lt; &quot;捕获异常&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">开始析构!     //  Exception().~Exception()   //  catch 处理完异常对象，析构。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>指针</li></ul><p>传递完指针，还未进入 catch 大括号，就会被立刻析构掉，但是异常类对象还在栈上（还可以调用函数，但是不能使用堆区空间）。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始构造！&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> Exception &amp;e)&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始拷贝！&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Exception</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;开始析构!&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    Exception tmp;<br>    <span class="hljs-keyword">throw</span> &amp;tmp;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">Fun</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (Exception *e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获异常&quot;</span> &lt;&lt; endl;<br>        e-&gt;~<span class="hljs-built_in">Exception</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">开始构造！    // Exception tmp;</span><br><span class="hljs-comment">开始析构!     // catch (Exception *e);   // 执行完 Exception *e，还没进入 catch 大括号，就被析构。</span><br><span class="hljs-comment">捕获异常      // cout &lt;&lt; &quot;捕获异常&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">开始析构!     // e-&gt;~Exception(); 析构堆区的空间，若无堆区空间，可多次析构。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="五、输入输出流">五、输入输出流</h2><h3 id="1-流的概念和流类库">1.流的概念和流类库</h3><p>键盘输入数据到程序：标准输入 input</p><p>程序输出到显示器：标准输出 output</p><p>标准输入 + 标准输出 = 标准I/O</p><p>文件的输入输出 = 文件I/O</p><p>cout：全局的流对象（ostream类），默认与屏幕关联。</p><p>cin：全局的流对象（istream类），默认与键盘关联。</p><p>cerr：标准错误，无缓冲区。</p><p>clog：标准日志，有缓冲区。</p><h3 id="2-缓冲区">2.缓冲区</h3><blockquote><p>缓冲区：一块内存。</p></blockquote><p>程序从输入缓冲区读数据，发现输入缓冲区没有数据，程序阻塞，等待键盘输入。</p><p>输出时，输出缓冲区满，或者刷新输出缓冲区，才可以输出到屏幕上。</p><p><strong>PS</strong>：在 windos 下，<code>cout &lt;&lt; &quot;hello world&quot;;</code> 会立即从缓冲区打印到屏幕上。</p><p>在 Linux 下，<code>cout &lt;&lt; &quot;hello world&quot;;</code> 不会立刻打印在屏幕，而是输出到输出缓冲区。</p><p><code>cout &lt;&lt; &quot;hello world &lt;&lt; endl;&quot;</code> 会立刻打印在屏幕上。endl 的作用：输出换行符，并刷新缓冲区。</p><p>用以下代码验证：（注意 “有endl的cout”，“有endl的cout” 的打印时间）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入&quot;</span>;<br>    <span class="hljs-type">int</span> a;<br>    cin &gt;&gt; a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;有endl的cout&quot;</span> &lt;&lt; endl;     <span class="hljs-comment">// 从缓冲区立即打印到屏幕。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;没有endl的cout&quot;</span>;           <span class="hljs-comment">// 不会立即打印到屏幕，for循环运行结束才会打印。 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i  = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>        <span class="hljs-type">int</span> num = i + i - i;     <br>    &#125;<br>    cout &lt;&lt; a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-cin的特点">3.cin的特点</h3><p>遇到 Tab、空格space、回车Enter时结束，并且空格换行符会留在缓冲区。</p><h3 id="4-cin-get">4.cin.get()</h3><p><strong>（1）无参数</strong></p><blockquote><p>从输入缓冲区读取一个字符，返回值为读取到的字符。</p></blockquote><p>可以读空格、读回车。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">while</span>((ch = cin.<span class="hljs-built_in">get</span>()) != EOF)&#123;  <span class="hljs-comment">// 判断是否是结束</span><br>    cout &lt;&lt; ch &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）一个参数</strong></p><blockquote><p>读取一个字符，给变量赋值。</p></blockquote><p>可以读空格、读回车。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch；<br>cin.<span class="hljs-built_in">get</span>(ch);    <span class="hljs-comment">// 参数为：字符变量</span><br></code></pre></td></tr></table></figure><p><strong>（3）两个参数</strong></p><blockquote><p>读取一个字符串，并给变量赋值。</p></blockquote><p>字符串中可以包含空格，不可以包含回车。</p><p>遇到回车结束，并将回车键保留在缓冲区（和 cin 一样）。(所以不能连续使用 cin.get() )</p><p>注意最后有结束符，所以 <code>cin.get(chars, 5);</code> 最多只能读取 4 个字符。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> chars[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>cin.<span class="hljs-built_in">get</span>(chars, <span class="hljs-number">5</span>);       <span class="hljs-comment">// 参数为：字符串变量名， 获取字符串的长度为5</span><br><br><span class="hljs-type">char</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>cin.<span class="hljs-built_in">get</span>(p, <span class="hljs-number">10</span>);                    <span class="hljs-comment">// 参数为：字符串首地址， 获取字符串的长度为10</span><br></code></pre></td></tr></table></figure><h3 id="5-cin-getline">5.cin.getline()</h3><blockquote><p>读取一行字符串。</p></blockquote><p>字符串中可以包含空格，不可以包含回车。</p><p>【<strong>重要</strong>】遇到回车结束，并删除该回车键，<strong>不在缓冲区保留</strong>。（和 cin、cin.get(buf, 10) 的区别）。</p><p><code>cin.getline(buf, 10);</code> 减去字符串结束符，最多只能读取 9 个字符，若越界，后面其他的 cin语句 不会执行。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>cin.<span class="hljs-built_in">getline</span>(buf, <span class="hljs-number">5</span>);   <span class="hljs-comment">// 读取一个字符串。并去除回车键，以免下一行的 cin.get() 读到回车键。</span><br>cin.<span class="hljs-built_in">get</span>(ch);<br>cout &lt;&lt; <span class="hljs-string">&quot;==&quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot;==&quot;</span>; <br></code></pre></td></tr></table></figure><p><strong>PS：遇到特定字符结束</strong>：</p><p>加入第三个参数，表示遇到该字符时，结束读取，并且该字符不在缓冲区保留。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>cin.<span class="hljs-built_in">getline</span>(buf, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;9&#x27;</span>);  <br><span class="hljs-comment">// 当输入 “19” 时，buf = “1”;</span><br><span class="hljs-comment">// ‘9’既不保存在 buf 中，也不保存在 缓冲区 中。</span><br></code></pre></td></tr></table></figure><h3 id="6-cin-ignore">6.cin.ignore()</h3><blockquote><p>忽略缓冲区当前的字符。</p></blockquote><p>比如 cin 之后，碰到空格结束，但是空格还在缓冲区，就可以使用 cin.ignore() 删除缓冲区当前字符。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>], b;<br>cin.<span class="hljs-built_in">get</span>(a, <span class="hljs-number">10</span>);<br>cin.<span class="hljs-built_in">ignore</span>()<br>cin.<span class="hljs-built_in">get</span>(b);<br><span class="hljs-comment">// 当输入 “xxx\ny” 时，变量 b 不是回车，而是 ‘y’，因为 ‘\n’ 被忽略了。</span><br></code></pre></td></tr></table></figure><p><strong>PS</strong>：无参数和有参数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 表示忽略 1 个字符</span><br>cin.<span class="hljs-built_in">ignore</span>();<br><br><span class="hljs-comment">//表示忽略 10 个字符</span><br>cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 表示忽略 10 个字符，如果碰到 ‘\n’,停止忽略。</span><br>cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="7-cin-peek">7.cin.peek()</h3><blockquote><p>看一看缓冲区的第一个字符，但是不取走。返回值为缓冲区的第一个字符。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch = cin.<span class="hljs-built_in">peek</span>();<br></code></pre></td></tr></table></figure><p>举个例子：实现功能：识别输入的是字符串还是数字。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch = cin.peek;              <span class="hljs-comment">// 看一看缓冲区的第一个字符是什么。</span><br><span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;     <span class="hljs-comment">// 对第一个字符进行判断。</span><br>    <span class="hljs-type">int</span> number;<br>    cin &gt;&gt; number;                 <span class="hljs-comment">// 真正读取缓冲区数据。</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;输入的是数字：&quot;</span> &lt;&lt; number &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    cin &gt;&gt; buf;                    <span class="hljs-comment">// 真正读取缓冲区数据。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入的是字符串：&quot;</span> &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-cin-putback">8.cin.putback()</h3><blockquote><p>把字符放回缓冲区。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch = ‘a’;<br>cin.<span class="hljs-built_in">putback</span>(ch);<br></code></pre></td></tr></table></figure><p>举个例子：实现和上面相同的功能：识别输入的是字符串还是数字。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> ch = cin.<span class="hljs-built_in">get</span>();             <span class="hljs-comment">// 读取缓冲区第一个字符。</span><br>cin.<span class="hljs-built_in">putback</span>(ch);                 <span class="hljs-comment">// 将第一个字符放回缓冲区。</span><br><span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;     <span class="hljs-comment">// 对第一个字符进行判断。</span><br>    nt number;<br>    cin &gt;&gt; number;                 <span class="hljs-comment">// 读取缓冲区数据。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入的是数字：&quot;</span> &lt;&lt; number &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    cin &gt;&gt; buf;                    <span class="hljs-comment">// 读取缓冲区数据。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入的是字符串：&quot;</span> &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-getline">9.getline()</h3><blockquote><p>cin.getline() 是 istream 类的成员函数，在头文件 &lt;istream&gt; 中。</p><p>getline() 是普通函数，在头文件 &lt;string&gt; 中。</p><p>区别在于 getline() 可以读取 string 字符串。</p></blockquote><p>先看一下函数声明：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 类的成员函数</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n )</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n, <span class="hljs-type">char</span> delim )</span></span>;<br><br><span class="hljs-comment">// 普通函数（需要将类对象传递进去）</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(istream&amp;  is, string&amp; str, <span class="hljs-type">char</span> delim)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(istream&amp;&amp; is, string&amp; str, <span class="hljs-type">char</span> delim)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">(istream&amp;  is, string&amp; str)</span></span>;<br></code></pre></td></tr></table></figure><p>与 cin.getline() 一样，可以读取空格，不可以读取回车。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br></code></pre></td></tr></table></figure><h3 id="10-cout-flush">10.cout.flush()</h3><blockquote><p>刷新缓冲区</p></blockquote><p>如果缓冲区没满，或者程序没有结束，cout 是不会输出的，必须刷新缓冲区才可以。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">cout.<span class="hljs-built_in">flush</span>();<br><span class="hljs-comment">// 类似的函数：int fflush(FILE *stream);</span><br></code></pre></td></tr></table></figure><h3 id="11-cout-put">11.cout.put()</h3><blockquote><p>向 输出缓冲区 写入一个字符。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br>cout.<span class="hljs-built_in">put</span>(c);<br><br><span class="hljs-comment">// 支持链式编程</span><br>cout.<span class="hljs-built_in">put</span>(c).<span class="hljs-built_in">put</span>(c).<span class="hljs-built_in">put</span>(c) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="12-cout-write">12.cout.write()</h3><blockquote><p>按长度向 输出缓冲区 写入字符串。</p></blockquote><p>第一个参数为字符串地址，第二个参数为输出字符的个数（不算结束符’\0’）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>cout.<span class="hljs-built_in">write</span>(s, <span class="hljs-built_in">strlen</span>(s)) &lt;&lt; endl;<br>cout.<span class="hljs-built_in">write</span>(s, <span class="hljs-number">3</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="13-cout-width-、cout-fill-、cout-setf">13.cout.width()、cout.fill()、cout.setf()</h3><blockquote><p>输出格式控制</p></blockquote><p><strong>通过成员方法的方式</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> number = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 控制进制</span><br>cout.<span class="hljs-built_in">unsetf</span>(ios::dec);     <span class="hljs-comment">// 卸载当前默认的 10 进制输出方式。</span><br>cout.<span class="hljs-built_in">setf</span>(ios::oct);       <span class="hljs-comment">// 设置成八进制输出</span><br>cout.<span class="hljs-built_in">setf</span>(ios::showbase);  <span class="hljs-comment">// 显示八进制数字前的0，十六进制数字前的0x</span><br>cout &lt;&lt; number &lt;&lt; endl;    <span class="hljs-comment">// 此时，打印为：012</span><br><br><span class="hljs-comment">// 控制宽度</span><br>cout.<span class="hljs-built_in">width</span>(<span class="hljs-number">5</span>);            <span class="hljs-comment">// 设置为宽度为 5</span><br>cout.<span class="hljs-built_in">fill</span>(<span class="hljs-string">&#x27;*&#x27;</span>);           <span class="hljs-comment">// 默认右对齐，多余的位置使用 * 填充</span><br>cout &lt;&lt; number &lt;&lt; endl;   <span class="hljs-comment">// 此时，打印为：**012</span><br><br><span class="hljs-comment">// 设置左对齐</span><br>cout.<span class="hljs-built_in">setf</span>(ios::left);      <span class="hljs-comment">// 设置左对齐</span><br>cout &lt;&lt; number &lt;&lt; endl;    <span class="hljs-comment">// 此时，打印为：012**</span><br></code></pre></td></tr></table></figure><p><strong>通过控制符的方式</strong>：</p><p>需要引入头文件 <code>#include &lt;iomanip&gt;</code></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> number = <span class="hljs-number">10</span>;<br>cout &lt;&lt; oct      <span class="hljs-comment">//八进制输出</span><br>       &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::showbase)		<span class="hljs-comment">// 显示八进制数字前的0，十六进制数字前的0x</span><br>     &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>)        <span class="hljs-comment">// 设置为宽度为 5</span><br>     &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;*&#x27;</span>)        <span class="hljs-comment">// 多余的位置使用 * 填充</span><br>     &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::left)    <span class="hljs-comment">// 设置左对齐</span><br>     &lt;&lt; number<br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="六、文件操作">六、文件操作</h2><p>继承关系：</p><ul><li>iostream 多继承于 istream 和 ostream。</li><li>fstream 继承于 iostream。</li></ul><pre><code class="mermaid">graph TD
A(istream) --&gt; B(ifstream) 
A --&gt; E(iostream)
C(ostream) --&gt; E
C --&gt; D(ofstream)
E --&gt; F(fstream)
</code></pre><h3 id="1-文本文件">1.文本文件</h3><p><strong>（1）文件读写的头文件</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>（2）打开文件</strong></p><p>通过 ifstream 类的构造函数打开文件。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">string source_file_name = <span class="hljs-string">&quot;/test_source/STL/todo.txt&quot;</span>;   <span class="hljs-comment">// 文件路径。</span><br><span class="hljs-function">ifstream <span class="hljs-title">ism</span><span class="hljs-params">(source_file_name, ios::in)</span></span>;  <span class="hljs-comment">// 只读的方式打开。</span><br><br>string target_file_name = <span class="hljs-string">&quot;/test_source/STL/todo_copy.txt&quot;</span>;<br><span class="hljs-function">ofstream <span class="hljs-title">osm</span><span class="hljs-params">(target_file_name, ios::out | ios::app)</span></span>;<br></code></pre></td></tr></table></figure><p>通过 ifstream 类的成员函数打开文件。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">ifstream osm;<br>osm.<span class="hljs-built_in">open</span>(source_file_name, ios::in);<br></code></pre></td></tr></table></figure><p><strong>标志含义</strong>：</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>ios::app</td><td>所有写入的字符追加在文件末尾。</td></tr><tr><td>ios::in</td><td>只读的方式打开。</td></tr><tr><td>ios::out</td><td>写入的方式打开。</td></tr><tr><td>ios::trunc</td><td>如果文件存在，清空文件。</td></tr><tr><td>ios::binary</td><td>二进制的方式打开。</td></tr></tbody></table><p>可以多个标志结合使用：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 写入的方式打开，并将写入的内容追加在文件末尾。</span><br>osm.<span class="hljs-built_in">open</span>(target_file_name, ios::out | ios:: app);<br></code></pre></td></tr></table></figure><p><strong>（3）判断是否为空</strong></p><p>fstream 重载了 <code>!</code> 符号。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">if</span> (!ism || !osm) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）读写文件</strong></p><p>因为 fstream 是多继承于 iostream 的，所以 cin、cout 的成员函数：get()，getline()，ignore() 等等都可以使用。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 读文件 &amp; 写文件</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(ism.<span class="hljs-built_in">get</span>(ch)) &#123;<br>    cout &lt;&lt; ch;<br>    osm.<span class="hljs-built_in">put</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）关闭文件</strong></p><p>依旧是类的成员函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">ism.<span class="hljs-built_in">close</span>();<br>osm.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h4 id="实例：拷贝文件">实例：拷贝文件</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">/*</span><br><span class="hljs-comment">实现拷贝文本文件的功能。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 打开读文件</span><br>    string source_file_name = <span class="hljs-string">&quot;/test_source/STL/todo.txt&quot;</span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ism</span><span class="hljs-params">(source_file_name, ios::in)</span></span>;<br>    <span class="hljs-comment">// ifstream ism;</span><br>    <span class="hljs-comment">// ism.open(source_file_name, ios::in);</span><br><br>    <span class="hljs-comment">// 打开写文件</span><br>    string target_file_name = <span class="hljs-string">&quot;/test_source/STL/todo_copy.txt&quot;</span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">osm</span><span class="hljs-params">(target_file_name, ios::out | ios::app)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!ism || !osm) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 读文件 &amp; 写文件</span><br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-keyword">while</span>(ism.<span class="hljs-built_in">get</span>(ch)) &#123;<br>        cout &lt;&lt; ch;<br>        osm.<span class="hljs-built_in">put</span>(ch);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 关闭文件</span><br>    ism.<span class="hljs-built_in">close</span>();<br>    osm.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-二进制文件">2.二进制文件</h3><p>与文本文件不一样的地方是：打开文件的时候，使用 <code>ios::binary</code> 标签。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">ofstream <span class="hljs-title">osm</span><span class="hljs-params">(target_file_name, ios::out | ios::binary)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="实例：对象序列化">实例：对象序列化</h4><blockquote><p>对象序列化：以流的形式，将对象保存到磁盘文件中。</p></blockquote><p>值得注意的地方，写文件时，对对象取地址，并强转为 char* 类型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">osm.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;p1, <span class="hljs-built_in">sizeof</span>(Person));<br></code></pre></td></tr></table></figure><p>完整如下：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">age</span>(age), <span class="hljs-built_in">id</span>(id)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 创建类对象</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>    <span class="hljs-comment">// 1.打开文件</span><br>    string target_file_name = <span class="hljs-string">&quot;/Users/STL/todo&quot;</span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">osm</span><span class="hljs-params">(target_file_name, ios::out | ios::binary)</span></span>;  <span class="hljs-comment">// 二进制的方式打开。</span><br><br>    <span class="hljs-comment">// 2.检查是否打开</span><br>    <span class="hljs-keyword">if</span> (!osm) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.写文件</span><br>    osm.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;p1, <span class="hljs-built_in">sizeof</span>(Person));   <span class="hljs-comment">// 【取地址后强转为 char*】</span><br>    osm.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;p2, <span class="hljs-built_in">sizeof</span>(Person));<br><br>    <span class="hljs-comment">// 4.关闭文件</span><br>    osm.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例：对象反序列化">实例：对象反序列化</h4><p>值得注意的是，读文件时，对对象取地址，并强转为 char* 类型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">ism.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p1, <span class="hljs-built_in">sizeof</span>(Person));<br></code></pre></td></tr></table></figure><p>完整如下：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">age</span>(age), <span class="hljs-built_in">id</span>(id)&#123;&#125;<br>    <span class="hljs-built_in">Person</span>()&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;id = &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 创建类对象</span><br>    Person p1, p2;<br><br>    <span class="hljs-comment">// 1.打开文件</span><br>    string target_file_name = <span class="hljs-string">&quot;/Users/STL/todo&quot;</span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ism</span><span class="hljs-params">(target_file_name, ios::in)</span></span>;<br><br>    <span class="hljs-comment">// 2.检查是否打开</span><br>    <span class="hljs-keyword">if</span> (!ism) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.读文件</span><br>    ism.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p1, <span class="hljs-built_in">sizeof</span>(Person));<br>    ism.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p2, <span class="hljs-built_in">sizeof</span>(Person));<br><br>    <span class="hljs-comment">// 4.关闭文件</span><br>    ism.<span class="hljs-built_in">close</span>();<br><br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">Show</span>();<br>    p<span class="hljs-number">2.</span><span class="hljs-built_in">Show</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、STL-概述">七、STL 概述</h2><blockquote><p>STL（Standard Template Library，标准模版库）</p></blockquote><p>STL分为：<strong>容器（container）</strong>、<strong>算法（algorithm）</strong>、<strong>迭代器（iterator）</strong></p><h3 id="1-容器（container）">1.容器（container）</h3><p>序列式容器：容器元素的位置，由进入的时机决定。比如 vector。</p><p>关联性容器：容器已有规则，与进入的时机有关。比如 set、map。</p><p><strong>补充</strong>：size() 返回值是 <strong>unsigned int</strong>，不可以和 <strong>负数</strong> 比较。</p><p><strong>解决办法</strong>：提前将 size() 存入变量。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (a &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-comment">// 无法进入循环体内。</span><br>    <span class="hljs-comment">// 因为 size() 是 unsigned int，和 负数 a 比较，编译器会将 a 强制转换为 unsigned int。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-迭代器（iterator）">2.迭代器（iterator）</h3><p>迭代器类似于指针，实际上迭代器是一个类，类中封装了指针，并重载了 ++、–、* 等等操作符。</p><p>其中 <code>begin()</code> 指向首地址，<code>end()</code> 指向 最后一个元素的下一个地址。【但迭代器 如<code>begin()</code> 不等于地址】</p><h4 id="（1）为什么使用迭代器">（1）为什么使用迭代器</h4><p>迭代器是容器和算法之间的桥梁。实现算法时，传递的是容器的迭代器。</p><h4 id="（2）迭代器类型">（2）迭代器类型</h4><p>迭代器类型（以 vector 为例）：<code>vector&lt;int&gt;::iterator</code> 。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;<span class="hljs-type">int</span>&gt;::iterator p_begin = a.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><h4 id="（3）容器算法分离案例">（3）容器算法分离案例</h4><blockquote><p>为了使容器和算法互相独立。</p></blockquote><p>实现功能：统计数组中出现某元素个数。</p><p>基本思路：容器为数组，迭代器分别指向数组的首部和尾部，将迭代器传入算法。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyCount</span><span class="hljs-params">(<span class="hljs-type">int</span>* p_begin, <span class="hljs-type">int</span>* p_end, <span class="hljs-type">int</span> num)</span> </span>&#123;   <span class="hljs-comment">// 传入迭代器</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>* p = p_begin; p!= p_end; p++) &#123;<br>        <span class="hljs-keyword">if</span> (*p == num) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 容器</span><br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br><br>    <span class="hljs-comment">// 迭代器</span><br>    <span class="hljs-type">int</span> *p_begin = &amp;arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> *p_end = &amp;arr[<span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];<br><br>    cout &lt;&lt; <span class="hljs-built_in">MyCount</span>(p_begin, p_end, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-算法（algorithm）">3.算法（algorithm）</h3><blockquote><p>注意头文件 #include &lt;algorithm&gt;</p></blockquote><p><a name="for_each"></a></p><h4 id="（1）for-ench">（1）for_ench()</h4><p>第一个是 begin()，第二个是 end()，第三个是 回调函数，比如 Print() 打印数据。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 函数声明</span><br>for_each(_InputIterator __first, _InputIterator __last, _Function __f);<br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>  cout &lt;&lt; val;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    for_each(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), Print);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似功能实现遍历（以类对象为例）：</p><p><code>&lt;&gt;</code> 中是什么，<code>*it</code> 就代表什么。比如，<code>vector&lt;Person&gt;</code> ，<code>*it</code> 表示 Person 类对象。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">age</span>(age), <span class="hljs-built_in">id</span>(id) &#123;&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Person&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    <span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>      cout &lt;&lt; (*it).age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、string">八、string</h2><h3 id="1-特性">1.特性</h3><ul><li>char* 是指针，string 是类，并在类中封装了 char* ，string 是一个 char* 型容器。</li><li>封装了成员方法：查找find、拷贝copy、删除delete、替换replace、插入inset。</li><li>不用考虑内存释放和越界问题（string 类负责维护）。</li></ul><h3 id="2-初始化">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 无参构造</span><br>string s1;<br><br><span class="hljs-comment">// 有参构造</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;   <span class="hljs-comment">// s2 == &quot;aaa&quot;  // 这里需要传入长度，函数原型：string (size_t n, char c);   </span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 拷贝构造。</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(s3)</span></span>;<br>string s5 = s3;<br>string s6 = <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="3-赋值">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;ab&quot;</span>)</span>, <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;cd&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 等号操作符</span><br>s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 = s2;<br>s1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br><span class="hljs-comment">// assign 成员函数</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-取值">4.取值</h3><p><code>[]</code> <code>at()</code> 区别：如果索引越界，<code>[]</code> 直接报错，<code>at()</code> 抛异常 out_of_range。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s1 = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br><span class="hljs-comment">// 重载 [] 操作符</span><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// at 成员函数</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="5-拼接">5.拼接</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 重载 += 操作符</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> string&amp; str);<br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str);<br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c);<br><br><span class="hljs-comment">// 重载 + 操作符</span><br>string <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> string&amp; str);<br><br><span class="hljs-comment">// append 成员函数</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>;    <span class="hljs-comment">// 字符串 str 连接到当前字符串结尾。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str)</span></span>; <br><br><span class="hljs-comment">// 参数 n 限定。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// 字符串 str 前 n 个字符连接到当前字符串结尾。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// 从 pos 开始的 n 个字符连接在当前字符串尾部。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在当前字符串结尾添加 n 个字符 c。</span><br></code></pre></td></tr></table></figure><h3 id="6-查找">6.查找</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 从 pos 位置开始，查找字符串 str，返回第一次出现的位置。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// 从 pos 位置开始，查找字符 c，返回第一次出现的位置。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// 从 pos 位置开始，查找字符串 str，返回最后一次出现的位置。  </span><br><span class="hljs-comment">// 如果没有找到，返回 npos。（npos是一个很大的数18446744073709551615UL，如果传递给int变量，= -1）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = npos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> pos = npos)</span></span>;<br><br><span class="hljs-comment">// 从 pos 位置开始，查找字符 c，返回最后一次出现的位置。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;abcfghfg&quot;</span>;<br><br><span class="hljs-comment">// 查找第一个出现的位置</span><br><span class="hljs-type">int</span> frist = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;fg&quot;</span>);<br><br><span class="hljs-comment">// 查找最后一个出现的位置</span><br><span class="hljs-type">int</span> last = s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;fg&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="7-替换">7.替换</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 从 pos 位置开始的 n 个字符，替换为字符串 str。（被替换的字符，包括 pos 位置字符）</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; str)</span></span>;<br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;abccc&quot;</span>;<br>s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xyz===&quot;</span>);<br>cout &lt;&lt; s;   <span class="hljs-comment">// xyz===ccc</span><br></code></pre></td></tr></table></figure><h3 id="8-比较">8.比较</h3><p>compare 函数，比较 ascii 码，（大写A比小写a小。A：65，a：97）</p><ul><li>对象 &gt; s 时返回 对象-s的值（正值）；</li><li>对象 &lt; s 时返回 对象-s的值（负值）；</li><li>对象 = s 时返回 0；</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 与字符串 s 比较大小。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s1 = <span class="hljs-string">&quot;abc&quot;</span>, s2 = <span class="hljs-string">&quot;aB&quot;</span>;<br>cout &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">compare</span>(s2);   <span class="hljs-comment">// 32（‘b’ - &#x27;B&#x27; 的值）</span><br></code></pre></td></tr></table></figure><h3 id="9-截取">9.截取</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 返回由 pos 开始的 n 个字符组成的字符串。</span><br><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> n = npos)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = “abcd”<br>cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// &quot;bcd&quot;</span><br>cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;bd&quot;</span><br></code></pre></td></tr></table></figure><h3 id="10-插入">10.插入</h3><p>【注意】</p><ul><li>pos 位置可以用 整型 表示，并函数返回值为 字符串本身。</li><li>pos 位置可以用 迭代器 表示，并返回插入后迭代器的位置 或 无返回值。（不返回字符串本身，所以不能直接打印。）</li><li>(vector、string 的迭代器可以加整型数字；list 的迭代器只能自加。（因为 list 不支持随机访问））</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 从 pos 位置开始，插入字符串 s。（原第 pos 位置字符的前面）</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>;<br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> string&amp; s)</span></span>;<br><br><span class="hljs-comment">// 在 pos 位置处，插入 n 个字符 c。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>;<br><br><span class="hljs-comment">// 用迭代器表示位置。————————————————————————————————————————————————————————</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(iterator it, <span class="hljs-type">char</span> c)</span></span>;<span class="hljs-comment">//在it处插入字符c，返回插入后迭代器的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator it, const_iterator first, const_iteratorlast)</span></span>;<span class="hljs-comment">//在it处插入从first开始至last-1的所有字符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator it, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>;<span class="hljs-comment">//在it处插入n个字符c</span><br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;abcde&quot;</span>;<br><span class="hljs-type">char</span> p[] = <span class="hljs-string">&quot;==gg==&quot;</span>;<br>cout &lt;&lt; s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, p);   <span class="hljs-comment">// abc==gg==de</span><br>cout &lt;&lt; s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;+&#x27;</span>);   <span class="hljs-comment">// abc+++++==gg==de</span><br><br><span class="hljs-comment">//用迭代器表示位置。————————————————————————————————————————————————————————</span><br><span class="hljs-comment">// 从第 3 位开始插入 ‘A’（有第 0 位）</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+3</span>, <span class="hljs-string">&#x27;A&#x27;</span>);    <span class="hljs-comment">// 等同于 s.insert(3, 1, &#x27;A&#x27;);</span><br><br><span class="hljs-comment">// 从第 3 位开始插入 10 个‘A’（有第 0 位）</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+3</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);    <span class="hljs-comment">// 等同于 s.insert(3, 10, &#x27;A&#x27;);</span><br><br><span class="hljs-comment">// 插入区间 [ s.begin()+1, s.end() ) 一段字符串。</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+3</span>, s.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>, s.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h3 id="11-删除">11.删除</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 删除从 pos 开始的 n 个字符。</span><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n = npos)</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;abcde&quot;</span>;<br>cout &lt;&lt; s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 从 1 号元素开始，删除两个元素。 // ade</span><br>cout &lt;&lt; s.<span class="hljs-built_in">earse</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 从 1 号元素开始，删到末尾。     // a</span><br></code></pre></td></tr></table></figure><h3 id="12-string-转-char">12.string 转 char*</h3><p>接收的变量类型不能是 <code>char *</code> ，而是 <code>const char*</code> ，因为 <code>c_str</code> 返回的是 const char *。不能用安全性低的变量接受安全性高的数据。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc">string s = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s_ptr = s.<span class="hljs-built_in">c_str</span>();<br>cout &lt;&lt; s_ptr &lt;&lt; endl;  <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><h3 id="13-char-转-string">13.char 转 string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">1</span>, c)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">3</span>, c)</span></span>;<br>cout &lt;&lt; s1 &lt;&lt; endl;  <span class="hljs-comment">// &quot;a&quot;   // char 转 string</span><br>cout &lt;&lt; s3 &lt;&lt; endl;   <span class="hljs-comment">// &quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><h2 id="九、vector">九、vector</h2><blockquote><p>动态数组，单口容器。</p></blockquote><p><img src="https://hutu.aimtao.net/mark/2020-08-07-fblvQf.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="1-动态增长原理与特性">1.动态增长原理与特性</h3><p>当插入新元素时，若空间不足，</p><ol><li>则重新申请更大的内存（两倍空间），</li><li>将原空间数据拷贝到新空间，</li><li>释放旧空间的数据，</li><li>再把新元素插入新空间中。</li></ol><p>【注意：】将原空间数据拷贝到新空间时，会调用拷贝构造函数。</p><p><strong>特性</strong>：</p><ul><li>指定位置插入效率低，最坏情况要移动整个数组，时间复杂度 O(n)。</li><li>随机读取效率高，O(1)。</li></ul><h3 id="2-初始化-2">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 无参构造函数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br><span class="hljs-comment">// 有参构造</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v<span class="hljs-number">1.</span>begin(), v<span class="hljs-number">1.</span>end())</span></span>;  <span class="hljs-comment">//用迭代器初始化。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">// 五个元素，都为 1。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;    <span class="hljs-comment">// 五个元素，都为 0。</span><br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v5</span><span class="hljs-params">(v2)</span></span>;<br><br><span class="hljs-comment">// 用数组初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v6</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;   <span class="hljs-comment">// 类似于 begin() 和 end()。</span><br></code></pre></td></tr></table></figure><h3 id="3-赋值-2">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><br><span class="hljs-comment">// 迭代器赋值</span><br>v<span class="hljs-number">2.</span><span class="hljs-built_in">assign</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 用数组（类似于迭代器）</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">assign</span>(arr, arr + <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-comment">// 赋值 n 个 num</span><br>v<span class="hljs-number">2.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 重载 = 操作符</span><br>v2 = v1;<br><br><span class="hljs-comment">//交换整个容器</span><br>v<span class="hljs-number">2.</span><span class="hljs-built_in">swap</span>(v1);   <span class="hljs-comment">// v1变为v2，v2变为v1。</span><br></code></pre></td></tr></table></figure><h3 id="4-swap-函数交换原理">4.swap 函数交换原理</h3><p>栈区有两个 vector 类对象，类成员变量中有一个指针，指向堆区的一块内存。</p><p>swap 函数，并非交换所有数据，只是交换指针。</p><p>对象地址为：&amp;v；数据地址为：&amp;(v[0]).</p><p><img src="https://hutu.aimtao.net/mark/2020-08-07-YexN4W.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="5-大小操作">5.大小操作</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-comment">// 容器大小</span><br>v.<span class="hljs-built_in">size</span>(); <br><br><span class="hljs-comment">// 改变容器大小</span><br><span class="hljs-comment">// 若 n 比原来大，用 elem 填充新增的空间，无 elem 默认用 0 填充。</span><br><span class="hljs-comment">// 若 n 比原来小，删除愿容器中多余的数据。</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> n, elem);     <span class="hljs-comment">// 【只能改变大小，不能改变容量。】 </span><br><br><span class="hljs-comment">// 容器是否为空</span><br>v.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 空返回 true，不空返回 false</span><br><span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">empty</span>()) &#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;v 为空！&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 容器的容量    // 只有string 和 vector 有 capacity 属性</span><br>v.<span class="hljs-built_in">capacity</span>();  <span class="hljs-comment">// 增加空间要拷贝内存，耗时，所以最好一开始申请足够的容量。</span><br></code></pre></td></tr></table></figure><h3 id="6-取值">6.取值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector v;<br><br><span class="hljs-comment">// 抛异常</span><br>v.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 不抛异常，重载 [] 操作符</span><br>v[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 返回容器第一个元素</span><br>v.<span class="hljs-built_in">front</span>();<br><br><span class="hljs-comment">// 返回容器最后一个元素</span><br>v.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><h3 id="7-插入删除">7.插入删除</h3><p>【注意】：vector 的 insert函数 pos 位置，只能用 迭代器，(vector、string 的迭代器可以加整型数字；list 的迭代器只能自加。（因为 list 不支持随机访问））</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 样例：</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>() + a, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// v.insert(a, 5, 0);  // error</span><br><span class="hljs-comment">// v.insert(2, 5, 0);  // error</span><br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector v;<br><span class="hljs-comment">// 在 pos 位置插入 1 个元素 0。</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 在 pos 位置插入 5 个元素 0。</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 在尾部插入 1；</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 在尾部删除 1；</span><br>v.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 删除迭代器指向的元素</span><br>v.<span class="hljs-built_in">erase</span>(const_iterator pos);<br><br><span class="hljs-comment">// 删除从迭代器 start 到 end 之间的元素。</span><br>v.<span class="hljs-built_in">erase</span>(const_iterator start, const_iterator end);  <span class="hljs-comment">//【左闭右开】</span><br><br><span class="hljs-comment">// 清空容器</span><br>v.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure><h3 id="8-用-swap-收缩空间">8.用 swap 收缩空间</h3><p>用 v 初始化匿名对象（按照 size 的大小初始化，而非 capacity ），并交换 匿名对象 和 v。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);<br></code></pre></td></tr></table></figure><p>例如下面程序，虽然 size 是 10w，但是 capacity 是 13w。因为在扩大空间时，是默认按照两倍空间扩增的。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    a.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <span class="hljs-comment">// a.size() = 100000</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// a.capacity() = 131072</span><br><br><span class="hljs-comment">// 当想要将 容量capacity 缩小成和 大小size 一致时，</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(a).<span class="hljs-built_in">swap</span>(a);<br></code></pre></td></tr></table></figure><h3 id="9-reserve-预留空间">9.reserve 预留空间</h3><blockquote><p><strong>reserve 和 resize 区别</strong>：</p><ul><li>reserve 是预留空间，不是创建真正的元素对象，未添加对象之前，不能引用容器内元素。</li><li>resize 是改变容器大小 size（不改变 容量capacity ），调用此函数后，能引用容器内元素。</li></ul></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br></code></pre></td></tr></table></figure><p><strong>预留空间的作用</strong>： 减少容器扩容时的拷贝。</p><p>计算拷贝次数：</p><ul><li>注意：&amp;v 不是 数据的地址，是栈中 v 对象的地址；而数据储存在堆区，可用 &amp;(v[0]) 表示。</li><li>迭代器不是地址，是一个类对象，无法直接和地址比较。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 方法一：判断 v.begin() 的值是否改变。</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator address = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">begin</span>() != address) &#123;<br>        address = v.<span class="hljs-built_in">begin</span>();<br>        count++;<br>    &#125;<br>&#125;<br>cout &lt;&lt; count &lt;&lt; endl;   <span class="hljs-comment">// 18次</span><br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 方法二：判断 v[0] 的地址是否改变。</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* address = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">if</span> (address != &amp;(v[<span class="hljs-number">0</span>])) &#123;<br>        address = &amp;(v[<span class="hljs-number">0</span>]);<br>        count++;<br>    &#125;<br>&#125;<br>cout &lt;&lt; count &lt;&lt; endl;   <span class="hljs-comment">// 18次</span><br></code></pre></td></tr></table></figure><p>若加入 <code>v.reserve(100000)</code> 则一次也不需要拷贝。</p><h2 id="十、deque">十、deque</h2><blockquote><p>double-ended queue 双端队列，（更像 双端 vector）.</p><p>deque：[/'di:ke/] queue：[/kju/]</p></blockquote><p><img src="https://hutu.aimtao.net/mark/2020-08-11-LFyZ9h.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>分片存储原理</strong>：</p><ul><li>左边是一个 map 数组，节点中保存的是 右边缓冲区内存片段 的地址。</li><li>右边是缓冲区，有若干连续的内存片段，片段之间不连续，片段内部连续。</li></ul><p><img src="https://hutu.aimtao.net/mark/2020-08-11-2dDt8U.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="1-特性：">1.特性：</h3><ul><li>双端插入和删除元素效率高。</li><li>指定位置插入会导致数据元素移动，效率低。</li><li>随机存取效率高。</li><li>分块储存，排序效率非常低，【deque 特有的特点】。所以可以拷到 vector 容器中排序再拷回 deque容器。</li></ul><p><strong>总结</strong>：与其说是双端队列，不如说是 双端vector，特性基本相同，API基本相同（差别在于：deque 可以双端插入和删除，vector 只能一端插入删除）。</p><h3 id="2-初始化-3">2.初始化</h3><blockquote><p>API 和 vector 相同。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 无参构造</span><br>deque&lt;<span class="hljs-type">int</span>&gt; q1;<br><br><span class="hljs-comment">// 有参构造</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q2</span><span class="hljs-params">(q<span class="hljs-number">1.</span>begin(), q<span class="hljs-number">2.</span>end())</span></span>;  <br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q3</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">// 初始化为 5 个 1；</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q4</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;       <span class="hljs-comment">// 初始化为 5 个 0；</span><br><br><span class="hljs-comment">// 数组初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q6</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br><span class="hljs-comment">//拷贝构造</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q5</span><span class="hljs-params">(q1)</span></span>;    <span class="hljs-comment">// deque&lt;int&gt; q4(const deque &amp;deq);</span><br></code></pre></td></tr></table></figure><h3 id="3-赋值-3">3.赋值</h3><blockquote><p>API 和 vector 相同。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cc">deque&lt;<span class="hljs-type">int</span>&gt; q1, <span class="hljs-built_in">q2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 迭代器赋值</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(q<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), q<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 用数组（类似于迭代器）</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>q<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(arr, arr + <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]));<br><br><span class="hljs-comment">// 赋值 n 个 num</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 重载 = 操作符</span><br>q1 = q2;<br><br><span class="hljs-comment">// swap 函数交换</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(q2);<br></code></pre></td></tr></table></figure><h3 id="4-大小操作">4.大小操作</h3><blockquote><ul><li><p>API 和 vector 相同。</p></li><li><p>唯一不同：deque 没有 容量capacity 属性（只有string 和 vector 有 capacity 属性）。</p></li></ul></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span>;<br><br><span class="hljs-comment">// 返回元素个数</span><br>q.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 改变容器大小</span><br><span class="hljs-comment">// 若 n 比原来大，用 elem 填充新增的空间，无 elem 默认用 0 填充。</span><br><span class="hljs-comment">// 若 n 比原来小，删除愿容器中多余的数据。</span><br>q.<span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> n, elem);<br><br><span class="hljs-comment">// 容器是否为空</span><br>q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 空返回 true，不空返回 false</span><br><span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;q 为空！&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-双端插入删除">5.双端插入删除</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc">deque&lt;<span class="hljs-type">int</span>&gt; q；<br><span class="hljs-comment">// 从后面操作</span><br>q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>q.<span class="hljs-built_in">pop_back</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 从前面操作</span><br>q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>q.<span class="hljs-built_in">pop_front</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="6-取值-2">6.取值</h3><blockquote><p>API 和 vector 相同。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 抛异常</span><br>q.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 不抛异常，重载 [] 操作符</span><br>q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 返回容器第一个元素</span><br>q.<span class="hljs-built_in">front</span>();<br><br><span class="hljs-comment">// 返回容器最后一个元素</span><br>q.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><h2 id="十一、stack">十一、stack</h2><h3 id="1-特性-2">1.特性</h3><ul><li>不能遍历，不能随机读取；只能通过 栈顶元素 访问或删除。</li><li>不提供迭代器（意味着 不能遍历）。</li></ul><h3 id="2-初始化-4">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 默认构造</span><br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(<span class="hljs-type">const</span> stack&lt;<span class="hljs-type">int</span>&gt; &amp;stk)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-赋值-4">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc">stack&lt;<span class="hljs-type">int</span>&gt; stk1, stk2;<br><br><span class="hljs-comment">// 重载 = 操作符</span><br>stk1 = stk2;<br></code></pre></td></tr></table></figure><h3 id="4-大小操作-2">4.大小操作</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-comment">// 元素个数 </span><br>stk.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 是否为空</span><br>stk.<span class="hljs-built_in">empty</span>();   <span class="hljs-comment">// 空返回 true</span><br></code></pre></td></tr></table></figure><h3 id="5-插入删除">5.插入删除</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc">stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-comment">// 插入</span><br>stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 删除</span><br>stk.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">// 访问顶部元素</span><br>stk.<span class="hljs-built_in">top</span>();<br></code></pre></td></tr></table></figure><h2 id="十二、queue">十二、queue</h2><h3 id="1-特性-3">1.特性</h3><ul><li>不支持随机访问。</li><li>不提供迭代器，所以不能遍历。</li></ul><h3 id="2-初始化-5">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 默认构造</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-type">const</span> queue&lt;<span class="hljs-type">int</span>&gt; &amp;another_q)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-赋值-5">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc">queue&lt;<span class="hljs-type">int</span>&gt; q1, q2;<br><br><span class="hljs-comment">// 重载 = 号操作符</span><br>q1 = q2;<br></code></pre></td></tr></table></figure><h3 id="4-大小操作-3">4.大小操作</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-comment">// 元素个数</span><br>q.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 是否为空</span><br>q.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h3 id="5-插入删除-2">5.插入删除</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-comment">// 队尾插入元素</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 队首删除元素</span><br>q.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure><h3 id="6-取值-3">6.取值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-comment">// 返回队首元素</span><br>q.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">// 返回队尾元素</span><br>q.<span class="hljs-built_in">front</span>();<br></code></pre></td></tr></table></figure><h2 id="十三、list">十三、list</h2><p>简要图：</p><p><img src="https://hutu.aimtao.net/mark/2020-08-13-XlF1X8.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>实际上的图：</p><ul><li>有头节点 head_node：data 是随机值，next 指向 begin() 位置节点。</li><li>首尾相连，end() 指向头节点位置。</li></ul><p>验证：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br>cout &lt;&lt; *l.<span class="hljs-built_in">end</span>();    <span class="hljs-comment">// 随机值</span><br>cout &lt;&lt; *(++l.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// begin() 位置的节点的 data。</span><br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2020-08-16-7j0SBg.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="1-特性-4">1.特性</h3><ul><li><p>节点包括两个域：数据域、指针域；</p></li><li><p>不需要连续的内存空间；</p></li><li><p>添加和删除元素效率高；</p></li><li><p>链表需要的时候，才分配内存；</p></li><li><p>链表需要额外的空间保存节点关系（前驱后继）。</p></li></ul><h3 id="2-初始化-6">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"> <span class="hljs-comment">// 默认构造 </span><br>list&lt;<span class="hljs-type">int</span>&gt; l1;<br><br><span class="hljs-comment">// 有参构造</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(l<span class="hljs-number">1.</span>begin(), l<span class="hljs-number">1.</span>end())</span></span>;  <span class="hljs-comment">// 用迭代器</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;   <span class="hljs-comment">// 初始化为 10 个 5</span><br><br><span class="hljs-comment">// 用数组初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l4</span><span class="hljs-params">(l3)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-赋值-6">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc">list&lt;<span class="hljs-type">int</span>&gt; l1, <span class="hljs-built_in">l2</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 用区间 [l2.begin() + 1, l2.end())    // list 的迭代器不可以加整型，只能自加。</span><br>l<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(++l<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), l<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br><br>l<span class="hljs-number">1.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 将 l1 赋值为 5 个 1。</span><br><br><span class="hljs-comment">// 重载 = 操作符</span><br>l1 = l2;<br><br><span class="hljs-comment">// 交换链表</span><br>l<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(l2);<br></code></pre></td></tr></table></figure><h3 id="4-大小操作-4">4.大小操作</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 节点个数</span><br>l.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 是否为空</span><br>l.<span class="hljs-built_in">empty</span>();<br><br><span class="hljs-comment">// 重新指定大小</span><br>l.<span class="hljs-built_in">resize</span>(num);<br><span class="hljs-comment">// 若容器变长，以 elem 填充，否则以 0 填充。</span><br>l.<span class="hljs-built_in">resize</span>(num, elem);<br></code></pre></td></tr></table></figure><h3 id="5-取值">5.取值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-comment">// 返回第一个元素</span><br>l.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">// 返回最后一个元素</span><br>l.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">// 迭代器取星</span><br>*l.<span class="hljs-built_in">begin</span>() = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="6-插入删除">6.插入删除</h3><ul><li><p>insert 函数只能使用迭代器。</p></li><li><p>list 的迭代器，不可以加整数，只能自加（因为 list 不支持随机访问）。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br><br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>l.<span class="hljs-built_in">pop_back</span>();<br>l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>l.<span class="hljs-built_in">pop_front</span>();<br><br><span class="hljs-comment">// 使用迭代器。</span><br>l.<span class="hljs-built_in">insert</span>(l.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">8</span>);<br>l.<span class="hljs-built_in">insert</span>(++l.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">8</span>);<br><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = l.<span class="hljs-built_in">begin</span>();<br>it++;<br>it++;<br>it++;<br>l.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>);   <span class="hljs-comment">// 迭代器只能自加。</span><br><br><span class="hljs-comment">// l.insert(l.begin() + 3, 2, 8); // error，只能自加。</span><br>l.<span class="hljs-built_in">insert</span>(l.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 清空</span><br>l.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 删除区间 [it, l.end()) 的内容。</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = l.<span class="hljs-built_in">begin</span>();<br>it++;<br>l.<span class="hljs-built_in">erase</span>(it, l.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 删除匹配的所有值</span><br>l.<span class="hljs-built_in">remove</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 删除所有 5；</span><br></code></pre></td></tr></table></figure><h3 id="7-链表反转和排序">7.链表反转和排序</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 翻转链表</span><br>l.<span class="hljs-built_in">reverse</span>();<br><br><span class="hljs-comment">// 链表元素排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br>l.<span class="hljs-built_in">sort</span>(compare); <span class="hljs-comment">// 调用回调函数 compare， 若无参数，默认按从小到大。</span><br></code></pre></td></tr></table></figure><h3 id="8-为什么有成员函数-sort？">8.为什么有成员函数 sort？</h3><p>list 不支持随机访问，如果使用算法中的 sort 函数，效率不稳定。</p><h2 id="十四、set-multiset">十四、set/multiset</h2><blockquote><p>基于红黑树（平衡二叉树的一种）实现的。</p></blockquote><h3 id="1-特性-5">1.特性</h3><ul><li><p>属于关联容器：元素位置由容器规则实现的；</p></li><li><p>查找效率非常高（元素自动排序）；</p></li><li><p>set 不可以有重复元素，multiset 可以有重复元素。</p></li><li><p>提供迭代器，但是不能通过迭代器改变数的值（如何改变元素数值，删除旧数据，添加新数据）。</p><p>和 map 一样，不可以修改 key， 因为 key 关系到容器元素的顺序。</p></li></ul><h3 id="2-初始化-7">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 默认构造函数</span><br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>multiset&lt;<span class="hljs-type">int</span>&gt; s2;<br><br><span class="hljs-comment">// 用数组初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s4</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br><span class="hljs-comment">// 用迭代器初始化</span><br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s5</span><span class="hljs-params">(s<span class="hljs-number">4.</span>begin(), s<span class="hljs-number">4.</span>end())</span></span>;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br>set&lt;<span class="hljs-type">int</span>&gt; s2 = s1;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s6</span><span class="hljs-params">(s1)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-赋值-7">3.赋值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">set&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br><br><span class="hljs-comment">// 重载 = 操作符</span><br>s1 = s2;<br><br><span class="hljs-comment">// 交换两个容器</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(s2);<br></code></pre></td></tr></table></figure><h3 id="4-大小操作-5">4.大小操作</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc">set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br><span class="hljs-comment">// 返回元素个数</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 判断容器是否为空</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h3 id="5-插入删除-3">5.插入删除</h3><p>erase 的位置参数只能使用迭代器（只有 string 可以使用数字代表位置 pos ），迭代器不能加常量，只能自加。（因为 set 不支持随机访问）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc">set&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-comment">// 插入元素</span><br>s.<span class="hljs-built_in">insert</span>(elem);<br><br><span class="hljs-comment">// 清空数组</span><br>s.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 删除迭代器所指元素，返回下一个元素的迭代器。</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>();<br>it++;<br>it++;<br>s.<span class="hljs-built_in">erase</span>(it);<br><br><span class="hljs-comment">// 删除迭代器区间的元素，返回下一个元素的迭代器。</span><br>s.<span class="hljs-built_in">erase</span>(++s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 删除 值为 elem 的全部元素（set 无重复，multiset 有重复）。</span><br>s.<span class="hljs-built_in">erase</span>(elem);<br></code></pre></td></tr></table></figure><h3 id="6-查找-2">6.查找</h3><p>如果 set 存储的是对象，那么按照 什么变量 排序，find 函数查找时，就是把 什么变量 当作 key。</p><p>见： <a href="#如果排序对象呢？">如果排序对象呢？</a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 1.找到，则返回当前位置的迭代器；2.未找到，返回 s.end() 迭代器。</span><br>s.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 返回第一个 key &gt;= keyElem 元素的迭代器。(lower_bound：下界)</span><br><span class="hljs-built_in">lower_bound</span>(keyElem);<br><br><span class="hljs-comment">// 返回第一个 key &gt; keyElem 元素的迭代器。 (upper_bound：上界)</span><br><span class="hljs-built_in">upper_bound</span>(keyElem);<br><br><span class="hljs-comment">// 返回 lower_bound、upper_bound 函数的两个迭代器。</span><br><span class="hljs-built_in">equal_range</span>(keyElem);<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, arr + <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br><span class="hljs-comment">// s.find(3);  1.找到，则返回当前位置的迭代器；2.未找到，返回 s.end() 迭代器。</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator res = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (res == s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Got it:&quot;</span> &lt;&lt; *res &lt;&lt; endl;  <span class="hljs-comment">// Got it:3</span><br>&#125;<br><br><span class="hljs-comment">// lower_bound(3);  返回第一个 key &gt;= keyElem 元素的迭代器。</span><br>res = s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (res == s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Got it:&quot;</span> &lt;&lt; *res &lt;&lt; endl;  <span class="hljs-comment">// Got it:3</span><br>&#125;<br><br><span class="hljs-comment">// upper_bound(3);   返回第一个 key &gt; keyElem 元素的迭代器。</span><br>res = s.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (res == s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Got it:&quot;</span> &lt;&lt; *res &lt;&lt; endl;  <span class="hljs-comment">// Got it:5</span><br>&#125;<br><br><span class="hljs-comment">// equal_range(3);   返回 lower_bound、upper_bound 函数的两个迭代器。pair 对组。</span><br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, set&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; pair_res = s.<span class="hljs-built_in">equal_range</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">if</span> (pair_res.first == s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;lower_bound:  Not found&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;lower_bound:  Got it:&quot;</span> &lt;&lt; *pair_res.first &lt;&lt; endl;  <span class="hljs-comment">// Got it:3</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (pair_res.second == s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;upper_bound:  Not found&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;upper_bound:  Got it:&quot;</span> &lt;&lt; *pair_res.second &lt;&lt; endl;  <span class="hljs-comment">// Got it:5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-pair-对组">7.pair 对组</h3><p>对组 pair 将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值分别用 pair 的两个公有函数 first 和 second 访问。</p><p>类模版：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span>.<br></code></pre></td></tr></table></figure><p><strong>如何创建对组？</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 第一种构造</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">pair_01</span><span class="hljs-params">(string(<span class="hljs-string">&quot;name&quot;</span>), <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">pair_02</span><span class="hljs-params">(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>pair&lt;string, <span class="hljs-type">int</span>&gt; pair_03 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 拷贝构造</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; pair_04 = pair_03;<br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">pair_05</span><span class="hljs-params">(pair_04)</span></span>;<br><br><span class="hljs-comment">// 重载 = 操作符</span><br>pair_04 = pair_02;<br><br><span class="hljs-comment">// 取值</span><br>cout &lt;&lt; pair_<span class="hljs-number">03.f</span>irst &lt;&lt; endl;;<br>cout &lt;&lt; pair_<span class="hljs-number">03.</span>second &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><a name="仿函数（函数对象）"></a></p><h3 id="8-仿函数（函数对象）">8.仿函数（函数对象）</h3><blockquote><ul><li>函数对象也叫仿函数。</li><li>函数对象是类，不是函数，只是重载了 () 操作符。</li><li>行为类似于函数的对象。</li></ul></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 以下代码用于更改 set 排序顺序</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;   <span class="hljs-comment">// 重载了 () 操作符，并且传入参数。</span><br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*  // 第二种写法：</span><br><span class="hljs-comment">template&lt;class T&gt;</span><br><span class="hljs-comment">struct Compare &#123;</span><br><span class="hljs-comment">      bool operator()(const T &amp;a, const T &amp;b) &#123;</span><br><span class="hljs-comment">          return a &gt; b;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Compare&lt;<span class="hljs-type">int</span>&gt; com;<br>    cout &lt;&lt; <span class="hljs-built_in">com</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>仿函数的另外一个作用</strong>：函数对象超出函数的概念，函数对象可以保存函数调用的状态。</p><ul><li><p>当统计函数调用次数时，就可以使用函数对象。函数对象可以用成员变量保存次数。</p></li><li><p>如果使用普通函数，就需要用全局变量保存次数，开发中，应少用全局变量。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyPrint</span>()&#123;<br>        num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">MyPrint&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        cout &lt;&lt; number &lt;&lt; endl;<br>        num++;              <span class="hljs-comment">// 调用一次，num 就 ++。</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;    <span class="hljs-comment">// 记录函数调用多少次</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br>    MyPrint print_01;<br>      <span class="hljs-comment">// 将对象 print_01 传入，for_each 会拷贝该对象，执行完后会将拷贝的对象作为返回值返回。</span><br>    <span class="hljs-comment">// 1.print_01 中的 num = 0; </span><br>    <span class="hljs-comment">// 2.for_each 实际调用的是 print_01 的拷贝对象，并将拷贝对象返回；</span><br>    <span class="hljs-comment">// 3.实例化一个新的对象来接收返回值。</span><br>    MyPrint print_02 = for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print_01);  <br>    cout &lt;&lt; print_<span class="hljs-number">01.</span><span class="hljs-built_in">getNum</span>();  <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; print_<span class="hljs-number">02.</span><span class="hljs-built_in">getNum</span>();  <span class="hljs-comment">// 10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-更改默认排序">9.更改默认排序</h3><p>写一个仿函数 Compare，并把 Compare 当错参数传入 set 中。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;       <span class="hljs-comment">// 从大到小</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;;<br>  <br>      <span class="hljs-comment">// 添加仿函数为参数。</span><br>    set&lt;<span class="hljs-type">int</span>, Compare&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">s</span>(arr, arr + <span class="hljs-built_in">sizeof</span>(arr)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">// for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="如果排序对象呢？"></a></p><p><strong>如果排序对象呢？</strong></p><p>以下面代码为例，如果以 Person 的 id 进行排序，find 函数查找时，就是按照 id 为key 进行查找，并且查找过程中不关心 age 的值。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 定义一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = id;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 排序规则：以 Person 类的 id 进行大小排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;a, <span class="hljs-type">const</span> Person &amp;b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.id &gt; b.id;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span>, <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br>  <br>    <span class="hljs-comment">// 初始化容器时，将仿函数传入。将是按照 id 的大小排序，并且 id 成为 key。 </span><br>    set&lt;Person, Compare&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(p1);<br>    s.<span class="hljs-built_in">insert</span>(p2);<br>    s.<span class="hljs-built_in">insert</span>(p3);<br><br>    <span class="hljs-keyword">for</span> (set&lt;Person&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; it-&gt;id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>  <br>      <span class="hljs-comment">// find 函数以 id 为 key 进行查找。</span><br>      <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">find</span>(p4)-&gt;id &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">find</span>(p4)-&gt;age;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十五、map-multimap">十五、map/multimap</h2><blockquote><p>基于红黑树（平衡二叉树的一种）实现的。</p></blockquote><p>map 把数据封装成一个 pair 键值对，有键值 key、实值 value，（pair 第一个值是键值，第二个值是实值），所有元素根据键值自动排序。（相比于 set，区别在于 set 键值实值是一个值）</p><h3 id="1-特性-6">1.特性</h3><ul><li><p>属于关联容器：元素位置由容器规则实现的；</p></li><li><p>map 中 key 不能重复，multimap 中 key 可以重复。</p></li><li><p>可以通过 迭代器 改变 map 的 key 吗？</p><p>不能！和 set 容器一样，key 关系到容器内的元素的排列规则，任意改变键值会破坏容器的排列规则。（set 和 map 只能删了旧 key， 再添加新的。）</p></li></ul><h3 id="2-初始化-8">2.初始化</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br></code></pre></td></tr></table></figure><h3 id="3-插入">3.插入</h3><p>【map】</p><ul><li>插入的一个 pair 对组，并且 key 不能重复。</li><li>insert 有返回值 pair&lt;iterator, bool&gt;。</li><li>[] 访问，不存在则创建（有值则为所的赋值，无值则为默认值），存在则修改实值。</li></ul><p>【multimap】</p><ul><li>insert 有返回值 iterator，标记插入位置的迭代器。</li><li>不能用 [] 访问。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// insert 返回值是 pair&lt;iterator, bool&gt;，第一个值标记着插入位置的迭代器，第二个值标记着是否插入成功。</span><br>pair&lt;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; res = m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br><span class="hljs-keyword">if</span> (res.second) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;插入成功!&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">// 如果 m[30] 不存在，创建 m[30]；</span><br><span class="hljs-comment">// 如果 m[30] 存在，修改实值。</span><br>m[<span class="hljs-number">30</span>] = <span class="hljs-number">10</span>;<br>m[<span class="hljs-number">40</span>];      <span class="hljs-comment">// 只要访问，默认创建 m[40] = 0;（int 的默认值是 0，string 的默认值是 “”）</span><br></code></pre></td></tr></table></figure><h3 id="4-遍历">4.遍历</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    cout &lt;&lt; “key:” &lt;&lt; it-&gt;first &lt;&lt; endl;  <span class="hljs-comment">// it 指向的是一个对组</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-删除">5.删除</h3><p>erase 的位置参数只能使用迭代器（只有 string 可以使用数字代表位置 pos ），迭代器不能加常量，只能自加。（因为 map 不支持随机访问）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 清空元素。</span><br>m.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 删除迭代器 pos 位置 的元素，返回下一个元素的迭代器。</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m.<span class="hljs-built_in">begin</span>();<br>pos++;<br>pos++;<br>m.<span class="hljs-built_in">erase</span>(pos);<br><br><span class="hljs-comment">// 删除迭代器区间 [++m.begin(), m.end()] 的元素。</span><br>m.<span class="hljs-built_in">erase</span>(++m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 删除容器中 key = key_elem 的对组。</span><br>m.<span class="hljs-built_in">erase</span>(key_elem);<br></code></pre></td></tr></table></figure><h3 id="6-查找-3">6.查找</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 查找键值 key 是否存在，存在返回该键迭代器，不存在，则返回 m.end()。</span><br>m.<span class="hljs-built_in">find</span>(key);<br><br><span class="hljs-comment">// 返回键值 key 的个数。</span><br>m.<span class="hljs-built_in">count</span>(key);<br><br><span class="hljs-comment">// 返回第一个 &gt;= key 的元素的迭代器。</span><br>m.<span class="hljs-built_in">lower_bound</span>(key);<br><br><span class="hljs-comment">// 返回第一个 &gt; key 的元素的迭代器。</span><br>m.<span class="hljs-built_in">upper_bound</span>(key);<br><br><span class="hljs-comment">// 返回 lower_bound 和 upper_bound 的两个迭代器</span><br>m.<span class="hljs-built_in">equal_range</span>(key);<br></code></pre></td></tr></table></figure><h3 id="7-更改排序规则">7.更改排序规则</h3><ul><li>加入规则时，可以使用 class 和 struct 。</li><li>bool operator() 函数必须限定返回值为 const 修饰。</li><li>以对象为 key，必须有规则。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 规则写法一：</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> MyKey &amp;a, <span class="hljs-type">const</span> MyKey &amp;b)</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">// const 修饰返回值</span><br>        <span class="hljs-keyword">return</span> a.index &gt; b.index;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 规则写法二：</span><br><span class="hljs-comment">// class Compare &#123;</span><br><span class="hljs-comment">// public:</span><br><span class="hljs-comment">//     bool operator()(const MyKey&amp; a, const MyKey&amp; b) const &#123;  // const 修饰返回值</span><br><span class="hljs-comment">//         return a.index &gt; b.index;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 带上规则初始化</span><br>    map&lt;MyKey, <span class="hljs-type">int</span>, Compare&gt; m;<br><br>    <span class="hljs-comment">// 插入元素（对组）</span><br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;MyKey, <span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">MyKey</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">MyKey</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(map&lt;MyKey, <span class="hljs-type">int</span>, Compare&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-built_in">MyKey</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">10</span>));<br><br>    <span class="hljs-comment">// 遍历，打印对象</span><br>    <span class="hljs-keyword">for</span> (map&lt;MyKey, <span class="hljs-type">int</span>, Compare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; it-&gt;first.index &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; it-&gt;first.id &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十六、STL">十六、STL</h2><h3 id="1-容器的共性机制">1.容器的共性机制</h3><p>【拷贝】：</p><ul><li><p>STL 容器提供的都是值（value）寓意，而非引用（reference）寓意。</p></li><li><p>当我们插入元素时，容器内部实施了拷贝动作：拷贝值到容器，而不是将原数据放入容器。</p></li><li><p>【提供给容器的元素必须能被拷贝。】</p></li></ul><p>【迭代器】：</p><ul><li>除 queue 和 stack 外，每个容器都有迭代器。</li><li>string、vector、deque 的迭代器可以加常数，list、set、map 只能迭代器自加（不空随机访问）。</li></ul><p>【异常】</p><ul><li>一般不会抛异常，需要传入正确的参数。</li></ul><p>【大小的函数】</p><p>size、empty 所有容器都有。</p><h3 id="2-容器深拷贝和浅拷贝">2.容器深拷贝和浅拷贝</h3><p>当元素插入容器时，容器将拷贝该元素，而且应该是深拷贝。</p><p>因为程序结束时，p 调用一次析构函数，v 中的元素也会调用一次析构函数，对堆区同一内存进行析构，报错！</p><p><strong>【如果容器元素为对象，类中必须有拷贝构造函数（深拷贝）、重载等号操作符（深拷贝）】</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, name);<br>    &#125;<br>    <br>   <span class="hljs-comment">/*  // 如果没有拷贝构造函数，将会报错。 </span><br><span class="hljs-comment">    Person(const Person&amp; another) &#123;</span><br><span class="hljs-comment">        this-&gt;name = new char[strlen(another.name) + 1];</span><br><span class="hljs-comment">        strcpy(this-&gt;name, another.name);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    // 等号操作符，也要注意深拷贝。</span><br><span class="hljs-comment">    Person&amp; operator=(const Person&amp; another) &#123;</span><br><span class="hljs-comment">        if (this-&gt;name != nullptr) &#123;</span><br><span class="hljs-comment">            delete this-&gt;name;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        this-&gt;name = new char[strlen(another.name) + 1];</span><br><span class="hljs-comment">        strcpy(name, another.name);</span><br><span class="hljs-comment">        return *this;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;name != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;name;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>)</span></span>;<br>    vector&lt;Person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-谓词">3.谓词</h3><p>谓词：返回值为 bool 类型的普通函数 或者 返回值为 bool 类型的重载 operator() 的仿函数。</p><ul><li>如果 operator() 接收一个参数，叫一元谓词。</li><li>接收两个参数，叫二元谓词。</li></ul><h3 id="4-内建函数对象">4.内建函数对象</h3><blockquote><p>什么是函数对象：<a href="#仿函数（函数对象）">仿函数（函数对象）</a></p></blockquote><p>STL 内建了一些函数对象：算术类函数对象、关系运算类函数对象，逻辑运算类函数对象。</p><p>使用需要引用头文件：<code>#include &lt;functional&gt;</code></p><p>举个例子：list 的自己的成员函数，sort 中的关于排序规则的参数，默认使用自己的内建函数对象。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc">list&lt;<span class="hljs-type">int</span>&gt; l;<br>l.<span class="hljs-built_in">sort</span>();   <span class="hljs-comment">// 无参数，默认调用内建函数对象，排序从小到大</span><br><br><span class="hljs-comment">// 链表元素排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>l.<span class="hljs-built_in">sort</span>(compare); <span class="hljs-comment">// 有回调函数</span><br></code></pre></td></tr></table></figure><p>算术类函数对象：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T plus&lt;T&gt;       <span class="hljs-comment">//加法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T minus&lt;T&gt;      <span class="hljs-comment">//减法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T multiplies&lt;T&gt; <span class="hljs-comment">//乘法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T divides&lt;T&gt;    <span class="hljs-comment">//除法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T modulus&lt;T&gt;    <span class="hljs-comment">//取模仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T negate&lt;T&gt;     <span class="hljs-comment">//取反仿函数</span><br></code></pre></td></tr></table></figure><p>关系类函数对象：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> equal_to&lt;T&gt;      <span class="hljs-comment">//等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> not_equal_to&lt;T&gt;  <span class="hljs-comment">//不等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater&lt;T&gt;       <span class="hljs-comment">//大于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater_equal&lt;T&gt; <span class="hljs-comment">//大于等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less&lt;T&gt;          <span class="hljs-comment">//小于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less_equal&lt;T&gt;    <span class="hljs-comment">//小于等于</span><br></code></pre></td></tr></table></figure><p>逻辑运算类函数对象：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_and&lt;T&gt; <span class="hljs-comment">//逻辑与</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_or&lt;T&gt;  <span class="hljs-comment">//逻辑或</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_not&lt;T&gt; <span class="hljs-comment">//逻辑非</span><br></code></pre></td></tr></table></figure><h3 id="5-函数对象适配器">5.函数对象适配器</h3><blockquote><p>注意：C++17 已废弃！</p></blockquote><blockquote><p>需要头文件 <code>#include &lt;functional&gt;</code></p></blockquote><h4 id="（1）绑定适配器-bind1st、bind2nd">（1）绑定适配器 bind1st、bind2nd</h4><blockquote><p>将一个二元的函数对象转变为一元的函数对象。</p></blockquote><p>【需求】：for_each 调用仿函数 MyPrint，想打印 val + 100 的数值，并不修改 MyPrint。</p><p>【问题】：for_each 调用仿函数，只能调用一个 一元函数对象。如何将 100 当作参数传入一元函数对象？</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// for_each 的定义</span><br>for_each(_InputIterator __first, _InputIterator __last, _Function __f)<br>&#123;<br>    <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br>        __f(*__first);   <span class="hljs-comment">// 只能传入一个参数，为一元函数或者一元函数对象。</span><br>    <span class="hljs-keyword">return</span> __f;<br>&#125;<br></code></pre></td></tr></table></figure><p>【解决】：使用 bind2nd，将一个二元的函数对象转变为一元的函数对象。</p><ul><li>MyPrint 要继承 binary_function&lt;T&gt; 类，类型中写 &lt;参数类型, 参数类型, 返回值类型&gt;。</li><li>operator() 函数要用 const 修饰，因为 bind2nd 参数是 const 修饰的。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">bind2nd</span>(<span class="hljs-type">const</span> __Operation&amp; __op, <span class="hljs-type">const</span> _Tp&amp; __x)<br>    &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">binder2nd</span>&lt;__Operation&gt;(__op, __x);&#125;<br></code></pre></td></tr></table></figure><p><strong>完整代码</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span> : <span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">void</span>&gt; &#123;   <span class="hljs-comment">// 继承 + 类型</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> number)</span> <span class="hljs-type">const</span> </span>&#123;   <span class="hljs-comment">// const 修饰</span><br>        cout &lt;&lt; val + number &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br>    MyPrint print;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(print, <span class="hljs-number">100</span>));   <span class="hljs-comment">// 使用 bind2nd</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>bind1st 和 bind2nd 有什么区别？</strong></p><ul><li><p>bind1st 将 100 绑定为函数对象的第一个参数。</p></li><li><p>bind2nd 将 100 绑定为函数对象的第二个参数。</p></li></ul><h4 id="（2）取反适配器-not1、not2">（2）取反适配器 not1、not2</h4><blockquote><p>注意：C++17 已废弃！</p></blockquote><blockquote><p>not1：一元谓词取反。</p><p>not2：二元谓词取反。</p></blockquote><p>【需求】：sort 排序时，需要传入规则 Compare，（否则默认按照从小到大排序），不过不想更改规则，如何将从大到小变成从小到大排序？</p><p>【解决】：使用取反适配器，因为比较两个值大小，所有使用 not2（二元仿函数）。</p><ul><li>Compare 要继承 binary_function&lt;T&gt; 类，类型中写 &lt;参数类型, 参数类型, 返回值类型&gt;。</li><li>operator() 函数要用 const 修饰。</li><li>【注意】一元仿函数继承 unary_function，二元仿函数继承 binary_function。</li></ul><p><strong>完整代码</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> : <span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; &#123;   <span class="hljs-comment">// 继承 binary_function，类型为 &lt;参数类型，参数类型，返回值类型&gt;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span> <span class="hljs-type">const</span> </span>&#123;   <span class="hljs-comment">// 返回值用 const 修饰</span><br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-comment">// 生成随机数</span><br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>    &#125;<br>        <br>      <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i  &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        cout &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;=====================================&quot;</span> &lt;&lt; endl;<br><br>      <span class="hljs-comment">// 排序</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not2</span>(<span class="hljs-built_in">Compare</span>()));  <span class="hljs-comment">// 使用取反适配器</span><br>        <br>      <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i  &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        cout &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">71  0  97  44  92  37  75  25  41  20  </span><br><span class="hljs-comment">=====================================</span><br><span class="hljs-comment">0  20  25  37  41  44  71  75  92  97 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="（3）函数对象适配器">（3）函数对象适配器</h4><blockquote><p>将普通函数修饰为函数对象。</p></blockquote><p><strong>ptr_fun</strong>：普通函数无法使用 bind2st 适配器，所以需要先将普通函数修饰为函数对象。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> tmp)</span> </span>&#123;<br>    cout &lt;&lt; val + tmp &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-comment">// 【ptr_fun(Print)】  将普通函数 修饰为 函数对象。</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">ptr_fun</span>(Print), <span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mem_fun_ref、mem_fun</strong>：将类的成员函数 修饰为 函数对象。</p><p>调用方式比较特殊：<code>mem_fun_ref(&amp;Person::Show)</code> 取类的地址 :: 对象名。</p><p>mem_fun、mem_fun的区别：</p><ul><li>如果存放的是对象，使用 mem_fun_ref。</li><li>如果存放的是对象指针，使用 mem_fun。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>        <span class="hljs-keyword">this</span>-&gt;id = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; age:&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NewID</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;new_id:&quot;</span> &lt;&lt; id + val &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br>    vector&lt;Person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>  <br>      <br>    <span class="hljs-comment">// 【mem_fun_ref(&amp;Person::Show)】  将类中的函数修饰成函数对象。</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::Show));<br>    <span class="hljs-comment">// 【bind2nd(mem_fun_ref(&amp;Person::NewID), 1999)】  使用 bind2nd，使二元的函数对象，修饰为 一元的函数对象。</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::NewID), <span class="hljs-number">1999</span>));<br>  <br>  <br>      vector&lt;Person*&gt; v_ptr;<br>    v_ptr.<span class="hljs-built_in">push_back</span>(&amp;p1);<br>    v_ptr.<span class="hljs-built_in">push_back</span>(&amp;p2);<br>    <span class="hljs-comment">// 【mem_fun(&amp;Person::Show)】  将类中的函数修饰成函数对象。</span><br>    for_each(v_ptr.<span class="hljs-built_in">begin</span>(), v_ptr.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun</span>(&amp;Person::Show));<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-常用的查找算法">6.常用的查找算法</h3><h4 id="（1）find">（1）find</h4><p><code>find(v.begin(), v.end(), 5)</code></p><p>若找到，返回迭代器；没找到，返回 end 迭代器。</p><ul><li><p>【打印之前需要判断是否等于 end() 】</p></li><li><p>【若是储存元素为对象，应写重载 == 操作符】</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 源码</span><br><span class="hljs-built_in">find</span>(_InputIterator __first, _InputIterator __last, <span class="hljs-type">const</span> _Tp&amp; __value_)<br>&#123;<br>    <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br>        <span class="hljs-keyword">if</span> (*__first == __value_)   <span class="hljs-comment">// 此处用 == 判断，所以类要重载 == 操作符。</span><br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">return</span> __first;<br>&#125;<br></code></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 普通元素</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    v[i] = tmp;<br>&#125;<br><br><span class="hljs-comment">// find 函数：找到，返回迭代器；没找到，返回 end 迭代器。</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it  = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;找到啦！&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;没有找到！&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 元素为对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> id) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = id;<br>    &#125;<br>    <span class="hljs-comment">// 重载 == 操作符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; another) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;id == another.id) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    vector&lt;Person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br><br>    vector&lt;Person&gt;::iterator it  = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p1);<br>    <span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到啦！&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;没有找到！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）binary-search">（2）binary_search</h4><p>二分查找，只能用于有序序列。</p><ul><li>返回值为 bool，若找到返回 true，没找到返回 false。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-type">bool</span> res  = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (res) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到啦！&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;没有找到！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）adjacent-find">（3）adjacent_find</h4><p>查找重复相邻的元素。</p><ul><li>返回值：相邻元素的第一个位置的迭代器。</li><li>若无相邻重复的元素，返回 end()。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;:: iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;没有找到！&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;找到：&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）find-if">（4）find_if</h4><p>调用回调函数，判断是否找到。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">_InputIterator <span class="hljs-title">find_if</span><span class="hljs-params">(_InputIterator __first, _InputIterator __last, _Predicate __pred)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (; __first != __last; ++__first)<br>        <span class="hljs-keyword">if</span> (__pred(*__first))<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">return</span> __first;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个列子：找到第一个大于 6 的数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// find_if 调用回调函数 MySearch，把 *it 传入 MySearch，如果得到 true 则找到。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);<br>     <br>    vector&lt;<span class="hljs-type">int</span>&gt;:: iterator it  = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), MySearch);  <span class="hljs-comment">// 回调函数,也可以是 仿函数。</span><br>    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;没有找到！&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到！&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）count、count-if">（5）count、count_if</h4><p>count：元素出现次数</p><p>count_if：根据回调函数，统计元素符合条件的个数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// count</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">9</span>);  <span class="hljs-comment">// 查找元素 9 出现的次数。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// count_if</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MySearch</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">5</span>) &#123;                 <span class="hljs-comment">// 大于 5 出现的元素个数。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);<br><br>    MySearch m;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), m);  <span class="hljs-comment">// 调用回调函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-常用的遍历">7.常用的遍历</h3><h4 id="（1）for-each">（1）for_each</h4><p>见：<a href="#for_each">遍历容器</a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">for_each(iterator begin, iterator end, _callback);<br></code></pre></td></tr></table></figure><h4 id="（2）transform">（2）transform</h4><p>将一个容器的元素搬运到另一个容器中。</p><p>参数：原容器的begin()，原容器的end()，新容器的begin()，回调函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">transform</span>(iterator begin1, iterator end, iterator begin2, _callback);<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CallBack</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1, v2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>    &#125;<br>        <br>      <span class="hljs-comment">// 1.先初始化足够的空间。</span><br>    v<span class="hljs-number">2.</span><span class="hljs-built_in">resize</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// 2.搬运元素。</span><br>    <span class="hljs-built_in">transform</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), CallBack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C-C/">#C/C++</a> <a href="/tags/STL/">#STL</a></div></div><div class="license-box my-3"><div class="license-title"><div>学习笔记｜STL</div><div>https://www.aimtao.net/stl/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2020-06-17</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/slef-wake-leancloud/" title="Gtihub Action｜一行命令解决 LeanCloud 流控问题"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Gtihub Action｜一行命令解决 LeanCloud 流控问题</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/linux-deploy/" title="用废旧手机搭建一个 Linux 服务器"><span class="hidden-mobile">用废旧手机搭建一个 Linux 服务器</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>