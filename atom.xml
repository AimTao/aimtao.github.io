<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AimTao</title>
  
  <subtitle>AimTao</subtitle>
  <link href="https://www.aimtao.net/atom.xml" rel="self"/>
  
  <link href="https://www.aimtao.net/"/>
  <updated>2025-09-02T19:44:00.000Z</updated>
  <id>https://www.aimtao.net/</id>
  
  <author>
    <name>AimTao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 docker 容器进行修改并成新镜像</title>
    <link href="https://www.aimtao.net/modified-container/"/>
    <id>https://www.aimtao.net/modified-container/</id>
    <published>2025-09-02T19:44:00.000Z</published>
    <updated>2025-09-02T19:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-背景和需求">0.背景和需求</h2><p><strong>背景</strong>：</p><p>有时会需要使用 <a href="https://github.com/google/battery-historian">battery-historian</a> 解析日志，很久之前使用以下命令本地部署过一次。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> -- run  -v /usr/share/zoneinfo:/usr/share/zoneinfo -p <span class="hljs-number">8855</span>:<span class="hljs-number">9999</span> gcr.io/android-battery-historian/stable:<span class="hljs-number">3</span>.<span class="hljs-number">0</span> --port <span class="hljs-number">9999</span> &gt;&gt; ~/battery_historian.log <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><blockquote><ul><li>-v /usr/share/zoneinfo:/usr/share/zoneinfo：设置为本地时区。</li><li>8888：是端口号，访问 <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a>  或本机 ip:8888 就可以使用 Battery Historian 了。</li><li>&gt;&gt;~/battery_historian.log 2&gt;&amp;1 &amp;：任何输出追加写入文件，并后台运行。</li></ul></blockquote><p><strong>需求</strong>：</p><p><code>gcr.io/android-battery-historian</code> 这个镜像存在一些问题，需要修改部分代码。</p><ul><li>问题一：由于 bugreport 数据类型/格式不对，偶现各种解析错误，需要做一些新的适配和规避。</li><li>问题二：其中使用的部分 js 来自 cdn，偶尔网络抽风，无法加载，需要将 cdn 资源本地储存，并替换链接。</li></ul><p>按道理可以直接修改 <a href="https://github.com/google/battery-historian">battery-historian</a> 源码并编译，但这个项目已经多年没人维护，其中使用的各种依赖版本都非常老（尤其是前端的部分），折腾一通勉强跑起来了，由于编译环境差异还是有些日志解析的有问题。</p><p>所以只能退而求其次，基于 <code>gcr.io/android-battery-historian/stable:3.0</code> 来修改了。</p><h2 id="1-修改容器">1.修改容器</h2><p>进入容器查看文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it 0952b5bff193 /bin/bash<br></code></pre></td></tr></table></figure><p>将 docker 容器中的文件，拷贝到本地进行修改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">cp</span> 0952b5bff193:/gopure/src/github.com/google/battery-historian/setup.go .<br>docker <span class="hljs-built_in">cp</span> 0952b5bff193:/gopure/src/github.com/google/battery-historian/templates/base.html .<br></code></pre></td></tr></table></figure><p>将修改好的文件，拷贝到 docker 容器中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">cp</span> setup.go 0952b5bff193:/gopure/src/github.com/google/battery-historian/<br>docker <span class="hljs-built_in">cp</span> base.html 0952b5bff193:/gopure/src/github.com/google/battery-historian/templates/<br>docker <span class="hljs-built_in">cp</span> cdn 0952b5bff193:/gopure/src/github.com/google/battery-historian/third_party/<br></code></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker restart 09<br></code></pre></td></tr></table></figure><h2 id="2-生成镜像">2.生成镜像</h2><p>基于容器生成新的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker commit 0952b5bff193 battery-historian:end<br></code></pre></td></tr></table></figure><h2 id="3-分享">3.分享</h2><p>保存镜像，方便分享给其他人</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o battery-historian.tar battery-historian:end<br></code></pre></td></tr></table></figure><p>其他人拿到镜像，加载镜像并启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i battery-historian.tar<br>docker -- run -v /usr/share/zoneinfo:/usr/share/zoneinfo -p 8888:9999 battery-historian:end --port 9999 &gt; /dev/null 2&gt;&amp;1 &amp;<br><span class="hljs-comment"># 8888：是端口号，访问 http://127.0.0.1:8888/  或本机 ip:8888 就可以使用 Battery Historian 了。</span><br></code></pre></td></tr></table></figure><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">本文演示了一种对于容器进行快速二开的方法。</summary>
    
    
    
    <category term="Solution" scheme="https://www.aimtao.net/categories/Solution/"/>
    
    
    <category term="Docker" scheme="https://www.aimtao.net/tags/Docker/"/>
    
    <category term="Battery-Historian" scheme="https://www.aimtao.net/tags/Battery-Historian/"/>
    
  </entry>
  
  <entry>
    <title>配置 Win+WSL 环境下的网络代理</title>
    <link href="https://www.aimtao.net/wsl-proxy/"/>
    <id>https://www.aimtao.net/wsl-proxy/</id>
    <published>2025-08-30T19:44:00.000Z</published>
    <updated>2025-08-30T19:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-背景和需求">0.背景和需求</h2><ul><li>背景：win11 安装了 WSL2，并运行了 ubuntu，ubuntu 中安装了 docker。</li><li>需求：可以正常运行 docker pull 镜像（不依靠第三方镜像加速站，因为安全性/合规性存疑）。</li><li>现状：docker pull 报错超时。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ docker pull hello-world<br>Using default tag: latest<br>Error response from daemon: Get <span class="hljs-string">&quot;https://registry-1.docker.io/v2/&quot;</span>: net/http: request canceled <span class="hljs-keyword">while</span> waiting <span class="hljs-keyword">for</span> connection (Client.Timeout exceeded <span class="hljs-keyword">while</span> awaiting headers)<br></code></pre></td></tr></table></figure><h2 id="1-设置-win-系统代理、终端代理">1.设置 win 系统代理、终端代理</h2><p>这里不赘述，自行设置，可以走公司合规的网络专线。</p><p><strong>验证</strong>：win powershell 可以正常 <code>curl https://hub.docker.com/</code></p><h2 id="2-设置-WSL可以使用-win-系统代理">2.设置 WSL可以使用 win 系统代理</h2><ol><li>在文件夹地址栏，输入 <code>%UserProfile%</code>，创建 <code>.wslconfig</code> 文件。</li><li>在<code>.wslconfig</code> 中写入以下内容。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">[wsl2]<br>networkingMode=mirrored<br>dnsTunneling=true<br>autoProxy=true<br><br>[experimental]<br># requires dnsTunneling but are also OPTIONAL<br>bestEffortDnsParsing=true<br></code></pre></td></tr></table></figure><p>这段配置主要是 <strong>让 WSL2 内的网络和 Windows 镜像</strong>，这样 WSL 网络就和 win 完全一致了。</p><ol start="3"><li>重启 WSL</li></ol><p><strong>验证</strong>：WSL2 终端可以正常 <code>curl https://hub.docker.com/</code></p><p>参考：</p><ul><li><a href="https://gist.github.com/libChan/3a804a46b532cc326a2ee55b27e8ac19">WSL2使用clash for windows代理</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl-config#experimental-settings">WSL 中的高级设置配置 | Microsoft Learn</a></li></ul><h2 id="3-设置-WSL-中-docker-可以使用系统代理">3.设置 WSL 中 docker 可以使用系统代理</h2><p>此时虽然 WSL 可以使用系统代理，但是 docker 为守护进程，还需要手动设置代理。</p><ol><li>创建目录。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d <br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>docker.service.d</code>目录下写文件。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim proxy.conf <br></code></pre></td></tr></table></figure><ol start="3"><li>文件中写入以下内容。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 这个端口设成你自己的代理端口</span><br>[Service]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://127.0.0.1:xxxx&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://127.0.0.1:xxxx&quot;</span><br>Environment=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></code></pre></td></tr></table></figure><p>表示docker 使用以上端口进行代理。</p><ol start="4"><li>重启docker</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><p><strong>验证</strong>：得到的结果和你配置的端口一样。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  ~ systemctl show --property=Environment docker<br>Environment=HTTP_PROXY=http://127.0.0.1:7890 HTTPS_PROXY=http://127.0.0.1:7890 NO_PROXY=localhost,127.0.0.1<br></code></pre></td></tr></table></figure><h2 id="4-大公告成">4.大公告成</h2><p><code> docker pull hello-world</code> 正常。</p><p>注意，虽然实现了系统代理，但是没法 ping，所以不要用 ping 做测试，ping 走的是 ICMP 协议，系统代理仅代理了 HTTP/HTTPS 应用层协议。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">Win11+WSL2+远程开发这一套真舒服~</summary>
    
    
    
    <category term="Solution" scheme="https://www.aimtao.net/categories/Solution/"/>
    
    
    <category term="Docker" scheme="https://www.aimtao.net/tags/Docker/"/>
    
    <category term="Windows" scheme="https://www.aimtao.net/tags/Windows/"/>
    
    <category term="WSL" scheme="https://www.aimtao.net/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>指定 docker 容器的网段和IP</title>
    <link href="https://www.aimtao.net/docker-network/"/>
    <id>https://www.aimtao.net/docker-network/</id>
    <published>2024-11-25T03:59:37.000Z</published>
    <updated>2024-11-25T03:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>docker 启动 msyql 容器，mysql 容器和宿主机，可以互相访问。</p><p>宿主机使用 192.168.13.0/24 网段，指定 msyql 容器 IP 地址是 192.168.13.14，宿主机的 IP 地址是 192.168.13.1。</p><h2 id="分析">分析</h2><p>docker 容器和宿主机默认连接的方式是网桥，刚好符合我们的需求。</p><h2 id="解决">解决</h2><ol><li>创建网桥接口，名为<code>br-master</code></li><li>创建 Docker 网络，名为 <code>server-master</code>，指定子网 <code>192.168.13.0/24</code>，并绑定到网桥接口 <code>br-master</code></li><li>启动 MySQL 容器并设置静态 IP 地址为 <code>192.168.13.14</code></li></ol><h3 id="1-创建网桥接口-br-master">1.创建网桥接口 <code>br-master</code></h3><p>首先，我们需要创建一个网桥接口 <code>br-master</code>，并为它分配一个 IP 地址。使用以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 创建网桥接口 br-master</span><br>sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">add</span> name br-master<span class="hljs-built_in"> type bridge</span><br><span class="hljs-built_in"></span><br><span class="hljs-comment"># 设置网桥的 IP 地址和子网</span><br>sudo<span class="hljs-built_in"> ip </span>addr <span class="hljs-built_in">add</span> 192.168.13.1/24 dev br-master<br><br><span class="hljs-comment"># 启用网桥接口</span><br>sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">set</span> dev br-master up<br></code></pre></td></tr></table></figure><p>这样就创建了一个网桥接口 <code>br-master</code>，并为其分配了 IP 地址 <code>192.168.13.1/24</code>。</p><h3 id="2-创建-Docker-网络-server-master">2.创建 Docker 网络 <code>server-master</code></h3><p>接下来，我们为 Docker 创建一个自定义网络 <code>server-master</code>，并将其绑定到 <code>br-master</code> 网桥接口，设置子网为 <code>192.168.13.0/24</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create \<br>  <span class="hljs-attribute">--driver</span>=bridge \<br>  <span class="hljs-attribute">--subnet</span>=192.168.13.0/24 \<br>  <span class="hljs-attribute">--gateway</span>=192.168.13.1 \<br>  --opt com.docker.network.bridge.<span class="hljs-attribute">name</span>=br-master \<br>  server-master<br></code></pre></td></tr></table></figure><ul><li><code>--driver=bridge</code>：使用 Docker 的桥接网络模式。</li><li><code>--subnet=192.168.13.0/24</code>：设置网络的子网范围为 <code>192.168.13.0/24</code>。</li><li><code>--gateway=192.168.13.1</code>：设置网关地址为 <code>192.168.13.1</code>（即之前设置的网桥的 IP 地址）。</li><li><code>--opt com.docker.network.bridge.name=br-master</code>：指定 Docker 使用 <code>br-master</code> 网桥接口。</li><li><code>server-master</code>：设置 Docker 网络名称为 <code>server-master</code>。</li></ul><h3 id="3-启动-MySQL-容器并指定静态-IP-地址">3.启动 MySQL 容器并指定静态 IP 地址</h3><p>现在，我们可以启动一个 MySQL 容器并将其连接到 <code>server-master</code> 网络，并为其分配静态 IP 地址 <code>192.168.13.14</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name mysql-container <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --network server-master <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --ip <span class="hljs-number">192.168.13.14</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e MYSQL_ROOT_PASSWORD=root_password <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  mysql:<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li><code>--name mysql-container</code>：指定容器的名称为 <code>mysql-container</code>。</li><li><code>--network server-master</code>：将容器连接到 <code>server-master</code> 网络。</li><li><code>--ip 192.168.13.14</code>：为容器指定静态 IP 地址 <code>192.168.13.14</code>（这个地址会从 <code>192.168.13.0/24</code> 子网中分配）。</li><li><code>-e MYSQL_ROOT_PASSWORD=root_password</code>：设置 MySQL 容器的 root 密码为 <code>root_password</code>（可以根据需要更改）。</li><li><code>mysql:8</code>：使用官方 MySQL 8 镜像。</li></ul><h3 id="4-验证网络和容器配置">4.验证网络和容器配置</h3><h4 id="验证-Docker-网络配置">验证 Docker 网络配置</h4><p>你可以使用以下命令检查 <code>server-master</code> 网络的配置，确保它使用了 <code>br-master</code> 作为桥接网桥接口：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">docker network inspect <span class="hljs-keyword">server</span>-master<br></code></pre></td></tr></table></figure><p>这将显示 <code>server-master</code> 网络的详细信息，包括子网、网关以及所使用的网桥接口等。</p><h4 id="验证-MySQL-容器的-IP-地址">验证 MySQL 容器的 IP 地址</h4><p>使用以下命令验证 MySQL 容器是否成功分配了 IP 地址 <code>192.168.13.14</code>：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">docker inspect --format &#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> .NetworkSettings.Networks&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.IPAddress</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span><span class="language-xml">&#x27; mysql-container</span><br></code></pre></td></tr></table></figure><p>这将返回容器的 IP 地址，应该是 <code>192.168.13.14</code>。</p><h3 id="5-连接到-MySQL-容器">5.连接到 MySQL 容器</h3><p>如果你想通过 MySQL 客户端连接到该容器，可以使用以下命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mysql</span> -h <span class="hljs-number">192.168.13.14</span> -u root -p<br></code></pre></td></tr></table></figure><p>输入 <code>root_password</code> 作为密码，应该能够成功连接到 MySQL 容器。</p><h2 id="总结">总结</h2><ol><li><strong>创建网桥接口 <code>br-master</code></strong>：使用 <code>ip link</code> 创建一个网桥接口，并为其分配 <code>192.168.13.1/24</code> 的 IP 地址。</li><li><strong>创建 Docker 网络 <code>server-master</code></strong>：创建一个自定义 Docker 网络 <code>server-master</code>，将其绑定到网桥接口 <code>br-master</code>，并设置子网为 <code>192.168.13.0/24</code>。</li><li><strong>启动 MySQL 容器</strong>：启动一个 MySQL 容器，连接到 <code>server-master</code> 网络，并为其分配静态 IP 地址 <code>192.168.13.14</code>。</li><li><strong>验证网络和容器</strong>：使用 <code>docker inspect</code> 验证容器的 IP 地址和网络配置。</li></ol><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">本文通过网桥的方式，为容器指定静态IP，并实现宿主机与容器相互访问。</summary>
    
    
    
    <category term="Solution" scheme="https://www.aimtao.net/categories/Solution/"/>
    
    
    <category term="Network" scheme="https://www.aimtao.net/tags/Network/"/>
    
    <category term="Docker" scheme="https://www.aimtao.net/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>从零实现系列｜RPC</title>
    <link href="https://www.aimtao.net/7days-rpc/"/>
    <id>https://www.aimtao.net/7days-rpc/</id>
    <published>2024-10-18T14:36:00.000Z</published>
    <updated>2024-10-18T14:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-序言">0.序言</h2><h3 id="为什么需要-RPC">为什么需要 RPC</h3><p>最直观得是，客户端可以像调用本地程序一样，进行远程调用，使用者无需关注内部的实现细节。</p><p>另外一种广泛使用的调用方式是基于 HTTP 协议得 Restful API，让 gpt 总结一下。</p><table><thead><tr><th style="text-align:center">对比维度</th><th style="text-align:center">Restful API</th><th style="text-align:center">RPC</th></tr></thead><tbody><tr><td style="text-align:center"><strong>协议</strong></td><td style="text-align:center">基于 HTTP 协议（如 HTTPS）</td><td style="text-align:center">通常使用自定义协议（如 TCP 或高效二进制协议）</td></tr><tr><td style="text-align:center"><strong>通信方式</strong></td><td style="text-align:center">基于 HTTP 的请求-响应模型（如 GET/POST）</td><td style="text-align:center">类似本地方法调用的请求-响应模型（对开发者透明）</td></tr><tr><td style="text-align:center"><strong>报文格式</strong></td><td style="text-align:center">文本格式（JSON/XML），冗余较多</td><td style="text-align:center">二进制编码（如 Protobuf），精简高效</td></tr><tr><td style="text-align:center"><strong>性能</strong></td><td style="text-align:center">较低（文本解析、冗余数据）</td><td style="text-align:center">较高（二进制压缩、高效序列化）</td></tr><tr><td style="text-align:center"><strong>使用场景</strong></td><td style="text-align:center">通用性强，适合跨语言、对外的开放接口</td><td style="text-align:center">高性能要求高，适合内部服务间通信</td></tr><tr><td style="text-align:center"><strong>可扩展性</strong></td><td style="text-align:center">扩展依赖网关等中间件，功能相对固定</td><td style="text-align:center">原生支持注册中心、负载均衡、超时处理等扩展功能</td></tr><tr><td style="text-align:center"><strong>抽象模型</strong></td><td style="text-align:center"><strong>面向资源</strong>的抽象，通过 URI 唯一标识资源，通过 HTTP 方法定义操作</td><td style="text-align:center"><strong>面向过程</strong>的抽象，客户端直接调用服务端的函数或方法</td></tr></tbody></table><h3 id="RPC-框架需要解决哪些问题">RPC 框架需要解决哪些问题</h3><ul><li><p>通信协议：如何选择传输协议（TCP/HTTP/Unix Socket）？如何设计协议格式（如报文头、体结构）？</p></li><li><p>编码方式：如何高效编码/解码数据？如何压缩报文？</p></li><li><p>可用性问题</p><ul><li>超时处理：超时控制（如客户端连接超时、服务端处理超时）避免资源阻塞。</li><li>请求管理：如何支持并发请求、异步请求？</li></ul></li><li><p>服务治理组件</p><ul><li>注册中心：服务动态注册与发现，健康检查（心跳机制）</li><li>负载均衡：如何分配请求到多个服务实例？</li></ul></li></ul><p>以上种种，业务之外的公共能力，RPC 框架均需具备。</p><p><strong>注意</strong>：RPC 框架主要实现的是 client stub、server stub，为用户封装细节。</p><blockquote><p>对于 stub 不了解，可以看了解：<a href="https://www.aimtao.net/rpc#1-4-RPC-%E5%BC%80%E5%8F%91%E7%9A%84%E8%A6%81%E7%B4%A0">RPC 开发的四大要素</a></p></blockquote><p><img src="https://hutu.aimtao.net/mark/2022-07-03-CaL2S1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="市面上的-RPC-框架-有哪些">市面上的 RPC 框架 有哪些</h3><table><thead><tr><th style="text-align:center">框架名称</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>net/rpc</strong></td><td style="text-align:center">Go 标准库，轻量级，支持 TCP/HTTP 协议，默认使用 Gob 编码</td></tr><tr><td style="text-align:center"><strong>gRPC</strong></td><td style="text-align:center">Google 开源，基于 HTTP/2 和 Protobuf，跨语言，高性能，支持流式通信</td></tr><tr><td style="text-align:center"><strong>rpcx</strong></td><td style="text-align:center">高性能、支持多种编码（JSON/Protobuf），集成注册中心、负载均衡</td></tr><tr><td style="text-align:center"><strong>go-micro</strong></td><td style="text-align:center">微服务框架，包含 RPC 模块，支持插件化（注册中心、编码协议等）</td></tr></tbody></table><h3 id="本文如何从零实现-RPC-框架">本文如何从零实现 RPC 框架</h3><ol><li>从零实现标准库 <code>net/rpc</code></li><li>新增了协议交换（protocol exchange）、注册中心（registry）、服务发现（service discovery）、负载均衡（load balance）、超时处理（timeout processing）等特性</li></ol><h2 id="1-服务端与消息编码">1.服务端与消息编码</h2><h3 id="如何设计一个-RPC-请求">如何设计一个 RPC 请求</h3><p>这个问题也可以问成：一个 RPC 请求，应该传入传出什么数据，选择使用什么数据结构？</p><p>举个例子：一个典型的 RPC 调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err = client.Call(<span class="hljs-string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply)<br></code></pre></td></tr></table></figure><ul><li><code>Arith.Multiply</code>：服务名 <code>Arith</code> 和方法名 <code>Multipy</code>。</li><li><code>args</code>：传入参数</li><li><code>reply</code>：传出参数</li></ul><p>我们将服务名、方法名放在请求的 header 中，传输传出参数放在 body 中。</p><p>其中 header 定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>    ServiceMethod <span class="hljs-type">string</span> <span class="hljs-comment">// 服务名和方法名</span><br>    Seq           <span class="hljs-type">uint64</span> <span class="hljs-comment">// 请求序号</span><br>    Error         <span class="hljs-type">string</span> <span class="hljs-comment">// 客户端置为空，服务端如何出现错误，将错误信息写入Error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用什么编解码方式进行编解码">用什么编解码方式进行编解码</h3><p>编码方式可以选择 json、gob、protobuf 等等，为了更好的兼容性，我们抽象出来 Codec 的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-comment">// Codec 接口：对消息体进行编码，比如 Gob、Json 会实现该接口，代表两种编码方式</span><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">interface</span> &#123;<br>    io.Closer<br>    ReadHeader(*Header) <span class="hljs-type">error</span><br>    ReadBody(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>    Write(*Header, <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后想使用哪个编码方式都可以，只要实现了 Codec 接口即可。</p><p>将各个编解码方式名称硬编码保存下来，并使用 map 保存各个编解码方式的构造函数。所以使用的流程是，通过编解码方式名称获取到该编解码方式的构造函数，调用该构造函数，创建编解码的实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/codec.go</span><br><br><span class="hljs-keyword">type</span> Type <span class="hljs-type">string</span><br><span class="hljs-keyword">const</span> (<br>    GobType  Type = <span class="hljs-string">&quot;application/gob&quot;</span><br>    JsonType Type = <span class="hljs-string">&quot;application/json&quot;</span><br>)<br><br><span class="hljs-comment">// NewCodecFunc Codec 接口类型的构造函数</span><br><span class="hljs-keyword">type</span> NewCodecFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(io.ReadWriteCloser)</span></span> Codec<br><br><span class="hljs-comment">// NewCodecFuncMap 通过 type 来选择对应的 codec 的构造函数</span><br><span class="hljs-keyword">var</span> NewCodecFuncMap <span class="hljs-keyword">map</span>[Type]NewCodecFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    NewCodecFuncMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]NewCodecFunc)<br>    NewCodecFuncMap[GobType] = NewGobCodec <span class="hljs-comment">// 赋值为 Gob codec 的构造函数（NewGobCodec 为 Gob codec 的构造函数，在 codec/gob.go 实现。）</span><br>    <span class="hljs-comment">//NewCodecFuncMap[JsonType] = NewJsonCodec  // 赋值为 Json codec 的构造函数, 暂不实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现编解码方式的接口">如何实现编解码方式的接口</h3><p>下面将以 Gob 为例，说明如何实现 Codec 接口。先定义 Gob 编解码的结构体 GobCodec 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-keyword">type</span> GobCodec <span class="hljs-keyword">struct</span> &#123;<br>    conn io.ReadWriteCloser<br>    buf  *bufio.Writer <span class="hljs-comment">// 使用缓冲流来提高性能，防止阻塞</span><br>    dec  *gob.Decoder<br>    enc  *gob.Encoder<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 Codec 的接口函数，主要是封装 encoding/gob 的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-comment">// ReadHeader 封装了 encoding/gob 的 Decode 方法，从连接中读取 Header 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadHeader(header *Header) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(header)<br>&#125;<br><br><span class="hljs-comment">// ReadBody 封装了 encoding/gob 的 Decode 方法，从连接中读取 Body 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadBody(body <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(body)<br>&#125;<br><br><span class="hljs-comment">// Write 封装了 encoding/gob 的 Encode 方法，将 Header 和 Body 信息写入连接中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Write(header *Header, body <span class="hljs-keyword">interface</span>&#123;&#125;) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 关闭前，先将 buf 中的数据写入连接中</span><br>        _ = c.buf.Flush()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            _ = c.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(header); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding header: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding body: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Close 封装了 io.ReadWriteCloser 的 Close 方法，关闭连接</span><br><span class="hljs-comment">// io.ReadWriteCloser 包含 io.Closer 类型，io.Closer 类型包含 Close 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.conn.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再实现 GobCodec 的构造函数，方便初始化时，传给 Codec 接口变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// codec/gob.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGobCodec</span><span class="hljs-params">(conn io.ReadWriteCloser)</span></span> Codec &#123;<br>    buf := bufio.NewWriter(conn)<br>    <span class="hljs-keyword">return</span> &amp;GobCodec&#123;<br>        conn: conn,<br>        buf:  buf,<br>        dec:  gob.NewDecoder(conn),<br>        enc:  gob.NewEncoder(buf),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>P.S. <strong>为什么  GobCodec 需要加一个 buf ？</strong></p><p>用于缓冲写入操作，减少系统调用次数。如果没有 buf，每次小数据写入直接触发系统调用，增加延迟；频繁的 I/O 操作，影响性能。</p><h3 id="通信过程如何协商编码方式">通信过程如何协商编码方式</h3><p>以 HTTP 报文为例，HTTP 报文分为 header 和 body 两个部分。客户端和服务端收发消息时，只需要先解析 header 部分，就知道 body 的格式 Content-Type、长度 Content-Length。</p><p>在 RPC 协议的报文里，为了提升性能，仅在报文最开始规划固定的字节，来协商编码方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span>  <span class="hljs-comment">// 验证连接的合法性，确保客户端和服务端使用同一协议</span><br>    CodecType   codec.Type  <span class="hljs-comment">// 编码方式的名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以实际的报文是这样的。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Option </span>|<span class="hljs-string"> Header1 </span>|<span class="hljs-string"> Body1 </span>|<span class="hljs-string"> Header2 </span>|<span class="hljs-string"> Body2 </span>|<span class="hljs-string"> ...</span><br></code></pre></td></tr></table></figure><p>那  Option 使用什么编码方式呢？</p><p>为了方便，我们可以规定，Option 使用  JSON 编码，后面的 header、body 使用 Option 规定的编解码方式编解码。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">| <span class="hljs-type">Option</span>&#123;MagicNumber: xxx, CodecType: xxx&#125; | <span class="hljs-type">Header</span>&#123;ServiceMethod ...&#125; | <span class="hljs-type">Body</span> interface&#123;&#125; |<br><span class="hljs-type">| &lt;------    Option</span> 固定使用 JSON 编码      ------&gt;  | <span class="hljs-type">&lt;-------   Header</span>/Body 编码方式由 CodeType 决定   -------&gt;|<span class="hljs-type"></span><br></code></pre></td></tr></table></figure><h3 id="如何实现一个服务端">如何实现一个服务端</h3><p>先看一下，服务端要做什么，要实现哪些功能。</p><ul><li>建立连接：实现 Accept 方法，等待 socket 连接，并开启协程处理请求。</li><li>处理请求：<ul><li>解析 Option 信息，检查 Option.MagicNumber 是匹配，根据 Option.CodecType 实例化编解码器。</li><li>读取请求：使用编解码器实例解码 header 和 body。</li><li>处理请求。</li><li>回复请求。</li></ul></li></ul><p>搞清楚需要实现哪些功能，就可以开始具体实现了。（可以先看主要的调用流程，具体实现实现细节晚点再看）</p><ul><li>服务器实例的构造函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;  <span class="hljs-comment">// 肚子里没什么要放的</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</p><ul><li><code>json.NewDecoder(conn).Decode(&amp;opt)</code> 的含义？<ul><li><code>json.NewDecoder(conn)</code> 创建一个从连接读取JSON数据的解码器 <code>*Decoder</code>；</li><li><code>*Decoder.Decode(&amp;opt)</code> 将JSON数据解码到 opt 结构体中，一次只读一个 JSON。</li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>       log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;  <span class="hljs-comment">// 验证 MagicNumber，证明请求合法</span><br>       log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]  <span class="hljs-comment">// 获取编解码器的构造函数</span><br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>       log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求。<ul><li>使用协程来并发处理请求。</li><li>使用 <code>sync.WaitGroup</code> 保证即使因为读请求出错退出循环，也等待所有协程请求处理完成再关闭连接，优雅终止。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg) <span class="hljs-comment">// 使用协程来并发处理请求。</span><br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 即使因为读请求出错退出循环，也需要等待所有协程请求处理完成再关闭连接，优雅终止。</span><br>    _ = cc.Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>readRequest 读取请求：调用 readRequestHeader 方法读取请求头，再调用 ReadBody 方法读取请求参数，返回 request 结构体</p><ul><li>这里定义了请求体的结构体 request，其中，h 储存 header，argv 储存传入参数，replyValue 储存传出参数，也就是返回值。</li><li>readRequestHeader 就是进一步调用 编解码器 的 ReadHeader 方法，这里的编解码器是 gob。gob 的 ReadHeader 方法是封装的 encoding/gob 的 Decode 方法。ReadBody 同理。</li></ul></li><li><p>什么是 <code>reflect.Value</code> 类型？</p><ul><li>两个前置知识：具体看 <a href="https://www.aimtao.net/go#11-reflect">reflect</a><ul><li>每个 <code>interface&#123;&#125;</code> 类型的变量都包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</li><li><strong>反射就是把 <code>interface&#123;&#125;</code> 类型变量转化为 reflect.Value 或 reflect.Type 类型变量，随后用 reflect 包中的方法对它们进行各种操作</strong>。</li></ul></li><li><code>reflect.Value</code> 是反射值，是描述值的一个容器。</li></ul></li><li><p>argv 和 replyValue 为什么都是 <code>reflect.Value</code> 类型呢？</p><ul><li>因为对于服务端来说，他并不知道客户端会调用哪个具体的方法、要传入什么类型的参数、要传出什么类型的参数。</li><li>所以需要在运行时，动态地获取参数类型和返回值类型，并取指和赋值。</li></ul></li><li><p><code>req.argv = reflect.New(reflect.TypeOf(&quot;&quot;))</code> 的含义？</p><ul><li><code>reflect.TypeOf(&quot;&quot;)</code> 获取空字符串的类型信息，得到 reflect.Type 类型变量，描述 string 类型。</li><li><code>reflect.New(t)</code> 创建一个该类型 t 的指针值，返回一个 <code>reflect.Value</code> 对象，实际内部是一个指针类型，指针类型为 *t，这里也就是描述 *string 类型的容器。（相当于 <code>new(string)</code> ）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 举个例子</span><br>v := reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))  <span class="hljs-comment">// v 是 reflect.Value, 类型是 *string</span><br>fmt.Println(v.Type())                 <span class="hljs-comment">// 输出 *string</span><br>fmt.Println(v.Elem().Type())          <span class="hljs-comment">// 输出 string</span><br>v.Elem().SetString(<span class="hljs-string">&quot;hello&quot;</span>)           <span class="hljs-comment">// 设置值</span><br>fmt.Println(v.Elem().Interface())     <span class="hljs-comment">// 输出 hello</span><br><br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span>      <span class="hljs-comment">// 声明字符串变量</span><br>ptr := &amp;s         <span class="hljs-comment">// 获取指针</span><br>v = reflect.ValueOf(ptr)  <span class="hljs-comment">// 包装为 reflect.Value</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h                *codec.Header <span class="hljs-comment">// 读到的请求头</span><br>    argv, replyValue reflect.Value <span class="hljs-comment">// argv 储存传入参数，replyValue 储存传出参数。reflect.Value 是反射值，是描述值的一个容器。</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    req := request&#123;<br>        h: h,<br>    &#125;<br><br>    req.argv = reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))               <span class="hljs-comment">// 初始化传入参数，使用 New 方法创建一个表示 *string 类型值的反射值。reflect.Value 是描述值的一个容器。</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(req.argv.Interface()); err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 读取请求参数，ReadBody 函数的参数类型是 interface&#123;&#125;，需要使用 Interface() 方法，将 reflect.Value 转化为 interface&#123;&#125; 类型</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: read body error: &quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>handleRequest 处理请求：这部分目前处理的比较简单，主要是根据请求，构造请求的响应信息，并通过 sendResponse 发送给请求方。<ul><li>为什么要加锁？处理请求可以并发的读，但是发送数据不能并发写入链接，否则多个回复报文交织在一起，影响客户端解析。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    log.Println(<span class="hljs-string">&quot;handleRequest: &quot;</span>, req.h, req.argv.Elem())<br>    req.replyValue = reflect.ValueOf(fmt.Sprintf(<span class="hljs-string">&quot;geerpc resp %d&quot;</span>, req.h.Seq)) <span class="hljs-comment">// 构造请求的响应信息</span><br>    server.sendResponse(cc, req.h, req.replyValue.Interface(), sending)        <span class="hljs-comment">// 发送响应</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现一个客户端">如何实现一个客户端</h3><p>这里在 main 函数中实现一个简易的客户端，验证一下 server 的功能。</p><p>客户端主要做的事：</p><ul><li>连接到服务器</li><li>构造 header 和 body，发送请求</li><li>接收请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main/main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-comment">// 启动服务端</span><br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    <span class="hljs-comment">// 以下是客户端的逻辑</span><br>    addrString := &lt;-addr<br>    fmt.Println(addrString)<br>    conn, _ := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addrString) <span class="hljs-comment">// 建立到服务端的连接</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    time.Sleep(time.Second)<br><br>    _ = json.NewEncoder(conn).Encode(geerpc.DefaultOption)            <span class="hljs-comment">// 将 DefaultOption 以 JSON 格式编码，并发给服务端，用于协商 RPC 通信参数</span><br>    cc := codec.NewCodecFuncMap[geerpc.DefaultOption.CodecType](conn) <span class="hljs-comment">// 根据 DefaultOption 中的 CodecType 选择对应的 codec</span><br><br>    <span class="hljs-comment">// 发送 5 个请求并接收响应</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        h := &amp;codec.Header&#123; <span class="hljs-comment">// 构造请求头</span><br>            ServiceMethod: <span class="hljs-string">&quot;Foo.Sum&quot;</span>,<br>            Seq:           <span class="hljs-type">uint64</span>(i),<br>        &#125;<br><br>        <span class="hljs-comment">// 发送 header 和 body，其中 body 是一个字符串，格式为 &quot;geerpc req %d&quot;</span><br>        _ = cc.Write(h, fmt.Sprintf(<span class="hljs-string">&quot;geerpc req %d&quot;</span>, h.Seq))<br><br>        <span class="hljs-keyword">var</span> replyHeader codec.Header<br>        _ = cc.ReadHeader(&amp;replyHeader) <span class="hljs-comment">// 读取响应头</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>        _ = cc.ReadBody(&amp;reply) <span class="hljs-comment">// 读取响应体</span><br>        log.Println(<span class="hljs-string">&quot;main: reply: &quot;</span>, replyHeader, reply)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 监听随机可以用的端口</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;startServer: start rpc server on&quot;</span>, listen.Addr())<br><br>    <span class="hljs-comment">// 将监听地址返回给主协程</span><br>    addr &lt;- listen.Addr().String()<br>    geerpc.Accept(listen) <span class="hljs-comment">// 开始处理连接</span><br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">[::]:43017</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 0 &#125; geerpc req 0</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 0 &#125; geerpc resp 0</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 1 &#125; geerpc req 1</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 1 &#125; geerpc resp 1</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 2 &#125; geerpc req 2</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 2 &#125; geerpc resp 2</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 3 &#125; geerpc req 3</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 3 &#125; geerpc resp 3</span><br><span class="hljs-comment">handleRequest:  &amp;&#123;Foo.Sum 4 &#125; geerpc req 4</span><br><span class="hljs-comment">main: reply:  &#123;Foo.Sum 4 &#125; geerpc resp 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_1_codec<br>├── codec<br>│   ├── codec.go  <span class="hljs-comment"># 编码方式的抽象接口</span><br>│   └── gob.go  <span class="hljs-comment"># 实现 Codec 接口</span><br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 简易客户端，发送请求</span><br>└── server.go  <span class="hljs-comment"># 服务端 stub，接受请求</span><br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            codec/codec.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个抽象的 Codec 接口，Codec 接口包含了对消息体的编码和解码操作</span><br><span class="hljs-comment">// 具体的编码方式（如 Gob、Json）会来实现该接口</span><br><br><span class="hljs-keyword">package</span> codec<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;io&quot;</span><br><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>    ServiceMethod <span class="hljs-type">string</span> <span class="hljs-comment">// 服务名和方法名</span><br>    Seq           <span class="hljs-type">uint64</span> <span class="hljs-comment">// 请求序号</span><br>    Error         <span class="hljs-type">string</span> <span class="hljs-comment">// 客户端置为空，服务端如何出现错误，将错误信息写入Error</span><br>&#125;<br><br><span class="hljs-comment">// Codec 接口：对消息体进行编码，比如 Gob、Json 会实现该接口，代表两种编码方式</span><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">interface</span> &#123;<br>    io.Closer<br>    ReadHeader(*Header) <span class="hljs-type">error</span><br>    ReadBody(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>    Write(*Header, <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Type <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>    GobType  Type = <span class="hljs-string">&quot;application/gob&quot;</span><br>    JsonType Type = <span class="hljs-string">&quot;application/json&quot;</span><br>)<br><br><span class="hljs-comment">// NewCodecFunc Codec 接口类型的构造函数</span><br><span class="hljs-keyword">type</span> NewCodecFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(io.ReadWriteCloser)</span></span> Codec<br><br><span class="hljs-comment">// NewCodecFuncMap 通过 type 来选择对应的 codec 的构造函数</span><br><span class="hljs-keyword">var</span> NewCodecFuncMap <span class="hljs-keyword">map</span>[Type]NewCodecFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    NewCodecFuncMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]NewCodecFunc)<br>    NewCodecFuncMap[GobType] = NewGobCodec <span class="hljs-comment">// 赋值为 Gob codec 的构造函数</span><br>    <span class="hljs-comment">//NewCodecFuncMap[JsonType] = NewJsonCodec  // 赋值为 Json codec 的构造函数, 暂不实现</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            codec/gob.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 Gob 编码方式的结构体，对 encoding/gob 进行了封装，实现了 Codec 接口</span><br><br><span class="hljs-keyword">package</span> codec<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;encoding/gob&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> GobCodec <span class="hljs-keyword">struct</span> &#123;<br>    conn io.ReadWriteCloser<br>    buf  *bufio.Writer <span class="hljs-comment">// 使用缓冲流来提高性能，防止阻塞</span><br>    dec  *gob.Decoder<br>    enc  *gob.Encoder<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGobCodec</span><span class="hljs-params">(conn io.ReadWriteCloser)</span></span> Codec &#123;<br>    buf := bufio.NewWriter(conn)<br>    <span class="hljs-keyword">return</span> &amp;GobCodec&#123;<br>        conn: conn,<br>        buf:  buf,<br>        dec:  gob.NewDecoder(conn),<br>        enc:  gob.NewEncoder(buf),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ReadHeader 封装了 encoding/gob 的 Decode 方法，从连接中读取 Header 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadHeader(header *Header) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(header)<br>&#125;<br><br><span class="hljs-comment">// ReadBody 封装了 encoding/gob 的 Decode 方法，从连接中读取 Body 信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> ReadBody(body <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.dec.Decode(body)<br>&#125;<br><br><span class="hljs-comment">// Write 封装了 encoding/gob 的 Encode 方法，将 Header 和 Body 信息写入连接中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Write(header *Header, body <span class="hljs-keyword">interface</span>&#123;&#125;) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 关闭前，先将 buf 中的数据写入连接中</span><br>        _ = c.buf.Flush()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            _ = c.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(header); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding header: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> err = c.enc.Encode(body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Panicln(<span class="hljs-string">&quot;rpc codec: gob error encoding body: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Close 封装了 io.ReadWriteCloser 的 Close 方法，关闭连接</span><br><span class="hljs-comment">// io.ReadWriteCloser 包含 io.Closer 类型，io.Closer 类型包含 Close 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *GobCodec)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> c.conn.Close()<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            server.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span> <span class="hljs-comment">// 验证连接的合法性，确保客户端和服务端使用同一协议</span><br>    CodecType   codec.Type<br>&#125;<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg) <span class="hljs-comment">// 使用协程来并发处理请求。</span><br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 即使因为读请求出错退出循环，也需要等待所有协程请求处理完成再关闭连接，优雅终止。</span><br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h                *codec.Header <span class="hljs-comment">// 读到的请求头</span><br>    argv, replyValue reflect.Value <span class="hljs-comment">// argv 储存传入参数，replyValue 储存传出参数。reflect.Value 是反射值，是描述值的一个容器。</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    req := request&#123;<br>        h: h,<br>    &#125;<br><br>    req.argv = reflect.New(reflect.TypeOf(<span class="hljs-string">&quot;&quot;</span>))               <span class="hljs-comment">// 初始化传入参数，使用 New 方法创建一个表示 *string 类型值的反射值。reflect.Value 是描述值的一个容器。</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(req.argv.Interface()); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 读取请求参数，ReadBody 函数的参数类型是 interface&#123;&#125;，需要使用 Interface() 方法，将 reflect.Value 转化为 interface&#123;&#125; 类型</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: read body error: &quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    log.Println(<span class="hljs-string">&quot;handleRequest: &quot;</span>, req.h, req.argv.Elem())<br>    req.replyValue = reflect.ValueOf(fmt.Sprintf(<span class="hljs-string">&quot;geerpc resp %d&quot;</span>, req.h.Seq)) <span class="hljs-comment">// 构造请求的响应信息</span><br>    server.sendResponse(cc, req.h, req.replyValue.Interface(), sending)        <span class="hljs-comment">// 发送响应</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber: MagicNumber,<br>    CodecType:   codec.GobType,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main/main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-comment">// 启动服务端</span><br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    <span class="hljs-comment">// 以下是客户端的逻辑</span><br>    addrString := &lt;-addr<br>    fmt.Println(addrString)<br>    conn, _ := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addrString) <span class="hljs-comment">// 建立到服务端的连接</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    time.Sleep(time.Second)<br><br>    _ = json.NewEncoder(conn).Encode(geerpc.DefaultOption)            <span class="hljs-comment">// 将 DefaultOption 以 JSON 格式编码，并发给服务端，用于协商 RPC 通信参数</span><br>    cc := codec.NewCodecFuncMap[geerpc.DefaultOption.CodecType](conn) <span class="hljs-comment">// 根据 DefaultOption 中的 CodecType 选择对应的 codec</span><br><br>    <span class="hljs-comment">// 发送 5 个请求并接收响应</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        h := &amp;codec.Header&#123; <span class="hljs-comment">// 构造请求头</span><br>            ServiceMethod: <span class="hljs-string">&quot;Foo.Sum&quot;</span>,<br>            Seq:           <span class="hljs-type">uint64</span>(i),<br>        &#125;<br><br>        <span class="hljs-comment">// 发送 header 和 body，其中 body 是一个字符串，格式为 &quot;geerpc req %d&quot;</span><br>        _ = cc.Write(h, fmt.Sprintf(<span class="hljs-string">&quot;geerpc req %d&quot;</span>, h.Seq))<br><br>        <span class="hljs-keyword">var</span> replyHeader codec.Header<br>        _ = cc.ReadHeader(&amp;replyHeader) <span class="hljs-comment">// 读取响应头</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>        _ = cc.ReadBody(&amp;reply) <span class="hljs-comment">// 读取响应体</span><br>        log.Println(<span class="hljs-string">&quot;main: reply: &quot;</span>, replyHeader, reply)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 监听随机可以用的端口</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;startServer: start rpc server on&quot;</span>, listen.Addr())<br><br>    <span class="hljs-comment">// 将监听地址返回给主协程</span><br>    addr &lt;- listen.Addr().String()<br>    geerpc.Accept(listen) <span class="hljs-comment">// 开始处理连接</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="2-高性能客户端">2.高性能客户端</h2><p>虽然这章节叫高性能客户端，实际上具体来说，应该是 client stub，为真正的 client （具体的业务代码）提供基础设施。</p><h3 id="客户端需要提供哪些能力">客户端需要提供哪些能力</h3><p>首先我们期望用户可以怎么用我们这个框架。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化客户端，连接到服务器</span><br>client, err := geerpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>)<br><br><span class="hljs-comment">// 发送请求</span><br><span class="hljs-keyword">var</span> args, reply <span class="hljs-type">string</span><br>err = client.Call(<span class="hljs-string">&quot;methodName&quot;</span>, args, &amp;reply)<br></code></pre></td></tr></table></figure><p>所以肯定需要提供 Dial、Call 这两个方法给用户使用。但在这背后的能力，应该有这些：</p><ul><li><p>连接管理的能力：</p><ul><li>网络连接建立：通过 Dial 方法连接到服务器。</li><li>协议协商：在建立连接后，完成协议交换（通过发送 option 协商）。</li><li>连接状态管理：当用户主动关闭连接或者程序出现异常时，关闭连接并释放资源。</li></ul></li><li><p>请求管理的能力：</p><ul><li>请求封装：将单次的请求信息封装在一个结构体中。</li><li>唯一标识：为每个请求生成一个唯一的序例号。</li></ul></li><li><p>通信能力：</p><ul><li>请求发送：<ul><li>序例化 header 和 body。</li><li>发送请求（通过锁来保证原子性）。</li><li>并发的处理多个请求。</li></ul></li><li>响应接收：<ul><li>持续接收响应。</li><li>异常处理：服务出错、请求不存在（已移除）。</li></ul></li></ul></li></ul><p>虽然这些能力看着很多，但大多是细节。接下来，我们自顶向下地实现 Dial、Call 这两个核心方法。</p><h3 id="如何实现-Dial-方法">如何实现 Dial 方法</h3><p>从主流程来看，Dial 有三件事：</p><ul><li>确定编码方式</li><li>连接服务器</li><li>返回一个 Client 实例，用户使用这个 Client 实例进行远程调用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Dial connects to an RPC server at the specified network address</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*geerpc.Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 真正拨号建立连接</span><br>    conn, err := net.Dial(network, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>            _ = conn.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 返回 Client 实例</span><br>    <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>确定编码方式</strong>：根据用户传入的 Option 来实例化 Codec，如果没有传入，则默认使用 gob 编码，所以这里是可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*geerpc.Option)</span></span> (*geerpc.Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> geerpc.DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = geerpc.DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = geerpc.DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>连接服务器</strong>：使用 net 包得 Dial 方法，获得一个  <code>net.Conn</code> 接口类型，表示面向流的网络连接。 GobCodec 会对 conn 进一步封装，向外提供读/写/关闭的能力。</p><p><strong>返回 client 实例</strong>：这里是 Dail 的重中之重，很多特性都需要通过 client 的设计来实现。</p><h3 id="如何抽象一个请求">如何抽象一个请求</h3><p>用户拿着 Client 实例，可以和服务端进行多次请求的发送和接收，也就是 Client 需要管理多个请求。所以在设计 Client 之前，需要将请求抽象出来。</p><ul><li>Args、Reply：请求的参数是 interface{} 类型，因为 codec 读写方法参数都是 interface{}。</li><li>Done：是一个 channel，请求结束时，调用 done 方法，给 Done chanel 写值，Client 拿着这个 channel 就可以知道请求结束了。（正常结束或者异常结束）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123; <br>    call.Done &lt;- call<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何设计一个-Client">如何设计一个 Client</h3><p><strong>（1）基础的收发消息</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>opt      *geerpc.Option   <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br></code></pre></td></tr></table></figure><p><strong>（2）发送请求提前准备的信息</strong>：多个请求共用一个 header，放在 Client 里，避免每次构造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br></code></pre></td></tr></table></figure><p><strong>（3）处理并发请求的工具</strong>：因为请求时并发的，会存在两个问题：不知道什么时候收到响应？不知道收到的响应是哪个请求的？</p><ul><li>seq：Client 发的每个请求和接收的每个响应的 header 中，都有一个序号，保证请求的顺序和唯一性。</li><li>pending：未处理完的请求，比如还未发送的请求、已经发送还未回复的请求。<ul><li>对于未处理完的请求，调用者一直在阻塞，等待响应。当我收到响应后，可以根据序号，拿到该请求的 channel，告知调用者已经收到结果，并将响应结果储存在对应 call 的 reply 变量中。</li><li>如果没有这个 map，一无法通知，二也不知道通知谁，结果储存给谁。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br></code></pre></td></tr></table></figure><p><strong>（4）保证并发读写的锁</strong>：</p><ul><li>sending：保证每次发送给服务器，只有一个请求在发，否则服务端交叉收到不好解析。</li><li>mu：保护  seq、pending 、shutdown、closing 字段，防止并发读写。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending、shutdown、closing 字段，防止并发读写</span><br></code></pre></td></tr></table></figure><p><strong>（5）异常处理的标志位</strong>：为什么要设计两个字段？</p><ul><li>closing：表示用户正在主动关闭 Client，避免多次关闭客户端，还可以做优雅退出。</li><li>shutdown：表示因为异常错误，Client 无法发送接收了，快速失败，对于没处理完的请求返回错误，避免调用者长时间阻塞等待响应。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br></code></pre></td></tr></table></figure><p>整体如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *geerpc.Option   <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending 、shutdown字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于上面这些，我们要提供几个基础的方法。</p><p><strong>（1）创建客户端</strong></p><ul><li>确定编码方式</li><li>根据编码方式实例化 Codec</li><li>根据 Codec 实例化  Client</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *geerpc.Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *geerpc.Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()  <span class="hljs-comment">// 启动协程持续接收响应</span><br>    <span class="hljs-keyword">return</span> client<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）启动协程持续接收响应</strong></p><ul><li>接收请求，先读取 header，其中有序号。</li><li>请求已经收到响应，表示已经处理完了，该序号的请求就可以在 pending 中移出，并拿到该请求的实例 call。</li><li>读取 body，并将响应储存在 <code>call.Reply</code> 中。（在此之前要处理两种错误）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>            <span class="hljs-comment">//fmt.Println(call.Reply)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）异常处理，快速失败</strong></p><p>如果发生错误（如连接断开），调用 <code>terminateCalls</code> 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）优雅退出</strong></p><p>提供 Close 方法，给用户主动关闭 Client。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）可用性</strong></p><p>暴露给用户。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）注册/移出请求</strong></p><p>主要是将请求保存在 pending 中管理，根据 seq 快速拿到请求实例 call。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何设计异步-同步调用方法">如何设计异步/同步调用方法</h3><p>基础设施已经有了，万事俱备，就差发送请求了。</p><p><strong>异步调用方法</strong>：流程很明确，主要有三步。</p><ul><li>构造 Call 请求实例</li><li><code>registerCall</code> 注册请求</li><li><code>Codec.Write</code> 发送请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个调用的方式是异步的，调完就完了，也不需要等待结果，因为有 receive 协程专门在接收数据。</p><p>举个例子，用户可以批量的调用，再统一的等待结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">done1 := client.Go(<span class="hljs-string">&quot;Arith.Add&quot;</span>, args1, &amp;reply1, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br>done2 := client.Go(<span class="hljs-string">&quot;Arith.Mul&quot;</span>, args2, &amp;reply2, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>call1 := &lt;-done1<br>call2 := &lt;-done2<br></code></pre></td></tr></table></figure><p>也可以不关心返回的结果。（比如打日志、异步上报）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">client.Go(<span class="hljs-string">&quot;LogService.Log&quot;</span>, args, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 不需要 reply</span><br></code></pre></td></tr></table></figure><p><strong>同步调用方法</strong>：</p><p>用户想调用完，等待结果再继续。我们可以在 <code>Client.Go</code> 方法的基础上，简单封装一个同步调用的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := &lt;-client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>)).Done <span class="hljs-comment">// 读 Done 的数据，阻塞等待 receive() 处理完响应结果，对 Done 写值</span><br>    <span class="hljs-keyword">return</span> call.Error<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-2">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_2_client<br>├── client.go  <span class="hljs-comment"># 新增：封装 RPC 请求，设计 client stub</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main <span class="hljs-comment"># 改动：使用 client stub 发起连接和请求</span><br>│   └── main.go<br>└── server.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            client.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 client 对连接、发送请求、接受请求进行封装，并对用户提供 Dial、Call 方法。</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 seq、pending 、shutdown、closing字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理完的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Dial connects to an RPC server at the specified network address</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 真正拨号建立连接</span><br>    conn, err := net.Dial(network, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>            _ = conn.Close()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 返回 Client 实例</span><br>    <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>            <span class="hljs-comment">//fmt.Println(call.Reply)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := &lt;-client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>)).Done <span class="hljs-comment">// 读 Done 的数据，阻塞等待 receive() 处理完响应结果，对 Done 写值</span><br>    <span class="hljs-keyword">return</span> call.Error<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="3-服务注册">3.服务注册</h2><p>前面两章，我们都在假装调用  Foo 类型的 Sum 方法，获取到了方法名和参数返回了，没有真正去调用方法。要想真正可以调用，那就需要 client stub 把 Foo 类型（其实也是一种服务）注册到 server stub 中，这就是服务注册，下面来看细节。</p><h3 id="这一章是干什么的">这一章是干什么的</h3><p>服务端的主要工作：</p><ul><li>监听端口</li><li>响应请求<ul><li>解析请求</li><li>处理请求<ul><li>从请求中获取方法名、参数</li><li>获取方法</li><li>调用方法</li></ul></li><li>返回结果</li></ul></li></ul><p>这一章主要完成处理请求部分，其中，从请求中获取方法名、参数在上一章已完成。client 在发送请求时，方法名在请求头里 <code>client.header.ServiceMethod</code>，参数在请求体里 <code>call.Args</code>。</p><p>所以我们重点关注</p><ul><li>获取方法（获取方法的重点在于，事前将可调用的方法注册到服务中）</li><li>调用方法</li></ul><h3 id="如何获取方法">如何获取方法</h3><p>服务端通过方法名获取实际的方法，需要两步：</p><ol><li>在启动服务端服务时，我们可以将所有可调用的方法都加到一个 map 中。</li><li>当 client 调用 hello 时，我们从 map 中找到对应的方法皆可。</li></ol><p>由于不同类型的结构体，可能有同名的结构体方法。我们的方法名，使用 <code>结构体实例名.方法名</code> 来作为方法名。比如上一章中的，结构体类型 <code>Foo</code> ，有 <code>Sum</code> 方法，客户端实例化 <code>foo</code> 对象后，远程调用 Client.Call 时，传入的就是 <code>foo.Sum</code>。</p><h3 id="如何方法注册到-map-中">如何方法注册到 map 中</h3><p>首先，先说数据存储方式，简单来说是这样的，</p><pre><code class=" mermaid">graph LR    A[Server.serviceMap] --&gt;|map储存多个service| B[Service&lt;br&gt;一个 service 表示一个变量类型]    B --&gt;|service包含一个 map 变量| C[service.method]    C --&gt;|map 储存多个方法| D[methodType&lt;br&gt;一个 methodType 表示一个该变量类型的方法] </code></pre><p>具体数据存储方式设计如下：</p><p>服务端保存着一个 serviceMap。使用 serviceMap 保存变量类型及其方法。key 是变量类型名，value 是 service 类型实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br></code></pre></td></tr></table></figure><p>service 类型定义如下，一个 service 表示一个变量类型。其中，也包含一个 map，保存着这个变量的方法。key 是方法名，value 是 methodType 类型实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// 一个 service 表示一个变量类型</span><br><span class="hljs-keyword">type</span> service <span class="hljs-keyword">struct</span> &#123;<br>    name   <span class="hljs-type">string</span>                 <span class="hljs-comment">// 变量类型名，用来打 log，例如字符串 &quot;Foo&quot;</span><br>    typ    reflect.Type           <span class="hljs-comment">// 变量类型，通过变量的类型，可以直接获取变量的方法，例如 Foo 类型，可获取到方法 Sum</span><br>    rcvr   reflect.Value          <span class="hljs-comment">// 变量的值，通过变量的值，可以调用变量的方法，例如 &amp;foo，调用 Sum</span><br>    method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType <span class="hljs-comment">//  map 储存变量的方法中所有可调用的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>methodType 类型定义如下，一个 methodType 表示一个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// 一个 methodType 表示一个方法</span><br><span class="hljs-keyword">type</span> methodType <span class="hljs-keyword">struct</span> &#123;<br>    method    reflect.Method <span class="hljs-comment">// 方法本身，用于调用方法，例如 Foo.Sum</span><br>    ArgType   reflect.Type   <span class="hljs-comment">// 参数的类型，用于判断参数是否正确</span><br>    ReplyType reflect.Type   <span class="hljs-comment">// 返回的类型，用于判断返回值是否正确</span><br>    numCalls  <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 方法调用次数，用于统计方法调用次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，下面将以一个实际例子，演示如何将方法注册到 map 中。</p><pre><code class=" mermaid">graph LR    A[startServer, 启动服务器] --&gt; B[Server.Register , 为 Foo 类型注册服务]    B --&gt; C[newService, 为 Foo 类型创建 service 结构体]    C --&gt; D[获取 rcvr 值, 类型名和类型]    C --&gt; G[service.registerMethods, 获取方法列表]    G --&gt; K[检查方法的参数和返回值]    K --&gt; L[保存方法到 map 变量 service.method]</code></pre><ol><li>启动服务，将 Foo 类型注册到 rpc server 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    addr &lt;- l.Addr().String()<br>    geerpc.Accept(l)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>为 Foo 类型创建 service 对象，并保存到 server 的 map 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建 service 对象、获取对象的方法、检查方法参数和返回值，最后将方法保存到 map 中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// newService 通过发射获取 rcvr 变量的类型及其方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newService</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *service &#123;<br>    s := <span class="hljs-built_in">new</span>(service)<br>    s.rcvr = reflect.ValueOf(rcvr)                  <span class="hljs-comment">// 获取 rcvr 变量的值，例如 &amp;foo</span><br>    s.name = reflect.Indirect(s.rcvr).Type().Name() <span class="hljs-comment">// 获取 rcvr 变量的类型名，例如 &quot;Foo&quot;</span><br>    s.typ = reflect.TypeOf(rcvr)                    <span class="hljs-comment">// 获取 rcvr 变量的类型，例如 Foo</span><br>    <span class="hljs-keyword">if</span> !ast.IsExported(s.name) &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;rpc server: %s is not a valid service name&quot;</span>, s.name)<br>    &#125;<br>    s.registerMethods() <span class="hljs-comment">// 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// registerMethods 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> registerMethods() &#123;<br>    s.method = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.typ.NumMethod(); i++ &#123; <span class="hljs-comment">// 遍历 rcvr 变量的方法列表</span><br>        method := s.typ.Method(i) <span class="hljs-comment">// 获取 rcvr 变量，第 i 个方法</span><br>        mType := method.Type      <span class="hljs-comment">// 获取 rcvr 变量的方法的类型</span><br><br>        <span class="hljs-comment">// 检查方法的参数是否正确。rpc 的方法必须满足以下条件：</span><br>        <span class="hljs-comment">// 1. 方法有 3 个参数，第 1 个参数是 rcvr 变量(相当于 python 的 self，java 的 this)，第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>        <span class="hljs-comment">// 2. 第 2 个参数和第 3 个参数都是导出的类型</span><br>        <span class="hljs-comment">// 3. 返回值只有一个，是 error 类型</span><br>        <span class="hljs-comment">// 例如这样 func (t *T) MethodName(argType T1, replyType *T2) error</span><br>        <span class="hljs-keyword">if</span> mType.NumIn() != <span class="hljs-number">3</span> || mType.NumOut() != <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 检查参数个数</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> mType.Out(<span class="hljs-number">0</span>) != reflect.TypeOf((*<span class="hljs-type">error</span>)(<span class="hljs-literal">nil</span>)).Elem() &#123; <span class="hljs-comment">// 检测返回值个数和类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        argType, replyType := mType.In(<span class="hljs-number">1</span>), mType.In(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123; <span class="hljs-comment">// 检查参数类型是否是导出的类型或者内置类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查完毕，将方法保存到 service 的方法 map 中</span><br>        s.method[method.Name] = &amp;methodType&#123;<br>            method:    method,<br>            ArgType:   argType,<br>            ReplyType: replyType,<br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: register %s.%s\n&quot;</span>, s.name, method.Name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// isExportedOrBuiltinType 检查类型是否是导出的类型或者内置类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExportedOrBuiltinType</span><span class="hljs-params">(t reflect.Type)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> ast.IsExported(t.Name()) || t.PkgPath() == <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何从-map-获取方法">如何从 map 获取方法</h3><p>在 readRequest 时，从请求头中，获取方法名；根据方法名在对应的 service 的 map 中获取到方法、传入参数、传出参数。</p><pre><code class=" mermaid">graph LR    A[Server.readRequest] --&gt;|解析请求头| B[Server.readRequestHeader]    B--&gt;|返回请求头,包含方法名| A    A --&gt;|获取方法| C[Server.findService]    A --&gt;|获取方法传入参数,传出参数| D[GobCodec.ReadBody]    E[request]    C--&gt;|方法保存到 request| E    D--&gt;|传入参数,传出参数保存到 request| E</code></pre><ol><li>request 储存了一次远程调用请求的信息，方法、传入参数、传出参数指针。它的定义如下。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>readRequest 获取方法名、方法、传入参数、传出参数，并储存在 request 实例中，为方法调用做准备。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，需要注意一下，</p><ul><li>创建传入参数时，需区分值类型还是指针类型。</li><li>创建传出参数时，需对 map、slice 特殊处理。（因为 reflect.New 初始化时，map、slice 都是 nil）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// newArgv 创建一个参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newArgv() reflect.Value &#123;<br>    <span class="hljs-keyword">var</span> argv reflect.Value<br>    <span class="hljs-comment">// 参数可能是指针类型也可能是值类型</span><br>    <span class="hljs-keyword">if</span> m.ArgType.Kind() == reflect.Ptr &#123;<br>        argv = reflect.New(m.ArgType.Elem()) <span class="hljs-comment">// 指针类型，则创建指针类型变量</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argv = reflect.New(m.ArgType).Elem() <span class="hljs-comment">// 值类型，则创建值类型变量</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> argv<br>&#125;<br><br><span class="hljs-comment">// newReplyv 创建一个传出参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newReplyv() reflect.Value &#123;<br>    <span class="hljs-comment">// 传出参数必须是指针类型</span><br>    replyv := reflect.New(m.ReplyType.Elem())<br><br>    <span class="hljs-comment">// 为什么需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// reflect.New 创建的 map 和 slice 都是 nil，需要先初始化，再使用。</span><br>    <span class="hljs-comment">// 为什么 newArgv 方法不需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// 因为 argv 是用于接收调用方传入的参数，这些参数由调用方提供且已经初始化。</span><br>    <span class="hljs-keyword">switch</span> m.ReplyType.Elem().Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Map:<br>        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))<br>    <span class="hljs-keyword">case</span> reflect.Slice:<br>        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> replyv<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何调用方法">如何调用方法</h3><p>在 handleRequest 时，通过 service.call 利用反射来调用函数。这里主要学习这个用法。</p><pre><code class=" mermaid">graph LR    A[Server.serveCodec]--&gt;|获取请求信息| B[Server.readRequest]     A --&gt;|调用方法| C[Server.handleRequest]    C --&gt; D[request.svc.call, 也就是 Service.call]    D --&gt;|使用反射调用| E[methodType.method.Func.Call]</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        req.h.Error = err.Error()<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// service.go</span><br><span class="hljs-comment">// call 调用 rcvr 变量的方法，例如 Foo.Sum</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> call(m *methodType, argv, replyv reflect.Value) <span class="hljs-type">error</span> &#123;<br>    atomic.AddUint64(&amp;m.numCalls, <span class="hljs-number">1</span>)<br>    f := m.method.Func<br>    <span class="hljs-comment">// 用反射的方式调用方法</span><br>    <span class="hljs-comment">// 第一个参数是 rcvr 变量，例如 &amp;foo，类似于 java 的 this，python 的 self</span><br>    <span class="hljs-comment">// 第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>    returnValues := f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)<br>    <span class="hljs-keyword">if</span> errInter := returnValues[<span class="hljs-number">0</span>].Interface(); errInter != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errInter.(<span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更深入了解反射">更深入了解反射</h3><p>请看这篇 <a href="https://www.aimtao.net/go#11-reflect">https://www.aimtao.net/go#11-reflect</a></p><h3 id="完整代码-3">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_3_service<br>├── client.go<br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 改动：增加真正将服务注册到 server stub 的步骤</span><br>├── server.go  <span class="hljs-comment"># 改动：增加 serviceMap 保存所有可以调用的方法，并对用户暴露服务注册的方法</span><br>├── service.go  <span class="hljs-comment"># 新增：将每个变量抽象成一个 service，并储存该变量的方法</span><br>└── service_test.go  <span class="hljs-comment"># 新增：测试 service 方法</span><br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            main/main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    geerpc <span class="hljs-string">&quot;GeeRPC&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    addr &lt;- l.Addr().String()<br>    geerpc.Accept(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    log.SetFlags(<span class="hljs-number">0</span>)<br><br>    addr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> startServer(addr)<br><br>    client, _ := geerpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addr)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(<span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            server.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;GeeRPC/codec&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber <span class="hljs-type">int</span><br>    CodecType   codec.Type<br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn))<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        req.h.Error = err.Error()<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber: MagicNumber,<br>    CodecType:   codec.GobType,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            service.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义 service 类型，一个 service 表示一个变量类型，每个 service 储存了该变量的所有方法。（方法名、参数、返回值）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;go/ast&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> methodType <span class="hljs-keyword">struct</span> &#123;<br>    method    reflect.Method <span class="hljs-comment">// 方法本身，用于调用方法，例如 Foo.Sum</span><br>    ArgType   reflect.Type   <span class="hljs-comment">// 参数的类型，用于判断参数是否正确</span><br>    ReplyType reflect.Type   <span class="hljs-comment">// 返回的类型，用于判断返回值是否正确</span><br>    numCalls  <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 方法调用次数，用于统计方法调用次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> NumCalls() <span class="hljs-type">uint64</span> &#123;<br>    <span class="hljs-keyword">return</span> atomic.LoadUint64(&amp;m.numCalls)<br>&#125;<br><br><span class="hljs-comment">// newArgv 创建一个参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newArgv() reflect.Value &#123;<br>    <span class="hljs-keyword">var</span> argv reflect.Value<br>    <span class="hljs-comment">// 参数可能是指针类型也可能是值类型</span><br>    <span class="hljs-keyword">if</span> m.ArgType.Kind() == reflect.Ptr &#123;<br>        argv = reflect.New(m.ArgType.Elem()) <span class="hljs-comment">// 指针类型，则创建指针类型变量</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argv = reflect.New(m.ArgType).Elem() <span class="hljs-comment">// 值类型，则创建值类型变量</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> argv<br>&#125;<br><br><span class="hljs-comment">// newReplyv 创建一个传出参数变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *methodType)</span></span> newReplyv() reflect.Value &#123;<br>    <span class="hljs-comment">// 传出参数必须是指针类型</span><br>    replyv := reflect.New(m.ReplyType.Elem())<br><br>    <span class="hljs-comment">// 为什么需要对 map 和 slice 特殊处理？</span><br>    <span class="hljs-comment">// reflect.New 创建的 map 和 slice 都是 nil，需要先初始化，再使用。</span><br>    <span class="hljs-keyword">switch</span> m.ReplyType.Elem().Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Map:<br>        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))<br>    <span class="hljs-keyword">case</span> reflect.Slice:<br>        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> replyv<br>&#125;<br><br><span class="hljs-keyword">type</span> service <span class="hljs-keyword">struct</span> &#123;<br>    name   <span class="hljs-type">string</span>                 <span class="hljs-comment">// 变量类型名，用来打 log，例如字符串 &quot;Foo&quot;</span><br>    typ    reflect.Type           <span class="hljs-comment">// 变量类型，通过变量的类型，可以直接获取变量的方法，例如 Foo 类型，可获取到方法 Sum</span><br>    rcvr   reflect.Value          <span class="hljs-comment">// 变量的值，通过变量的值，可以调用变量的方法，例如 &amp;foo，调用 Sum</span><br>    method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType <span class="hljs-comment">//  map 储存变量的方法中所有可调用的方法</span><br>&#125;<br><br><span class="hljs-comment">// newService 通过发射获取 rcvr 变量的类型及其方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newService</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *service &#123;<br>    s := <span class="hljs-built_in">new</span>(service)<br>    s.rcvr = reflect.ValueOf(rcvr)                  <span class="hljs-comment">// 获取 rcvr 变量的值，例如 &amp;foo</span><br>    s.name = reflect.Indirect(s.rcvr).Type().Name() <span class="hljs-comment">// 获取 rcvr 变量的类型名，例如 &quot;Foo&quot;</span><br>    s.typ = reflect.TypeOf(rcvr)                    <span class="hljs-comment">// 获取 rcvr 变量的类型，例如 Foo</span><br>    <span class="hljs-keyword">if</span> !ast.IsExported(s.name) &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;rpc server: %s is not a valid service name&quot;</span>, s.name)<br>    &#125;<br>    s.registerMethods() <span class="hljs-comment">// 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// registerMethods 获取 rcvr 变量的方法列表，例如 Foo.Sum，并将其保存到 service 的方法 map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> registerMethods() &#123;<br>    s.method = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.typ.NumMethod(); i++ &#123; <span class="hljs-comment">// 遍历 rcvr 变量的方法列表</span><br>        method := s.typ.Method(i) <span class="hljs-comment">// 获取 rcvr 变量，第 i 个方法</span><br>        mType := method.Type      <span class="hljs-comment">// 获取 rcvr 变量的方法的类型</span><br><br>        <span class="hljs-comment">// 检查方法的参数是否正确。rpc 的方法必须满足以下条件：</span><br>        <span class="hljs-comment">// 1. 方法有 3 个参数，第 1 个参数是 rcvr 变量(相当于 python 的 self，java 的 this)，第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>        <span class="hljs-comment">// 2. 第 2 个参数和第 3 个参数都是导出的类型</span><br>        <span class="hljs-comment">// 3. 返回值只有一个，是 error 类型</span><br>        <span class="hljs-comment">// 例如这样 func (t *T) MethodName(argType T1, replyType *T2) error</span><br>        <span class="hljs-keyword">if</span> mType.NumIn() != <span class="hljs-number">3</span> || mType.NumOut() != <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 检查参数个数</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> mType.Out(<span class="hljs-number">0</span>) != reflect.TypeOf((*<span class="hljs-type">error</span>)(<span class="hljs-literal">nil</span>)).Elem() &#123; <span class="hljs-comment">// 检测返回值个数和类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        argType, replyType := mType.In(<span class="hljs-number">1</span>), mType.In(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123; <span class="hljs-comment">// 检查参数类型是否是导出的类型或者内置类型</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查完毕，将方法保存到 service 的方法 map 中</span><br>        s.method[method.Name] = &amp;methodType&#123;<br>            method:    method,<br>            ArgType:   argType,<br>            ReplyType: replyType,<br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: register %s.%s\n&quot;</span>, s.name, method.Name)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// isExportedOrBuiltinType 检查类型是否是导出的类型或者内置类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isExportedOrBuiltinType</span><span class="hljs-params">(t reflect.Type)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> ast.IsExported(t.Name()) || t.PkgPath() == <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// call 调用 rcvr 变量的方法，例如 Foo.Sum</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *service)</span></span> call(m *methodType, argv, replyv reflect.Value) <span class="hljs-type">error</span> &#123;<br>    atomic.AddUint64(&amp;m.numCalls, <span class="hljs-number">1</span>)<br>    f := m.method.Func<br>    <span class="hljs-comment">// 用反射的方式调用方法</span><br>    <span class="hljs-comment">// 第一个参数是 rcvr 变量，例如 &amp;foo，类似于 java 的 this，python 的 self</span><br>    <span class="hljs-comment">// 第 2 个参数是传入参数，第 3 个参数是传出参数，指针类型</span><br>    returnValues := f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)<br>    <span class="hljs-keyword">if</span> errInter := returnValues[<span class="hljs-number">0</span>].Interface(); errInter != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errInter.(<span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            service_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span><br><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// it&#x27;s not a exported Method</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">assert</span><span class="hljs-params">(condition <span class="hljs-type">bool</span>, msg <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !condition &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;assertion failed: &quot;</span>+msg, v...))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    _assert(<span class="hljs-built_in">len</span>(s.method) == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;wrong service Method, expect 1, but got %d&quot;</span>, <span class="hljs-built_in">len</span>(s.method))<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br>    _assert(mType != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;wrong Method, Sum shouldn&#x27;t nil&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMethodType_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br><br>    argv := mType.newArgv()<br>    replyv := mType.newReplyv()<br>    argv.Set(reflect.ValueOf(Args&#123;Num1: <span class="hljs-number">1</span>, Num2: <span class="hljs-number">3</span>&#125;))<br>    err := s.call(mType, argv, replyv)<br>    _assert(err == <span class="hljs-literal">nil</span> &amp;&amp; *replyv.Interface().(*<span class="hljs-type">int</span>) == <span class="hljs-number">4</span> &amp;&amp; mType.NumCalls() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;failed to call Foo.Sum&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="4-超时处理">4.超时处理</h2><h3 id="哪些地方需要超时处理">哪些地方需要超时处理</h3><p>简单来看整个流程：</p><ul><li><p>客户端：</p><ol><li>拨号连接 ✓</li><li>远程调用（发送数据）✓</li><li>等待服务端处理 ✓</li><li>接收返回的结果（接收数据）✓</li></ol></li><li><p>服务端：</p><ol><li>端口监听</li><li>接收请求信息（接收数据）✓</li><li>调用方法处理请求信息（处理数据）✓</li><li>返回请求结果（发送数据）✓</li></ol></li></ul><p>以上打 ✓ 的步骤，均可能出现超时，主要为，</p><ul><li>客户端建立连接超时</li><li>发送数据<ul><li>客户端/服务端写报文时超时</li></ul></li><li>处理数据<ul><li>服务端调用方法超时</li></ul></li><li>接收数据<ul><li>客户端等待服务端响应超时</li><li>客户端/服务端读取报文超时</li></ul></li></ul><p>基于这个超时的情景，我们可以在以下三个地方设置超时处理机制。</p><p>客户端：</p><ul><li>建立连接</li><li><code>Client.call()</code> 的整个过程（包含发送数据、等待处理、接收数据）</li></ul><p>服务端：</p><ul><li><code>Server.handleRequest()</code> 的整个过程（包括处理数据、发送数据，接收数据先不管了）</li></ul><h3 id="建立连接的超时处理">建立连接的超时处理</h3><p>启动一个 goroutine 来拨号建立连接，使用 select 设置超时器，阻塞等待拨号结果，如果在接收拨号结果之前，先收到了超时信号，则进行超时处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult)<br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时的时长，设置在 Option struct 内，便于用户自定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Call-的超时处理">Call 的超时处理</h3><p>把选择权交给用户。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户如何使用？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx, _ := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>err := client.Call(ctx, <span class="hljs-string">&quot;Foo.Sum&quot;</span>, &amp;Args&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &amp;reply)<br></code></pre></td></tr></table></figure><h3 id="handleRequest-超时处理">handleRequest 超时处理</h3><p>这里先不管读取数据了，仅对 handleRequest 做超时处理。handleRequest 其中又分为两个步骤，处理数据、发送数据，仅对处理数据做超时处理。</p><p>设置两个  channel，一个表示 <code>req.svc.call </code> 完成，一个表示 <code>server.sendResponse</code> 完成。当 <code>req.svc.call </code> 完成后，就不用管超时时间是否到达，继续让 server.sendResponse 发送数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;  <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试代码">测试代码</h3><p>测试客户端处理连接超时的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_dialTimeout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel() <span class="hljs-comment">// 设置测试项并行执行</span><br><br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>        _ = conn.Close()<br>        time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 模拟了一个没有错误的客户端连接</span><br>    &#125;<br><br>    l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br><br>    <span class="hljs-comment">// 测试客户端连接有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;connect timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)<br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;connect timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试客户端连接没有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: <span class="hljs-number">0</span>&#125;)<br>        _assert(err == <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;0 means no limit&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试客户端处理调用超时和服务端处理超时的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server_test.go</span><br><span class="hljs-keyword">type</span> ServiceTemp <span class="hljs-type">int</span><br><br><span class="hljs-comment">// ServiceTemp 有一个方法 Timeout，该方法耗时2s</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s ServiceTemp)</span></span> Timeout(args <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    time.Sleep(time.Second * time.Duration(args))<br>    *reply = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel()<br><br>    addrCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123; <span class="hljs-comment">// 启动一个服务器，监听 0 端口，注册 ServiceTemp 类型的对象，然后启动 Accept 方法，等待客户端连接</span><br>        <span class="hljs-keyword">var</span> s ServiceTemp<br>        _ = Register(&amp;s)<br>        l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>        addrCh &lt;- l.Addr().String()<br>        Accept(l)<br>    &#125;(addrCh)<br>    addr := &lt;-addrCh<br><br>    <span class="hljs-comment">// 测试客户端处理调用超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;client call timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br><br>        ctx, _ := context.WithTimeout(context.Background(), time.Second) <span class="hljs-comment">// 创建一个超时的 context，如果 1s 内没有返回结果，context.Done() 会传出信号 struct&#123;&#125;&#123;&#125;</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(ctx, <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，Call 发生超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试服务端处理超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;server handle timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr, &amp;Option&#123;HandleTimeout: time.Second&#125;)<br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(context.Background(), <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，服务端处理超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;handle timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-4">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_4_timeout<br>├── client.go  <span class="hljs-comment"># 改动：增加客户端端超时处理的逻辑</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── go.mod<br>├── main<br>│   └── main.go<br>├── server.go  <span class="hljs-comment"># 改动：增加服务端超时处理的逻辑</span><br>├── service.go<br>└── service_test.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            server.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个 server stub，建立链接，处理请求（读取 option 协商协议，读取请求，处理请求，回复请求）</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn), &amp;opt)<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec, opt *Option) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                                 <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        req.h.Error = fmt.Sprintf(<span class="hljs-string">&quot;rpc server: request handle timeout: expect within %s&quot;</span>, timeout)<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            client.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 client 对连接、发送请求、接受请求进行封装，并对用户提供 Dial、Call 方法。</span><br><br><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 pending 和 shutdown 字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 如果超时时间为 0，表示没限制，直接等待 result 通道返回结果</span><br>    <span class="hljs-keyword">if</span> opt.ConnectTimeout == <span class="hljs-number">0</span> &#123;<br>        result := &lt;-result<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            server_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span><br><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// it&#x27;s not a exported Method</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">assert</span><span class="hljs-params">(condition <span class="hljs-type">bool</span>, msg <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !condition &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;assertion failed: &quot;</span>+msg, v...))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    _assert(<span class="hljs-built_in">len</span>(s.method) == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;wrong service Method, expect 1, but got %d&quot;</span>, <span class="hljs-built_in">len</span>(s.method))<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br>    _assert(mType != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;wrong Method, Sum shouldn&#x27;t nil&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMethodType_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> foo Foo<br>    s := newService(&amp;foo)<br>    mType := s.method[<span class="hljs-string">&quot;Sum&quot;</span>]<br><br>    argv := mType.newArgv()<br>    replyv := mType.newReplyv()<br>    argv.Set(reflect.ValueOf(Args&#123;Num1: <span class="hljs-number">1</span>, Num2: <span class="hljs-number">3</span>&#125;))<br>    err := s.call(mType, argv, replyv)<br>    _assert(err == <span class="hljs-literal">nil</span> &amp;&amp; *replyv.Interface().(*<span class="hljs-type">int</span>) == <span class="hljs-number">4</span> &amp;&amp; mType.NumCalls() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;failed to call Foo.Sum&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> ServiceTemp <span class="hljs-type">int</span><br><br><span class="hljs-comment">// ServiceTemp 有一个方法 Timeout，该方法耗时2s</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s ServiceTemp)</span></span> Timeout(args <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    time.Sleep(time.Second * time.Duration(args))<br>    *reply = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_Call</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel()<br><br>    addrCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123; <span class="hljs-comment">// 启动一个服务器，监听 0 端口，注册 ServiceTemp 类型的对象，然后启动 Accept 方法，等待客户端连接</span><br>        <span class="hljs-keyword">var</span> s ServiceTemp<br>        _ = Register(&amp;s)<br>        l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>        addrCh &lt;- l.Addr().String()<br>        Accept(l)<br>    &#125;(addrCh)<br>    addr := &lt;-addrCh<br><br>    <span class="hljs-comment">// 测试客户端处理调用超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;client call timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br><br>        ctx, _ := context.WithTimeout(context.Background(), time.Second) <span class="hljs-comment">// 创建一个超时的 context，如果 1s 内没有返回结果，context.Done() 会传出信号 struct&#123;&#125;&#123;&#125;</span><br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(ctx, <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，Call 发生超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试服务端处理超时的情况</span><br>    t.Run(<span class="hljs-string">&quot;server handle timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        client, _ := Dial(<span class="hljs-string">&quot;tcp&quot;</span>, addr, &amp;Option&#123;HandleTimeout: time.Second&#125;)<br>        <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>        err := client.Call(context.Background(), <span class="hljs-string">&quot;ServiceTemp.Timeout&quot;</span>, <span class="hljs-number">20</span>, &amp;reply) <span class="hljs-comment">// 调用 ServiceTemp.Timeout 方法，服务端处理超时</span><br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;handle timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            client_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient_dialTimeout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    t.Parallel() <span class="hljs-comment">// 设置测试项并行执行</span><br><br>    f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>        _ = conn.Close()<br>        time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 模拟了一个没有错误的客户端连接</span><br>    &#125;<br><br>    l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br><br>    <span class="hljs-comment">// 测试客户端连接有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;connect timeout&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)<br>        _assert(err != <span class="hljs-literal">nil</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;connect timeout&quot;</span>), <span class="hljs-string">&quot;expect a timeout error&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 测试客户端连接没有超时处理的情况</span><br>    t.Run(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>        _, err := dialTimeout(f, <span class="hljs-string">&quot;tcp&quot;</span>, l.Addr().String(), &amp;Option&#123;ConnectTimeout: <span class="hljs-number">0</span>&#125;)<br>        _assert(err == <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;0 means no limit&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="5-支持-HTTP-协议">5.支持 HTTP 协议</h2><h3 id="什么是支持-HTTP-协议">什么是支持 HTTP 协议</h3><p>当前我们 RPC 框架是基于 TCP 协议的。通过监听端口，建立 TCP socket 连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br>l, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9999&quot;</span>)    <span class="hljs-comment">// 使用 TCP 协议</span><br>geerpc.Accept(l)  <span class="hljs-comment">// 等待建立连接</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，客户端只能通过建立 socket 连接与服务端通信。如果支持了 HTTP 协议是什么样子呢？</p><p>用户在浏览器访问 <code>http://ip:port/xxx</code> 就可以访问服务端的服务。</p><h3 id="为什么需要支持-HTTP-协议">为什么需要支持 HTTP 协议</h3><ul><li>兼容性：很多应用是基于 HTTP 协议的，RPC 框架支持 HTTP，便于兼容。</li><li>方便调试：通过 HTTP 提供调试界面，可以实时监控RPC服务的状态和调用统计，方便开发和运维。</li><li>安全性：HTTP 可以和 TLS/SSL 结合，提供安全的通信方式。</li></ul><h3 id="如何支持-HTTP-协议">如何支持 HTTP 协议</h3><p>这一块非常关键，决定你是否真正理解服务端这块的核心逻辑。（为了便于理解，我尽可以使用冗余的语言来描述）</p><ol><li>首先要明确需求，我们支持 HTTP 协议，并不是要用 HTTP 替换掉之前的 TCP socket 的连接方式，而是要兼容二者。</li><li>其次要明确原理，HTTP 协议是基于 TCP 协议的，HTTP 是应用层协议，TCP 是传输层协议。HTTP 是在 TCP 上的一层封装。</li></ol><p>所以，需要兼容二者，我既需要完成 HTTP 请求和响应，又需要拿到底层的 TCP socket 连接。 该怎么做呢？</p><p>对于 HTTP 请求和响应，</p><ul><li>客户端：客户端通过 <code>net.DialTimeout</code> 建立 TCP 连接，得到 <code>net.Conn</code> ，然后通过 <code>net.Conn</code> 向 RPC 服务器，发送 HTTP  CONNECT 请求，并接收 HTTP 响应，确认连接成功。</li><li>服务端：对于 HTTP 请求的监听，我们很熟悉，在  <a href="https://www.aimtao.net/7days-web/#%E5%A6%82%E4%BD%95%E6%8E%A5%E7%AE%A1-HTTP-%E8%AF%B7%E6%B1%82">如何接管 HTTP 请求</a> 中介绍过，我们的 Server 只需要实现 <code>ServeHTTP(ResponseWriter, *Request)</code> 方法就可以实现 <code>Handler </code> 接口，最后用 <code>http.Handle()</code> 方法将 Server 注册到对应的路由上，Server 就可以接管部分 HTTP 请求了（细节后面再讨论）。</li></ul><p>对于 TCP 连接，</p><ul><li><p>客户端：无需额外做什么，使用 <code>net.DialTimeout</code> 建立的已经就是 TCP 连接。</p></li><li><p>服务端：</p><ul><li><p>在之前我们是通过 <code>net.Listen()</code> 监听端口、 <code>net.Listener.Accept()</code> 阻塞等待连接完成的，最关键的是最后每个连接都返回一个 <code>net.Conn</code> 用来传输数据，这是建立的 TCP 连接。</p></li><li><p>现在是监听 TCP 端口，并启动 HTTP 服务器，服务端只能响应 HTTP 请求，无法获得 TCP 连接。</p></li><li><p>既然 HTTP 是基于 TCP 封装的，那 HTTP 请求能否拿到底层 TCP 的 <code>net.Conn</code> 呢？如果可以拿到，我们就可以根据请求类型，来选择是响应 HTTP 请求，还是建立  TCP 连接。</p></li><li><p>答案是当然可以拿到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *response)</span></span> Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>最后梳理一下，基于通信流程梳理需要做哪些事情：</p><ol><li>服务端监听端口，并启动 HTTP 服务器。</li><li>客户端 Dial 建立 TCP 连接，获得 <code>net.conn</code>，并向 RPC 服务器，发送 HTTP  CONNECT 方法请求</li><li>服务端响应 HTTP  CONNECT 方法请求，并通过 <code>Hijack</code> 劫持 HTTP 底层的 TCP 连接。</li><li>客户端使用建立的连接，发送 RPC 报文（先发送 option，再发送 RPC 报文）</li><li>服务端处理 RPC 请求，并同时可以响应 HTTP 请求。</li></ol><h3 id="服务端支持-HTTP-协议">服务端支持 HTTP 协议</h3><p>实现 ServeHTTP 函数接管 <code>/_geeprc_</code> 路由的 HTTP 请求处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>)<br><br><span class="hljs-comment">// Server 实现 ServeHTTP，并使用 http.Handle 注册到对应路由中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> r.Method != <span class="hljs-string">&quot;CONNECT&quot;</span> &#123; <span class="hljs-comment">// &quot;/_geeprc_&quot; 理由地址只响应 CONNECT 请求</span><br>        w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>)<br>        w.WriteHeader(http.StatusMethodNotAllowed)<br>        _, _ = io.WriteString(w, <span class="hljs-string">&quot;405 must CONNECT\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从 HTTP 请求中，劫持底层的 TCP 连接</span><br>    conn, _, err := w.(http.Hijacker).Hijack()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;rpc hijacking &quot;</span>, r.RemoteAddr, <span class="hljs-string">&quot;: &quot;</span>, err.Error())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, _ = io.WriteString(conn, <span class="hljs-string">&quot;HTTP/1.0 &quot;</span>+connected+<span class="hljs-string">&quot;\n\n&quot;</span>)<br>    server.ServeConn(conn) <span class="hljs-comment">// 处理 TCP 连接的 RPC 报文</span><br>&#125;<br><br><span class="hljs-comment">// HandleHTTP 将 Server 注册到  defaultRPCPath 路由上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server) <span class="hljs-comment">// 使用 Server.ServeHTTP 方法处理 defaultRPCPath 路由</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHTTP</span><span class="hljs-params">()</span></span> &#123;<br>    DefaultServer.HandleHTTP()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户如何启动-HTTP-服务">用户如何启动 HTTP 服务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    geerpc.HandleHTTP() <span class="hljs-comment">// 注册静态路由</span><br>    addr &lt;- l.Addr().String()<br>    _ = http.Serve(l, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 启动 HTTP 服务，不使用 accpet</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端支持-HTTP-协议">客户端支持 HTTP 协议</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>   <span class="hljs-comment">//...</span><br>   conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>   <span class="hljs-comment">//...</span><br>   client, err = f(conn, opt)<br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 dialTimeout 过程中，先会获得了一个 TCP 连接 <code>net.conn</code>，原本的逻辑调会用 NewClient，利用该连接，生成一个 Client 使用。</p><p>但是现在服务端想同时响应 HTTP 请求和TCP 连接，服务端只启动 HTTP 服务，不进行 Accpet，所以需要利用该 TCP 连接，向服务端发送一条 HTTP 请求，让服务端有机会从 HTTP 请求中，拿到底层的 TCP 连接。</p><p>什么时候发送呢？在 NewClient 之前。发送请求并接收响应后，再正常调用 NewClient 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-comment">// NewHTTPClient 做所的事，就是在 NewClient 之前，向 conn 发送一条 HTTP 请求 “CONNECT /_geeprc_ HTTP/1.0”，并获得响应</span><br><span class="hljs-comment">// 服务端 收到这条 HTTP CONNECT 请求后，会做出回复，并拿到 HTTP 底层的 conn 连接。所以服务器可以响应 HTTP 请求，又可以通过 conn 这个 tcp socket 通信</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    _, _ = io.WriteString(conn, fmt.Sprintf(<span class="hljs-string">&quot;CONNECT %s HTTP/1.0\n\n&quot;</span>, defaultRPCPath))<br><br>    response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;) <span class="hljs-comment">// 读取服务端响应</span><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; response.Status == connected &#123;<br>        <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;unexpected HTTP response: &quot;</span> + response.Status)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>为了用户更方便的调用，为 NewHTTPClient 封装两个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialHTTP</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewHTTPClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">XDial</span><span class="hljs-params">(rpcAddr <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    parts := strings.Split(rpcAddr, <span class="hljs-string">&quot;@&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client err: wrong format &#x27;%s&#x27;, expect protocol@addr&quot;</span>, rpcAddr)<br>    &#125;<br>    protocol, addr := parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">switch</span> protocol &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;http&quot;</span>:<br>        <span class="hljs-keyword">return</span> DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, addr, opts...)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// tcp, unix or other transport protocol</span><br>        <span class="hljs-keyword">return</span> Dial(protocol, addr, opts...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户如何使用客户端">用户如何使用客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(addrCh <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    client, _ := geerpc.DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addrCh)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(context.Background(), <span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些问题">一些问题</h3><ul><li><p>客户端只想建立 TCP 连接，还需发送 HTTP  请求吗？</p><ul><li>需要的。为什么？客户端通过 Dial 就可以拿到 TCP 连接，但是这个 TCP 连接如果没有服务器 Accept，是没有办法和服务器进行通信的（这是因为什么下面会讲）。所以是否需要发送 HTTP 请求，这取决于服务端使用什么样的监听方式。</li><li><code>http.Serve(l, nil)</code> 如果服务端启动 HTTP 服务器，就需要使用 DialHTTP 方法去拨号，在这个过程中，客户端会自动帮用户发送 HTTP CONNECT 请求，服务端会通过 HTTP 劫持到底层 TCP 连接。</li><li><code>geerpc.Accept(l)</code> 如果服务端启动 TCP socket 监听，就可以直接 Dial 拨号，建立 TCP 连接。</li></ul></li><li><p>为什么通过 Dial 可以拿到 TCP 连接，服务器不 Accept 二者无法通信？</p><ul><li>TCP 连接的本质：<ul><li>内核层连接 Dial 成功 = TCP 三次握手完成</li><li>连接在内核层面进入 ESTABLISHED 状态</li><li>但应用层无法直接使用该连接</li></ul></li><li>应用层通信必备条件：<ul><li>服务端必须调用 Accept</li></ul></li><li>Accept 的作用：<ul><li>将内核连接转交应用层</li><li>创建应用层 socket</li><li>分配通信资源（缓冲区等）</li></ul></li></ul></li><li><p>为什么 <code>http.ReadResponse</code> 可以读出数据？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>bufio.NewReader(conn)</code> 创建缓冲读取器包装原始连接，读到服务端给客户端 HTTP CONNECT 请求的回复。</p></li></ul><h3 id="一个实例">一个实例</h3><p>上面这一些操作仅服务端仅实现了响应 “/<em>geeprc</em>” 路由的 CONNECT 请求。</p><p>下面实现一个用于客户端 debug 用的路由 “/debug/geerpc”。</p><p>（1）创建 debugHTTP，结构体中嵌入 Server。</p><p>为什么要嵌入：这样 debugHTTP 就可以拿到 Server 实例里的方法名和方法的调用次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// debug.go</span><br><br><span class="hljs-keyword">type</span> debugHTTP <span class="hljs-keyword">struct</span> &#123;<br>    *Server<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）实现 debugHTTP 的 ServeHTTP，来处理 HTTP 请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// debug.go</span><br><br><span class="hljs-keyword">const</span> debugText = <span class="hljs-string">`&lt;html&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;title&gt;GeeRPC Services&lt;/title&gt;</span><br><span class="hljs-string">    &#123;&#123;range .&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">    Service &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">        &lt;table&gt;</span><br><span class="hljs-string">        &lt;th align=center&gt;Method&lt;/th&gt;&lt;th align=center&gt;Calls&lt;/th&gt;</span><br><span class="hljs-string">        &#123;&#123;range $name, $mtype := .Method&#125;&#125;</span><br><span class="hljs-string">            &lt;tr&gt;</span><br><span class="hljs-string">            &lt;td align=left font=fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td align=center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;/tr&gt;</span><br><span class="hljs-string">        &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">        &lt;/table&gt;</span><br><span class="hljs-string">    &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;`</span><br><br><span class="hljs-keyword">var</span> debug = template.Must(template.New(<span class="hljs-string">&quot;RPC debug&quot;</span>).Parse(debugText))<br><br><span class="hljs-keyword">type</span> debugService <span class="hljs-keyword">struct</span> &#123;<br>    Name   <span class="hljs-type">string</span><br>    Method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType<br>&#125;<br><br><span class="hljs-comment">// Runs at /debug/geerpc</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server debugHTTP)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    <span class="hljs-comment">// Build a sorted version of the data.</span><br>    <span class="hljs-keyword">var</span> services []debugService<br>    server.serviceMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namei, svci <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>        svc := svci.(*service)<br>        services = <span class="hljs-built_in">append</span>(services, debugService&#123;<br>            Name:   namei.(<span class="hljs-type">string</span>),<br>            Method: svc.method,<br>        &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>    err := debug.Execute(w, services)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        _, _ = fmt.Fprintln(w, <span class="hljs-string">&quot;rpc: error executing template:&quot;</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）注册静态路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>    defaultDebugPath = <span class="hljs-string">&quot;/debug/geerpc&quot;</span>  <span class="hljs-comment">// debug 的路由地址</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server)<br>    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)  <span class="hljs-comment">// 注册 debug 路由</span><br>    log.Println(<span class="hljs-string">&quot;rpc server debug path:&quot;</span>, defaultDebugPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）在 main.go 执行后，可以访问目标端口的“/debug/geerpc”，可以看到各个方法被远程调用了多少次。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Service Foo<br>-------------------------------<br><span class="hljs-keyword">Method</span>                        <span class="hljs-title function_">Calls</span><br><span class="hljs-title function_">Sum</span><span class="hljs-params">(main.Args, *int)</span> <span class="hljs-title function_">error</span>    5<br></code></pre></td></tr></table></figure><h3 id="完整代码-5">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_5_http<br>├── client.go  <span class="hljs-comment"># 改动：增加 DialHTTP 方法（发送 HTTP CONNECT 请求）</span><br>├── client_test.go <span class="hljs-comment"># 新增：增加测试 XDial 的测试</span><br>├── codec<br>│   ├── codec.go<br>│   └── gob.go<br>├── debug.go  <span class="hljs-comment"># 新增：增加 debugHTTP，并接管部分请求</span><br>├── go.mod<br>├── main<br>│   └── main.go  <span class="hljs-comment"># 改动：服务端使用 HTTP 服务器，客户端使用 DialHTTP 拨号</span><br>├── server.go  <span class="hljs-comment"># 改动：ServeHTTP 接管 HTTP 请求，使用 HTTP 请求劫持 TCP 连接</span><br>├── service.go<br>└── service_test.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            client.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Call 实例表示一次 RPC 调用请求</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>    Seq           <span class="hljs-type">uint64</span>      <span class="hljs-comment">// 请求的序号</span><br>    ServiceMethod <span class="hljs-type">string</span>      <span class="hljs-comment">// 请求的方法名</span><br>    Args          <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的参数</span><br>    Reply         <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 请求的响应信息</span><br>    Error         <span class="hljs-type">error</span><br>    Done          <span class="hljs-keyword">chan</span> *Call <span class="hljs-comment">// 当调用结束后，会通过 Done 通知调用者  // 这个写法有意思，channel 的类型是 *Call</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(call *Call)</span></span> done() &#123;<br>    call.Done &lt;- call<br>&#125;<br><br><span class="hljs-comment">// Client 表示一个 RPC 客户端，一个客户端可以完成多个请求（Call 实例）的发送和接收</span><br><span class="hljs-comment">// 管理连接、请求和响应，可同时被多个协程并发使用</span><br><span class="hljs-comment">// 提供 Dial 方法，用于建立连接；提供 Call 方法，用于发送请求并等待响应结果</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    cc       codec.Codec      <span class="hljs-comment">// 消息编解码器，用于序列化请求和反序列化响应</span><br>    opt      *Option          <span class="hljs-comment">// 客户端配置，比如编码方式和协议参数。</span><br>    sending  sync.Mutex       <span class="hljs-comment">// 互斥锁，用于确保在同一时间只有一个请求被发送</span><br>    header   codec.Header     <span class="hljs-comment">// 每个请求，共用这个同一消息头</span><br>    mu       sync.Mutex       <span class="hljs-comment">// 互斥锁，保护 pending 和 shutdown 字段，防止并发读写</span><br>    seq      <span class="hljs-type">uint64</span>           <span class="hljs-comment">// 用于给每个请求分配一个编号，用于区分不同的请求。（每个请求间没有顺序要求）</span><br>    pending  <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call <span class="hljs-comment">// 每个请求对应一个 Call 实例。未处理的请求会被保存在该字段中</span><br>    closing  <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否正在关闭连接</span><br>    shutdown <span class="hljs-type">bool</span>             <span class="hljs-comment">// 客户端是否已经关闭</span><br>&#125;<br><br><span class="hljs-keyword">var</span> ErrShutdown = errors.New(<span class="hljs-string">&quot;client has been shut down&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Close() <span class="hljs-type">error</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing &#123;<br>        <span class="hljs-keyword">return</span> ErrShutdown<br>    &#125;<br>    client.closing = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> client.cc.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> IsAvailable() <span class="hljs-type">bool</span> &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br>    <span class="hljs-keyword">return</span> !client.shutdown &amp;&amp; !client.closing<br>&#125;<br><br><span class="hljs-comment">// registerCall 方法用于注册一个 Call 实例，并返回该实例的序号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> registerCall(call *Call) (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> client.closing || client.shutdown &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrShutdown<br>    &#125;<br><br>    call.Seq = client.seq<br>    client.pending[call.Seq] = call<br>    client.seq++<br>    <span class="hljs-keyword">return</span> call.Seq, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// removeCall 方法用于从 pending 中移除一个 Call 实例，表示该请求已处理完成或已取消，并返回该实例。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> removeCall(seq <span class="hljs-type">uint64</span>) *Call &#123;<br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    call := client.pending[seq]<br>    <span class="hljs-built_in">delete</span>(client.pending, seq)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// terminateCalls 方法用于在客户端关闭时，终止所有未完成的调用，并通知调用者发生了错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> terminateCalls(err <span class="hljs-type">error</span>) &#123;<br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    client.mu.Lock()<br>    <span class="hljs-keyword">defer</span> client.mu.Unlock()<br><br>    client.shutdown = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> client.pending &#123;<br>        call.Error = err<br>        call.done()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> receive() &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-keyword">for</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这个写法，会在 err 不为 nil 时退出循环，所以只会处理一次错误</span><br>        <span class="hljs-comment">// 读取请求头</span><br>        <span class="hljs-keyword">var</span> h codec.Header<br>        <span class="hljs-keyword">if</span> err = client.cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据 h.Seq 找到对应的 Call 实例，并从 pending 中移除。</span><br>        call := client.removeCall(h.Seq)<br><br>        <span class="hljs-comment">// 三种处理响应的情况</span><br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> call == <span class="hljs-literal">nil</span>: <span class="hljs-comment">// Call 实例不存在，（可能客户端已经取消请求，但服务器还是在响应请求），忽略该请求</span><br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">case</span> h.Error != <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-comment">// Call 实例存在，但服务器返回了错误</span><br>            <span class="hljs-comment">// 将错误信息写入 call.Error 中，调用 call.done() 通知调用方</span><br>            call.Error = fmt.Errorf(h.Error)<br>            err = client.cc.ReadBody(<span class="hljs-literal">nil</span>)<br>            call.done()<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// Call 实例存在，服务器正常响应</span><br>            <span class="hljs-comment">// 读取响应体，将响应信息写入 call.Reply 中，调用 call.done() 通知调用方</span><br>            err = client.cc.ReadBody(call.Reply)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                call.Error = errors.New(<span class="hljs-string">&quot;reading body &quot;</span> + err.Error())<br>            &#125;<br>            call.done()<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果发生错误（如连接断开），调用 terminateCalls 方法： 将所有未完成的调用（pending 中的所有调用）标记为错误状态。通知所有调用方，释放资源。</span><br>    client.terminateCalls(err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 用 JSON 数据通知服务器，客户端的编码方式</span><br>    <span class="hljs-comment">// json.NewEncoder(conn) 创建一个 JSON Encoder 对象，Encode 方法将 opt 编码为 JSON 数据， JSON Encoder 对象将 Json 数据写入到 conn 中，也就是发给服务器</span><br>    <span class="hljs-keyword">if</span> err := json.NewEncoder(conn).Encode(opt); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc client: options error: &quot;</span>, err)<br>        _ = conn.Close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    newCodecFunc := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> newCodecFunc == <span class="hljs-literal">nil</span> &#123;<br>        err := fmt.Errorf(<span class="hljs-string">&quot;invalid codec type %s&quot;</span>, opt.CodecType)<br>        log.Println(<span class="hljs-string">&quot;rpc client: codec error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> newClientCodec(newCodecFunc(conn), opt), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClientCodec</span><span class="hljs-params">(cc codec.Codec, opt *Option)</span></span> *Client &#123;<br>    client := &amp;Client&#123;<br>        seq:     <span class="hljs-number">1</span>, <span class="hljs-comment">// seq starts with 1, 0 means invalid call</span><br>        cc:      cc,<br>        opt:     opt,<br>        pending: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]*Call),<br>    &#125;<br>    <span class="hljs-keyword">go</span> client.receive()<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseOptions</span><span class="hljs-params">(opts ...*Option)</span></span> (*Option, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// if opts is nil or pass nil as parameter</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) == <span class="hljs-number">0</span> || opts[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> DefaultOption, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(opts) != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;number of options is more than 1&quot;</span>)<br>    &#125;<br>    opt := opts[<span class="hljs-number">0</span>]<br>    opt.MagicNumber = DefaultOption.MagicNumber<br>    <span class="hljs-keyword">if</span> opt.CodecType == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        opt.CodecType = DefaultOption.CodecType<br>    &#125;<br>    <span class="hljs-keyword">return</span> opt, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NewClientFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-keyword">type</span> dialResult <span class="hljs-keyword">struct</span> &#123;<br>    client *Client<br>    err    <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dialTimeout</span><span class="hljs-params">(f NewClientFunc, network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (client *Client, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 默认使用 Gob 编码</span><br>    opt, err := parseOptions(opts...)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 声明一个通道，用于传输拨号建立连接的结果</span><br>    result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dialResult, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-comment">// 当发生错误时，保证 client 为 nil</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            client = <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 启动一个 goroutine 连接服务器，连接成功后，调用 f 创建 Client 实例，并将结果发送到 result 通道中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        conn, err := net.DialTimeout(network, address, opt.ConnectTimeout)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            result &lt;- dialResult&#123;client: <span class="hljs-literal">nil</span>, err: err&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        client, err = f(conn, opt)<br>        result &lt;- dialResult&#123;client: client, err: err&#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 如果超时时间为 0，表示没限制，直接等待 result 通道返回结果</span><br>    <span class="hljs-keyword">if</span> opt.ConnectTimeout == <span class="hljs-number">0</span> &#123;<br>        result := &lt;-result<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br><br>    <span class="hljs-comment">// 超时处理，阻塞等待，等待超时或收到结果</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(opt.ConnectTimeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client: connect timeout: %v&quot;</span>, opt.ConnectTimeout)<br>    <span class="hljs-keyword">case</span> result := &lt;-result:<br>        <span class="hljs-keyword">return</span> result.client, result.err<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// send 发送请求到服务器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> send(call *Call) &#123;<br>    <span class="hljs-comment">// make sure that the client will send a complete request</span><br>    client.sending.Lock()<br>    <span class="hljs-keyword">defer</span> client.sending.Unlock()<br><br>    <span class="hljs-comment">// register this call.</span><br>    seq, err := client.registerCall(call)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        call.Error = err<br>        call.done()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// prepare request header</span><br>    client.header.ServiceMethod = call.ServiceMethod<br>    client.header.Seq = seq<br>    client.header.Error = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment">// encode and send the request</span><br>    <span class="hljs-keyword">if</span> err := client.cc.Write(&amp;client.header, call.Args); err != <span class="hljs-literal">nil</span> &#123;<br>        call := client.removeCall(seq)<br>        <span class="hljs-comment">// call 可能为 nil</span><br>        <span class="hljs-comment">// 比如由于网络或者某种错误，客户端在 receive() 中已经将该请求从 pending 中移除，此时 call 为 nil</span><br>        <span class="hljs-keyword">if</span> call != <span class="hljs-literal">nil</span> &#123;<br>            call.Error = err<br>            call.done()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Go 异步调用，不阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Go(serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;, done <span class="hljs-keyword">chan</span> *Call) *Call &#123;<br>    <span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>        done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">10</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span>(done) == <span class="hljs-number">0</span> &#123;<br>        log.Panic(<span class="hljs-string">&quot;rpc client: done channel is unbuffered&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 为本次调用请求创建一个 Call 实例</span><br>    call := &amp;Call&#123;<br>        ServiceMethod: serviceMethod,<br>        Args:          args,<br>        Reply:         reply,<br>        Done:          done,<br>    &#125;<br><br>    <span class="hljs-comment">// 将 Call 实例发送到客户端</span><br>    client.send(call)<br>    <span class="hljs-keyword">return</span> call<br>&#125;<br><br><span class="hljs-comment">// Call 同步调用，阻塞等待响应结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(client *Client)</span></span> Call(ctx context.Context, serviceMethod <span class="hljs-type">string</span>, args, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    call := client.Go(serviceMethod, args, reply, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Call, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment">// 等待响应结果/超时</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        client.removeCall(call.Seq)<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc client: call failed: &quot;</span> + ctx.Err().Error())<br>    <span class="hljs-keyword">case</span> call := &lt;-call.Done:<br>        <span class="hljs-keyword">return</span> call.Error<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// NewHTTPClient 做所的事，就是在 NewClient 前面，向 conn 发送一条 HTTP 请求 “CONNECT /_geeprc_ HTTP/1.0”，并获得响应</span><br><span class="hljs-comment">// 服务端 收到这条 HTTP CONNECT 请求后，会做出回复，并拿到 HTTP 底层的 conn 连接。所以服务器可以响应 HTTP 请求，又可以通过 conn 这个 tcp socket 通信</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPClient</span><span class="hljs-params">(conn net.Conn, opt *Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    _, _ = io.WriteString(conn, fmt.Sprintf(<span class="hljs-string">&quot;CONNECT %s HTTP/1.0\n\n&quot;</span>, defaultRPCPath))<br><br>    response, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="hljs-string">&quot;CONNECT&quot;</span>&#125;) <span class="hljs-comment">// 读取服务端响应</span><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; response.Status == connected &#123;<br>        <span class="hljs-keyword">return</span> NewClient(conn, opt)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;unexpected HTTP response: &quot;</span> + response.Status)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialHTTP</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> dialTimeout(NewHTTPClient, network, address, opts...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">XDial</span><span class="hljs-params">(rpcAddr <span class="hljs-type">string</span>, opts ...*Option)</span></span> (*Client, <span class="hljs-type">error</span>) &#123;<br>    parts := strings.Split(rpcAddr, <span class="hljs-string">&quot;@&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;rpc client err: wrong format &#x27;%s&#x27;, expect protocol@addr&quot;</span>, rpcAddr)<br>    &#125;<br>    protocol, addr := parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">switch</span> protocol &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;http&quot;</span>:<br>        <span class="hljs-keyword">return</span> DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, addr, opts...)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// tcp, unix or other transport protocol</span><br>        <span class="hljs-keyword">return</span> Dial(protocol, addr, opts...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            server.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geerpc/codec&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MagicNumber = <span class="hljs-number">0x3bef5c</span><br><br><span class="hljs-comment">// Option 定义 Option 结构体，封装了 MagicNumber 和 CodecType 字段，从 conn 中解析出 Option 的信息，表示 RPC 消息的编码方式</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>    MagicNumber    <span class="hljs-type">int</span><br>    CodecType      codec.Type<br>    ConnectTimeout time.Duration <span class="hljs-comment">// Client 建立连接的超时时间</span><br>    HandleTimeout  time.Duration <span class="hljs-comment">// Client.Call() 整个过程的超时时间</span><br>&#125;<br><br><span class="hljs-comment">// Server 定义 Server 结构体，封装了 Accept、ServeConn、serveCodec 方法</span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>    serviceMap sync.Map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>    <span class="hljs-keyword">return</span> &amp;Server&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Accept 处理连接：建立 socket 连接，使用 goroutine 处理连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Accept(lis net.Listener) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := lis.Accept() <span class="hljs-comment">// 建立 socket 连接</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: accept error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> server.ServeConn(conn) <span class="hljs-comment">// 使用 goroutine 处理连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ServeConn 处理消息：解析出 Option 信息，根据 CodecType 选择对应的 codec，调用 serveCodec 方法处理剩下的消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser) &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = conn.Close()<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> opt Option<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(conn).Decode(&amp;opt); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// opt 是传出参数，读到 RPC 前面的 JSON 数据，这包含了 option 信息，表示 RPC 消息的编码方式</span><br>        log.Println(<span class="hljs-string">&quot;rpc server: options error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> opt.MagicNumber != MagicNumber &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid magic number %x&quot;</span>, opt.MagicNumber)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    f := codec.NewCodecFuncMap[opt.CodecType]<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>        log.Printf(<span class="hljs-string">&quot;rpc server: invalid codec type %s&quot;</span>, opt.CodecType)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    server.serveCodec(f(conn), &amp;opt)<br>&#125;<br><br><span class="hljs-comment">// serveCodec 处理请求：调用 readRequest 方法读取请求，调用 handleRequest 方法处理请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> serveCodec(cc codec.Codec, opt *Option) &#123;<br>    sending := <span class="hljs-built_in">new</span>(sync.Mutex)<br>    wg := <span class="hljs-built_in">new</span>(sync.WaitGroup)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        req, err := server.readRequest(cc)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)<br>    &#125;<br>    wg.Wait()<br>    _ = cc.Close()<br>&#125;<br><br><span class="hljs-comment">// request 表示一次调用的所有信息</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    h            *codec.Header <span class="hljs-comment">// 请求头</span><br>    svc          *service      <span class="hljs-comment">// 请求对应的服务，使用 svc.call 调用对应的方法</span><br>    mtype        *methodType   <span class="hljs-comment">// 请求对应的方法，是 svc.call 的第一个参数</span><br>    argv, replyv reflect.Value <span class="hljs-comment">// 方法的传入参数和传出参数，是 svc.call 的第二个和第三个参数</span><br>&#125;<br><br><span class="hljs-comment">// readRequest 读取请求：调用 readRequestHeader 方法读取请求头，调用 ReadBody 方法读取请求参数，返回 request 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequest(cc codec.Codec) (*request, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 读取请求头</span><br>    h, err := server.readRequestHeader(cc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化请求结构体</span><br>    req := &amp;request&#123;h: h&#125;<br><br>    <span class="hljs-comment">// 根据请求头中的 ServiceMethod 字段找到对应的服务和方法类型</span><br>    req.svc, req.mtype, err = server.findService(h.ServiceMethod)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br><br>    <span class="hljs-comment">// 创建传入参数和传出参数的反射对象</span><br>    req.argv = req.mtype.newArgv()<br>    req.replyv = req.mtype.newReplyv()<br><br>    <span class="hljs-comment">// 检查请求传入参数的类型是否为指针类型，如果不是，则使用 Addr() 方法将 req.argv 转换为指针类型</span><br>    <span class="hljs-comment">// 为什么？</span><br>    <span class="hljs-comment">// 因为如果传入值是值类型，传入后，是值拷贝，不会修改传入变量的原值，所以需要使用 Addr() 获取地址后传入。</span><br>    argvi := req.argv.Interface() <span class="hljs-comment">// 使用 interface() 方法将 req.argv 转换为 interface&#123;&#125; 类型，这样可以传入任意类型的参数</span><br>    <span class="hljs-keyword">if</span> req.argv.Type().Kind() != reflect.Ptr &#123;<br>        argvi = req.argv.Addr().Interface()<br>    &#125;<br><br>    <span class="hljs-comment">// ReadBody 方法会将请求参数解码到 argvi 中储存</span><br>    <span class="hljs-keyword">if</span> err = cc.ReadBody(argvi); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: read body err:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> req, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// readRequestHeader 读取请求头：调用 ReadHeader 方法读取请求头，返回请求头结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> readRequestHeader(cc codec.Codec) (*codec.Header, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> h codec.Header<br>    <span class="hljs-keyword">if</span> err := cc.ReadHeader(&amp;h); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err != io.EOF &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) &#123;<br>            log.Println(<span class="hljs-string">&quot;rpc server: read header error: &quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;h, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// invalidRequest is a placeholder for response argv when error occurs</span><br><span class="hljs-keyword">var</span> invalidRequest = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><br><span class="hljs-comment">// handleRequest 处理请求：构造请求响应信息，调用 sendResponse 方法发送响应</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    called := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br>    sent := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)   <span class="hljs-comment">// 设置缓冲区为 1，防止在超时后，无人接收 channel 数据，导致 channel 发送时阻塞，导致 goroutine 泄漏</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        err := req.svc.call(req.mtype, req.argv, req.replyv) <span class="hljs-comment">// 调用</span><br>        called &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                                 <span class="hljs-comment">// 调用完成, 不管是否超时，继续发送数据</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            req.h.Error = err.Error()<br>            server.sendResponse(cc, req.h, invalidRequest, sending)<br>            sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        server.sendResponse(cc, req.h, req.replyv.Interface(), sending)<br>        sent &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">if</span> timeout == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有超时时间，直接等待</span><br>        &lt;-called<br>        &lt;-sent<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 有超时时间，使用 select 等待超时或调用完成</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        req.h.Error = fmt.Sprintf(<span class="hljs-string">&quot;rpc server: request handle timeout: expect within %s&quot;</span>, timeout)<br>        server.sendResponse(cc, req.h, invalidRequest, sending)<br>    <span class="hljs-keyword">case</span> &lt;-called: <span class="hljs-comment">// 如果调用完成，则不管超时时间，等待 sent（仅对 req.svc.call 做超时处理）</span><br>        &lt;-sent<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> sendResponse(cc codec.Codec, header *codec.Header, body <span class="hljs-keyword">interface</span>&#123;&#125;, sending *sync.Mutex) &#123;<br>    sending.Lock() <span class="hljs-comment">// 加锁，防止并发写</span><br>    <span class="hljs-keyword">defer</span> sending.Unlock()<br>    <span class="hljs-keyword">if</span> err := cc.Write(header, body); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;rpc server: write response error: &quot;</span>, err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultServer = NewServer()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> DefaultServer.Register(rcvr) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> Register(rcvr <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    s := newService(rcvr)                                        <span class="hljs-comment">// 为 rcvr 变量的类型创建 service 结构体</span><br>    <span class="hljs-keyword">if</span> _, dup := server.serviceMap.LoadOrStore(s.name, s); dup &#123; <span class="hljs-comment">// 调用 serviceMap.LoadOrStore 将 service 结构体保存到 map 中</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;rpc: service already defined: &quot;</span> + s.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> findService(serviceMethod <span class="hljs-type">string</span>) (svc *service, mtype *methodType, err <span class="hljs-type">error</span>) &#123;<br>    dot := strings.LastIndex(serviceMethod, <span class="hljs-string">&quot;.&quot;</span>)<br>    <span class="hljs-keyword">if</span> dot &lt; <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: service/method request ill-formed: &quot;</span> + serviceMethod)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    serviceName, methodName := serviceMethod[:dot], serviceMethod[dot+<span class="hljs-number">1</span>:]<br>    svci, ok := server.serviceMap.Load(serviceName)<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find service &quot;</span> + serviceName)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    svc = svci.(*service)<br>    mtype = svc.method[methodName]<br>    <span class="hljs-keyword">if</span> mtype == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;rpc server: can&#x27;t find method &quot;</span> + methodName)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> DefaultOption = &amp;Option&#123;<br>    MagicNumber:    MagicNumber,<br>    CodecType:      codec.GobType,<br>    ConnectTimeout: time.Second * <span class="hljs-number">10</span>,<br>    <span class="hljs-comment">//HandleTimeout:  time.Second * 10,  // 默认为 0，不设置超时时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Accept</span><span class="hljs-params">(lis net.Listener)</span></span> &#123;<br>    DefaultServer.Accept(lis)<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>    connected        = <span class="hljs-string">&quot;200 Connected to Gee RPC&quot;</span><br>    defaultRPCPath   = <span class="hljs-string">&quot;/_geeprc_&quot;</span><br>    defaultDebugPath = <span class="hljs-string">&quot;/debug/geerpc&quot;</span><br>)<br><br><span class="hljs-comment">// Server 实现 ServeHTTP，并使用 http.Handle 注册到对应路由中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> r.Method != <span class="hljs-string">&quot;CONNECT&quot;</span> &#123; <span class="hljs-comment">// &quot;/_geeprc_&quot; 理由地址只响应 CONNECT 请求</span><br>        w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>)<br>        w.WriteHeader(http.StatusMethodNotAllowed)<br>        _, _ = io.WriteString(w, <span class="hljs-string">&quot;405 must CONNECT\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从 HTTP 请求中，劫持底层的 TCP 连接</span><br>    conn, _, err := w.(http.Hijacker).Hijack()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;rpc hijacking &quot;</span>, r.RemoteAddr, <span class="hljs-string">&quot;: &quot;</span>, err.Error())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, _ = io.WriteString(conn, <span class="hljs-string">&quot;HTTP/1.0 &quot;</span>+connected+<span class="hljs-string">&quot;\n\n&quot;</span>)<br>    server.ServeConn(conn) <span class="hljs-comment">// 处理 TCP 连接的 RPC 报文</span><br>&#125;<br><br><span class="hljs-comment">// HandleHTTP 将 Server 注册到  defaultRPCPath 路由上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server *Server)</span></span> HandleHTTP() &#123;<br>    http.Handle(defaultRPCPath, server) <span class="hljs-comment">// 使用 Server.ServeHTTP 方法处理 defaultRPCPath 路由</span><br>    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)<br>    log.Println(<span class="hljs-string">&quot;rpc server debug path:&quot;</span>, defaultDebugPath)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHTTP</span><span class="hljs-params">()</span></span> &#123;<br>    DefaultServer.HandleHTTP()<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            debug.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geerpc<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> debugText = <span class="hljs-string">`&lt;html&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">    &lt;title&gt;GeeRPC Services&lt;/title&gt;</span><br><span class="hljs-string">    &#123;&#123;range .&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">    Service &#123;&#123;.Name&#125;&#125;</span><br><span class="hljs-string">    &lt;hr&gt;</span><br><span class="hljs-string">        &lt;table&gt;</span><br><span class="hljs-string">        &lt;th align=center&gt;Method&lt;/th&gt;&lt;th align=center&gt;Calls&lt;/th&gt;</span><br><span class="hljs-string">        &#123;&#123;range $name, $mtype := .Method&#125;&#125;</span><br><span class="hljs-string">            &lt;tr&gt;</span><br><span class="hljs-string">            &lt;td align=left font=fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td align=center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;/tr&gt;</span><br><span class="hljs-string">        &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">        &lt;/table&gt;</span><br><span class="hljs-string">    &#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;`</span><br><br><span class="hljs-keyword">var</span> debug = template.Must(template.New(<span class="hljs-string">&quot;RPC debug&quot;</span>).Parse(debugText))<br><br><span class="hljs-keyword">type</span> debugHTTP <span class="hljs-keyword">struct</span> &#123;<br>    *Server<br>&#125;<br><span class="hljs-keyword">type</span> debugService <span class="hljs-keyword">struct</span> &#123;<br>    Name   <span class="hljs-type">string</span><br>    Method <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*methodType<br>&#125;<br><br><span class="hljs-comment">// Runs at /debug/geerpc</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(server debugHTTP)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    <span class="hljs-comment">// Build a sorted version of the data.</span><br>    <span class="hljs-keyword">var</span> services []debugService<br>    server.serviceMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namei, svci <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>        svc := svci.(*service)<br>        services = <span class="hljs-built_in">append</span>(services, debugService&#123;<br>            Name:   namei.(<span class="hljs-type">string</span>),<br>            Method: svc.method,<br>        &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>    err := debug.Execute(w, services)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        _, _ = fmt.Fprintln(w, <span class="hljs-string">&quot;rpc: error executing template:&quot;</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;geerpc&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int</span> <span class="hljs-comment">// Foo 类型，实现了 Sum 方法</span><br><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">struct</span>&#123; Num1, Num2 <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foo)</span></span> Sum(args Args, reply *<span class="hljs-type">int</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = args.Num1 + args.Num2<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(addr <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> foo Foo                                   <span class="hljs-comment">// 实例化 Foo 类型的对象</span><br>    <span class="hljs-keyword">if</span> err := geerpc.Register(&amp;foo); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 注册 Foo 类型的对象，注册的是 Foo 类型的对象，不是 Foo 类型的方法</span><br>        log.Fatal(<span class="hljs-string">&quot;register error:&quot;</span>, err)<br>    &#125;<br><br>    l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:0&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;network error:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;start rpc server on&quot;</span>, l.Addr())<br>    geerpc.HandleHTTP() <span class="hljs-comment">// 注册静态路由</span><br>    addr &lt;- l.Addr().String()<br>    _ = http.Serve(l, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 启动 HTTP 服务，不使用 accpet</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(addrCh <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    client, _ := geerpc.DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, &lt;-addrCh)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = client.Close() &#125;()<br><br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// send request &amp; receive response</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            args := &amp;Args&#123;Num1: i, Num2: i * i&#125;<br>            <span class="hljs-keyword">var</span> reply <span class="hljs-type">int</span><br>            <span class="hljs-keyword">if</span> err := client.Call(context.Background(), <span class="hljs-string">&quot;Foo.Sum&quot;</span>, args, &amp;reply); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;call Foo.Sum error:&quot;</span>, err)<br>            &#125;<br>            log.Printf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, args.Num1, args.Num2, reply)<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    log.SetFlags(<span class="hljs-number">0</span>)<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> call(ch)<br>    startServer(ch)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">从零实现标准库 net/rpc，新增了协议交换、注册中心、服务发现、负载均衡、超时处理等特性。</summary>
    
    
    
    <category term="Implement From Scratch" scheme="https://www.aimtao.net/categories/Implement-From-Scratch/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="RPC" scheme="https://www.aimtao.net/tags/RPC/"/>
    
    <category term="Framework" scheme="https://www.aimtao.net/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中返回含锁对象的风险</title>
    <link href="https://www.aimtao.net/copy-lock-value/"/>
    <id>https://www.aimtao.net/copy-lock-value/</id>
    <published>2023-10-06T05:06:00.000Z</published>
    <updated>2023-10-06T05:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个报错引起的思考。</p><span id="more"></span><h2 id="1-问题">1.问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ModelToResponse</span><span class="hljs-params">(user model.User)</span></span> proto.UserInfoResponse &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> userInfoRsp<br>&#125;<br></code></pre></td></tr></table></figure><p>在实现以上代码时，Goland 有以下 Warning 信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Return copies the lock value: <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;proto.UserInfoResponse&#x27;</span> contains <span class="hljs-string">&#x27;protoimpl.MessageState&#x27;</span> contains <span class="hljs-string">&#x27;sync.Mutex&#x27;</span> <span class="hljs-built_in">which</span> is <span class="hljs-string">&#x27;sync.Locker&#x27;</span><br></code></pre></td></tr></table></figure><p>虽然不处理可以正常运行，但是本着学习的态度一探究竟。</p><h2 id="2-原因">2.原因</h2><p><code>UserInfoResponse.protoimpl.MessageState</code> 包含锁 <code>sync.Mutex</code>。为了保障并发安全，不建议直接通过值传递的方式返回含锁对象，而应该使用指针传递的方式。比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ModelToResponse</span><span class="hljs-params">(user model.User)</span></span> *proto.UserInfoResponse &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> &amp;userInfoRsp<br>&#125;<br></code></pre></td></tr></table></figure><p>具体原因是：值拷贝过程中，也会复制锁（也就是存在两把锁），对于同一临界资源，两个协程分别使用两把锁起不到互斥作用。</p><h2 id="3-分析">3.分析</h2><p>下面以一个例来具体分析：S 中含有一个指针和一个锁，使用锁可以保障指针指向内存的并发安全。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    p     *<span class="hljs-type">int</span><br>    mutex sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewS</span><span class="hljs-params">()</span></span> S &#123;<br>    a := <span class="hljs-number">0</span><br>    A := S&#123;p: &amp;a&#125;<br>    <span class="hljs-keyword">return</span> A<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    A := NewS()<br>    B := A<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>            A.mutex.Lock()<br>            *A.p++<br>            A.mutex.Unlock()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>            B.mutex.Lock()<br>            *B.p++<br>            B.mutex.Unlock()<br>        &#125;<br>    &#125;()<br><br>    time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>    fmt.Println(*A.p, *B.p)  <span class="hljs-comment">// 结果小于 20000</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个份代码会报两个 warning，分别是第 17 行 <code>return A</code> 和第 22 行 <code>B := A</code> 两个地方，报错意思是一样的，均不建议使用值传递的方式拷贝带锁的对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">line 17:Return copies the lock value: <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;S&#x27;</span> contains <span class="hljs-string">&#x27;sync.Mutex&#x27;</span> <span class="hljs-built_in">which</span> is <span class="hljs-string">&#x27;sync.Locker&#x27;</span><br>line 22:Variable declaration copies a lock value to <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;S&#x27;</span> contains <span class="hljs-string">&#x27;sync.Mutex&#x27;</span> <span class="hljs-built_in">which</span> is <span class="hljs-string">&#x27;sync.Locker&#x27;</span><br></code></pre></td></tr></table></figure><p>以上述代码为例，由于是值传递，对象中的锁也会被拷贝，<code>A.Mutex</code> 和 <code>B.Mutex</code> 是两个不同的锁，而 <code>A.p</code> 和 <code>B.p</code> 是指向同一块内存，对于这块内存，两把锁无法起到互斥作用。</p><p>所以，这块内存的数据 a，在两个 goroutine 中一共进行 20000 次加法之后，结果仍小于 20000。</p><h2 id="4-修正">4.修正</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewS</span><span class="hljs-params">()</span></span> *S &#123;<br>    a := <span class="hljs-number">0</span><br>    A := S&#123;p: &amp;a&#125;<br>    <span class="hljs-keyword">return</span> &amp;A<br>&#125;<br></code></pre></td></tr></table></figure><p>只需改为指针传递即可。这样 <code>A.Mutex</code> 和 <code>B.Mutex</code> 是同一把锁，在并发场景下，对于 a 的加锁是有效的。</p><p>最后加法后的结果为 20000。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个报错引起的思考。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://www.aimtao.net/categories/Coding/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="Mutex" scheme="https://www.aimtao.net/tags/Mutex/"/>
    
  </entry>
  
  <entry>
    <title>从零实现系列｜分布式缓存</title>
    <link href="https://www.aimtao.net/7days-cache/"/>
    <id>https://www.aimtao.net/7days-cache/</id>
    <published>2023-05-12T16:24:00.000Z</published>
    <updated>2023-05-12T16:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文逐步实现了一个分布式缓存系统，涵盖LRU缓存淘汰策略、单机并发控制、HTTP服务接口及一致性哈希算法。通过封装缓存值、互斥锁机制和虚拟节点映射，解决了并发安全、节点负载均衡等核心问题，构建了支持分布式部署的缓存框架。</p><p>通过回答关键问题的方式，记录阅读 <a href="https://geektutu.com/post/geecache.html">geeCache</a> 代码过程中的思考，并做出补充和改进，重点在“怎么做”的基础上，补充“为什么这么做”等逻辑。</p><h2 id="0-序言">0.序言</h2><h3 id="为什么需要-cache">为什么需要 cache</h3><ul><li>优化性能：将耗时操作的结果储存起来，下次需要请求，直接使用，避免重复耗时操作。</li><li>降低延迟：静态资源缓存（CDN/浏览器缓存），提高访问速度。</li><li>转移负载：将高频访问的数据，从数据库迁移到内存中，降低后端压力。</li><li>高并发支撑：通过内存级的响应能力支持大规模的并发请求，避免数据库被击穿。</li></ul><h3 id="cache-要解决哪些问题">cache 要解决哪些问题</h3><ul><li>怎么存储？维护一个键值对缓存，实现 O(1) 的存取速度。</li><li>内存不够？实现一种缓存的淘汰策略。</li><li>并发冲突？对缓存的修改，实现并发保护。</li><li>单机性能差？实现可以横向扩展的分布式缓存。<ul><li>分布式缓存存在多个节点，节点间如何通信？需要支持 HTTP、protobuf。</li><li>如何用 O(1) 的速度找到 cache 对应的节点？使用一致性哈希来选择节点，实现负载均衡。</li></ul></li></ul><h2 id="1-缓存淘汰策略">1.缓存淘汰策略</h2><h3 id="介绍三种常见的缓存淘汰算法">介绍三种常见的缓存淘汰算法</h3><p>缓存储存在内存中，内存是有限的，对于没用的数据就需要移出。三种常见的缓存淘汰算法。</p><p><strong>FIFO（First In First Out）</strong></p><ul><li>新进先出，按照时间顺序，优先淘汰最早添加的数据。</li><li>实现：维护一个先进先出队列，新数据插入队尾，淘汰时移除队首数据。</li><li>缺点：无法感知访问频率，即使高频访问的数据，若进入缓存较早仍会被淘汰，可能导致缓存命中率下降。</li></ul><p><strong>LFU（Least Frequently Used）</strong></p><ul><li>最少使用，按照访问频率，优先淘汰访问次数最少的数据。</li><li>实现：维护一个按照访问次数排序的最小堆/双层链表。每次访问，访问次数+1，重新排序。淘汰时，直接淘汰队首访问次数最少的即可。</li><li>优点：缓存命中率高。</li><li>缺点：<ul><li>维护成本高：每次访问都需要更新计数，并重新排序。</li><li>受历史数据影响大：早期高频但后期失效的数据（比如过时的热点新闻）难以被淘汰。（解决：定期衰减历史计数。）</li></ul></li></ul><p><strong>LRU（Least Recently Used）</strong></p><ul><li>基于时间局部性原理，认为最近被访问过的，更有可能被再次访问。那么最近没使用过的数据，就是要淘汰的数据。</li><li>实现：维护一个队列，某个数据被访问，就将数据移至队尾，这样队首则是最近最少被访问的数据。</li><li>优点：FIFO 考虑时间因素，LFU 考虑访问频率，LRU 既考虑时间，也考虑频次（多次访问，意味着多次被移到队尾）。</li></ul><h3 id="如何设计-cache">如何设计 cache</h3><p><strong>cache 数据结构设计思路</strong></p><ul><li><p>使用哈希表和双向链表，来实现 LRU 淘汰策略的缓存。</p><ul><li>哈希表：通过 key 可以 O(1) 的复杂度获取 value</li><li>双向链表：维护访问顺序，最近访问的节点移动到链表头部，队尾节点是“最近最少使用”的数据，即将被淘汰的数据。</li></ul></li><li><p>value 储存在 entry 的结构体中。每个 entry 结构体都是双向链表上的一个节点。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/lru/lru.go</span><br><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>    maxBytes  <span class="hljs-type">int64</span>                         <span class="hljs-comment">// 最大的内存</span><br>    nBytes    <span class="hljs-type">int64</span>                            <span class="hljs-comment">// 已经被用作缓存的内存</span><br>    ll        *list.List                             <span class="hljs-comment">// 双向链表</span><br>    cache     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element              <span class="hljs-comment">// 用 map 查找链表的节点</span><br>    OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 删除缓存节点的回调函数</span><br>&#125;<br><br><span class="hljs-comment">// 链表节点的数据类型</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>    key   <span class="hljs-type">string</span> <span class="hljs-comment">// 保存 key，删除链表缓存时，便于同步删除 map 中的 k/v 记录</span><br>    value Value  <span class="hljs-comment">// 真正的缓存数据，允许 Value 是任何类型</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;<br>    Len() <span class="hljs-type">int</span> <span class="hljs-comment">// Len() 表示该数据的内存大小, 添加数据前,应该手动实现该数据类型的 Len 函数</span><br>&#125;<br><br><span class="hljs-comment">// 初始化 cache</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(maxBytes <span class="hljs-type">int64</span>, onEvicted <span class="hljs-keyword">func</span>(key <span class="hljs-type">string</span>, value Value)</span></span>) *Cache &#123;<br>    <span class="hljs-keyword">return</span> &amp;Cache&#123;<br>        maxBytes:  maxBytes,<br>        ll:        list.New(),<br>        cache:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element),<br>        OnEvicted: onEvicted,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么-value-不直接放在链表里，要放在-entry-结构体里">为什么 value 不直接放在链表里，要放在 entry 结构体里</h3><ul><li>淘汰缓存时，可以直接从 entry 结构体中拿到 key，用来删除哈希表中的映射。</li></ul><h3 id="为什么要新建一个-Value-接口类型，并包含-Len-方法">为什么要新建一个 Value 接口类型，并包含 <code>Len</code> 方法</h3><ul><li>缓存的数据可以什么格式都有，用接口变量储存最好，即 <code>interface&#123;&#125;</code>。</li><li>因为整个 cache 是有大小的，所有有需要查询所有缓存数据的大小。所以在 <code>interface&#123;&#125;</code> 中增加一个 <code>Len</code>方法，只有实现了这个方法的变量，才能作为接口类型 Value 的变量储存在 cache 中。</li><li>下面举个例子，如歌 entry 的 value 变量需要储存 String  变量，String 需要主动实现 Len 方法，也就是实现 Value 接口。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> String <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s String)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现-cache-增删改查">如何实现 cache 增删改查</h3><p><strong>增加</strong></p><ul><li>检查是否存在，存在即更新，不存在则增加缓存</li><li>维护缓存大小，超过最大值需要淘汰缓存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/lru/lru.go</span><br><br><span class="hljs-comment">// Add 增加缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<br>    <span class="hljs-keyword">if</span> _, ok := c.cache[key]; ok &#123;<br>        c.Update(key, value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)<br>        c.cache[key] = ele<br>        c.nBytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())<br>        <span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;<br>            c.RemoveOldest()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><ul><li>链表删除尾部节点，map 删除 key，更新 cache 总体大小，调用回调函数（回调函数是初始化时传入的）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/lru/lru.go</span><br><br><span class="hljs-comment">// RemoveOldest 删除链表尾部的缓存数据</span><br><span class="hljs-comment">// 用户并不需要调用，Add/Update时，可用空间不够，才会删除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;<br>    ele := c.ll.Back()<br>    <span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;<br>        c.ll.Remove(ele)<br>        kv := ele.Value.(*entry) <span class="hljs-comment">// 先获取链表节点的 Value 字段，类型是 any，并转化为 *entry 类型</span><br>        <span class="hljs-built_in">delete</span>(c.cache, kv.key)<br>        c.nBytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len())<br>        <span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;<br>            c.OnEvicted(kv.key, kv.value)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改</strong></p><ul><li>查询是否存在，将节点移至首部（表示频率），更新 cache 总体大小，更新节点的缓存值。</li><li>注意：更新缓存还需要看缓存是否超过最大容量，如果超过需要淘汰缓存，下面代码暂时不写这个逻辑了。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/lru/lru.go</span><br><br><span class="hljs-comment">// Update 更新缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Update(key <span class="hljs-type">string</span>, value Value) &#123;<br>    <span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>        c.ll.MoveToFront(ele)<br>        kv := ele.Value.(*entry)<br>        c.nBytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())<br>        kv.value = value<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        c.Add(key, value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查询</strong></p><ul><li>查询是否存在，将节点移至首部（表示频率），返回节点的缓存值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/lru/lru.go</span><br><br><span class="hljs-comment">// Get 获取缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>        c.ll.MoveToFront(ele)<br>        kv := ele.Value.(*entry)<br>        <span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ele-Value-entry-的写法"><code>ele.Value.(*entry)</code> 的写法</h3><ul><li>ele 是 *list.Element 类型的变量，表示链表的一个节点。Element 变量中有 Value 变量，Value 变量类型是 any。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// container/list/list.go</span><br><br><span class="hljs-keyword">package</span> list<br><br><span class="hljs-comment">// Element is an element of a linked list.</span><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Next and previous pointers in the doubly-linked list of elements.</span><br>    <span class="hljs-comment">// To simplify the implementation, internally a list l is implemented</span><br>    <span class="hljs-comment">// as a ring, such that &amp;l.root is both the next element of the last</span><br>    <span class="hljs-comment">// list element (l.Back()) and the previous element of the first list</span><br>    <span class="hljs-comment">// element (l.Front()).</span><br>    next, prev *Element<br><br>    <span class="hljs-comment">// The list to which this element belongs.</span><br>    list *List<br><br>    <span class="hljs-comment">// The value stored with this element.</span><br>    Value any<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Element.Value 变量中存储的，实际上是我们的 entry 类型的结构体变量的指针。</li><li>这里写法是断言，将 any 类型的 Element.Value 变量还原为  *entry 类型变量。</li></ul><h3 id="完整代码">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">version_1_LRU[geecache]<br>├── go.mod<br>└── lru<br>    ├── lru.go<br>    └── lru_test.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            lru/lru.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>    maxBytes  <span class="hljs-type">int64</span>                         <span class="hljs-comment">// 最大的内存</span><br>    nBytes    <span class="hljs-type">int64</span>                         <span class="hljs-comment">// 已经被用作缓存的内存</span><br>    ll        *list.List                    <span class="hljs-comment">// 双向链表</span><br>    cache     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element      <span class="hljs-comment">// 用 map 查找链表的节点</span><br>    OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 删除缓存节点的回调函数</span><br>&#125;<br><br><span class="hljs-comment">// 链表节点的数据类型</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>    key   <span class="hljs-type">string</span> <span class="hljs-comment">// 保存 key，删除链表缓存时，便于同步删除 map 中的 k/v 记录</span><br>    value Value  <span class="hljs-comment">// 真正的缓存数据，允许 Value 是任何类型</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;<br>    Len() <span class="hljs-type">int</span> <span class="hljs-comment">// Len() 表示该数据的内存大小, 添加数据前,应该手动实现该数据类型的 Len 函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(maxBytes <span class="hljs-type">int64</span>, onEvicted <span class="hljs-keyword">func</span>(key <span class="hljs-type">string</span>, value Value)</span></span>) *Cache &#123;<br>    <span class="hljs-keyword">return</span> &amp;Cache&#123;<br>        maxBytes:  maxBytes,<br>        ll:        list.New(),<br>        cache:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element),<br>        OnEvicted: onEvicted,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Add 增加缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<br>    <span class="hljs-keyword">if</span> _, ok := c.cache[key]; ok &#123;<br>        c.Update(key, value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)<br>        c.cache[key] = ele<br>        c.nBytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())<br>        <span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nBytes &#123;<br>            c.RemoveOldest()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// RemoveOldest 删除链表尾部的缓存数据</span><br><span class="hljs-comment">// 用户并不需要调用，Add/Update时，可用空间不够，才会删除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;<br>    ele := c.ll.Back()<br>    <span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;<br>        c.ll.Remove(ele)<br>        kv := ele.Value.(*entry) <span class="hljs-comment">// 先获取链表节点的 Value 字段，类型是 any，并转化为 *entry 类型</span><br>        <span class="hljs-built_in">delete</span>(c.cache, kv.key)<br>        c.nBytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len())<br>        <span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;<br>            c.OnEvicted(kv.key, kv.value)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Update 更新缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Update(key <span class="hljs-type">string</span>, value Value) &#123;<br>    <span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>        c.ll.MoveToFront(ele)<br>        kv := ele.Value.(*entry)<br>        c.nBytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())<br>        kv.value = value<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        c.Add(key, value)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Get 获取缓存数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>        c.ll.MoveToFront(ele)<br>        kv := ele.Value.(*entry)<br>        <span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Len 获取缓存数据的条数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> c.ll.Len()<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            lru/lru_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-comment">// 对于数据类型，需要进行封装，因为无法在原生类型 string 中添加 Len 方法</span><br><span class="hljs-keyword">type</span> String <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s String)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><br><span class="hljs-comment">// TestFunction 测试增删改查基本功能</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunction</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    lru := New(<span class="hljs-type">int64</span>(<span class="hljs-number">10</span>), <span class="hljs-literal">nil</span>)<br><br>    lru.Add(<span class="hljs-string">&quot;k1&quot;</span>, String(<span class="hljs-string">&quot;1234&quot;</span>))<br>    fmt.Println(lru.Get(<span class="hljs-string">&quot;k1&quot;</span>))<br><br>    lru.RemoveOldest()<br>    fmt.Println(lru.Get(<span class="hljs-string">&quot;k1&quot;</span>))<br><br>    lru.Update(<span class="hljs-string">&quot;k2&quot;</span>, String(<span class="hljs-string">&quot;123&quot;</span>))<br>    fmt.Println(lru.Get(<span class="hljs-string">&quot;k2&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// TestAutoRemoveOldest 测试当使用内存超过 maxBytes，是否会触发 “无用” 节点的删除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAutoRemoveOldest</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    testData := []<span class="hljs-keyword">struct</span> &#123;<br>        key   <span class="hljs-type">string</span><br>        value Value<br>    &#125;&#123;<br>        &#123;<span class="hljs-string">&quot;k1&quot;</span>, String(<span class="hljs-string">&quot;1234567890&quot;</span>)&#125;,<br>        &#123;<span class="hljs-string">&quot;k2&quot;</span>, String(<span class="hljs-string">&quot;234567890&quot;</span>)&#125;,<br>        &#123;<span class="hljs-string">&quot;k3&quot;</span>, String(<span class="hljs-string">&quot;34567890&quot;</span>)&#125;,<br>    &#125;<br><br>    lru := New(<span class="hljs-type">int64</span>(<span class="hljs-number">10</span>), <span class="hljs-literal">nil</span>)<br><br>    <span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> testData &#123;<br>        lru.Add(test.key, test.value)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> testData &#123;<br>        fmt.Println(lru.Get(test.key))<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// TestCallbackOnEvicted 测试删除缓存时回调函数是否能被调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCallbackOnEvicted</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    keys := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    lru := New(<span class="hljs-number">10</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> &#123;<br>        keys = <span class="hljs-built_in">append</span>(keys, key)<br>    &#125;)<br>    lru.Add(<span class="hljs-string">&quot;k1&quot;</span>, String(<span class="hljs-string">&quot;k1&quot;</span>))<br>    lru.Add(<span class="hljs-string">&quot;k2&quot;</span>, String(<span class="hljs-string">&quot;k2&quot;</span>))<br>    lru.Add(<span class="hljs-string">&quot;k3&quot;</span>, String(<span class="hljs-string">&quot;k3&quot;</span>))<br>    lru.Add(<span class="hljs-string">&quot;k4&quot;</span>, String(<span class="hljs-string">&quot;k4&quot;</span>))<br><br>    fmt.Println(keys)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="2-单机并发缓存">2.单机并发缓存</h2><h3 id="如何设计并发安全的-cache">如何设计并发安全的  cache</h3><p>主要做两件事：加锁 + 保证数据不可变性</p><p><strong>对互斥操作进行加锁</strong></p><ul><li>在 <code>lru.Cache</code> 的基础上，封装一个 cache 结构体，将 <code>lru.Cache</code> 的操作都加互斥锁。（注意不能是读写锁，因为读数据，也要移动链表节点）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/cache.go</span><br><br><span class="hljs-comment">// 为什么要封装 cache？</span><br><span class="hljs-comment">// 加锁，保证对 lru.Cache 的并发安全</span><br><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br>    mu         sync.Mutex<br>    lru        *lru.Cache<br>    cacheBytes <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-comment">// add 并发安全地添加缓存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> add(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<br>        c.lru = lru.New(c.cacheBytes, <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// 懒加载，延迟初始化 lru.Cache</span><br>    &#125;<br>    c.lru.Add(key, value)<br>&#125;<br><br><span class="hljs-comment">// get 并发安全地获取缓存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> get(key <span class="hljs-type">string</span>) (value ByteView, ok <span class="hljs-type">bool</span>) &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> v, ok := c.lru.Get(key); ok &#123;<br>        <span class="hljs-keyword">return</span> v.(ByteView), ok<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>保证数据不可变性</strong>（只读）</p><ul><li>上面代码中，无论是 add 还是 get 操作的数据类型都是 <code>ByteView</code>，也就是说，缓存的类型被规定成了 <code>ByteView</code>，这是为什么呢？</li><li>其实就是为了保证数据的不可变性， <code>ByteView</code> 的定义如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/byteview.go</span><br><br><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">type</span> ByteView <span class="hljs-keyword">struct</span> &#123;<br>    b []<span class="hljs-type">byte</span> <span class="hljs-comment">// slice</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// ByteView 实现 lru.Value 接口</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(byteView.b)<br>&#125;<br><br><span class="hljs-comment">// 为什么 ByteSlice 要返回拷贝？</span><br><span class="hljs-comment">// 防止缓存值被外部修改，这里直接返回拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> ByteSlice() []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">return</span> cloneBytes(byteView.b) <span class="hljs-comment">// 为什么不直接使用 make，要封装 cloneBytes 函数</span><br>&#125;<br><br><span class="hljs-comment">// 为什么需要 cloneBytes ?</span><br><span class="hljs-comment">// 因为 []byte 是切片，传递时，不会深拷贝，传递的是视图，底层数据会被外界修改</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cloneBytes</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<br>    <span class="hljs-built_in">copy</span>(c, b)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(byteView.b)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要抽象 <code>ByteView</code> 数据类型来表示缓存值？</strong></p><ol><li>在 lru 中定义的 <code>entry.value</code>  是 Value 接口类型，所有传入的数据的类型均需要实现这个接口，也就是实现 <code>Len</code> 函数，比较麻烦。<code>[]byte</code> 可以支持任何数据类型的存储，并为 <code>[]byte</code> 抽象为 <code>ByteView</code> 类型，并实现 <code>lru.Value</code> 接口。</li><li>保证 <code>ByteView</code> 是只读类型。如何保证？<ul><li><code>ByteView</code> 的变量只有一个 <code>b</code>，<code>b</code> 是小写，外部无法直接读取。</li><li>只能通过 <code>ByteSlice</code> 和 <code>String</code> 方法获取 <code>b</code> 的数据<ul><li><code>ByteSlice</code> 返回 slice 时，会拷贝一个副本再返回</li><li>String 将 b 的数据强制转换为 String。（外界也无法直接修改 b 的值）</li></ul></li></ul></li></ol><h3 id="为什么-get-操作也要加锁">为什么 get 操作也要加锁</h3><p>想象两个场景：</p><ol><li>cache 在 add 函数中，初始化 <code>lru.Cache</code> 的过程是懒加载，<code>lru.Cache</code> 初始化过程中，还为初始化完，如果这时候访问 Get，会导致空指针的情况。</li><li><code>lru.cache</code> 在写数据时，需要移动节点到首部，如果这时候去访问，会同时移动链表节点到首部，会造成链表断裂，节点丢失。</li></ol><p>也就是说，需要保证 <code>lru.cache</code> 初始化的原子性，以及 <code>lru.cache</code> 内部操作的原子性。</p><h3 id="为什么要延迟初始化（Lazy-Initialization）">为什么要延迟初始化（Lazy Initialization）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/cache.go</span><br><br><span class="hljs-comment">// add 并发安全地添加缓存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> add(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<br>        c.lru = lru.New(c.cacheBytes, <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// 懒加载，延迟初始化 lru.Cache</span><br>    &#125;<br>    c.lru.Add(key, value)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>节省内存：只有使用时才初始化，没使用不初始化。</li><li>减少初始化 cache 时的开销，加块整个程序的冷启动速度。</li></ul><h3 id="为什么要设计-Group">为什么要设计 Group</h3><p>在使用 cache 对 <code>lru.Cache</code> 进行封装后，又使用 Group 对 cache 进行了封装。这是为什么呢？</p><p>其实站在使用者的角度，只有一个并发安全的 cache，会存在很多问题没法解决：</p><ul><li>不同的数据因为大小、有效期等不同，需要放到不同的 cache 实例中，如何标识不同的 cache 实例呢？需要一个名字/ID。</li><li>当前机器没有找到的数据，需要访问其他分布式节点或者回源（可能是多种数据源）。这个过程如何统一呢？</li></ul><p>为此，我们使用分层设计的思想，再封装一层，<code>cache</code> 负责并发存储，<code>Group</code> 负责业务逻辑。</p><p>有哪些业务逻辑？</p><ul><li>为 cache 实例标识一个命名空间。</li><li>为 cache 实例提供回源方法的接口。</li><li>注：还可以在 group 中，针对 cache 实例增加各种缓存策略。</li></ul><h3 id="如何设计-Group">如何设计 Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span> <span class="hljs-comment">// 一个 Group 是一个命名空间，并有唯一的 name。比如可以创建多个 Group，储存不同类别的信息。</span><br>    getter    Getter <span class="hljs-comment">// 当缓存未命中时，可以调用 Getter.Get 这个回调函数获取值，并储存在缓存中。</span><br>    mainCache cache  <span class="hljs-comment">// 并发安全的缓存</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    groupMu sync.RWMutex  <span class="hljs-comment">// 全局读写锁</span><br>    groups  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group)  <span class="hljs-comment">// 全局缓存组注册表</span><br>)<br></code></pre></td></tr></table></figure><p><strong>通过 groups 进行全局管理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<br>    <span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)<br>    &#125;<br><br>    groupMu.Lock()<br>    <span class="hljs-keyword">defer</span> groupMu.Unlock()<br><br>    g := &amp;Group&#123;<br>        name:      name,<br>        getter:    getter,<br>        mainCache: cache&#123;cacheBytes: cacheBytes&#125;,<br>    &#125;<br>    groups[name] = g<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;<br>    groupMu.RLock() <span class="hljs-comment">// 为什么是读锁？保证写操作的原子性</span><br>    g := groups[name]<br>    groupMu.RUnlock()<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>统一管理缓存回源逻辑</strong></p><p>首先是回源接口，</p><ul><li>Group 只要获取不到数据，都通过 <code>group.getter.Get</code> 来回源。但是数据源数据有很多，可能是文件，可能是数据库。所以需要抽象一个接口。</li><li>只要实现了 Get 方法，都可以作为 Getter 接口类型变量，供 group 回源时调用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-comment">// Getter 用于从各类的外部数据源获取数据</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>    Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc 为了便于使用者传入匿名函数到 Getter 中</span><br><span class="hljs-comment">// 使用时，只需将匿名函数转化为 GetterFunc 类型，即可传入 Getter</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> f(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>有了回源接口，需要实现 group.Get 的逻辑，参考这个流程图。</p><pre><code class=" mermaid">graph LR    A[接收 key] --&gt; B[是否被缓存?]    B --&gt;|是| C[返回缓存值-步骤1]    B --&gt;|否| D[是否应从远程节点获取?]    D --&gt;|是| E[与远程节点交互]    E --&gt; F[返回缓存值-步骤2]    D --&gt;|否| G[调用回调函数]    G --&gt; H[获取值并添加到缓存]    H --&gt; I[返回缓存值-步骤3]</code></pre><ul><li>Get 完成步骤1</li><li>load + getLocally 完成步骤3</li><li>步骤二在第5章节《分布式节点》中实现。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;<br>        log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<br>        <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 缓存没有命中，就从其他数据源中获取</span><br>    <span class="hljs-keyword">return</span> g.load(key)<br>&#125;<br><br><span class="hljs-comment">// 当缓存不存在，Get -&gt; load -&gt; getLocally 获取数据</span><br><span class="hljs-comment">// 为什么不直接使用 getLocally，还要封装一个 load ？</span><br><span class="hljs-comment">// load 会先从 远程分布式节点获取，获取不到才会使用 getLocally。此处属于预留设计。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> g.getLocally(key)<br>&#125;<br><br><span class="hljs-comment">// getLocally 调用用户的回调函数 g.getter.Get，获取数据，并使用 populateCache 添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := g.getter.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    value := ByteView&#123;cloneBytes(bytes)&#125;<br>    g.populateCache(key, value)<br>    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// populateCache 将获取到的数据添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    g.mainCache.add(key, value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-2">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">version_2_singal_node[geecache]<br>├── geecache<br>│   ├── byteview.go  <span class="hljs-comment"># 缓存值的抽象与封装</span><br>│   ├── cache.go  <span class="hljs-comment"># 并发控制</span><br>│   ├── geecache.go  <span class="hljs-comment"># 负责与用户交互，并拥有从外部数据源获取缓存并存储的功能</span><br>│   ├── geecache_test.go<br>│   └── lru<br>│       ├── lru.go<br>│       └── lru_test.go<br>└── go.mod<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            byteview.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-comment">// 为什么要抽象 ByteView 数据类型来表示缓存值？</span><br><span class="hljs-comment">/* 1. 在 lru 中定义的 entry.value  是 Value 接口类型，所有传入的数据的类型均需要实现这个接口，也就是实现 Len 函数，比较麻烦。</span><br><span class="hljs-comment">      []byte 可以支持任何数据类型的存储，并为 []byte 抽象为 ByteView 类型，并实现 lru.Value 接口。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   2. 保证 ByteView 是只读类型</span><br><span class="hljs-comment">      如何保证？</span><br><span class="hljs-comment">      1. b 是小写，外部无法直接读取。</span><br><span class="hljs-comment">      2. 只能通过 ByteSlice 和 String 方法获取 b 的数据</span><br><span class="hljs-comment">        1.ByteSlice 返回 slice 时，会拷贝一个副本再返回</span><br><span class="hljs-comment">        2.String 将 b 的数据强制转换为 String。（外界也无法直接修改 b 的值）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">type</span> ByteView <span class="hljs-keyword">struct</span> &#123;<br>    b []<span class="hljs-type">byte</span> <span class="hljs-comment">// slice</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// ByteView 实现 lru.Value 接口</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(byteView.b)<br>&#125;<br><br><span class="hljs-comment">// 为什么要返回拷贝？</span><br><span class="hljs-comment">// 防止缓存值被外部修改，这里直接返回拷贝</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> ByteSlice() []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">return</span> cloneBytes(byteView.b) <span class="hljs-comment">// 为什么不直接使用 make，要封装 cloneBytes 函数？方便 cloneBytes 复用</span><br>&#125;<br><br><span class="hljs-comment">// 为什么需要 cloneBytes ?</span><br><span class="hljs-comment">// 因为 []byte 是切片，传递时，不会深拷贝，传递的是视图，底层数据会被外界修改</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cloneBytes</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<br>    <span class="hljs-built_in">copy</span>(c, b)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(byteView ByteView)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(byteView.b)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            cache.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/lru&quot;</span><br>)<br><br><span class="hljs-comment">// 为什么要封装 cache？</span><br><span class="hljs-comment">// 加锁，保证对 lru.Cache 的并发安全</span><br><br><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br>    mu         sync.Mutex<br>    lru        *lru.Cache<br>    cacheBytes <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> add(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<br>        c.lru = lru.New(c.cacheBytes, <span class="hljs-literal">nil</span>)<br>    &#125;<br>    c.lru.Add(key, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> get(key <span class="hljs-type">string</span>) (value ByteView, ok <span class="hljs-type">bool</span>) &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> v, ok := c.lru.Get(key); ok &#123;<br>        <span class="hljs-keyword">return</span> v.(ByteView), ok<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Getter 用于从各类的外部数据源获取数据</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>    Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc 为了便于使用者传入匿名函数到 Getter 中</span><br><span class="hljs-comment">// 使用时，只需将匿名函数转化为 GetterFunc 类型，即可传入 Getter</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> f(key)<br>&#125;<br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span> <span class="hljs-comment">// 一个 Group 是一个命名空间，并有唯一的 name。比如可以创建多个 Group，储存不同类别的信息。</span><br>    getter    Getter <span class="hljs-comment">// 当缓存未命中时，可以调用 Getter.Get 这个回调函数获取值，并储存在缓存中。</span><br>    mainCache cache  <span class="hljs-comment">// 并发安全的缓存</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    groupMu sync.RWMutex<br>    groups  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<br>    <span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)<br>    &#125;<br><br>    groupMu.Lock()<br>    <span class="hljs-keyword">defer</span> groupMu.Unlock()<br><br>    g := &amp;Group&#123;<br>        name:      name,<br>        getter:    getter,<br>        mainCache: cache&#123;cacheBytes: cacheBytes&#125;,<br>    &#125;<br>    groups[name] = g<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;<br>    groupMu.RLock() <span class="hljs-comment">// 为什么是读锁？</span><br>    g := groups[name]<br>    groupMu.RUnlock()<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">                          是</span><br><span class="hljs-comment">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 (1)</span><br><span class="hljs-comment">                |  否                         是</span><br><span class="hljs-comment">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 (2)</span><br><span class="hljs-comment">                            |  否</span><br><span class="hljs-comment">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 (3)</span><br><span class="hljs-comment">Get 完成流程（1）</span><br><span class="hljs-comment">load + getLocally 完成流程(3)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;<br>        log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<br>        <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 缓存没有命中，就从其他数据源中获取</span><br>    <span class="hljs-keyword">return</span> g.load(key)<br>&#125;<br><br><span class="hljs-comment">// 当缓存不存在，Get -&gt; load -&gt; getLocally 获取数据</span><br><span class="hljs-comment">// 为什么不直接使用 getLocally，还要封装一个 load ？</span><br><span class="hljs-comment">// load 会先从 远程分布式节点获取，获取不到才会使用 getLocally。此处属于预留设计。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> g.getLocally(key)<br>&#125;<br><br><span class="hljs-comment">// getLocally 调用用户的回调函数 g.getter.Get，获取数据，并使用 populateCache 添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := g.getter.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    value := ByteView&#123;cloneBytes(bytes)&#125;<br>    g.populateCache(key, value)<br>    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// populateCache 将获取到的数据添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    g.mainCache.add(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetter</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> g Getter = GetterFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(key), <span class="hljs-literal">nil</span><br>    &#125;)<br><br>    bytes, _ := g.Get(<span class="hljs-string">&quot;key&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, bytes)<br>&#125;<br><br><span class="hljs-comment">// 外部数据源</span><br><span class="hljs-keyword">var</span> db = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span>:  <span class="hljs-string">&quot;630&quot;</span>,<br>    <span class="hljs-string">&quot;Jack&quot;</span>: <span class="hljs-string">&quot;589&quot;</span>,<br>    <span class="hljs-string">&quot;Sam&quot;</span>:  <span class="hljs-string">&quot;567&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    loadCounts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(db)) <span class="hljs-comment">// 记录加入缓存的次数</span><br><br>    gee := NewGroup(<span class="hljs-string">&quot;scores&quot;</span>, <span class="hljs-number">1024</span>, GetterFunc(<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 缓存未命中时，从其他数据源获取数据的函数</span><br>            log.Println(<span class="hljs-string">&quot;[SlowDB] search key&quot;</span>, key)<br>            <span class="hljs-keyword">if</span> v, ok := db[key]; ok &#123;<br>                <span class="hljs-keyword">if</span> _, ok := loadCounts[key]; !ok &#123;<br>                    loadCounts[key] = <span class="hljs-number">0</span><br>                &#125;<br>                loadCounts[key] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(v), <span class="hljs-literal">nil</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;%s not exist&quot;</span>, key)<br>        &#125;))<br><br>    <span class="hljs-comment">// 从缓存中查看各个 key，测试缓存从外部数据源获取数据的能力</span><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> db &#123;<br>        view, err := gee.Get(k)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>        fmt.Println(k, v, view.String())<br>    &#125;<br><br>    <span class="hljs-comment">// 对于数据源中不存在的数据的处理</span><br>    view, err := gee.Get(<span class="hljs-string">&quot;unknown&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125;<br>    fmt.Println(view.String())<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="3-HTTP-服务器">3.HTTP 服务器</h2><p>这部分比较简单，主要是启动一个 http 服务，处理 URL，获取到 group name 和 key，返回缓存查询到的结果。</p><h3 id="完整代码-3">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">version_3_http_server[geecache]<br>├── geecache<br>│   ├── byteview.go<br>│   ├── cache.go<br>│   ├── geecache.go<br>│   ├── geecache_test.go <span class="hljs-comment"># 新增 http 测试</span><br>│   ├── http.go <span class="hljs-comment"># 新增从 HTTP 服务器获取 cache</span><br>│   └── lru<br>│       ├── lru.go<br>│       └── lru_test.go<br>└── go.mod<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            http.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> BASEPATH = <span class="hljs-string">&quot;/_geecache/&quot;</span> <span class="hljs-comment">// 请求路径应该是 &quot;/&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt;&quot;</span><br><br><span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;<br>    self     <span class="hljs-type">string</span><br>    basePath <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPPool</span><span class="hljs-params">(self <span class="hljs-type">string</span>)</span></span> *HTTPPool &#123; <span class="hljs-comment">// 为什么要设置这两个字段</span><br>    <span class="hljs-keyword">return</span> &amp;HTTPPool&#123;<br>        self:     self,     <span class="hljs-comment">// 本机的IP/端口</span><br>        basePath: BASEPATH, <span class="hljs-comment">// 请求前缀，便于过滤请求</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> !strings.HasPrefix(r.URL.Path, h.basePath) &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Error path: &quot;</span> + r.URL.Path)<br>    &#125;<br><br>    h.Log(<span class="hljs-string">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)<br><br>    parts := strings.SplitN(r.URL.Path[<span class="hljs-built_in">len</span>(BASEPATH):], <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;bad request&quot;</span>, http.StatusBadRequest)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    groupName := parts[<span class="hljs-number">0</span>]<br>    key := parts[<span class="hljs-number">1</span>]<br>    group := GetGroup(groupName)<br>    <span class="hljs-keyword">if</span> group == <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    view, err := group.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    w.Write(view.ByteSlice())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Log(format <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    log.Printf(<span class="hljs-string">&quot;[Server %s] %s&quot;</span>, h.self, fmt.Sprintf(format, v...))<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache_test.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-comment">// 外部数据源</span><br><span class="hljs-keyword">var</span> db = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span>:  <span class="hljs-string">&quot;630&quot;</span>,<br>    <span class="hljs-string">&quot;Jack&quot;</span>: <span class="hljs-string">&quot;589&quot;</span>,<br>    <span class="hljs-string">&quot;Sam&quot;</span>:  <span class="hljs-string">&quot;567&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHTTP</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    NewGroup(<span class="hljs-string">&quot;scores&quot;</span>, <span class="hljs-number">1024</span>, GetterFunc(<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>            log.Println(<span class="hljs-string">&quot;[SlowDB] search key&quot;</span>, key)<br>            <span class="hljs-keyword">if</span> v, ok := db[key]; ok &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(v), <span class="hljs-literal">nil</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;%s not exist&quot;</span>, key)<br>        &#125;))<br><br>    addr := <span class="hljs-string">&quot;localhost:9999&quot;</span><br>    peers := NewHTTPPool(addr)<br>    log.Println(<span class="hljs-string">&quot;cache is running at&quot;</span>, addr)<br>    log.Fatal(http.ListenAndServe(addr, peers))<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">curl http://localhost:9999/_geecache/scores/Tom</span><br><span class="hljs-comment">curl http://localhost:9999/_geecache/scores/xxx</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">log:</span><br><span class="hljs-comment">2023/10/16 17:40:24 [Server localhost:9999] GET /_geecache/scores/Tom</span><br><span class="hljs-comment">2023/10/16 17:40:24 [SlowDB] search key Tom</span><br><span class="hljs-comment">2023/10/16 17:40:51 [Server localhost:9999] GET /_geecache/scores/567</span><br><span class="hljs-comment">2023/10/16 17:40:51 [SlowDB] search key 567</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="4-一致性哈希">4.一致性哈希</h2><h3 id="该访问哪个缓存节点">该访问哪个缓存节点</h3><ul><li>分布式缓存，也就是有多个机器，每个机器存储一部分数据。但当一个请求过来，该去哪个节点查询缓存呢？</li><li>解决：通过哈希算法对 key 进行计算，并对节点个数进行取余。这样每个 key 都会固定映射到一个节点中。</li></ul><h3 id="缓存节点数量调整怎么办">缓存节点数量调整怎么办</h3><ul><li>缓存运行过程中，如果有节点增加/减少，<code>hash(key) % N</code>，这里的 <code>N</code> 会变为 <code>N-1</code>，大部分缓存都会失效，在原来的节点中找不到，会引发缓存雪崩。</li><li>解决：一致性哈希可以解决这个问题。</li></ul><h3 id="一致性哈希是什么">一致性哈希是什么</h3><ul><li>一致性哈希是一个哈希环，通过哈希算法将 key 和节点映射到 0 到 2³²−1 的环形空间。（为什么是 2³²？因为大部分哈希计算出的值都是 32 位的，其实也可以用 64 位的，只不过 2³² 是40亿，足够应对哈希冲突了。）</li><li>每个 key 归属于顺时针找到的第一个节点。</li><li><strong>增加节点时</strong>，只有新增节点区域的 key 需要迁移至新节点。减少节点也是同理。</li></ul><p><img src="/Users/nice/Desktop/todo/add_peer.webp" srcset="/img/loading.gif" lazyload alt="add_peer"></p><h3 id="数据倾斜问题怎么处理">数据倾斜问题怎么处理</h3><ul><li>如上图左侧哈希环中，key2、key11、key27 都在节点 peer2 上，这就是数据倾斜，大部分数据储存在少部分几个节点中。</li><li>为什么会数据倾斜？因为节点在哈希环上分布不均。所以我们使用更多的虚拟节点将环划分为更小的区间，每个真实节点对应多个虚拟节点。这样就不会因为真实节点分布不均，导致的大段连续区间被单一节点垄断的问题。</li></ul><h3 id="如何实现一致性哈希">如何实现一致性哈希</h3><p>主要有三件事：构建哈希环、节点数量变化的处理、查找 key 所在节点。</p><p><strong>（1）构建哈希环</strong></p><p>哈希环就是map，</p><ul><li>支持自定义哈希函数，在初始化时，使用者传入，不传入则默认使用 crc32。</li><li>设置虚拟节点，虚拟节点个数是真实节点的 <code>replicas</code> 倍。</li><li>将所有虚拟节点有序排列，储存在数组 <code>keys</code> 里，这就是哈希环本体。</li><li>虚拟节点与真实节点的映射保存在 <code>hashMap</code> 中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Hash <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash 函数类型</span><br><br><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 一致性哈希算法的主要数据结构</span><br>    hash     Hash           <span class="hljs-comment">// 设置自定义一种哈希算法函数</span><br>    replicas <span class="hljs-type">int</span>            <span class="hljs-comment">// 虚拟节点的倍数</span><br>    keys     []<span class="hljs-type">int</span>          <span class="hljs-comment">// 哈希环，有序储存所有虚拟节点</span><br>    hashMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// 虚拟节点和真实节点的映射表，key 是虚拟节点的哈希值，value 是真实节点的名称</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(replicas <span class="hljs-type">int</span>, fn Hash)</span></span> *Map &#123;<br>    m := &amp;Map&#123;<br>        hash:     fn,<br>        replicas: replicas,<br>        hashMap:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>),<br>    &#125;<br>    <span class="hljs-keyword">if</span> m.hash == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 默认使用 crc32.ChecksumIEEE 哈希算法</span><br>        m.hash = crc32.ChecksumIEEE<br>    &#125;<br>    <span class="hljs-keyword">return</span> m<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）节点数量变化的处理</strong></p><blockquote><p>暂时不考虑已有缓存迁移的问题，仅考虑节点数量变化后，能否找到对应的真实节点。</p></blockquote><p>加入节点：</p><ul><li>加入一个真实节点，实际操作是，加入 <code>replicas</code> 个虚拟节点。</li><li>先都加入到  <code>keys</code> 中，再排序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add 在哈希环 Map.keys 中加入真实节点</span><br><span class="hljs-comment">// 节点名和虚拟节点名经过 hash 计算后得到哈希值，将哈希值加入 Map.keys 中，并排序。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Add(keys ...<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123; <span class="hljs-comment">// 对于每个真实节点，添加 m.replicas 个虚拟节点。</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.replicas; i++ &#123;<br>            hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(strconv.Itoa(i) + key))) <span class="hljs-comment">// 计算虚拟节点的 hash 值</span><br>            m.keys = <span class="hljs-built_in">append</span>(m.keys, hash)                      <span class="hljs-comment">// 虚拟节点加入环</span><br>            m.hashMap[hash] = key                              <span class="hljs-comment">// 将虚拟节点和真实节点加入映射表</span><br>        &#125;<br>    &#125;<br>    sort.Ints(m.keys) <span class="hljs-comment">// 对虚拟节点排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>删除节点：</p><ul><li>删除真实节点与虚拟节点的映射</li><li>重新构建哈希环（仅保留未被删除的哈希值）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Del 在哈希环 Map.keys 中减少真实节点对应的虚拟节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Del(keys ...<span class="hljs-type">string</span>) &#123;<br><br>    <span class="hljs-comment">// 删除真实节点与虚拟节点的映射</span><br>    <span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.replicas; i++ &#123;<br>            hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(strconv.Itoa(i) + key)))<br>            <span class="hljs-built_in">delete</span>(m.hashMap, hash)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 重新构建哈希环（仅保留未被删除的哈希值）</span><br>    <span class="hljs-keyword">var</span> newKeys []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> hash := <span class="hljs-keyword">range</span> m.hashMap &#123;<br>        newKeys = <span class="hljs-built_in">append</span>(newKeys, hash)<br>    &#125;<br>    sort.Ints(newKeys)<br>    m.keys = newKeys<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）查找 key 所在节点</strong></p><ul><li>最初的定义是，每个 key 归属于顺时针找到的第一个节点。</li><li>给定一个 hash，他归属的节点就是第一个大于等于 hash 的节点。</li><li>通过二分查找来寻找第一个大于等于 hash 的节点，注意需手动传入判断函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get 获取 key 所在节点名</span><br><span class="hljs-comment">// key 经过 hash 计算后得到哈希值，在哈希环 Map.keys 上查找最接近的节点。</span><br><span class="hljs-comment">// 例如：key 的哈希值是 10000，哈希环上找到最接近的两个节点是 8000、11000，应该存在 8000 这个节点上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Get(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.keys) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br><br>    hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(key)))<br><br>    <span class="hljs-comment">// 二分查找虚拟节点</span><br>    index := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> m.keys[i] &gt;= hash <span class="hljs-comment">// 找到第一个大于等于 hash 的节点，没有则返回 len(m.keys)</span><br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> m.hashMap[m.keys[index%<span class="hljs-built_in">len</span>(m.keys)]]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同时来了解一下，<code>sort.Search</code> 函数，二分查找，找到第一个符合条件的索引。什么条件？就是传入的函数为 true。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, n<br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        <br>        <span class="hljs-comment">// 因为i、j是int， (i+j)/2 在 i+j &gt; 2^31-1 时会溢出，先转化为无符号整型计算可以防止溢出。</span><br>        h := <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// i ≤ h &lt; j</span><br>        <span class="hljs-keyword">if</span> !f(h) &#123;<br>            i = h + <span class="hljs-number">1</span> <span class="hljs-comment">// h 不满足条件，答案在 h 的右侧。[h + 1, j)</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = h <span class="hljs-comment">// h 满足条件，答案在 h 的左侧。[i, h)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span><br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-4">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">version_4_consistent_hashing[geecache]<br>├── geecache<br>│   ├── byteview.go<br>│   ├── cache.go<br>│   ├── consistenthash<br>│   │   └── consistent_hash.go <span class="hljs-comment"># 新增一致性哈希</span><br>│   ├── geecache.go<br>│   ├── geecache_test.go<br>│   ├── http.go<br>│   └── lru<br>│       ├── lru.go<br>│       └── lru_test.go<br>└── go.mod<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            consistenthash/consistent_hash.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> consistenthash<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;hash/crc32&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">一致性哈希解决什么问题？</span><br><span class="hljs-comment">    每个数据，都会准确的分配到一个节点上。访问时，根据该数据的hash值，确定该访问哪个节点。</span><br><span class="hljs-comment">    数据倾斜问题：服务器节点过少时，会导致数据无法均匀分配在各节点上。使用虚拟节点解决。</span><br><span class="hljs-comment">    删除节点或增加节点时，只需要调整该节点的数据。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">type</span> Hash <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash 函数类型</span><br><br><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 一致性哈希算法的主要数据结构</span><br>    hash     Hash           <span class="hljs-comment">// 设置自定义一种哈希算法函数</span><br>    replicas <span class="hljs-type">int</span>            <span class="hljs-comment">// 虚拟节点的倍数</span><br>    keys     []<span class="hljs-type">int</span>          <span class="hljs-comment">// 哈希环，有序储存所有虚拟节点</span><br>    hashMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// 虚拟节点和真实节点的映射表，key 是虚拟节点的哈希值，value 是真实节点的名称</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(replicas <span class="hljs-type">int</span>, fn Hash)</span></span> *Map &#123;<br>    m := &amp;Map&#123;<br>        hash:     fn,<br>        replicas: replicas,<br>        hashMap:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>),<br>    &#125;<br>    <span class="hljs-keyword">if</span> m.hash == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 默认使用 crc32.ChecksumIEEE 哈希算法</span><br>        m.hash = crc32.ChecksumIEEE<br>    &#125;<br>    <span class="hljs-keyword">return</span> m<br>&#125;<br><br><span class="hljs-comment">// Add 在哈希环 Map.keys 中加入真实节点对应的虚拟节点</span><br><span class="hljs-comment">// 节点名和虚拟节点名经过 hash 计算后得到哈希值，将哈希值加入 Map.keys 中，并排序。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Add(keys ...<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123; <span class="hljs-comment">// 对于每个真实节点，添加 m.replicas 个虚拟节点。</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.replicas; i++ &#123;<br>            hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(strconv.Itoa(i) + key))) <span class="hljs-comment">// 计算虚拟节点的 hash 值</span><br>            m.keys = <span class="hljs-built_in">append</span>(m.keys, hash)                      <span class="hljs-comment">// 虚拟节点加入环</span><br>            m.hashMap[hash] = key                              <span class="hljs-comment">// 将虚拟节点和真实节点加入映射表</span><br>        &#125;<br>    &#125;<br>    sort.Ints(m.keys) <span class="hljs-comment">// 对虚拟节点排序</span><br>&#125;<br><br><span class="hljs-comment">// Del 在哈希环 Map.keys 中减少真实节点对应的虚拟节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Del(keys ...<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.replicas; i++ &#123;<br>            hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(strconv.Itoa(i) + key)))<br>            <span class="hljs-built_in">delete</span>(m.hashMap, hash)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> newKeys []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> hash := <span class="hljs-keyword">range</span> m.hashMap &#123;<br>        newKeys = <span class="hljs-built_in">append</span>(newKeys, hash)<br>    &#125;<br>    sort.Ints(newKeys)<br>    m.keys = newKeys<br>&#125;<br><br><span class="hljs-comment">// Get 获取 key 所在节点名</span><br><span class="hljs-comment">// key 经过 hash 计算后得到哈希值，在哈希环 Map.keys 上查找最接近的节点。</span><br><span class="hljs-comment">// 例如：key 的哈希值是 10000，哈希环上找到最接近的两个节点是 8000、11000，应该存在 8000 这个节点上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Get(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.keys) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br><br>    hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(key)))<br><br>    <span class="hljs-comment">// 二分查找虚拟节点</span><br>    index := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 这个函数的意义</span><br>        <span class="hljs-keyword">return</span> m.keys[i] &gt;= hash<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> m.hashMap[m.keys[index%<span class="hljs-built_in">len</span>(m.keys)]]<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="5-分布式节点">5.分布式节点</h2><blockquote><p>这一章节作者原文站在架构的角度自上而下描述的，看的时候未免有些疑惑，比如为什么上来要抽象两个接口。下面我会按照实用主义角度来回答，“基于什么需求，所以这么做”，以作为补充。</p></blockquote><h3 id="分布式缓存要做哪些工作">分布式缓存要做哪些工作</h3><p>整个分布式缓存，要做的工作就是实现下面这个图。</p><pre><code class=" mermaid">graph LR    A[接收 key] --&gt; B[是否被缓存?]    B --&gt;|是| C[返回缓存值-步骤1]    B --&gt;|否| D[是否应从远程节点获取?]    D --&gt;|是| E[与远程节点交互]    E --&gt; F[返回缓存值-步骤2]    D --&gt;|否| G[调用回调函数]    G --&gt; H[获取值并添加到缓存]    H --&gt; I[返回缓存值-步骤3]</code></pre><ul><li>在第二章节，我们完成了单个节点的功能：查找本地缓存（步骤1）；找不到时进行回源储存（步骤3）。</li><li>在第三章节，我们解决了单个节点如何为其他节点提供服务的问题。</li><li>在第四章节，我们解决了多个节点的情况下，查找缓存该查哪个节点的问题。</li><li>有了以上铺垫，我们该完成上图中的步骤二了：与远程节点交互，查找远程节点的数据。</li></ul><pre><code class=" mermaid">graph LR    A[接收 key] --&gt; B[是否被缓存?]    B --&gt;|是| C[返回缓存值-步骤1]    B --&gt;|否| E[使用一致性哈希选择节点,是否从远程节点获取?]    E --&gt;|是| G[HTTP 客户端访问远程节点]    G --&gt;|成功| I[返回缓存值-步骤2]    G --&gt;|失败| K[调用回调函数]    K --&gt; L[获取值并添加到缓存]    L --&gt; M[返回缓存值-步骤3]    E --&gt;|否| K</code></pre><p>补充一些步骤二的细节，如上图。</p><p><strong>站在使用者的角度，当我拿到 Group 之后，要完成步骤二，我需要哪些方法供我调用？</strong></p><ol><li>方法一：通过 Key 查找到属于哪个远程节点。</li><li>方法二：访问远程节点，获取缓存。</li><li>方法三：远程节点也没有，则调用本地的回调函数。</li></ol><p>所以 Group 声明了两个接口，PeerPicker 为 Group 提供方法一，PeerGetter 为 Group 提供方法二，方法三在原有 <code>group.load</code> 逻辑中改写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-comment">// PeerPicker 协助 Group 通过 key 选择远程节点</span><br><span class="hljs-keyword">type</span> PeerPicker <span class="hljs-keyword">interface</span> &#123;<br>    PickPeer(key <span class="hljs-type">string</span>) (peer PeerGetter, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 根据 key 选择节点 PeerGetter</span><br>&#125;<br><br><span class="hljs-comment">// PeerGetter 获取到的远程节点，协助 Group 从远程节点获取缓存值</span><br><span class="hljs-keyword">type</span> PeerGetter <span class="hljs-keyword">interface</span> &#123;<br>    Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) <span class="hljs-comment">// 获取缓存值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Group 只需要拿着口变量调用接口的方法，就可以完成整体逻辑。</p><p>至于这两个接口是谁来实现，用什么协议实现，Group 并不关心，我就规定了这几个方法，谁实现了我用谁完成。所以可能是 HTTPPool 用 HTTP 协议实现的，也可能是 HTTPPool 用 protobuf 实现的。</p><blockquote><p>就比如你是一个 leader，你有一项工作，你分为part 1、part2，你只需要说出你最终想要什么。你也不管谁来做，具体怎么做。比如张三李四说他们有能力做，那你要做的就是合并张三李四成果，向上汇报就行。</p></blockquote><p><strong>这样做有什么好处？</strong><s>领导轻松</s>。</p><ul><li>业务与实现分离，自己做自己的事情：<ul><li>Group 调用各种方法，完成业务逻辑。</li><li>HTTPPool 实现 Group 规定的两个方法。</li></ul></li><li>依赖倒置，Group 不依赖 HTTPPool，HTTPPool 变成可插拔的了，方便自定义修改。（也就是上面例子里，把张三李四换成王五，让王五来干）</li></ul><h3 id="如何实现-Group-访问远程节点的逻辑">如何实现 Group 访问远程节点的逻辑</h3><ul><li>首先将 PeerPicker 接口变量，放在 Group 结构体中，并提供注入方法，便于 Group 后续调用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span><br>    getter    Getter<br>    mainCache cache<br><br>    peers PeerPicker <span class="hljs-comment">// 用于选择远程节点</span><br>&#125;<br><br><span class="hljs-comment">// RegisterPeers 将实现了 PeerPicker 接口的变量注入到 Group 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> RegisterPeers(peers PeerPicker) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;RegisterPeerPicker called more than once&quot;</span>)<br>    &#125;<br>    g.peers = peers<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在查找缓存时，仅在 load 函数里增加去远程节点查找的逻辑。</li><li>去远程节点查找的逻辑更为简单。（就像领导直接安排张三李四干活一样）<ul><li>先调用 <code>PeerPicker.PickPeer</code> 找到远程节点，并拿到访问这个节点的客户端。</li><li>再调用 <code>PeerGetter.Get</code> 给远程节点发送请求，获取缓存值。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/geecache.go</span><br><br><span class="hljs-comment">// load: 缓存不存在时，先在远程节点中查找，未果再调用 getLocally 获取数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br><br>        <span class="hljs-comment">// 新增逻辑</span><br>        <span class="hljs-keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123; <span class="hljs-comment">// 找到 key 对应的远程节点。</span><br>            value, err := g.getFromPeer(peer, key) <span class="hljs-comment">// 在远程节点中查找</span><br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>            &#125;<br>            log.Println(<span class="hljs-string">&quot;[GeeCache] failed to get from peer&quot;</span>, err)<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> g.getLocally(key)<br>&#125;<br><br><span class="hljs-comment">// 从远程节点获取数据，传入的是 PeerGetter 接口类型，只要实现了 Get 方法，就可以传入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := peer.Get(g.name, key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;bytes&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ok，至此，Group 的工作就做完了，只管调用 <code>PeerPicker.PickPeer</code> 和 <code>PeerGetter.Get</code> 的方法，这两件事谁来干不知道，具体怎么干不知道，十分简洁优雅。</p><p>谁来完成具体的工作呢？我们把这个重任交给第三章中出现的 HTTPPool，让 HTTPPool 实现 <code>PeerPicker.PickPeer</code> 接口，用户就可以调用 RegisterPeers，把 HTTPPool 注入 Group 了。</p><p><strong>为什么是 HTTPPool 来实现？</strong></p><ul><li>统一网络通信层：第三章中 HTTPPool 主要是作为服务端，提供获取本机缓存的 HTTP 服务；那同样他也可以作为客户端，可以发送 HTTP 请求到其他节点。</li></ul><h3 id="HTTPPool-如何实现-PeerPicker-接口">HTTPPool 如何实现 PeerPicker 接口</h3><p>实现 PickPeer 方法就实现了这个接口，也就是实现通过 key 查找远程节点的功能。</p><ul><li>要查找远程节点，则需要将一致性哈希环集成到内部。</li><li>找到节点后，要可以请求访问，则需要保存各节点 IP/Port。</li></ul><h3 id="如何将一致性哈希加入-HTTPPool">如何将一致性哈希加入 HTTPPool</h3><ul><li>增加 <code>sync.Mutex</code> 锁。为什么要加锁？</li><li>增加一致哈希 peers，保存所有节点。</li><li>增加 map，将节点和节点的 ip/port 映射起来，知道访问那个 IP 去查询。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/http.go</span><br><br><span class="hljs-comment">// HTTPPool :包含服务端和客户端，服务端提供获取本机数据的 HTTP 服务，客户端提供访问其他节点的方法</span><br><span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;<br>    self     <span class="hljs-type">string</span> <span class="hljs-comment">// 当前节点的 IP/端口</span><br>    basePath <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 增加能力：设置和获取远程节点的能力</span><br>    mu          sync.Mutex<br>    peers       *consistenthash.Map    <span class="hljs-comment">// 一致性哈希</span><br>    httpGetters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter <span class="hljs-comment">// 记录每个远程节点的 httpGetter，httpGetter 包含了 baseURL</span><br>&#125;<br><br><span class="hljs-comment">// httpGetter 客户端：保存节点的 IP/Port</span><br><span class="hljs-keyword">type</span> httpGetter <span class="hljs-keyword">struct</span> &#123;<br>    baseURL <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>HTTPPool 能做的，也就是对 <code>consistenthash.Map</code> 能力进行封装，为自己所用：</p><ul><li><code>HTTPPool.Set</code> 初始化一致性哈希 peers，把所有节点都加到哈希环里，并为每个节点初始化 HTTP 客户端 httpGetter（其实就是保存了 IP/Port 而已）。</li><li><code>HTTPPool.PickPeer</code> 通过 key，在一致性哈希环上，查找 key 所属的节点，返回这个节点的 IP/Port，我们将 IP/Port 保存在客户端 httpGetter，所以直接返回 httpGetter 实例。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/http.go</span><br><br><span class="hljs-comment">// Set 设置远程节点的能力：实例化一个一致性哈希，并向哈希环中添加节点。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Set(peers ...<span class="hljs-type">string</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    h.peers = consistenthash.New(defaultReplicas, <span class="hljs-literal">nil</span>)   <span class="hljs-comment">// 初始化哈希环</span><br>    h.peers.Add(peers...) <span class="hljs-comment">// 将节点加到哈希环上</span><br><br>    <span class="hljs-comment">// 保存 key 和对应的 httpGetter 到 map 字段 httpGetters 中</span><br>    h.httpGetters = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter, <span class="hljs-built_in">len</span>(peers))<br>    <span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;<br>        h.httpGetters[peer] = &amp;httpGetter&#123;<br>            baseURL: peer + h.basePath,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// PickPeer 获取远程节点的能力：包装了一致性哈希获取真实节点的方法 consistenthash.Map.Get</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> PickPeer(key <span class="hljs-type">string</span>) (PeerGetter, <span class="hljs-type">bool</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    <span class="hljs-comment">// 从哈希环上获取缓存值属于那个节点，如果不是空且不是自身，则返回对应的节点。</span><br>    <span class="hljs-keyword">if</span> peer := h.peers.Get(key); peer != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; peer != h.self &#123;<br>        h.Log(<span class="hljs-string">&quot;Pick peer %s&quot;</span>, peer)<br>        <span class="hljs-keyword">return</span> h.httpGetters[peer], <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要返回客户端 httpGetter 实例，而不是直接的 IP/Port，让 Group 拿到 IP/Port 自己去发 HTTP 请求呢？</strong></p><p>和上面，Group 为什么设计 PeerPicker 和 PeerGetter 接口一样。因为我们要做到  HTTPPool 和 Group 解耦，实现与业务分离。</p><ul><li>HTTPPool 负责管理所有节点信息，根据节点信息提供 HTTP 服务、访问 HTTP 服务。</li><li>Group 只管调用 <code>PeerPicker.PickPeer</code> 和 <code>PeerGetter.Get</code> 的方法，去完成业务逻辑即可。</li></ul><p>所以，我们还需为 httpGetter 写一个发送请求的方法，让 httpGetter 实现 PeerGetter 接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// geecache/http.go</span><br><br><span class="hljs-comment">// Get 步骤：</span><br><span class="hljs-comment">// 1.将 baseURL、group、key 拼接为远程节点缓存值的访问地址 URL</span><br><span class="hljs-comment">// 2.访问 URL 获取缓存值返回</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *httpGetter)</span></span> Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    u := fmt.Sprintf(<span class="hljs-string">&quot;%v%v/%v&quot;</span>, g.baseURL, url.QueryEscape(group), url.QueryEscape(key))<br>    <span class="hljs-comment">/* url.QueryEscape 是 URL 转义函数，</span><br><span class="hljs-comment">       比如 http://123.com/123?image=http://images.com/cat.png</span><br><span class="hljs-comment">       需要转义为 http://123.com/123?image=http%3A%2F%2Fimages.com%2Fcat.png</span><br><span class="hljs-comment">    */</span><br><br>    res, err := http.Get(u)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> res.Body.Close()<br><br>    <span class="hljs-keyword">if</span> res.StatusCode != http.StatusOK &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;server returned %v&quot;</span>, res.Status)<br>    &#125;<br><br>    bytes, err := io.ReadAll(res.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;reading response body %v&quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bytes, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何验证功能">如何验证功能</h3><p>这个 main 函数看着很绕，其实逻辑是这样：</p><ul><li>8001 - 8003 端口模拟三个的主机节点。</li><li>端口 9999 相当于 8001 节点机器供用户交互的网关，每个节点都有与用户交互的网关，这里演示只启动 8001 节点的 9999 端口用于交互。</li><li>main 做的就是初始化 Group；初始化 HTTPPool；将 HTTPPool 注册到 Group 中；启动一个 api 服务监听 9999 端口。</li></ul><pre><code class=" mermaid">graph LR    A[查询请求] --&gt; B[API-端口 9999  +  分布式节点一-端口 8001]    B --&gt; D[分布式节点二-端口 8002]    B --&gt;|经过查询 key 在节点三| E[分布式节点三-端口 8003]    E --&gt; F[返回缓存值]</code></pre><p>具体实现不细描述，跑起来就明白了。</p><h3 id="完整代码-5">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── geecache<br>│   ├── byteview.go<br>│   ├── cache.go<br>│   ├── consistenthash<br>│   │   ├── consistent_hash.go<br>│   │   └── consistent_hash_test.go<br>│   ├── geecache.go <span class="hljs-comment"># 增加与远程节点交互的业务逻辑</span><br>│   ├── geecache_test.go<br>│   ├── http.go <span class="hljs-comment"># 增加与远程节点交互的实现逻辑</span><br>│   └── lru<br>│       ├── lru.go<br>│       └── lru_test.go<br>├── go.mod<br>└── main.go <span class="hljs-comment"># 增加与远程节点交互的 demo</span><br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            geecache/geecache.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Getter 用于从各类的外部数据源获取数据</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>    Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc 为了便于使用者传入匿名函数到 Getter 中</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> f(key)<br>&#125;<br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span><br>    getter    Getter<br>    mainCache cache<br><br>    peers PeerPicker <span class="hljs-comment">// 用于选择远程节点</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    groupMu sync.RWMutex<br>    groups  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<br>    <span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)<br>    &#125;<br><br>    groupMu.Lock()<br>    <span class="hljs-keyword">defer</span> groupMu.Unlock()<br><br>    g := &amp;Group&#123;<br>        name:      name,<br>        getter:    getter,<br>        mainCache: cache&#123;cacheBytes: cacheBytes&#125;,<br>    &#125;<br>    groups[name] = g<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;<br>    groupMu.RLock()<br>    g := groups[name]<br>    groupMu.RUnlock()<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">                               是</span><br><span class="hljs-comment">(Get)接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 (1)</span><br><span class="hljs-comment">                |  否                              是</span><br><span class="hljs-comment">                |-----&gt; (load)是否应当从远程节点获取 -----&gt; (getFromPeer)与远程节点交互 --&gt; 返回缓存值 (2)</span><br><span class="hljs-comment">                            |  否</span><br><span class="hljs-comment">                            |-----&gt; (getLocally)调用`回调函数`，获取值，(populateCache)并添加到缓存 --&gt; 返回缓存值 (3)</span><br><span class="hljs-comment">Get 完成流程（1）</span><br><span class="hljs-comment">load + getLocally 完成流程(3)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;<br>        log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<br>        <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 缓存没有命中，就从其他数据源中获取</span><br>    <span class="hljs-keyword">return</span> g.load(key)<br>&#125;<br><br><span class="hljs-comment">// load: 缓存不存在时，先在远程节点中查找，未果再调用 getLocally 获取数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123; <span class="hljs-comment">// 找到 key 对应的远程节点。</span><br>            value, err := g.getFromPeer(peer, key) <span class="hljs-comment">// 在远程节点中查找</span><br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>            &#125;<br>            log.Println(<span class="hljs-string">&quot;[GeeCache] failed to get from peer&quot;</span>, err)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> g.getLocally(key)<br>&#125;<br><br><span class="hljs-comment">// 从远程节点获取数据，传入的是 PeerGetter 接口类型，只要实现了 Get 方法，就可以传入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := peer.Get(g.name, key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;bytes&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// getLocally 调用用户的回调函数 g.getter.Get，获取数据，并使用 populateCache 添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := g.getter.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    value := ByteView&#123;cloneBytes(bytes)&#125;<br>    g.populateCache(key, value)<br>    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// populateCache 将获取到的数据添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    g.mainCache.add(key, value)<br>&#125;<br><br><span class="hljs-comment">// RegisterPeers 将实现了 PeerPicker 接口的变量注入到 Group 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> RegisterPeers(peers PeerPicker) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;RegisterPeerPicker called more than once&quot;</span>)<br>    &#125;<br>    g.peers = peers<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用一致性哈希选择节点        是                                    是</span><br><span class="hljs-comment">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class="hljs-comment">                    |  否                                  ↓  否</span><br><span class="hljs-comment">                    |----------------------------&gt; 回退到本地节点处理。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// PeerGetter 获取到的远程节点，协助 Group 从远程节点获取缓存值</span><br><span class="hljs-keyword">type</span> PeerGetter <span class="hljs-keyword">interface</span> &#123;<br>    Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) <span class="hljs-comment">// 获取缓存值</span><br>&#125;<br><br><span class="hljs-comment">// PeerPicker 协助 Group 通过 key 选择远程节点</span><br><span class="hljs-keyword">type</span> PeerPicker <span class="hljs-keyword">interface</span> &#123;<br>    PickPeer(key <span class="hljs-type">string</span>) (peer PeerGetter, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 根据 key 选择节点 PeerGetter</span><br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache/http.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/consistenthash&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;net/url&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    defaultBasePath = <span class="hljs-string">&quot;/_geecache/&quot;</span> <span class="hljs-comment">// 请求路径应该是 &quot;/&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt;&quot;</span><br>    defaultReplicas = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-comment">// HTTPPool :包含服务端和客户端，服务端提供获取本机数据的 HTTP 服务，客户端提供访问其他节点的方法</span><br><span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;<br>    self     <span class="hljs-type">string</span> <span class="hljs-comment">// 当前节点的 IP/端口</span><br>    basePath <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 增加能力：设置和获取远程节点的能力</span><br>    mu          sync.Mutex<br>    peers       *consistenthash.Map    <span class="hljs-comment">// 一致性哈希</span><br>    httpGetters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter <span class="hljs-comment">// 记录每个远程节点的 httpGetter，httpGetter 包含了 baseURL</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPPool</span><span class="hljs-params">(self <span class="hljs-type">string</span>)</span></span> *HTTPPool &#123; <span class="hljs-comment">// 为什么要设置这两个字段</span><br>    <span class="hljs-keyword">return</span> &amp;HTTPPool&#123;<br>        self:     self,            <span class="hljs-comment">// 本机的IP/端口</span><br>        basePath: defaultBasePath, <span class="hljs-comment">// 请求前缀，便于过滤请求</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> !strings.HasPrefix(r.URL.Path, h.basePath) &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Error path: &quot;</span> + r.URL.Path)<br>    &#125;<br><br>    h.Log(<span class="hljs-string">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)<br><br>    parts := strings.SplitN(r.URL.Path[<span class="hljs-built_in">len</span>(defaultBasePath):], <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;bad request&quot;</span>, http.StatusBadRequest)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    groupName := parts[<span class="hljs-number">0</span>]<br>    key := parts[<span class="hljs-number">1</span>]<br>    group := GetGroup(groupName)<br>    <span class="hljs-keyword">if</span> group == <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    view, err := group.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    w.Write(view.ByteSlice())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Log(format <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    log.Printf(<span class="hljs-string">&quot;[Server %s] %s&quot;</span>, h.self, fmt.Sprintf(format, v...))<br>&#125;<br><br><span class="hljs-comment">// Set 设置远程节点的能力：实例化一个一致性哈希，并向哈希环中添加节点。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Set(peers ...<span class="hljs-type">string</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    h.peers = consistenthash.New(defaultReplicas, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 初始化哈希环</span><br>    h.peers.Add(peers...)                              <span class="hljs-comment">// 将节点加到哈希环上</span><br><br>    <span class="hljs-comment">// 保存 key 和对应的 httpGetter 到 map 字段 httpGetters 中</span><br>    h.httpGetters = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter, <span class="hljs-built_in">len</span>(peers))<br>    <span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;<br>        h.httpGetters[peer] = &amp;httpGetter&#123;<br>            baseURL: peer + h.basePath,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// PickPeer 获取远程节点的能力：包装了一致性哈希获取真实节点的方法 consistenthash.Map.Get</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> PickPeer(key <span class="hljs-type">string</span>) (PeerGetter, <span class="hljs-type">bool</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    <span class="hljs-comment">// 从哈希环上获取缓存值属于那个节点，如果不是空且不是自身，则返回对应的节点。</span><br>    <span class="hljs-keyword">if</span> peer := h.peers.Get(key); peer != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; peer != h.self &#123;<br>        h.Log(<span class="hljs-string">&quot;Pick peer %s&quot;</span>, peer)<br>        <span class="hljs-keyword">return</span> h.httpGetters[peer], <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// httpGetter 客户端：获取数据，实现 PeerGetter 接口</span><br><span class="hljs-keyword">type</span> httpGetter <span class="hljs-keyword">struct</span> &#123;<br>    baseURL <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Get 步骤：</span><br><span class="hljs-comment">// 1.将 baseURL、group、key 拼接为远程节点缓存值的访问地址 URL</span><br><span class="hljs-comment">// 2.访问 URL 获取缓存值返回</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *httpGetter)</span></span> Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    u := fmt.Sprintf(<span class="hljs-string">&quot;%v%v/%v&quot;</span>, g.baseURL, url.QueryEscape(group), url.QueryEscape(key))<br>    <span class="hljs-comment">/* url.QueryEscape 是 URL 转义函数，</span><br><span class="hljs-comment">       比如 http://123.com/123?image=http://images.com/cat.png</span><br><span class="hljs-comment">       需要转义为 http://123.com/123?image=http%3A%2F%2Fimages.com%2Fcat.png</span><br><span class="hljs-comment">    */</span><br><br>    res, err := http.Get(u)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> res.Body.Close()<br><br>    <span class="hljs-keyword">if</span> res.StatusCode != http.StatusOK &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;server returned %v&quot;</span>, res.Status)<br>    &#125;<br><br>    bytes, err := io.ReadAll(res.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;reading response body %v&quot;</span>, err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bytes, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">var</span> _ PeerGetter = (*httpGetter)(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// 保证 httpGetter 实现了 PeerGetter。没实现在编译时报错。</span><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟回源的数据库</span><br><span class="hljs-keyword">var</span> db = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span>:  <span class="hljs-string">&quot;630&quot;</span>,<br>    <span class="hljs-string">&quot;Jack&quot;</span>: <span class="hljs-string">&quot;589&quot;</span>,<br>    <span class="hljs-string">&quot;Sam&quot;</span>:  <span class="hljs-string">&quot;567&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createGroup</span><span class="hljs-params">()</span></span> *geecache.Group &#123;<br>    <span class="hljs-keyword">return</span> geecache.NewGroup(<span class="hljs-string">&quot;scores&quot;</span>, <span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">10</span>,<br>        geecache.GetterFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 回源函数</span><br>            log.Println(<span class="hljs-string">&quot;[SlowDB] search key&quot;</span>, key)<br>            <span class="hljs-keyword">if</span> v, ok := db[key]; ok &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(v), <span class="hljs-literal">nil</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;%s not exist&quot;</span>, key)<br>        &#125;))<br>&#125;<br><br><span class="hljs-comment">// startCacheServer 每个节点启动一个 HTTP 服务器，用于接收请求，返回缓存值。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startCacheServer</span><span class="hljs-params">(addr <span class="hljs-type">string</span>, addrs []<span class="hljs-type">string</span>, gee *geecache.Group)</span></span> &#123;<br>    peers := geecache.NewHTTPPool(addr) <span class="hljs-comment">// 初始化一个 HTTPPool 实例</span><br>    peers.Set(addrs...)                 <span class="hljs-comment">// 将所有节点的地址加入到 HTTPPool 中</span><br>    gee.RegisterPeers(peers)<br>    log.Println(<span class="hljs-string">&quot;geecache is running at&quot;</span>, addr)<br>    log.Fatal(http.ListenAndServe(addr[<span class="hljs-number">7</span>:], peers)) <span class="hljs-comment">// 监听端口，让 NewHTTPPool 的 ServeHTTP 方法处理请求</span><br>&#125;<br><br><span class="hljs-comment">// startAPIServer 启动一个 API 服务，用于测试。接收请求，根据 key 查找对应节点，访问节点，返回结果。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startAPIServer</span><span class="hljs-params">(apiAddr <span class="hljs-type">string</span>, gee *geecache.Group)</span></span> &#123;<br>    http.Handle(<span class="hljs-string">&quot;/api&quot;</span>, http.HandlerFunc(<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>            key := r.URL.Query().Get(<span class="hljs-string">&quot;key&quot;</span>)<br>            view, err := gee.Get(key)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                http.Error(w, err.Error(), http.StatusInternalServerError)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>)<br>            w.Write(view.ByteSlice())<br><br>        &#125;))<br>    log.Println(<span class="hljs-string">&quot;fontend server is running at&quot;</span>, apiAddr)<br>    log.Fatal(http.ListenAndServe(apiAddr[<span class="hljs-number">7</span>:], <span class="hljs-literal">nil</span>))<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> port <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> api <span class="hljs-type">bool</span><br>    flag.IntVar(&amp;port, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-number">8001</span>, <span class="hljs-string">&quot;Geecache server port&quot;</span>)<br>    flag.BoolVar(&amp;api, <span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;Start a api server?&quot;</span>)<br>    flag.Parse()<br><br>    apiAddr := <span class="hljs-string">&quot;http://localhost:9999&quot;</span><br><br>    <span class="hljs-comment">// 所有分布式节点的地址，包括本机</span><br>    addrMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-number">8001</span>: <span class="hljs-string">&quot;http://localhost:8001&quot;</span>,<br>        <span class="hljs-number">8002</span>: <span class="hljs-string">&quot;http://localhost:8002&quot;</span>,<br>        <span class="hljs-number">8003</span>: <span class="hljs-string">&quot;http://localhost:8003&quot;</span>,<br>    &#125;<br>    <span class="hljs-keyword">var</span> addrs []<span class="hljs-type">string</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> addrMap &#123;<br>        addrs = <span class="hljs-built_in">append</span>(addrs, v)<br>    &#125;<br><br>    gee := createGroup()<br><br>    <span class="hljs-comment">// 启动一个 API 服务，用于测试。接收请求，根据 key 查找对应节点，访问节点，返回结果。</span><br>    <span class="hljs-keyword">if</span> api &#123;<br>        <span class="hljs-keyword">go</span> startAPIServer(apiAddr, gee)<br>    &#125;<br><br>    startCacheServer(addrMap[port], []<span class="hljs-type">string</span>(addrs), gee)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="6-防止缓存击穿">6.防止缓存击穿</h2><blockquote><ul><li>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</li><li><strong>缓存击穿</strong>：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</li><li><strong>缓存穿透</strong>：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</li></ul></blockquote><blockquote><p>延伸阅读：golang 中 singleflight 包的实现：<a href="https://pkg.go.dev/golang.org/x/sync/singleflight">singleflight.go</a></p></blockquote><h3 id="如何防止缓存击穿">如何防止缓存击穿</h3><p>这一章节可写的不多，主要是一个思想：</p><ul><li>对于短时间内的大量并发的同种请求，只响应第一个。</li><li>其他的请求等待第一个请求完毕，直接使用第一个请求的结果。</li></ul><p>值得学习的地方：</p><ul><li>singleflight 的实现，使用代理模式，load 中查询远程节点的逻辑，全部交给了 <code>singleflight.Do</code> 这个方法进行封装，有点类似中间件的工作模式。</li><li>仅需少量代码就可以完成对于每个请求的控制，简单优雅。</li></ul><h3 id="什么时候应该加锁">什么时候应该加锁</h3><ul><li><p>在读写 <code>g.m[key]</code> 前均需加锁。但是互斥锁效率太低，下面改成读写锁。</p></li><li><p>并对于懒汉单例模式，使用双检锁来优化性能。</p><ul><li><strong>第一次检查（无锁）</strong>：<br>减少锁竞争。大多数情况下实例已存在，无需加锁直接进入后续业务。</li><li><strong>第二次检查（加锁）</strong>：<br>防止多个协程同时通过第一次检查后，在锁内重复创建实例。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Do(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 第一次不加锁，因为 g.m 的概率小</span><br>        g.mu.Lock() <span class="hljs-comment">// 如果 g.m == nil，说明是第一次，需要加锁，避免其他并发也进来创建 g.m</span><br>        <span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;<br>            g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call) <span class="hljs-comment">// 懒加载</span><br>        &#125;<br>        g.mu.Unlock()<br>    &#125;<br><br>    g.mu.RLock()<br>    <span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>        g.mu.RUnlock() <span class="hljs-comment">// 读 g.m 后解锁</span><br>        c.wg.Wait()<br>        <span class="hljs-keyword">return</span> c.val, c.err<br>    &#125;<br>    g.mu.RUnlock() <span class="hljs-comment">// 读 g.m 后解锁</span><br><br>    c := <span class="hljs-built_in">new</span>(call)<br>    c.wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 记录同步的事件数量，其他并发请求阻塞等待当前请求结束</span><br>    g.mu.Lock() <span class="hljs-comment">// 写 g.m 前加锁</span><br>    g.m[key] = c<br>    g.mu.Unlock() <span class="hljs-comment">// 写 g.m 后解锁</span><br><br>    c.val, c.err = fn() <span class="hljs-comment">// 调用 fn，发起请求</span><br>    c.wg.Done()         <span class="hljs-comment">// 结束请求</span><br><br>    g.mu.Lock()      <span class="hljs-comment">// 写 g.m 前加锁</span><br>    <span class="hljs-built_in">delete</span>(g.m, key) <span class="hljs-comment">// 更新 g.m</span><br>    g.mu.Unlock()    <span class="hljs-comment">// 写 g.m 后解锁</span><br><br>    <span class="hljs-keyword">return</span> c.val, c.err <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-6">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── geecache<br>│   ├── byteview.go<br>│   ├── cache.go<br>│   ├── consistenthash<br>│   │   ├── consistent_hash.go<br>│   │   └── consistent_hash_test.go<br>│   ├── geecache.go <span class="hljs-comment"># 增加 singleflight</span><br>│   ├── geecache_test.go<br>│   ├── http.go<br>│   └── lru<br>│   │  ├── lru.go<br>│   │  └── lru_test.go<br>│   └── singleflight <br>│       └── singleflight.go  <span class="hljs-comment"># 新增对并发请求的控制</span><br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            geecache/singleflight/singleflight.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleflight<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>    wg  sync.WaitGroup<br>    val <span class="hljs-keyword">interface</span>&#123;&#125;<br>    err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    mu sync.RWMutex<br>    m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Do(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 第一次不加锁，因为 g.m 的概率小</span><br>        g.mu.Lock() <span class="hljs-comment">// 如果 g.m == nil，说明是第一次，需要加锁，避免其他并发也进来创建 g.m</span><br>        <span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;<br>            g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call) <span class="hljs-comment">// 懒加载</span><br>        &#125;<br>        g.mu.Unlock()<br>    &#125;<br><br>    g.mu.RLock()<br>    <span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>        g.mu.RUnlock() <span class="hljs-comment">// 读 g.m 后解锁</span><br>        c.wg.Wait()<br>        <span class="hljs-keyword">return</span> c.val, c.err<br>    &#125;<br>    g.mu.RUnlock() <span class="hljs-comment">// 读 g.m 后解锁</span><br><br>    c := <span class="hljs-built_in">new</span>(call)<br>    c.wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 记录同步的事件数量，其他并发请求阻塞等待当前请求结束</span><br>    g.mu.Lock() <span class="hljs-comment">// 写 g.m 前加锁</span><br>    g.m[key] = c<br>    g.mu.Unlock() <span class="hljs-comment">// 写 g.m 后解锁</span><br><br>    c.val, c.err = fn() <span class="hljs-comment">// 调用 fn，发起请求</span><br>    c.wg.Done()         <span class="hljs-comment">// 结束请求</span><br><br>    g.mu.Lock()      <span class="hljs-comment">// 写 g.m 前加锁</span><br>    <span class="hljs-built_in">delete</span>(g.m, key) <span class="hljs-comment">// 更新 g.m</span><br>    g.mu.Unlock()    <span class="hljs-comment">// 写 g.m 后解锁</span><br><br>    <span class="hljs-keyword">return</span> c.val, c.err <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache/geecache.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/singleflight&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Getter 用于从各类的外部数据源获取数据</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>    Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc 为了便于使用者传入匿名函数到 Getter 中</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> f(key)<br>&#125;<br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span><br>    getter    Getter<br>    mainCache cache<br>    peers     PeerPicker<br><br>    loader *singleflight.Group<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    groupMu sync.RWMutex<br>    groups  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<br>    <span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)<br>    &#125;<br><br>    groupMu.Lock()<br>    <span class="hljs-keyword">defer</span> groupMu.Unlock()<br><br>    g := &amp;Group&#123;<br>        name:      name,<br>        getter:    getter,<br>        mainCache: cache&#123;cacheBytes: cacheBytes&#125;,<br>        loader:    &amp;singleflight.Group&#123;&#125;,<br>    &#125;<br>    groups[name] = g<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;<br>    groupMu.RLock()<br>    g := groups[name]<br>    groupMu.RUnlock()<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">                               是</span><br><span class="hljs-comment">(Get)接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 (1)</span><br><span class="hljs-comment">                |  否                              是</span><br><span class="hljs-comment">                |-----&gt; (load)是否应当从远程节点获取 -----&gt; (getFromPeer)与远程节点交互 --&gt; 返回缓存值 (2)</span><br><span class="hljs-comment">                            |  否</span><br><span class="hljs-comment">                            |-----&gt; (getLocally)调用`回调函数`，获取值，(populateCache)并添加到缓存 --&gt; 返回缓存值 (3)</span><br><span class="hljs-comment">Get 完成流程（1）</span><br><span class="hljs-comment">load + getLocally 完成流程(3)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;<br>        log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<br>        <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 缓存没有命中，就从其他数据源中获取</span><br>    <span class="hljs-keyword">return</span> g.load(key)<br>&#125;<br><br><span class="hljs-comment">// load: 缓存不存在时，先在远程节点中查找，未果再调用 getLocally 获取数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    val, err := g.loader.Do(key, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123; <span class="hljs-comment">// 找到 key 对应的远程节点。</span><br>                value, err := g.getFromPeer(peer, key) <span class="hljs-comment">// 在远程节点中查找</span><br>                <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>                &#125;<br>                log.Println(<span class="hljs-string">&quot;[GeeCache] failed to get from peer&quot;</span>, err)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> g.getLocally(key)<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> val.(ByteView), <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>&#125;<br><br><span class="hljs-comment">// 从远程节点获取数据，传入的是 PeerGetter 接口类型，只要实现了 Get 方法，就可以传入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := peer.Get(g.name, key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;bytes&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// getLocally 调用用户的回调函数 g.getter.Get，获取数据，并使用 populateCache 添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := g.getter.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    value := ByteView&#123;cloneBytes(bytes)&#125;<br>    g.populateCache(key, value)<br>    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// populateCache 将获取到的数据添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    g.mainCache.add(key, value)<br>&#125;<br><br><span class="hljs-comment">// RegisterPeers 将实现了 PeerPicker 接口的变量注入到 Group 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> RegisterPeers(peers PeerPicker) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;RegisterPeerPicker called more than once&quot;</span>)<br>    &#125;<br>    g.peers = peers<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用一致性哈希选择节点        是                                    是</span><br><span class="hljs-comment">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class="hljs-comment">                    |  否                                  ↓  否</span><br><span class="hljs-comment">                    |----------------------------&gt; 回退到本地节点处理。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// PeerGetter 获取到的远程节点，协助 Group 从远程节点获取缓存值</span><br><span class="hljs-keyword">type</span> PeerGetter <span class="hljs-keyword">interface</span> &#123;<br>    Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) <span class="hljs-comment">// 获取缓存值</span><br>&#125;<br><br><span class="hljs-comment">// PeerPicker 协助 Group 通过 key 选择远程节点</span><br><span class="hljs-keyword">type</span> PeerPicker <span class="hljs-keyword">interface</span> &#123;<br>    PickPeer(key <span class="hljs-type">string</span>) (peer PeerGetter, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 根据 key 选择节点 PeerGetter</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="7-使用-Protobuf-编码">7.使用 Protobuf 编码</h2><h3 id="使用-protobuf-编码需要做哪些更改">使用 protobuf 编码需要做哪些更改</h3><p><strong>（1）原来逻辑</strong></p><p>客户端：</p><ol><li>拿到 group、key 构造 url</li><li>使用 <code>http.Get</code> 发送请求</li></ol><p>服务端：</p><ol start="3"><li>处理请求，将结果 view 返回</li></ol><p>客户端：</p><ol start="4"><li>接收服务端结果，直接使用</li></ol><p><strong>（2）使用 protobuf 编码后的逻辑</strong></p><p>客户端：</p><ol><li>拿到 group、key 构造 url</li><li>使用 <code>http.Get</code> 发送请求</li></ol><p>服务端：</p><ol start="3"><li>处理请求，将结果 view 使用 protobuf 编码（变更）</li></ol><p>客户端：</p><ol start="4"><li>接收服务端结果，使用 protobuf 解码。（变更）</li></ol><h3 id="如何实现">如何实现</h3><ol><li>创建 proto 文件，定义 Request 和 Response。</li><li>更改 <code>PeerGetter.Get</code> 参数，改为 Request 和 Response。</li><li>在处理请求和接收数据时，使用 protobuf 进行编解码。</li></ol><h3 id="完整代码-7">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── geecache<br>│   ├── byteview.go<br>│   ├── cache.go<br>│   ├── consistenthash<br>│   │   ├── consistent_hash.go<br>│   │   └── consistent_hash_test.go<br>│   ├── geecache.go  <span class="hljs-comment"># getFromPeer 修改传参方式。</span><br>│   ├── geecachepb  <span class="hljs-comment"># protobuf 编解码</span><br>│   │   ├── geecachepb.pb.go<br>│   │   └── geecachepb.proto<br>│   ├── geecache_test.go<br>│   ├── geers.go <span class="hljs-comment"># 新增文件存放 PeerGetter、PeerPicker 接口</span><br>│   ├── http.go <span class="hljs-comment"># 新增在处理请求和接收数据时，使用 protobuf 进行编解码。</span><br>│   └── lru<br>│   │  ├── lru.go<br>│   │  └── lru_test.go<br>│   └── singleflight <br>│       └── singleflight.go<br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            geecache/geecachepb/geecachepb.proto        </div>        <div class='fold-content'>            <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;geecachepb&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Request</span> &#123;<br>  <span class="hljs-type">string</span> <span class="hljs-keyword">group</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> key = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Response</span> &#123;<br>  <span class="hljs-type">bytes</span> value = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache/geecache.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/geecachepb&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/singleflight&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Getter 用于从各类的外部数据源获取数据</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>    Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc 为了便于使用者传入匿名函数到 Getter 中</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> f(key)<br>&#125;<br><br><span class="hljs-comment">// Group 负责与用户交互（获取缓存值），并拥有从外部数据源获取值并存储在缓存中的功能</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    name      <span class="hljs-type">string</span><br>    getter    Getter<br>    mainCache cache<br>    peers     PeerPicker<br><br>    loader *singleflight.Group<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>    groupMu sync.RWMutex<br>    groups  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<br>    <span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)<br>    &#125;<br><br>    groupMu.Lock()<br>    <span class="hljs-keyword">defer</span> groupMu.Unlock()<br><br>    g := &amp;Group&#123;<br>        name:      name,<br>        getter:    getter,<br>        mainCache: cache&#123;cacheBytes: cacheBytes&#125;,<br>        loader:    &amp;singleflight.Group&#123;&#125;,<br>    &#125;<br>    groups[name] = g<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;<br>    groupMu.RLock()<br>    g := groups[name]<br>    groupMu.RUnlock()<br>    <span class="hljs-keyword">return</span> g<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">                               是</span><br><span class="hljs-comment">(Get)接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 (1)</span><br><span class="hljs-comment">                |  否                              是</span><br><span class="hljs-comment">                |-----&gt; (load)是否应当从远程节点获取 -----&gt; (getFromPeer)与远程节点交互 --&gt; 返回缓存值 (2)</span><br><span class="hljs-comment">                            |  否</span><br><span class="hljs-comment">                            |-----&gt; (getLocally)调用`回调函数`，获取值，(populateCache)并添加到缓存 --&gt; 返回缓存值 (3)</span><br><span class="hljs-comment">Get 完成流程（1）</span><br><span class="hljs-comment">load + getLocally 完成流程(3)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;<br>        log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<br>        <span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 缓存没有命中，就从其他数据源中获取</span><br>    <span class="hljs-keyword">return</span> g.load(key)<br>&#125;<br><br><span class="hljs-comment">// load: 缓存不存在时，先在远程节点中查找，未果再调用 getLocally 获取数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    val, err := g.loader.Do(key, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123; <span class="hljs-comment">// 找到 key 对应的远程节点。</span><br>                value, err := g.getFromPeer(peer, key) <span class="hljs-comment">// 在远程节点中查找</span><br>                <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>                &#125;<br>                log.Println(<span class="hljs-string">&quot;[GeeCache] failed to get from peer&quot;</span>, err)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> g.getLocally(key)<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> val.(ByteView), <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>&#125;<br><br><span class="hljs-comment">// 从远程节点获取数据，传入的是 PeerGetter 接口类型，只要实现了 Get 方法，就可以传入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    req := &amp;geecachepb.Request&#123;<br>        Group: g.name,<br>        Key:   key,<br>    &#125;<br>    res := &amp;geecachepb.Response&#123;&#125;<br><br>    err := peer.Get(req, res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> ByteView&#123;res.Value&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// getLocally 调用用户的回调函数 g.getter.Get，获取数据，并使用 populateCache 添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<br>    bytes, err := g.getter.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ByteView&#123;&#125;, err<br>    &#125;<br>    value := ByteView&#123;cloneBytes(bytes)&#125;<br>    g.populateCache(key, value)<br>    <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// populateCache 将获取到的数据添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;<br>    g.mainCache.add(key, value)<br>&#125;<br><br><span class="hljs-comment">// RegisterPeers 将实现了 PeerPicker 接口的变量注入到 Group 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> RegisterPeers(peers PeerPicker) &#123;<br>    <span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;RegisterPeerPicker called more than once&quot;</span>)<br>    &#125;<br>    g.peers = peers<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            geecache/http.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/consistenthash&quot;</span><br>    <span class="hljs-string">&quot;geecache/geecache/geecachepb&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;net/url&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    defaultBasePath = <span class="hljs-string">&quot;/_geecache/&quot;</span> <span class="hljs-comment">// 请求路径应该是 &quot;/&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt;&quot;</span><br>    defaultReplicas = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-comment">// HTTPPool :包含服务端和客户端，服务端提供获取本机数据的 HTTP 服务，客户端提供访问其他节点的方法</span><br><span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;<br>    self     <span class="hljs-type">string</span> <span class="hljs-comment">// 当前节点的 IP/端口</span><br>    basePath <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 增加能力：设置和获取远程节点的能力</span><br>    mu          sync.Mutex<br>    peers       *consistenthash.Map    <span class="hljs-comment">// 一致性哈希</span><br>    httpGetters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter <span class="hljs-comment">// 记录每个远程节点的 httpGetter，httpGetter 包含了 baseURL</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPPool</span><span class="hljs-params">(self <span class="hljs-type">string</span>)</span></span> *HTTPPool &#123; <span class="hljs-comment">// 为什么要设置这两个字段</span><br>    <span class="hljs-keyword">return</span> &amp;HTTPPool&#123;<br>        self:     self,            <span class="hljs-comment">// 本机的IP/端口</span><br>        basePath: defaultBasePath, <span class="hljs-comment">// 请求前缀，便于过滤请求</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    <span class="hljs-keyword">if</span> !strings.HasPrefix(r.URL.Path, h.basePath) &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Error path: &quot;</span> + r.URL.Path)<br>    &#125;<br><br>    h.Log(<span class="hljs-string">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)<br><br>    parts := strings.SplitN(r.URL.Path[<span class="hljs-built_in">len</span>(defaultBasePath):], <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;bad request&quot;</span>, http.StatusBadRequest)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    groupName := parts[<span class="hljs-number">0</span>]<br>    key := parts[<span class="hljs-number">1</span>]<br>    group := GetGroup(groupName)<br>    <span class="hljs-keyword">if</span> group == <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, <span class="hljs-string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    view, err := group.Get(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    res := &amp;geecachepb.Response&#123;<br>        Value: view.ByteSlice(),<br>    &#125;<br>    body, err := proto.Marshal(res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    w.Write(body)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Log(format <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    log.Printf(<span class="hljs-string">&quot;[Server %s] %s&quot;</span>, h.self, fmt.Sprintf(format, v...))<br>&#125;<br><br><span class="hljs-comment">// Set 设置远程节点的能力：实例化一个一致性哈希，并向哈希环中添加节点。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> Set(peers ...<span class="hljs-type">string</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    h.peers = consistenthash.New(defaultReplicas, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 初始化哈希环</span><br>    h.peers.Add(peers...)                              <span class="hljs-comment">// 将节点加到哈希环上</span><br><br>    <span class="hljs-comment">// 保存 key 和对应的 httpGetter 到 map 字段 httpGetters 中</span><br>    h.httpGetters = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter, <span class="hljs-built_in">len</span>(peers))<br>    <span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;<br>        h.httpGetters[peer] = &amp;httpGetter&#123;<br>            baseURL: peer + h.basePath,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// PickPeer 获取远程节点的能力：包装了一致性哈希获取真实节点的方法 consistenthash.Map.Get</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HTTPPool)</span></span> PickPeer(key <span class="hljs-type">string</span>) (PeerGetter, <span class="hljs-type">bool</span>) &#123;<br>    h.mu.Lock()<br>    <span class="hljs-keyword">defer</span> h.mu.Unlock()<br><br>    <span class="hljs-comment">// 从哈希环上获取缓存值属于那个节点，如果不是空且不是自身，则返回对应的节点。</span><br>    <span class="hljs-keyword">if</span> peer := h.peers.Get(key); peer != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; peer != h.self &#123;<br>        h.Log(<span class="hljs-string">&quot;Pick peer %s&quot;</span>, peer)<br>        <span class="hljs-keyword">return</span> h.httpGetters[peer], <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// httpGetter 客户端：获取数据，实现 PeerGetter 接口</span><br><span class="hljs-keyword">type</span> httpGetter <span class="hljs-keyword">struct</span> &#123;<br>    baseURL <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Get 步骤：</span><br><span class="hljs-comment">// 1.将 baseURL、group、key 拼接为远程节点缓存值的访问地址 URL</span><br><span class="hljs-comment">// 2.访问 URL 获取缓存值返回</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *httpGetter)</span></span> Get(in *geecachepb.Request, out *geecachepb.Response) <span class="hljs-type">error</span> &#123;<br>    group := in.Group<br>    key := in.Key<br><br>    u := fmt.Sprintf(<span class="hljs-string">&quot;%v%v/%v&quot;</span>, g.baseURL, url.QueryEscape(group), url.QueryEscape(key))<br>    <span class="hljs-comment">/* url.QueryEscape 是 URL 转义函数，</span><br><span class="hljs-comment">       比如 http://123.com/123?image=http://images.com/cat.png</span><br><span class="hljs-comment">       需要转义为 http://123.com/123?image=http%3A%2F%2Fimages.com%2Fcat.png</span><br><span class="hljs-comment">    */</span><br><br>    res, err := http.Get(u)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> res.Body.Close()<br><br>    <span class="hljs-keyword">if</span> res.StatusCode != http.StatusOK &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;server returned %v&quot;</span>, res.Status)<br>    &#125;<br><br>    bytes, err := io.ReadAll(res.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;reading response body %v&quot;</span>, err)<br>    &#125;<br><br>    err = proto.Unmarshal(bytes, out)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">var</span> _ PeerGetter = (*httpGetter)(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// 保证 httpGetter 实现了 PeerGetter。没实现在编译时报错。</span><br></code></pre></td></tr></table></figure>        </div>    </div><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">本文逐步实现了一个分布式缓存系统，涵盖LRU缓存淘汰策略、单机并发控制、HTTP服务接口及一致性哈希算法。</summary>
    
    
    
    <category term="Implement From Scratch" scheme="https://www.aimtao.net/categories/Implement-From-Scratch/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="Cache" scheme="https://www.aimtao.net/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>从零实现系列｜web 框架</title>
    <link href="https://www.aimtao.net/7days-web/"/>
    <id>https://www.aimtao.net/7days-web/</id>
    <published>2023-02-25T14:00:00.000Z</published>
    <updated>2023-02-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过回答关键问题的方式，记录阅读 <a href="https://geektutu.com/post/gee.html">gee</a> 代码过程中的思考，并做出补充和改进，其中有所借鉴 gin 框架。</p><span id="more"></span><p>参考 gee 的方式，共设置七个模块，每个模块相互独立并依次迭代，源码在 <a href="https://github.com/AimTao/implement-from-scratch">implement-from-scratch</a>。下面从如何设计框架的角度，提出了一些问题。</p><h2 id="0-序言">0.序言</h2><h3 id="net-http-可以干什么">net/http 可以干什么</h3><p>提供基础的 web 功能：</p><ul><li>监听端口</li><li>映射静态路由</li><li>请求处理（解析 HTTP 报文）</li><li>响应处理（生成和发送HTTP报文）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Web-框架需要干什么">Web 框架需要干什么</h3><blockquote><p>换句话说，需要 web 框架在 net/http 的基础上实现什么？</p></blockquote><ul><li>路由（Routing）：将请求映射到函数，支持动态路由（例如<code>'/hello/:name</code>）、支持路由分组</li><li>上下文（Context）：Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。为请求封装上下文，可以简化接口调用（不然需要带上 http.Request、http.ResponseWriter；还可以保存中间件产生的中间信息）。</li><li>中间件（Midddleware）：提供通用的中间件、为用户自定义中间件提供插入点。</li><li>模板（Templates）：使用内置模板引擎提供模板渲染机制。</li><li>错误恢复（Panic Recover）：提供错误处理机制，防止 panic 导致服务宕掉。</li></ul><h2 id="1-HTTP-基础">1.HTTP 基础</h2><h3 id="如何接管-HTTP-请求">如何接管 HTTP 请求</h3><p>在 <code> http.ListenAndServe(&quot;:9999&quot;, nil))</code> 中第二个参数，表示处理所有 HTTP 请求的实例。如果传入 nil，则使用默认的 http.DefaultServeMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// net/http/server.go</span><br><span class="hljs-comment">// 传入的第二个参数，会被用于初始化 Server 这个结构体的 Handler 字段。 </span><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>        Addr <span class="hljs-type">string</span><br><br>        Handler Handler <span class="hljs-comment">// handler to invoke, http.DefaultServeMux if nil  // 注意这里的官方注释</span><br></code></pre></td></tr></table></figure><p>只需要不传入 nil，传入我们自己的实例，就可以接管所有 HTTP 请求，开始构建我们的 web 框架。</p><p>那该传入什么呢？先看看 net/http 是如何实现的。第二个参数的类型是 Handler 接口类型，接口定义如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// net/http/server.go</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 net/http/server.go 中，HandlerFunc 实现了这个 Handler 接口。实现如下。</p><p>注：这里插一下，HandlerFunc 是一个函数类型，在 go 中，函数是第一公民，也是可以实现接口的。第一次看这个写法可能比较奇怪，函数类型 HandlerFunc 调用一个函数 ServeHTTP，竟然最后还是调用自己 <code> f(w, r)</code>。为什么要这么做？可以阅读一下这篇文章《<a href="https://geektutu.com/post/7days-golang-q1.html">Go 接口型函数的使用场景</a>》。这里总结一下，**为了既可以传入任何函数，也可以传入结构体，**以 HandlerFunc 为例：</p><ul><li>参数类型是 Handler 接口类型，<strong>普通函数/匿名函数</strong>只需要强制转换为 HandlerFunc，就可以作为参数传入）</li><li>只要实现了 ServeHTTP 方法的<strong>结构体</strong>，也可以作为参数传入。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// net/http/server.go</span><br><span class="hljs-comment">// The HandlerFunc type is an adapter to allow the use of</span><br><span class="hljs-comment">// ordinary functions as HTTP handlers. If f is a function</span><br><span class="hljs-comment">// with the appropriate signature, HandlerFunc(f) is a</span><br><span class="hljs-comment">// Handler that calls f.</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-comment">// ServeHTTP calls f(w, r).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;<br>    f(w, r)<br>&#125;<br></code></pre></td></tr></table></figure><p>回到主线，也就是说，只要我们像 HandlerFunc 一样，实现了 Handler 接口，就可以作为  http.ListenAndServe 第二个参数，从而接管监听到的所有 HTTP 请求。</p><p>定义 Engine，并实现结构体函数 ServeHTTP。将 http.ListenAndServe 的参数传递，封装到 Run 函数中，完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/gee.go</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    <span class="hljs-keyword">return</span> &amp;Engine&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)    <span class="hljs-comment">// 传入 Handler 接口类型，只要实现了 ServeHTTP(ResponseWriter, *Request) 就实现了 Handler 接口。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    fmt.Println(req)<br>    <span class="hljs-comment">//  处理请求</span><br>&#125;<br><br><br><span class="hljs-comment">// main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gee.New()<br>    _ = engine.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么-ServeHTTP-参数分别是指针传递-值传递">为什么 ServeHTTP 参数分别是指针传递/值传递</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>req 接收的是结构体，可能有大量数据，使用指针可以节省内存。</p><p>http.ResponseWriter 是一个接口类型，w 是接口类型变量，不能使用指针。</p><p>目的是，不管接收的是什么，只要它实现了 <code>Header()</code>、<code>Write([]byte)</code>、<code>WriteHeader(statusCode int)</code> 这三个函数，它就可以保存在 w 这个变量中。（也没必要使用指针，这里需要得是 w 的三个方法。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go</span><br><br><span class="hljs-comment">// http.ResponseWriter 接口的定义</span><br><span class="hljs-keyword">type</span> ResponseWriter <span class="hljs-keyword">interface</span> &#123;<br>    Header() Header<br>    Write([]<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br>    WriteHeader(statusCode <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何管理静态路由及请求处理函数">如何管理静态路由及请求处理函数</h3><p>框架使用者想要什么？想要用这样的方式注册静态路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gee.New()<br>    engine.GET(<span class="hljs-string">&quot;/&quot;</span>, Index)  <span class="hljs-comment">// 注册静态路由</span><br>   _ = engine.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span>  &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 Engine 内部维护一个 map，用来映射路由地址和处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc  <span class="hljs-comment">// 内部维护一个map 做路由映射</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    <span class="hljs-keyword">return</span> &amp;Engine&#123;<br>        router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),  <span class="hljs-comment">// 初始化 Engine 时初始化 map</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 map 中，使用 <code>method + &quot;-&quot; + pattern</code> 作为 key，HandlerFunc 作为 value。提供 addRoute 函数增加 map 中的路由映射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>    engine.router[key] = handler  <span class="hljs-comment">// 增加路由映射</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后需要改写  ServeHTTP 的逻辑。收到请求后，用请求方法和请求路径构造 key，并执行对应的请求处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    key := req.Method + <span class="hljs-string">&quot;-&quot;</span> + req.URL.Path<br>    <span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok &#123;<br>        handler(w, req)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br><br>version_1_http[geeweb]<br>├── gee<br>│   └── gee.go<br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc   <span class="hljs-comment">// 内部维护一个map 做路由映射</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    <span class="hljs-keyword">return</span> &amp;Engine&#123;<br>        router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),  <span class="hljs-comment">// 初始化 Engine 时初始化 map</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>    engine.router[key] = handler   <span class="hljs-comment">// 增加路由映射</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)    <span class="hljs-comment">// 传入 Handler 接口类型，只要实现了 ServeHTTP(ResponseWriter, *Request) 就实现了 Handler 接口。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    key := req.Method + <span class="hljs-string">&quot;-&quot;</span> + req.URL.Path<br>    <span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok &#123;<br>        handler(w, req)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gee.New()<br>    engine.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;    <span class="hljs-comment">// 注册静态路由</span><br>        fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)<br>    &#125;)<br><br>    engine.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;<br>            fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)<br>        &#125;<br>    &#125;)<br><br>    err := engine.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="2-上下文">2. 上下文</h2><h3 id="需要-context-做什么">需要 context 做什么</h3><p>context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。将扩展性和复杂性留在了 context 内部，而对外提供简化的接口。</p><ul><li>简化接口参数：<ul><li>context 储存 http.Request、http.ResponseWriter，让请求处理函数的参数、中间件的参数，均使用 context 实例。</li></ul></li><li>封装常用方法：<ul><li>http.Request、http.ResponseWriter 提供的接口粒度太细，用起来繁琐。</li><li>封装获取请求参数的方法。</li><li>封装快速构造 String/Data/JSON/HTML 响应的方法。</li><li>封装设置响应的 header（状态码 StatusCode 和消息类型 ContentType）的方法。</li></ul></li><li>储存上下文信息<ul><li>储存动态路由的参数。</li><li>储存中间件产生的信息。</li></ul></li></ul><h3 id="如何简化接口参数">如何简化接口参数</h3><ul><li>先构造 context</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// 暂且保存常用的参数</span><br>    Req *http.Request<br>    Writer http.ResponseWriter<br>    Path <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    StatusCode <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req: req,<br>        Writer: writer,<br>        Path: req.URL.Path,<br>        Method: req.Method,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将请求处理函数的参数，由原来的 http.ResponseWriter、*http.Request 改成 context。</li></ul><h3 id="如何封装常用方法">如何封装常用方法</h3><p>主要是封装 http 的原生功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-comment">// 获取请求参数的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>&#125;<br><br><span class="hljs-comment">// 获取请求参数的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>&#125;<br><br><span class="hljs-comment">// 设置响应的 header 的消息类型 ContentType 的方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>)  &#123;<br>    c.Writer.Header().Set(key, value)<br>&#125;<br><br><span class="hljs-comment">// 设置响应的 header 的状态码 StatusCode 的方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>)  &#123;<br>    c.StatusCode = code<br>    c.Writer.WriteHeader(code)<br>&#125;<br><br><span class="hljs-comment">// 快速构造 String 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)  &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...))); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 JSON 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    c.Status(code)<br>    encoder := json.NewEncoder(c.Writer)<br>    <span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 Data 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, date []<span class="hljs-type">byte</span>)  &#123;<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write(date); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 HTML 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(html)); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-2">完整代码</h3><p>注：为便于动态路由的处理，我们将 router  的这个 map，单独提取出来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br><br>version_2_context[geeweb]<br>├── gee<br>│   ├── context.go<br>│   ├── gee.go<br>│   └── router.go <span class="hljs-comment"># 新增</span><br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span><br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    router *router<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    <span class="hljs-keyword">return</span> &amp;Engine&#123;<br>        router: newRouter(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.router.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.router.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    context := NewContext(w, req)<br>    engine.router.handle(context)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/router.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/router.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> &#123;<br>    handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router &#123;<br>    <span class="hljs-keyword">return</span> &amp;router&#123;<br>        handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增加路由映射</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>    r.handlers[key] = handler<br>&#125;<br><br><br><span class="hljs-comment">// 封装统一的调用请求处理函数的方法，供 ServeHTTP 调用。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;  <span class="hljs-comment">// 注意参数已更改为 context。</span><br>    key := c.Req.Method + <span class="hljs-string">&quot;-&quot;</span> + c.Req.URL.Path<br>    <span class="hljs-keyword">if</span> handler, ok := r.handlers[key]; ok &#123;<br>        handler(c)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(c.Writer, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/context.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// 暂且保存常用的参数</span><br>    Req *http.Request<br>    Writer http.ResponseWriter<br>    Path <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    StatusCode <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req: req,<br>        Writer: writer,<br>        Path: req.URL.Path,<br>        Method: req.Method,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取请求参数的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>&#125;<br><br><span class="hljs-comment">// 获取请求参数的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>&#125;<br><br><span class="hljs-comment">// 设置响应的 header 的消息类型 ContentType 的方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>)  &#123;<br>    c.Writer.Header().Set(key, value)<br>&#125;<br><br><span class="hljs-comment">// 设置响应的 header 的状态码 StatusCode 的方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>)  &#123;<br>    c.StatusCode = code<br>    c.Writer.WriteHeader(code)<br>&#125;<br><br><span class="hljs-comment">// 快速构造 String 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)  &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...))); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 JSON 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    c.Status(code)<br>    encoder := json.NewEncoder(c.Writer)<br>    <span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 Data 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, date []<span class="hljs-type">byte</span>)  &#123;<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write(date); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速构造 HTML 响应的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(html)); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            mian.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mian.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gee.New()<br>    engine.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.HTML(http.StatusOK, <span class="hljs-string">&quot;&lt;h1&gt;hello Gee&lt;/h1&gt;&quot;</span>)<br>    &#125;)<br><br>    engine.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.String(http.StatusOK, <span class="hljs-string">&quot;hello %s&quot;</span>, ctx.Query(<span class="hljs-string">&quot;name&quot;</span>))<br>    &#125;)<br><br>    engine.POST(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.JSON(http.StatusOK, gee.H&#123;<br>            <span class="hljs-string">&quot;username&quot;</span>: ctx.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>            <span class="hljs-string">&quot;password&quot;</span>: ctx.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>        &#125;)<br>    &#125;)<br><br>    err := engine.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">curl http://127.0.0.1:9999/</span><br><span class="hljs-comment">&lt;h1&gt;hello Gee&lt;/h1&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl http://127.0.0.1:9999/hello?name=aimtao</span><br><span class="hljs-comment">hello aimtao</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl http://127.0.0.1:9999/hello -X POST -d &#x27;username=aimtao&amp;password=123&#x27;</span><br><span class="hljs-comment">&#123;&quot;username&quot;:&quot;aimtao&quot;, &quot;password&quot;:&quot;123&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="3-前缀树路由"><strong>3.前缀树路由</strong></h2><h3 id="为什么需要前缀树路由">为什么需要前缀树路由</h3><p>之前使用 map 存储路由表，但是请求路径都是确定的，无法支持动态路由的匹配，比如用 <code>/hello/:name</code> 匹配 <code>/hello/aimtao</code>。</p><p>使用前缀树结构后，可以将一个请求地址 <code>/hello/:name</code>，以 “/” 为分割符分为不同段 <code>hello</code>、<code>aimtao</code>，依次进行匹配判断。</p><h3 id="如何实现前缀树">如何实现前缀树</h3><p>在实现前缀树路由之前，我们先回顾一下，如何实现一颗前缀树。比如在要插入 AB、ABC、DF、DH、XY 五个字符串。</p><p><img src="http://hutu.aimtao.net/mark/2023-08-04-TtegjF.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>实现前缀树需要做三件事：设计 Node 节点、实现前缀树的插入、实现前缀树的搜索。</p><p>每个节点应该存哪些内容呢？</p><ul><li>需要一个 bool 型 isEnd 来标记，当前节点的字符是否是一个单词的结尾。</li><li>每个节点都使用 map 存子节点，便于快速查找下一个字符的 Node 节点。</li><li>其实并不需要储存当前节点代表哪个字符，因为父节点的 map 中已保存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/draft/tire.go</span><br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    isEnd <span class="hljs-type">bool</span>           <span class="hljs-comment">// 当前字符是否是单词结尾</span><br>    next   <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]*Node <span class="hljs-comment">// 子节点储存后续的字符</span><br>&#125;<br><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    root *Node<br>&#125;<br></code></pre></td></tr></table></figure><p>所以在前缀树中插入 AB、ABC、DF、DH、XY 五个字符串，实际上是一个这样的树。</p><p><img src="http://hutu.aimtao.net/mark/2023-08-04-m4ZbBD.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>确定好 Node 结构，再来看看如何插入字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/draft/tire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(trie *Trie)</span></span> Insert(word <span class="hljs-type">string</span>) &#123;<br>    cur := trie.root<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> []<span class="hljs-type">rune</span>(word) &#123; <span class="hljs-comment">// 依次遍历字符，如果不存在 char 这个字符，则将 char 加入 map 中。</span><br>        <span class="hljs-keyword">if</span> _, ok := cur.next[char]; !ok &#123;<br>            cur.next[char] = &amp;Node&#123;next: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]*Node)&#125;<br>        &#125;<br>        cur = cur.next[char] <span class="hljs-comment">// cur 指针指向 char 这个 node。</span><br>    &#125;<br>    cur.isEnd = <span class="hljs-literal">true</span> <span class="hljs-comment">// 说明当前字符是结尾字符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查询的时候，和插入流程是一样的，区别在于，插入时，map 中没有则创建，查询时，map 中没有则返回 false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/draft/tire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(trie *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    cur := trie.root<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> []<span class="hljs-type">rune</span>(word) &#123;  <span class="hljs-comment">// 依次遍历字符，如果不存在 char 这个字符，则返回 false</span><br>        <span class="hljs-keyword">if</span> _, ok := cur.next[char]; !ok &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        cur = cur.next[char]<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur.isEnd  <span class="hljs-comment">// 注意，这里即使存在路经可以遍历 word，仍需判断当前字符是否是结尾字符。例如前缀树里只存在 ABC，查询 AB，应该返回 fasle</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// gee/draft/trie_test.go</span><br><br><span class="hljs-keyword">package</span> draft<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestTrie</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    trie := Trie&#123;<br>        root: &amp;Node&#123;next: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]*Node)&#125;,<br>    &#125;<br><br>    trie.InsertMore(<span class="hljs-string">&quot;AB&quot;</span>, <span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-string">&quot;DF&quot;</span>, <span class="hljs-string">&quot;DH&quot;</span>, <span class="hljs-string">&quot;XY&quot;</span>)<br>    Print(trie.root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(node *Node)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Node&#123;isEnd:%t, next:[&quot;</span>, node.isEnd)<br>    n := <span class="hljs-built_in">len</span>(node.next)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> node.next &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;&#x27;%c&#x27;: %p&quot;</span>, k, v)<br>        i++<br>        <span class="hljs-keyword">if</span> i &lt; n &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;, &quot;</span>)<br>        &#125;<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;]&#125;&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> node.next &#123;<br>        Print(v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现前缀树路由">如何实现前缀树路由</h3><p>路由地址由 <code>/</code> 进行分隔，例如注册三个 GET 请求 “/hello”、“/hello/:name”、“/assets/*filepath”，一个POST 请求 “/hello”，前缀树应该是这样的。</p><p><img src="http://hutu.aimtao.net/mark/2023-08-04-FzE0cb.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>和实现前缀树一样，实现前缀树路由需要做三件事：设计 Node 节点、实现前缀树路由的插入，实现前缀树路由的查找。</p><p>前缀树路由 Node 节点，需要保存四个字段，各有作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/trie.go</span><br><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>    path     <span class="hljs-type">string</span>           <span class="hljs-comment">// 匹配上的完整的路由地址，只有最后节点才能保存 path</span><br>    part     <span class="hljs-type">string</span>           <span class="hljs-comment">// 当前节点的 URL 片段</span><br>    children <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node <span class="hljs-comment">// 储存后续片段的节点</span><br>    isWild   <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否是通配符节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如配置路由地址 “/hello”、“/hello/:name”、“/assets/*filepath” 时，实际上的前缀树如图。</p><p>图</p><p>将路由地址按 <code>/</code> 进行分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/trie.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePath</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    patterns := strings.Split(pattern, <span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment">/* 注意：</span><br><span class="hljs-comment">       pattern 是 &quot;/hello&quot;，前面会被分出两个空字符串，需要删除</span><br><span class="hljs-comment">       pattern 是 &quot;hello/&quot;, 后面会被分出一个空字符串，需要删除</span><br><span class="hljs-comment">       pattern 是 &quot;/&quot;，前后会被分出两个空字符串，需要删除</span><br><span class="hljs-comment">       所以，直接删除前面的空格和后面的空格。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(patterns) &gt; <span class="hljs-number">0</span> &amp;&amp; patterns[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;&quot;</span> &#123; <span class="hljs-comment">// 删除前面的空格</span><br>        patterns = patterns[<span class="hljs-number">1</span>:]<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(patterns) &gt; <span class="hljs-number">0</span> &amp;&amp; patterns[<span class="hljs-built_in">len</span>(patterns)<span class="hljs-number">-1</span>] == <span class="hljs-string">&quot;&quot;</span> &#123; <span class="hljs-comment">// 删除后面的空格</span><br>        patterns = patterns[:<span class="hljs-built_in">len</span>(patterns)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> patterns<br>&#125;<br></code></pre></td></tr></table></figure><p>插入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/trie.go</span><br><br><span class="hljs-comment">// 路由注册，将路由地址插入到前缀树中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *node)</span></span> insert(pattern <span class="hljs-type">string</span>) &#123;<br>    cur := root<br>    patterns := parsePath(pattern) <span class="hljs-comment">// 提前将路由地址，分割成片段保存在数组中</span><br><br>    <span class="hljs-comment">// 依次遍历路由地址的片段，不存在则创建保存该片段的节点。</span><br>    <span class="hljs-keyword">for</span> _, part := <span class="hljs-keyword">range</span> patterns &#123;<br>        <span class="hljs-keyword">if</span> _, ok := cur.children[part]; !ok &#123;<br>            cur.children[part] = &amp;node&#123;<br>                part:     part,<br>                children: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>                isWild:   part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>,<br>            &#125;<br>        &#125;<br>        cur = cur.children[part] <span class="hljs-comment">// cur 指向保存当前片段的节点，后面的片段保存在 cur 当前节点的子节点中</span><br>    &#125;<br><br>    cur.path = pattern <span class="hljs-comment">// 当遍历完路由地址，在最后一个节点中，保存完整的路由地址，其他节点不保存完整的路由地址。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/trie.go</span><br><br><span class="hljs-comment">// search 获取路由树节点以及请求地址中的变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *node)</span></span> search(pattern <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;<br>    params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>    cur := root<br>    patterns := parsePath(pattern)<br><br>    <span class="hljs-comment">// 依次遍历路由地址的片段，无法匹配上则退出</span><br>    <span class="hljs-keyword">for</span> _, part := <span class="hljs-keyword">range</span> patterns &#123;<br>        <span class="hljs-keyword">if</span> cur.children[part] == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 无法匹配上，开始尝试通配符匹配</span><br>            <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> cur.children &#123; <span class="hljs-comment">// 遍历当前片段下的所有子节点，排查有通配符的节点。</span><br>                <span class="hljs-keyword">if</span> v.isWild == <span class="hljs-literal">true</span> &amp;&amp; k[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123; <span class="hljs-comment">// 找到*，保存该片段及该片段后的所有内容做参数</span><br>                    params[k[<span class="hljs-number">1</span>:]] = pattern[strings.Index(pattern, part):]<br>                    <span class="hljs-keyword">return</span> v, params<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v.isWild == <span class="hljs-literal">true</span> &amp;&amp; k[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> &#123; <span class="hljs-comment">// 找到：，保存该片段做参数</span><br>                    params[k[<span class="hljs-number">1</span>:]] = part<br>                    cur = v<br>                    <span class="hljs-keyword">break</span><br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有通配符节点</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当前片段准确匹配上，继续匹配后面的片段</span><br>            cur = cur.children[part]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 所有请求路经片段均匹配完毕，检查当前节点是否有完整的路由地址。比如,路由注册了 /a/b，请求路经是 /a，虽然也匹配上了，但 a 这个节点未保存完整的路经，只有最后的节点 b 节点会保存。</span><br>    <span class="hljs-keyword">if</span> cur.path != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> cur, params<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-3">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br><br>version_3_router[geeweb]<br>├── gee<br>│   ├── context.go<br>│   ├── gee.go<br>│   ├── router.go<br>│   ├── trie.go <span class="hljs-comment"># 新增：前缀树路由</span><br>│   └── draft   <span class="hljs-comment"># 草稿：实现一个前缀树</span><br>│       ├── tire.go<br>│       └── trie_test.go<br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span><br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    router *router<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    <span class="hljs-keyword">return</span> &amp;Engine&#123;<br>        router: newRouter(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.router.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    engine.router.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    context := NewContext(w, req)<br>    engine.router.handle(context)<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/context.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// origin objects</span><br>    Req    *http.Request<br>    Writer http.ResponseWriter<br>    <span class="hljs-comment">// request info</span><br>    Path   <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    Params <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// 增加参数</span><br>    <span class="hljs-comment">// response info</span><br>    StatusCode <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req:    req,<br>        Writer: writer,<br>        Path:   req.URL.Path,<br>        Method: req.Method,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>&#125;<br><br><span class="hljs-comment">// Param 从请求地址中获取参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Param(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Params[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>) &#123;<br>    c.Writer.Header().Set(key, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) &#123;<br>    c.StatusCode = code<br>    c.Writer.WriteHeader(code)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...))); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    c.Status(code)<br>    encoder := json.NewEncoder(c.Writer)<br>    <span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, date []<span class="hljs-type">byte</span>) &#123;<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write(date); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(html)); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/router.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/router.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> &#123;<br>    roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node       <span class="hljs-comment">// 不同请求方式的 Trie 树根节点</span><br>    handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc <span class="hljs-comment">// 储存路由对应的请求处理函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router &#123;<br>    <span class="hljs-keyword">return</span> &amp;router&#123;<br>        roots:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>        handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增加路由映射</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    <span class="hljs-comment">// 添加请求方法，例如 GET、POST</span><br>    <span class="hljs-keyword">if</span> _, ok := r.roots[method]; !ok &#123;<br>        r.roots[method] = &amp;node&#123;children: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node)&#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路由地址插入前缀树</span><br>    r.roots[method].insert(pattern)<br><br>    key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>    r.handlers[key] = handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRouter(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-comment">// 如果不存在该请求方法，直接退出</span><br>    <span class="hljs-keyword">if</span> _, ok := r.roots[method]; !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r.roots[method].search(pattern)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>    node, params := r.getRouter(c.Method, c.Path)<br>    <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>        c.Params = params<br>        key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + node.path<br>        r.handlers[key](c)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(c.Writer, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/trie.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/trie.go</span><br><br><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>    path     <span class="hljs-type">string</span>           <span class="hljs-comment">// 匹配上的完整的路由地址，只有最后节点才能保存 path</span><br>    part     <span class="hljs-type">string</span>           <span class="hljs-comment">// 当前节点的 URL 片段</span><br>    children <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node <span class="hljs-comment">// 储存后续片段的节点</span><br>    isWild   <span class="hljs-type">bool</span>             <span class="hljs-comment">// 是否是通配符节点</span><br>&#125;<br><br><span class="hljs-comment">// 路由注册，将路由地址插入到前缀树中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *node)</span></span> insert(pattern <span class="hljs-type">string</span>) &#123;<br>    cur := root<br>    patterns := parsePath(pattern) <span class="hljs-comment">// 提前将路由地址，分割成片段保存在数组中</span><br><br>    <span class="hljs-comment">// 依次遍历路由地址的片段，不存在则创建保存该片段的节点。</span><br>    <span class="hljs-keyword">for</span> _, part := <span class="hljs-keyword">range</span> patterns &#123;<br>        <span class="hljs-keyword">if</span> _, ok := cur.children[part]; !ok &#123;<br>            cur.children[part] = &amp;node&#123;<br>                part:     part,<br>                children: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>                isWild:   part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>,<br>            &#125;<br>        &#125;<br>        cur = cur.children[part] <span class="hljs-comment">// cur 指向保存当前片段的节点，后面的片段保存在 cur 当前节点的子节点中</span><br>    &#125;<br><br>    cur.path = pattern <span class="hljs-comment">// 当遍历完路由地址，在最后一个节点中，保存完整的路由地址，其他节点不保存完整的路由地址。</span><br>&#125;<br><br><span class="hljs-comment">// search 获取路由树节点以及请求地址中的变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *node)</span></span> search(pattern <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;<br>    params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>    cur := root<br>    patterns := parsePath(pattern)<br><br>    <span class="hljs-comment">// 依次遍历路由地址的片段，无法匹配上则退出</span><br>    <span class="hljs-keyword">for</span> _, part := <span class="hljs-keyword">range</span> patterns &#123;<br>        <span class="hljs-keyword">if</span> cur.children[part] == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 无法匹配上，开始尝试通配符匹配</span><br>            <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> cur.children &#123; <span class="hljs-comment">// 遍历当前片段下的所有子节点，排查有通配符的节点。</span><br>                <span class="hljs-keyword">if</span> v.isWild == <span class="hljs-literal">true</span> &amp;&amp; k[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123; <span class="hljs-comment">// 找到*，保存该片段及该片段后的所有内容做参数</span><br>                    params[k[<span class="hljs-number">1</span>:]] = pattern[strings.Index(pattern, part):]<br>                    <span class="hljs-keyword">return</span> v, params<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v.isWild == <span class="hljs-literal">true</span> &amp;&amp; k[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> &#123; <span class="hljs-comment">// 找到：，保存该片段做参数</span><br>                    params[k[<span class="hljs-number">1</span>:]] = part<br>                    cur = v<br>                    <span class="hljs-keyword">break</span><br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有通配符节点</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当前片段准确匹配上，继续匹配后面的片段</span><br>            cur = cur.children[part]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 所有请求路经片段均匹配完毕，检查当前节点是否有完整的路由地址。比如,路由注册了 /a/b，请求路经是 /a，虽然也匹配上了，但 a 这个节点未保存完整的路经，只有最后的节点 b 节点会保存。</span><br>    <span class="hljs-keyword">if</span> cur.path != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> cur, params<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePath</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    patterns := strings.Split(pattern, <span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment">/* 注意：</span><br><span class="hljs-comment">       pattern 是 &quot;/hello&quot;，前面会被分出两个空字符串，需要删除</span><br><span class="hljs-comment">       pattern 是 &quot;hello/&quot;, 后面会被分出一个空字符串，需要删除</span><br><span class="hljs-comment">       pattern 是 &quot;/&quot;，前后会被分出两个空字符串，需要删除</span><br><span class="hljs-comment">       所以，直接删除前面的空格和后面的空格。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(patterns) &gt; <span class="hljs-number">0</span> &amp;&amp; patterns[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;&quot;</span> &#123; <span class="hljs-comment">// 删除前面的空格</span><br>        patterns = patterns[<span class="hljs-number">1</span>:]<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(patterns) &gt; <span class="hljs-number">0</span> &amp;&amp; patterns[<span class="hljs-built_in">len</span>(patterns)<span class="hljs-number">-1</span>] == <span class="hljs-string">&quot;&quot;</span> &#123; <span class="hljs-comment">// 删除后面的空格</span><br>        patterns = patterns[:<span class="hljs-built_in">len</span>(patterns)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> patterns<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br><br>    r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        <span class="hljs-comment">// /hello?name=aimtao</span><br>        c.String(http.StatusOK, <span class="hljs-string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="hljs-string">&quot;name&quot;</span>), c.Path)<br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/hello/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        <span class="hljs-comment">// /hello/aimtao</span><br>        c.String(http.StatusOK, <span class="hljs-string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="hljs-string">&quot;name&quot;</span>), c.Path)<br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/assets/*filepath&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        <span class="hljs-comment">// /assets/pic/aimtao/1.jpg</span><br>        c.JSON(http.StatusOK, gee.H&#123;<span class="hljs-string">&quot;filepath&quot;</span>: c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)&#125;)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">curl http://127.0.0.1:9999/hello?name=aimtao</span><br><span class="hljs-comment">hello aimtao, you&#x27;re at /hello</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl &quot;http://127.0.0.1:9999/hello/aimtao?name=aimtao&quot;</span><br><span class="hljs-comment">hello aimtao, you&#x27;re at /hello/aimtao</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl http://127.0.0.1:9999/assets/pic/aimtao/1.jpg</span><br><span class="hljs-comment">&#123;&quot;filepath&quot;:&quot;pic/aimtao/1.jpg&quot;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="4-分组控制">4.分组控制</h2><h3 id="为什么需要路由分组">为什么需要路由分组</h3><p>便于统一处理某一组路由。比如这类需求，</p><ul><li>以<code>/post</code>开头的路由匿名可访问。</li><li>以<code>/admin</code>开头的路由需要鉴权。</li><li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li></ul><p>这里补充两点：</p><ul><li>常见的路由分组方式，就是以相同前缀来区分不同的路由。</li><li>如何统一处理某一组路由，需要使用中间件，下文第五章会详细叙述。</li></ul><h3 id="如何设计路由分组功能">如何设计路由分组功能</h3><p>以相同前缀来区分不同的路由。我们先看下，用户想如何使用，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gee.New()<br>v1 := r.Group(<span class="hljs-string">&quot;/v1&quot;</span>)<br>user  := v1.Group(<span class="hljs-string">&quot;/user&quot;</span>)<br>user.GET(<span class="hljs-string">&quot;/hello&quot;</span>, Hello)<br><br><span class="hljs-comment">// curl http://127.0.0.1:9999/v1/user/hello</span><br></code></pre></td></tr></table></figure><p>为了实现上述功能，需要做两件事：</p><ol><li><p>首先，我们使用 RouterGroup 来保存分组的数据，比如前缀、作用在这个分组上的中间件。</p></li><li><p>其次，RouterGroup 需要增加路由的能力（GET、POST），我们使用 组合（Composite） 来实现，在 RouterGroup 的肚子里，放一个全局的 Engine 指针变量。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    prefix      <span class="hljs-type">string</span>   <span class="hljs-comment">// 该分组的完整前缀，例如 user 分组保存的是 &quot;/v1/user/&quot;，从最顶层的 group 到当前的 group</span><br>    engine      *Engine  <span class="hljs-comment">// 组合的方式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过该指针变量，间接使用 Engine 的各种能力，比如封装自己的 GET、POST 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(prefix <span class="hljs-type">string</span>) *RouterGroup &#123;<br>    newGroup := &amp;RouterGroup&#123;<br>        prefix: group.prefix + prefix,<br>        engine: group.engine,<br>    &#125;<br>    group.engine.groups = <span class="hljs-built_in">append</span>(group.engine.groups, newGroup)  <span class="hljs-comment">// Engine 保存所有的 Group，后面查照中间件会用上，此处可以不 care</span><br>    <span class="hljs-keyword">return</span> newGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern   <span class="hljs-comment">// 拼接路径，比如上面例子中的 &quot;/v1/user&quot; 和 &quot;/hello&quot;</span><br>    group.engine.GET(pattern, handler) <span class="hljs-comment">// 间接使用 Engine 增加路由的能力</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern<br>    group.engine.POST(pattern, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么将-Engine-抽象为最顶层的-RouterGroup">为什么将 Engine 抽象为最顶层的 RouterGroup</h3><p>上述方式可以达到目的，但是我们会发现一个问题，</p><ul><li>Engine 可以通过 GET/POST 方法增加路由，RouterGroup 也需要。</li><li>Engine 可以通过 中间件 增加请求处理行为，RouterGroup 也需要。</li></ul><p>在这两个功能上，Engine 和 RouterGroup 是一样的，没必要写两套同样的逻辑。可以将 Engine 抽象成最顶层的 RouterGroup。</p><h3 id="如何将-Engine-抽象为最顶层的-RouterGroup">如何将 Engine 抽象为最顶层的 RouterGroup</h3><p>需要做两件事情：</p><ol><li>将这上述的两个功能（增加路由、使用中间件）全交给 RouterGroup 来做。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern<br>    group.engine.router.addRoute(method, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 嵌入（Embeding）的方式，让 Engine 拥有 RouterGroup 全部能力。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    *RouterGroup <span class="hljs-comment">// 拥有 RouterGroup 的能力，可以隐形地调用 RouterGroup 的方法</span><br>    router       *router<br>    groups       []*RouterGroup <span class="hljs-comment">// 所有分组路径</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    engine := &amp;Engine&#123;router: newRouter()&#125;<br>    engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;<br>    engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;<br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-comment">// 删除 Engine 的 GET、POST、addRouter 方法。</span><br></code></pre></td></tr></table></figure><h3 id="为什么要使用-嵌入的方式">为什么要使用 嵌入的方式</h3><p>当把路由能力交给 routerGroup来完成后，Engine 可以隐性地使用 RouterGroup 的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;hello&quot;</span>, hello)<br><br><span class="hljs-comment">// 使用组合的话，就需要这样使用 engine.RouterGroup.GET(&quot;hello&quot;, hello)</span><br></code></pre></td></tr></table></figure><h3 id="完整代码-4">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br><br>version_4_group[geeweb]<br>├── gee<br>│   ├── context.go <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>│   ├── gee.go<br>│   ├── router.go  <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>│   └── trie.go    <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span><br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    *RouterGroup<br>    router       *router<br>    groups       []*RouterGroup <span class="hljs-comment">// 所有分组路径</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    engine := &amp;Engine&#123;router: newRouter()&#125;<br>    engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;<br>    engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;<br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>    context := NewContext(w, req)<br>    engine.router.handle(context)<br>&#125;<br><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    prefix     <span class="hljs-type">string</span>  <span class="hljs-comment">// 该分组的完整前缀，例如 user 分组保存的是 &quot;/v1/user/&quot;，从最顶层的 group 到当前的 group</span><br>    middleware []HandlerFunc<br>    engine     *Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(prefix <span class="hljs-type">string</span>) *RouterGroup &#123;<br>    newGroup := &amp;RouterGroup&#123;<br>        prefix: group.prefix + prefix,<br>        engine: group.engine,<br>    &#125;<br>    group.engine.groups = <span class="hljs-built_in">append</span>(group.engine.groups, newGroup) <br>    <span class="hljs-keyword">return</span> newGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern  <span class="hljs-comment">// 拼接路径，比如上面例子中的 &quot;/v1/user&quot; 和 &quot;/hello&quot;</span><br>    group.engine.router.addRoute(method, pattern, handler)  <span class="hljs-comment">// 间接使用 Engine 增加路由的能力</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gee.New()<br>    v1 := engine.Group(<span class="hljs-string">&quot;/v1&quot;</span>)<br>    v1.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.HTML(http.StatusOK, <span class="hljs-string">&quot;&lt;h1&gt;hello Gee&lt;/h1&gt;&quot;</span>)<br>    &#125;)<br><br>    v1.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.String(http.StatusOK, <span class="hljs-string">&quot;hello %s&quot;</span>, ctx.Query(<span class="hljs-string">&quot;name&quot;</span>))<br>    &#125;)<br><br>    v1.POST(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.JSON(http.StatusOK, gee.H&#123;<br>            <span class="hljs-string">&quot;username&quot;</span>: ctx.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>            <span class="hljs-string">&quot;password&quot;</span>: ctx.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>        &#125;)<br>    &#125;)<br><br>    err := engine.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">curl http://127.0.0.1:9999/v1</span><br><span class="hljs-comment">&lt;h1&gt;hello Gee&lt;/h1&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl http://127.0.0.1:9999/v1/hello?name=aimtao</span><br><span class="hljs-comment">hello aimtao</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">curl http://127.0.0.1:9999/v1/login -X POST -d &#x27;username=aimtao&amp;password=123&#x27;</span><br><span class="hljs-comment">&#123;&quot;username&quot;:&quot;aimtao&quot;, &quot;password&quot;:&quot;123&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="5-中间件">5.中间件</h2><h3 id="为什么需要中间件">为什么需要中间件</h3><p>可以在不入侵业务逻辑的情况下，在业务开始前/结束后完成一些功能，比如 logger、recover。web 框架需要提供一个插入点，允许用户自定义功能。</p><h3 id="中间件的执行顺序">中间件的执行顺序</h3><p>例如 group v1、user 分别有中间件 middlewareA，middlewareB。则 /v1/user/hello 需要执行两个中间件，middlewareA、middlewareB。</p><p>执行的过程，和函数调用栈是一样的，</p><ol><li>middlewareA 前半部分（middlewareA 入栈，执行）</li><li>middlewareB 前半部分（middlewareB 入栈，执行）</li><li>真正的请求处理函数 handle（handle 入栈，执行，出栈）</li><li>middlewareB 后半部分（middlewareB 继续执行，出栈）</li><li>middlewareA 后半部分（middlewareA 继续执行，出栈）</li></ol><h3 id="如何设计中间件">如何设计中间件</h3><p>用户会如何使用？</p><ul><li>用户传入一个 <code>func(ctx *gee.Context)</code> 函数作为中间件。</li><li>中间件分为三部分，上半部分、执行下一个中间件/请求处理函数、下班部分。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br>r := gee.New()<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/v1&quot;</span>)<br>    v1.Use(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;  <span class="hljs-comment">// 在 v1 group 上使用中间件</span><br>        <span class="hljs-comment">// 中间件上半部分</span><br>        now := time.Now()<br>       <br>        <span class="hljs-comment">// 执行下一个中间件或者真正的请求处理函数</span><br>        ctx.Next()<br>        <br>        <span class="hljs-comment">// 中间件的下半部分</span><br>        fmt.Println(time.Since(now))<br>    &#125;)<br></code></pre></td></tr></table></figure><p>为了实现上述功能，需要做三件事：</p><ul><li>储存中间件。</li><li>处理请求时，明确该执行哪些中件间。</li><li>实现一种机制，让中间件依次执行。</li></ul><p>下面依次说明。</p><ol><li><strong>储存中间件。</strong></li></ol><p>首先中间件的类型是 <code>func(ctx *gee.Context)</code>，也就是 HandlerFunc 类型。</p><p>既然中间件和 RouterGroup 绑定的，我们就在 RouterGroup 中保存一个 HandlerFunc 数组，用来储存这个分组下的中间件。（一个分组可能有多个中间件）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    prefix      <span class="hljs-type">string</span><br>    middlewares []HandlerFunc  <span class="hljs-comment">// 储存该分组下的中间件</span><br>    engine      *Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Use(handlerFunc ...HandlerFunc) &#123;  <span class="hljs-comment">// 用户为该分组增加中间件</span><br>    group.middlewares = <span class="hljs-built_in">append</span>(group.middlewares, handlerFunc...)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>处理请求时，明确该执行哪些中间件。</strong></li></ol><p>思路：每个 RouterGroup 都保存了各自的中间件，我们在处理请求时，查看该请求，属于哪些分组，并将这些分组的中间件，均保存下来，交给 context 依次执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><br>    <span class="hljs-keyword">var</span> middlewares []HandlerFunc<br>    <span class="hljs-keyword">for</span> _, group := <span class="hljs-keyword">range</span> engine.groups &#123; <span class="hljs-comment">// 遍历所有分组</span><br>        prefix := group.prefix + <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-comment">// 为什么要加 &quot;/&quot;？防止匹配错误，详见 https://github.com/geektutu/7days-golang/pull/77</span><br>        <span class="hljs-keyword">if</span> strings.HasPrefix(req.URL.Path, prefix) &#123; <span class="hljs-comment">// 查看当前请求，是否属于该分组</span><br>            middlewares = <span class="hljs-built_in">append</span>(middlewares, group.middlewares...) <span class="hljs-comment">// 属于该分组，将该分组的中间件保存下来</span><br>        &#125;<br>    &#125;<br><br>    context := NewContext(w, req)<br>    context.handlers = middlewares <span class="hljs-comment">// 将保存下来的中间件，交给 context 依次执行</span><br>    engine.router.handle(context)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>实现一种机制，让中间件依次执行。</strong></li></ol><p>上一步提到，将保存下来的中间件，交给 context 依次执行。一个小疑问，为什么要交给 context 执行？</p><ul><li>中间件也是 HandlerFunc 类型，可以和请求处理函数统一起来，让请求处理函数跟在中间件后面，按顺序执行。</li><li>context 信息相当于全局信息，将 HandlerFunc 数组放在 context 中，无论执行哪个函数，均可知道下一个该执行哪个函数。（用 index 记录执行到哪个函数）</li></ul><p>所以我们在 context 中新建两个变量 handlers 和 index。将 index 初始化为 -1，表示还没开始执行函数，下一个执行 handlers[0]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// origin objects</span><br>    Req    *http.Request<br>    Writer http.ResponseWriter<br>    <span class="hljs-comment">// request info</span><br>    Path   <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    Params <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">// response info</span><br>    StatusCode <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// middleware</span><br>    handlers []HandlerFunc <span class="hljs-comment">// 保存中间件和请求处理函数</span><br>    index    <span class="hljs-type">int</span>           <span class="hljs-comment">// 标志当前执行到第几个函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req:    req,<br>        Writer: writer,<br>        Path:   req.URL.Path,<br>        Method: req.Method,<br><br>        index: <span class="hljs-number">-1</span>, <span class="hljs-comment">// 初始化为 -1，表示还没开始执行函数，下一个执行 handlers[0]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并提供执行下一个中间件/请求处理函数的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;<br>    c.index++<br>    s := <span class="hljs-built_in">len</span>(c.handlers)<br>    <span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;<br>        c.handlers[c.index](c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>准备完毕，最后需要让 context.handlers 执行。</p><p>原本逻辑是 ServeHTTP -&gt; router.handle 执行 请求处理函数，现在需要把请求处理函数也加在context.handlers 后面，一并执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/router.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>    node, params := r.getRouter(c.Method, c.Path)<br>    <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>        c.Params = params<br>        key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + node.path<br>        c.handlers = <span class="hljs-built_in">append</span>(c.handlers, r.handlers[key]) <span class="hljs-comment">// 将找到的 请求处理函数 加在 c.handlers 的后面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(c.Writer, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Req.URL)<br>    &#125;<br>    c.Next() <span class="hljs-comment">// 依次执行 c.handlers 的函数。 // c.Next() 一定要放在最后，不能放在  if node != nil  中，因为即使找不到请求处理函数，也是要执行中间件</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="为什么需要遍历-handlers">为什么需要遍历 handlers</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 写法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;<br>    c.index++<br>    s := <span class="hljs-built_in">len</span>(c.handlers)<br>    <span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;   <span class="hljs-comment">// 中间件会自己调用 c.Next()，为什么这里还需要遍历？</span><br>        c.handlers[c.index](c)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//  写法二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;<br>    c.index++<br>    c.handlers[c.index](c)<br>&#125;<br></code></pre></td></tr></table></figure><p>不是所有的 handler 都会调用 <code>Next()</code>。手动调用 <code>Next()</code>，一般用于在请求前后各实现一些行为。如果中间件只作用于请求前，写法一可以省略调用<code>Next()</code>，兼容性更好。</p><h3 id="Gin-中是如何设计中间件的">Gin 中是如何设计中间件的</h3><p>和本文思路一致，区别在于 “明确该执行哪些中间件” 这一步，</p><ul><li>本文是执行请求时，才开始查找要执行哪些中间件。在 ServeHTTP 中遍历所有 RouterGroup。</li><li>Gin 是在 addRouter 时，将中间件保存在 Router 的 map 中。</li></ul><p>主要看三个关键代码：</p><ol><li>**RouterGroup.Group。**每个中间件都保存该组执行的所有中间件。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 举个例子</span><br>v1 := engine.Group(<span class="hljs-string">&quot;v1&quot;</span>)<br>v1.Use(FuncA)<br><br>user := v1.Group(<span class="hljs-string">&quot;user&quot;</span>)<br>user.Use(FuncB)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">v1.Handlers = [FuncA]</span><br><span class="hljs-comment">user.Handlers = [FuncA, FuncB]  // user 中会保存该组需要执行的所有中间件。而本文的实现，只会保存 FuncB，要使用的时候，再依次查找。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>Gin 如何实现这一步骤？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// routergroup.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(relativePath <span class="hljs-type">string</span>, handlers ...HandlerFunc) *RouterGroup &#123;<br>    <span class="hljs-keyword">return</span> &amp;RouterGroup&#123;<br>        Handlers: group.combineHandlers(handlers),  <span class="hljs-comment">// 合并当前组的中间件和上层 RouterGroup 的中间件，该函数下文会提到。</span><br>        basePath: group.calculateAbsolutePath(relativePath),  <span class="hljs-comment">// 保存绝对路径</span><br>        engine:   group.engine,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>**RouterGroup.GET -&gt; RouterGroup.handle。**合并路径，合并中间件和请求处理函数到同一队列中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// routergroup.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> handle(httpMethod, relativePath <span class="hljs-type">string</span>, handlers HandlersChain) IRoutes &#123;<br>    absolutePath := group.calculateAbsolutePath(relativePath)  <span class="hljs-comment">// 保存当前请求的绝对路径，相对路径 + group 路径</span><br>    handlers = group.combineHandlers(handlers)  <span class="hljs-comment">// handlers = 当前请求处理函数 + 中间件处理函数</span><br>    group.engine.addRoute(httpMethod, absolutePath, handlers)<br>    <span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>**RouterGroup.handle -&gt; RouterGroup.combineHandlers。**合并中间件和请求处理函数到同一队列中的具体实现。（该函数也用于合并当前组的中间件和上层 RouterGroup 的中间件，原理一样。）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// routergroup.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> combineHandlers(handlers HandlersChain) HandlersChain &#123;<br>    finalSize := <span class="hljs-built_in">len</span>(group.Handlers) + <span class="hljs-built_in">len</span>(handlers)  <span class="hljs-comment">// 计算长度</span><br>    assert1(finalSize &lt; <span class="hljs-type">int</span>(abortIndex), <span class="hljs-string">&quot;too many handlers&quot;</span>)<br>    mergedHandlers := <span class="hljs-built_in">make</span>(HandlersChain, finalSize)  <span class="hljs-comment">// 创建新的数组</span><br>    <span class="hljs-built_in">copy</span>(mergedHandlers, group.Handlers)  <span class="hljs-comment">// 先拷贝中间件，在数组前面，先执行</span><br>    <span class="hljs-built_in">copy</span>(mergedHandlers[<span class="hljs-built_in">len</span>(group.Handlers):], handlers)  <span class="hljs-comment">// 再拷贝请求处理函数，在数组后面，后执行</span><br>    <span class="hljs-keyword">return</span> mergedHandlers<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-5">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br><br>version_5_middleware[geeweb]<br>├── gee<br>│   ├── context.go<br>│   ├── gee.go<br>│   ├── router.go<br>│   └── trie.go <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span><br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    *RouterGroup <span class="hljs-comment">// 拥有 RouterGroup 的能力，可以隐形地调用 RouterGroup 的方法</span><br>    router       *router<br>    groups       []*RouterGroup <span class="hljs-comment">// 所有分组路径</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    engine := &amp;Engine&#123;router: newRouter()&#125;<br>    engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;<br>    engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;<br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><br>    <span class="hljs-keyword">var</span> middlewares []HandlerFunc<br>    <span class="hljs-keyword">for</span> _, group := <span class="hljs-keyword">range</span> engine.groups &#123; <span class="hljs-comment">// 遍历所有分组</span><br>        prefix := group.prefix + <span class="hljs-string">&quot;/&quot;</span><br>        <span class="hljs-keyword">if</span> strings.HasPrefix(req.URL.Path, prefix) &#123; <span class="hljs-comment">// 查看当前请求，是否属于该分组</span><br>            middlewares = <span class="hljs-built_in">append</span>(middlewares, group.middlewares...) <span class="hljs-comment">// 属于该分组，将该分组的中间件保存下来</span><br>        &#125;<br>    &#125;<br><br>    context := NewContext(w, req)<br>    context.handlers = middlewares <span class="hljs-comment">// 将保存下来的中间件，交给 context 依次执行</span><br>    engine.router.handle(context)<br>&#125;<br><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    prefix      <span class="hljs-type">string</span><br>    middlewares []HandlerFunc <span class="hljs-comment">// 储存该分组下的中间件</span><br>    engine      *Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(prefix <span class="hljs-type">string</span>) *RouterGroup &#123;<br>    newGroup := &amp;RouterGroup&#123;<br>        prefix: group.prefix + prefix,<br>        engine: group.engine,<br>    &#125;<br>    group.engine.groups = <span class="hljs-built_in">append</span>(group.engine.groups, newGroup)<br>    <span class="hljs-keyword">return</span> newGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern<br>    group.engine.router.addRoute(method, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Use(handlerFunc ...HandlerFunc) &#123; <span class="hljs-comment">// 用户为该分组增加中间件</span><br>    group.middlewares = <span class="hljs-built_in">append</span>(group.middlewares, handlerFunc...)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/context.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// origin objects</span><br>    Req    *http.Request<br>    Writer http.ResponseWriter<br>    <span class="hljs-comment">// request info</span><br>    Path   <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    Params <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">// response info</span><br>    StatusCode <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// middleware</span><br>    handlers []HandlerFunc <span class="hljs-comment">// 保存中间件和请求处理函数</span><br>    index    <span class="hljs-type">int</span>           <span class="hljs-comment">// 标志当前执行到第几个函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req:    req,<br>        Writer: writer,<br>        Path:   req.URL.Path,<br>        Method: req.Method,<br><br>        index: <span class="hljs-number">-1</span>, <span class="hljs-comment">// 最开始赋值为 -1，表示还没开始执行函数，下一个执行 handlers[0]</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123; <span class="hljs-comment">// 提供手动调用下一个函数的方法。</span><br>    c.index++<br>    s := <span class="hljs-built_in">len</span>(c.handlers)<br>    <span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;<br>        c.handlers[c.index](c)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Param(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Params[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>) &#123;<br>    c.Writer.Header().Set(key, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) &#123;<br>    c.StatusCode = code<br>    c.Writer.WriteHeader(code)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...))); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    c.Status(code)<br>    encoder := json.NewEncoder(c.Writer)<br>    <span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, date []<span class="hljs-type">byte</span>) &#123;<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write(date); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(html)); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            gee/router.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> &#123;<br>    roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node<br>    handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router &#123;<br>    <span class="hljs-keyword">return</span> &amp;router&#123;<br>        roots:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>        handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    <span class="hljs-keyword">if</span> _, ok := r.roots[method]; !ok &#123;<br>        r.roots[method] = &amp;node&#123;children: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node)&#125;<br>    &#125;<br><br>    r.roots[method].insert(pattern)<br><br>    key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>    r.handlers[key] = handler<br><br>    fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRouter(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">if</span> _, ok := r.roots[method]; !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r.roots[method].search(pattern)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>    node, params := r.getRouter(c.Method, c.Path)<br>    <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>        c.Params = params<br>        key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + node.path<br>        c.handlers = <span class="hljs-built_in">append</span>(c.handlers, r.handlers[key]) <span class="hljs-comment">// 将找到的 请求处理函数 加在 c.handlers 的后面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Fprintf(c.Writer, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Req.URL)<br>    &#125;<br>    c.Next() <span class="hljs-comment">// 依次执行 c.handlers 的函数。</span><br>    <span class="hljs-comment">// c.Next() 一定要放在 这里即使 404，也要执行中间件</span><br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/v1&quot;</span>)<br>    v1.Use(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        now := time.Now()<br>        ctx.Next()<br>        fmt.Println(time.Since(now))<br>    &#125;)<br><br>    user := v1.Group(<span class="hljs-string">&quot;/user&quot;</span>)<br>    user.GET(<span class="hljs-string">&quot;/hello/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        ctx.JSON(http.StatusOK, gee.H&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: ctx.Param(<span class="hljs-string">&quot;name&quot;</span>),<br>        &#125;)<br>    &#125;)<br>    <br><br>    err := r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// curl &quot;http://127.0.0.1:9999/v1/user/hello/aimtao&quot;</span><br><span class="hljs-comment">// &#123;&quot;name&quot;:&quot;aimtao&quot;&#125;</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="6-模版">6.模版</h2><h3 id="模板可以干什么">模板可以干什么</h3><p>同一个 HTML 模板，样式是一样的，但是根据后端返回的数据不同，页面展示的数据不同。</p><p>举个例子，用户个人中心页面，虽然页面布局大致相同，但是不同用户的页面上显示的用户名是不同的。这就是根据后端返回的不同数据，基于同一个模板来渲染的。</p><h3 id="如何实现-HTML-渲染">如何实现 HTML 渲染</h3><blockquote><p>Go语言内置了<code>text/template</code>和<code>html/template</code>2个模板标准库，其中 <a href="https://golang.org/pkg/html/template/">html/template</a> 为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。</p></blockquote><p>我们需要做的就是，将 html/template 封装为 Engine 的能力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    *RouterGroup<br>    router *router<br>    groups []*RouterGroup<br><br>    <span class="hljs-comment">// for html render</span><br>    htmlTemplates *template.Template <span class="hljs-comment">// 将所有模板加载进内存</span><br>    funcMap       template.FuncMap   <span class="hljs-comment">// 模板的渲染函数(可自定义多个)</span><br>&#125;<br><br><span class="hljs-comment">// SetFuncMap 设置渲染函数，可以在模板中指定，某个数据使用某个渲染函数</span><br><span class="hljs-comment">// 传入的 template.FuncMap，一个 map，保存了渲染函数对应的名称，在模板中使用名称即可指定渲染函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> SetFuncMap(funcMap template.FuncMap) &#123;<br>    engine.funcMap = funcMap<br>&#125;<br><br><span class="hljs-comment">// LoadHTMLGlob 指定模板的路径，将模板加载到内存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> LoadHTMLGlob(pattern <span class="hljs-type">string</span>) &#123;<br>    engine.htmlTemplates = template.New(<span class="hljs-string">&quot;&quot;</span>)<br>    engine.htmlTemplates.Funcs(engine.funcMap)<br>    engine.htmlTemplates = template.Must(engine.htmlTemplates.ParseGlob(pattern))<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在 context 中，重新改造 HTML 函数。让 htmlTemplates 来响应请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/context.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>, data <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br><br>    <span class="hljs-comment">// context 需要保存 Engine 指针，以便可以访问 htmlTemplates</span><br>    err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        c.Fail(<span class="hljs-number">500</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板格式如下，其中，<code>&#123;&#123;.title&#125;&#125;</code> 表示 title 变量填充在这个位置，<code>&#123;&#123;.now | FormatAsDate&#125;&#125;</code> 表示 now 变量数据经过 FormatAsDate 函数处理之后填充在这个位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- templates/custom_func.tmpl&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;html&gt;</span><br><span class="hljs-comment">&lt;body&gt;</span><br><span class="hljs-comment">    &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;/p&gt;</span><br><span class="hljs-comment">    &lt;p&gt;Date: &#123;&#123;.now | FormatAsDate&#125;&#125;&lt;/p&gt;</span><br><span class="hljs-comment">&lt;/body&gt;</span><br><span class="hljs-comment">&lt;/html&gt;</span><br></code></pre></td></tr></table></figure><p>最后，main 函数中设置自定义函数、传入 gee.H。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FormatAsDate</span><span class="hljs-params">(t time.Time)</span></span> <span class="hljs-type">string</span> &#123;  <span class="hljs-comment">// 传入的数据按照这个方式渲染</span><br>    year, month, day := t.Date()<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d-%02d-%02d&quot;</span>, year, month, day)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br>    <br>    r.SetFuncMap(template.FuncMap&#123;  <span class="hljs-comment">// 设置自定义渲染函数</span><br>        <span class="hljs-string">&quot;FormatAsDate&quot;</span>: FormatAsDate,<br>    &#125;)<br>    r.LoadHTMLGlob(<span class="hljs-string">&quot;templates/*&quot;</span>)  <span class="hljs-comment">// 加载模板路径</span><br><br>    r.GET(<span class="hljs-string">&quot;/date&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;custom_func.tmpl&quot;</span>, gee.H&#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;gee&quot;</span>,<br>            <span class="hljs-string">&quot;now&quot;</span>:   time.Date(<span class="hljs-number">2019</span>, <span class="hljs-number">8</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br>        &#125;)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">curl 127.0.0.1:9999/date</span><br><span class="hljs-comment">&lt;html&gt;</span><br><span class="hljs-comment">&lt;body&gt;</span><br><span class="hljs-comment">    &lt;p&gt;hello, gee&lt;/p&gt;</span><br><span class="hljs-comment">    &lt;p&gt;Date: 2019-08-17&lt;/p&gt;</span><br><span class="hljs-comment">&lt;/body&gt;</span><br><span class="hljs-comment">&lt;/html&gt;%</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="如何在模板中使用静态文件">如何在模板中使用静态文件</h3><p>在渲染 html 文件的同时，还会需要加载一些静态文件，比如 css、js 文件。</p><p>需要提供给用户 Static 方法，使用 Static 方法配置完成后，用户访问 localhost:9999/assets/css/index.css，最终返回 /usr/static/css/index.css。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br>r.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;/usr/static/&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Static 方法需要做什么工作？</strong></p><ol><li>通过拼接得到路由路径 “/assets/*filepath”。</li><li>创建路由处理函数 handler。</li><li>添加路由映射 RouterGroup.GET。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-comment">//Static 例如 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Static(relativePath <span class="hljs-type">string</span>, root <span class="hljs-type">string</span>) &#123;<br>    urlPattern := path.Join(relativePath, <span class="hljs-string">&quot;/*filepath&quot;</span>)                <span class="hljs-comment">// 1.拼接路径，例如得到 &quot;/assets/*filepath&quot;</span><br>    handler := group.createStaticHandler(relativePath, http.Dir(root)) <span class="hljs-comment">// 2.得到路由处理函数 handler</span><br>    group.GET(urlPattern, handler)                                     <span class="hljs-comment">// 3.添加路由映射，例如将路由地址 &quot;/assets/*filepath&quot; 和处理函数 handler 相绑定。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个 handler 应该具有什么能力？</strong></p><ol><li>先去掉所有前缀，只剩下文件路径。例如 localhost:9999/assets/css/index.css 去掉前缀后是，css/index.css</li><li>在 /usr/static/ 的目录下，建立文件系统，在文件系统中打开 css/index.css。</li></ol><p>其中，第一点，去掉所有路径可以由 http.StripPrefix 完成；第二点，建立文件系统打开文件可以由 http.FileServer 完成。我们只需要封装一个这样的 handler。</p><p><strong>如何封装？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/gee.go</span><br><br><span class="hljs-comment">// createStaticHandler 例如获取路由地址 &quot;/assets/*filepath&quot; 的处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> createStaticHandler(relativePath <span class="hljs-type">string</span>, fs http.FileSystem) HandlerFunc &#123;<br>    absolutePath := path.Join(group.prefix, relativePath) <span class="hljs-comment">// 拼接上路由分组的前缀, 例如 &quot;/user&quot; + &quot;/assets&quot;, 即得到完整前缀，不包含实际文件路径</span><br>    <br>    <span class="hljs-comment">/* fileServer 是一个handler 接口类型变量，它的功能是：</span><br><span class="hljs-comment">            1.将请求的 URL 中的前缀 absolutePath 去掉得到文件路径</span><br><span class="hljs-comment">            2.将文件路径交给 http.FileServer(fs) 这个handler 来打开。</span><br><span class="hljs-comment">     */</span><br>    fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span> &#123;<br>        file := ctx.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>        <span class="hljs-keyword">if</span> _, err := fs.Open(file); err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.Status(http.StatusNotFound)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fileServer.ServeHTTP(ctx.Writer, ctx.Req)   <span class="hljs-comment">// 这里调用 fileServer.ServeHTTP，实际在调用 fileServer 函数本身。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有趣的函数式编程">有趣的函数式编程</h3><p>功能实现后，进一步看原码，会发现这里函数式编程很有意思。</p><ul><li><p>首先, 明确流程</p></li><li><p>http.StripPrefix 返回一个 HandlerFunc 类型函数 到 handler 接口类型变量 fileServer 中,  当下文调用 fileServer.ServeHTTP 时，就会执行这个 handler。（http.StripPrefix 是包装作用，<a href="https://www.aimtao.net/go#6-4-3-%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">统一处理错误</a> 也使用了这种用法）</p></li><li><p>为什么？因为 fileServer 底层是 HandlerFunc 类型，HandlerFunc 实现了 ServeHTTP 函数，调用 ServeHTTP 时就是在调用自己 HandlerFunc。这里讲过：<a href="https://www.aimtao.net/7days-web/#%E5%A6%82%E4%BD%95%E6%8E%A5%E7%AE%A1-HTTP-%E8%AF%B7%E6%B1%82">如何接管-HTTP-请求</a></p></li><li><p>其次, fileServer 这个 handle 做什么工作？</p><ul><li><p>在请求地址中，删除完整的前缀 absolutePath（例如 “/user/assets”），剩下文件路径（例如：/css/index.css）</p></li><li><p>用剩下的文件路径作为 URL 再构造一个 request，让 http.FileServer(fs) 来处理。（http.FileServer(fs)) 是一个 handler，也是一个文件系统）</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StripPrefix</span><span class="hljs-params">(prefix <span class="hljs-type">string</span>, h Handler)</span></span> Handler &#123;<br>    <span class="hljs-keyword">if</span> prefix == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> h<br>    &#125;<br>    <span class="hljs-keyword">return</span> HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;  <span class="hljs-comment">// 返回一个  HandlerFunc 函数</span><br>        p := strings.TrimPrefix(r.URL.Path, prefix)<br>        rp := strings.TrimPrefix(r.URL.RawPath, prefix)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) &lt; <span class="hljs-built_in">len</span>(r.URL.Path) &amp;&amp; (r.URL.RawPath == <span class="hljs-string">&quot;&quot;</span> || <span class="hljs-built_in">len</span>(rp) &lt; <span class="hljs-built_in">len</span>(r.URL.RawPath)) &#123;<br>            r2 := <span class="hljs-built_in">new</span>(Request)<br>            *r2 = *r<br>            r2.URL = <span class="hljs-built_in">new</span>(url.URL)<br>            *r2.URL = *r.URL<br>            r2.URL.Path = p<br>            r2.URL.RawPath = rp<br>            h.ServeHTTP(w, r2)  <span class="hljs-comment">// 构造新的请求 r2， 交给 h 去处理</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NotFound(w, r)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后，http.FileServer(fs) 这个  handler 做什么工作？<ul><li>主要是打开文件，http.FileServer(fs) 底层是 fileHandler 类型，打开文件的具体实现在 fileHandler 的 ServeHTTP 方法里。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// net/http/fs.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileServer</span><span class="hljs-params">(root FileSystem)</span></span> Handler &#123;<br>    <span class="hljs-keyword">return</span> &amp;fileHandler&#123;root&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *fileHandler)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;<br>    upath := r.URL.Path<br>    <span class="hljs-keyword">if</span> !strings.HasPrefix(upath, <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>        upath = <span class="hljs-string">&quot;/&quot;</span> + upath<br>        r.URL.Path = upath<br>    &#125;<br>    serveFile(w, r, f.root, path.Clean(upath), <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-6">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_6_template[geeweb]<br>├── gee<br>│   ├── context.go<br>│   ├── gee.go<br>│   ├── router.go   <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>│   └── trie.go   <span class="hljs-comment"># 未更改，与上一节代码相同</span><br>├── static  <span class="hljs-comment"># 存放静态文件</span><br>│   └── css<br>│       └── index.css<br>├── templates  <span class="hljs-comment"># 存放模板文件</span><br>│   ├── array.tmpl<br>│   ├── css.tmpl<br>│   └── custom_func.tmpl<br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/gee.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;geeweb/gee&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span><br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    *RouterGroup<br>    router *router<br>    groups []*RouterGroup<br><br>    <span class="hljs-comment">// for html render</span><br>    htmlTemplates *template.Template <span class="hljs-comment">// 将所有模板加载进内存</span><br>    funcMap       template.FuncMap   <span class="hljs-comment">// 模板的渲染函数(可自定义)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    engine := &amp;Engine&#123;router: newRouter()&#125;<br>    engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;<br>    engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;<br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><br>    <span class="hljs-keyword">var</span> middlewares []HandlerFunc<br>    <span class="hljs-keyword">for</span> _, group := <span class="hljs-keyword">range</span> engine.groups &#123;<br>        prefix := group.prefix + <span class="hljs-string">&quot;/&quot;</span><br>        <span class="hljs-keyword">if</span> strings.HasPrefix(req.URL.Path, prefix) &#123;<br>            middlewares = <span class="hljs-built_in">append</span>(middlewares, group.middlewares...)<br>        &#125;<br>    &#125;<br><br>    context := NewContext(w, req)<br>    context.handlers = middlewares<br>    context.engine = engine<br>    engine.router.handle(context)<br>&#125;<br><br><span class="hljs-comment">// SetFuncMap 设置渲染函数，可以在模板中指定，某个数据使用某个渲染函数</span><br><span class="hljs-comment">// 传入的 template.FuncMap，一个 map，保存了渲染函数对应的名称，在模板中使用名称即可指定渲染函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> SetFuncMap(funcMap template.FuncMap) &#123;<br>    engine.funcMap = funcMap<br>&#125;<br><br><span class="hljs-comment">// LoadHTMLGlob 指定模板的路径，将模板加载到内存中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> LoadHTMLGlob(pattern <span class="hljs-type">string</span>) &#123;<br>    engine.htmlTemplates = template.New(<span class="hljs-string">&quot;&quot;</span>)<br>    engine.htmlTemplates.Funcs(engine.funcMap)<br>    engine.htmlTemplates = template.Must(engine.htmlTemplates.ParseGlob(pattern))<br>&#125;<br><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    prefix      <span class="hljs-type">string</span><br>    middlewares []HandlerFunc<br>    engine      *Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(prefix <span class="hljs-type">string</span>) *RouterGroup &#123;<br>    newGroup := &amp;RouterGroup&#123;<br>        prefix: group.prefix + prefix,<br>        engine: group.engine,<br>    &#125;<br>    group.engine.groups = <span class="hljs-built_in">append</span>(group.engine.groups, newGroup)<br>    <span class="hljs-keyword">return</span> newGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    pattern = group.prefix + pattern<br>    group.engine.router.addRoute(method, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>    group.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Use(handlerFunc ...HandlerFunc) &#123;<br>    group.middlewares = <span class="hljs-built_in">append</span>(group.middlewares, handlerFunc...)<br>&#125;<br><br><span class="hljs-comment">//Static 例如 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Static(relativePath <span class="hljs-type">string</span>, root <span class="hljs-type">string</span>) &#123;<br>    urlPattern := path.Join(relativePath, <span class="hljs-string">&quot;/*filepath&quot;</span>)                <span class="hljs-comment">// 1.拼接路径，例如得到 &quot;/assets/*filepath&quot;</span><br>    handler := group.createStaticHandler(relativePath, http.Dir(root)) <span class="hljs-comment">// 2.得到路由处理函数 handler</span><br>    group.GET(urlPattern, handler)                                     <span class="hljs-comment">// 3.添加路由映射，例如将路由地址 &quot;/assets/*filepath&quot; 和处理函数 handler 相绑定。</span><br>&#125;<br><br><span class="hljs-comment">// createStaticHandler 例如获取路由地址 &quot;/assets/*filepath&quot; 的处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> createStaticHandler(relativePath <span class="hljs-type">string</span>, fs http.FileSystem) HandlerFunc &#123;<br>    absolutePath := path.Join(group.prefix, relativePath) <span class="hljs-comment">// 拼接上路由分组的前缀, 例如 &quot;/user&quot; + &quot;/assets&quot;, 即得到完整前缀，不包含实际文件路径</span><br><br>    <span class="hljs-comment">/* fileServer 是一个handler 接口类型变量，它的功能是：</span><br><span class="hljs-comment">       1.将请求的 URL 中的前缀 absolutePath 去掉得到文件路径</span><br><span class="hljs-comment">       2.将文件路径交给 http.FileServer(fs) 这个handler 来打开。</span><br><span class="hljs-comment">    */</span><br>    fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *Context)</span></span> &#123;<br>        file := ctx.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>        <span class="hljs-keyword">if</span> _, err := fs.Open(file); err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.Status(http.StatusNotFound)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fileServer.ServeHTTP(ctx.Writer, ctx.Req) <span class="hljs-comment">// 这里调用 fileServer.ServeHTTP，实际在调用 fileServer 函数本身。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            context.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 暂且保存常用的参数</span><br>    <span class="hljs-comment">// origin objects</span><br>    Req    *http.Request<br>    Writer http.ResponseWriter<br>    <span class="hljs-comment">// request info</span><br>    Path   <span class="hljs-type">string</span><br>    Method <span class="hljs-type">string</span><br>    Params <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    <span class="hljs-comment">// response info</span><br>    StatusCode <span class="hljs-type">int</span><br>    <span class="hljs-comment">// middleware</span><br>    handlers []HandlerFunc<br>    index    <span class="hljs-type">int</span><br>    <span class="hljs-comment">// engine pointer</span><br>    engine *Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContext</span><span class="hljs-params">(writer http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<br>    <span class="hljs-keyword">return</span> &amp;Context&#123;<br>        Req:    req,<br>        Writer: writer,<br>        Path:   req.URL.Path,<br>        Method: req.Method,<br><br>        index: <span class="hljs-number">-1</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;<br>    c.index++<br>    s := <span class="hljs-built_in">len</span>(c.handlers)<br>    <span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;<br>        c.handlers[c.index](c)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Param(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> c.Params[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>) &#123;<br>    c.Writer.Header().Set(key, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) &#123;<br>    c.StatusCode = code<br>    c.Writer.WriteHeader(code)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...))); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>    c.Status(code)<br>    encoder := json.NewEncoder(c.Writer)<br>    <span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, date []<span class="hljs-type">byte</span>) &#123;<br>    c.Status(code)<br>    <span class="hljs-keyword">if</span> _, err := c.Writer.Write(date); err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Fail(code <span class="hljs-type">int</span>, err <span class="hljs-type">string</span>) &#123;<br>    c.index = <span class="hljs-built_in">len</span>(c.handlers)<br>    c.JSON(code, H&#123;<span class="hljs-string">&quot;message&quot;</span>: err&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>, data <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    c.SetHeader(<span class="hljs-string">&quot;Context-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>    c.Status(code)<br><br>    <span class="hljs-comment">// context 需要保存 Engine 指针，以便可以访问 htmlTemplates</span><br>    err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        c.Fail(<span class="hljs-number">500</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;gee/gee&quot;</span><br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FormatAsDate</span><span class="hljs-params">(t time.Time)</span></span> <span class="hljs-type">string</span> &#123;<br>    year, month, day := t.Date()<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d-%02d-%02d&quot;</span>, year, month, day)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br><br>    <span class="hljs-comment">//r.Use(func(ctx *gee.Context) &#123;</span><br>    <span class="hljs-comment">//    now := time.Now()</span><br>    <span class="hljs-comment">//    ctx.Next()</span><br>    <span class="hljs-comment">//    fmt.Println(time.Since(now))</span><br>    <span class="hljs-comment">//&#125;)</span><br><br>    r.SetFuncMap(template.FuncMap&#123;<br>        <span class="hljs-string">&quot;FormatAsDate&quot;</span>: FormatAsDate,<br>    &#125;)<br><br>    r.LoadHTMLGlob(<span class="hljs-string">&quot;templates/*&quot;</span>)<br>    r.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>)<br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;css.tmpl&quot;</span>, <span class="hljs-literal">nil</span>)<br>    &#125;)<br><br>    stu1 := &amp;student&#123;Name: <span class="hljs-string">&quot;Aim&quot;</span>, Age: <span class="hljs-number">20</span>&#125;<br>    stu2 := &amp;student&#123;Name: <span class="hljs-string">&quot;Tao&quot;</span>, Age: <span class="hljs-number">22</span>&#125;<br>    r.GET(<span class="hljs-string">&quot;/students&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;array.tmpl&quot;</span>, gee.H&#123;<br>            <span class="hljs-string">&quot;title&quot;</span>:        <span class="hljs-string">&quot;gee&quot;</span>,<br>            <span class="hljs-string">&quot;studentArray&quot;</span>: [<span class="hljs-number">2</span>]*student&#123;stu1, stu2&#125;,<br>        &#125;)<br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/date&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;<br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;custom_func.tmpl&quot;</span>, gee.H&#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;gee&quot;</span>,<br>            <span class="hljs-string">&quot;now&quot;</span>:   time.Date(<span class="hljs-number">2019</span>, <span class="hljs-number">8</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br>        &#125;)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            static/css/index.css        </div>        <div class='fold-content'>            <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            templates/array.tmpl        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello, &#123;&#123;.title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;&#123;range $index, $ele := .studentArray &#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; $index &#125;&#125;: &#123;&#123; $ele.Name &#125;&#125; is &#123;&#123; $ele.Age &#125;&#125; years old<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;&#123; end &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            templates/css.tmpl        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/assets/css/index.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>geektutu.css is loaded<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            templates/custom_func.tmpl        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello, &#123;&#123;.title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Date: &#123;&#123;.now | FormatAsDate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>        </div>    </div><h2 id="7-错误恢复">7.错误恢复</h2><h3 id="为什么需要错误恢复">为什么需要错误恢复</h3><p>当处理请求时，出现 panic 等错误会导致整个程序宕掉。为了保证整个程序仍然为其他请求提供服务，就需要进行错误恢复。</p><h3 id="如何做错误恢复">如何做错误恢复</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;exit&quot;</span>) <span class="hljs-comment">// 可以输出</span><br>    fmt.Println(<span class="hljs-string">&quot;begin&quot;</span>)      <span class="hljs-comment">// 可以输出</span><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;end&quot;</span>) <span class="hljs-comment">// 无法输出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码需要明确几点：</p><ul><li>出现 panic 错误的位置之后的代码，是无法执行的，程序会直接结束。</li><li>在结束之前依旧会执行 defer 程序。</li></ul><p>defer 程序就我们错误恢复提供了时机。我们需要在 defer 中，捕获 panic 错误，解析 error 信息，写入 log，并给用户返回 Internal Server Error。</p><p>为了保证代码的通用性，我们使用中间件的形式加入 recovery。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gee/recovery.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recovery</span><span class="hljs-params">()</span></span> HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 捕获 panic error</span><br>                log.Printf(<span class="hljs-string">&quot;%s\n\n&quot;</span>, trace(err))                                <span class="hljs-comment">// 解析 error</span><br>                c.Fail(http.StatusInternalServerError, <span class="hljs-string">&quot;Internal Server Error&quot;</span>) <span class="hljs-comment">// 给用户返回 500 错误</span><br>            &#125;<br>        &#125;()<br>        c.Next() <span class="hljs-comment">// 为了保证 defer 的正确执行顺序，务必需要写 c.Next</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中间件中使用-defer-的注意点">中间件中使用 defer 的注意点</h3><p>中间件不手动调用 Next，函数执行顺序是 中间件开始-&gt;中间件结束-&gt;路由处理函数开始-&gt;路由处理函数结束。</p><p>中间件手动调用 Next，函数执行顺序是 中间件开始-&gt;路由处理函数开始-&gt;路由处理函数结束-&gt;中间件结束。</p><p>只有手动调用 Next，才能让中间件的 defer 最后执行。举个例子，观察一下 log 输出。</p><div class='fold collapsed'>        <div class='fold-title'>            手动调用        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br>    r.Use(Test())<br><br>    r.GET(<span class="hljs-string">&quot;/b&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;b begin.&quot;</span>)<br>        ctx.JSON(http.StatusOK, gee.H&#123;<span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>&#125;)<br>        fmt.Println(<span class="hljs-string">&quot;b end.&quot;</span>)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span> gee.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Test begin.&quot;</span>)<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;Test defer.&quot;</span>)<br>        fmt.Println(<span class="hljs-string">&quot;Test end.&quot;</span>)<br>        ctx.Next()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test begin.</span><br><span class="hljs-comment">Test end.</span><br><span class="hljs-comment">b begin.</span><br><span class="hljs-comment">b end.</span><br><span class="hljs-comment">Test defer.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            不手动调用        </div>        <div class='fold-content'>            <blockquote><p>不手动调用依然可以执行下一个 HandlerFunc，是因为 Next 函数做了循环。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br>    r.Use(Test())<br><br>    r.GET(<span class="hljs-string">&quot;/b&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;b begin.&quot;</span>)<br>        ctx.JSON(http.StatusOK, gee.H&#123;<span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>&#125;)<br>        fmt.Println(<span class="hljs-string">&quot;b end.&quot;</span>)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span> gee.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Test begin.&quot;</span>)<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;Test defer.&quot;</span>)<br>        fmt.Println(<span class="hljs-string">&quot;Test end.&quot;</span>)<br>        <span class="hljs-comment">//ctx.Next()   // 未手动调用 Next</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test begin.</span><br><span class="hljs-comment">Test end.</span><br><span class="hljs-comment">Test defer.</span><br><span class="hljs-comment">b begin.</span><br><span class="hljs-comment">b end.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>        </div>    </div><h3 id="完整代码-7">完整代码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 代码结构</span><br>version_7_recovery[geeweb]<br>├── gee<br>│   ├── context.go<br>│   ├── gee.go<br>│   ├── recovery.go  <span class="hljs-comment"># 仅新增该文件</span><br>│   ├── router.go<br>│   └── trie.go<br>├── static<br>│   └── css<br>│       └── index.css<br>├── templates<br>│   ├── array.tmpl<br>│   ├── css.tmpl<br>│   └── custom_func.tmpl<br>├── go.mod<br>└── main.go<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            gee/recovery.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recovery</span><span class="hljs-params">()</span></span> HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 捕获 panic error</span><br>                log.Printf(<span class="hljs-string">&quot;%s\n\n&quot;</span>, trace(err))                                <span class="hljs-comment">// 解析 error</span><br>                c.Fail(http.StatusInternalServerError, <span class="hljs-string">&quot;Internal Server Error&quot;</span>) <span class="hljs-comment">// 给用户返回 500 错误</span><br>            &#125;<br>        &#125;()<br>        c.Next() <span class="hljs-comment">// 为了保证 defer 的正确执行顺序，务必需要写 c.Next</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-type">error</span> any)</span></span> <span class="hljs-type">string</span> &#123;<br>    message := fmt.Sprintf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-type">error</span>)<br>    <span class="hljs-keyword">var</span> pcs [<span class="hljs-number">32</span>]<span class="hljs-type">uintptr</span><br>    n := runtime.Callers(<span class="hljs-number">3</span>, pcs[:]) <span class="hljs-comment">// skip first 3 caller</span><br><br>    <span class="hljs-keyword">var</span> str strings.Builder<br>    str.WriteString(message + <span class="hljs-string">&quot;\nTraceback:&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, pc := <span class="hljs-keyword">range</span> pcs[:n] &#123;<br>        fn := runtime.FuncForPC(pc)<br>        file, line := fn.FileLine(pc)<br>        str.WriteString(fmt.Sprintf(<span class="hljs-string">&quot;\n\t%s:%d&quot;</span>, file, line))<br>    &#125;<br>    <span class="hljs-keyword">return</span> str.String()<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            main.go        </div>        <div class='fold-content'>            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;geeweb/gee&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gee.New()<br><br>    r.Use(gee.Recovery())<br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gee.Context)</span></span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文通过回答关键问题的方式，记录阅读 &lt;a href=&quot;https://geektutu.com/post/gee.html&quot;&gt;gee&lt;/a&gt; 代码过程中的思考，并做出补充和改进，其中有所借鉴 gin 框架。&lt;/p&gt;</summary>
    
    
    
    <category term="Implement From Scratch" scheme="https://www.aimtao.net/categories/Implement-From-Scratch/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="Framework" scheme="https://www.aimtao.net/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记｜Gin</title>
    <link href="https://www.aimtao.net/gin/"/>
    <id>https://www.aimtao.net/gin/</id>
    <published>2022-08-25T14:39:00.000Z</published>
    <updated>2022-08-25T14:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文探讨 Gin 的一些用法和源码。</p></blockquote><span id="more"></span><h2 id="1-Quickstart">1. Quickstart</h2><h3 id="1-1-Gin-是什么">1.1 Gin 是什么</h3><p>一个用 Go (Golang) 编写的 HTTP Web 框架。</p><h3 id="1-2-安装">1.2 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">go get -u github.com/gin-gonic/gin<br></code></pre></td></tr></table></figure><h3 id="1-3-hello-word">1.3 hello word</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()  <span class="hljs-comment">// 实例化一个 gin 的 server 实例（结构体变量）。</span><br>    r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 路由 + 方法</span><br>        c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br>            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>        &#125;)<br>    &#125;)<br>    r.Run(<span class="hljs-string">&quot;:8099&quot;</span>) <span class="hljs-comment">// 监听并在 0.0.0.0:8099 上启动服务</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>r.GET</code>第一个参数是 路由地址，第二个参数是处理函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handlers).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(relativePath <span class="hljs-type">string</span>, handlers ...HandlerFunc) IRoutes &#123;<br>    <span class="hljs-keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>gin.H</code> 实际上就是键值对 map。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// H is a shortcut for map[string]interface&#123;&#125;</span><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any<br></code></pre></td></tr></table></figure><h3 id="1-4-Default-和-New-初始化路由器的区别">1.4 Default 和 New 初始化路由器的区别</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">router := gin.New()<br><br>router := gin.Default()<br></code></pre></td></tr></table></figure><p>使用 Default 方法，会在 New 的基础上，增加两个中间件：Logger、Recovery。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Default returns an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    debugPrintWARNINGDefault()<br>    engine := New()<br>    engine.Use(Logger(), Recovery())   <span class="hljs-comment">// 增加两个中间件：Logger、Recovery。</span><br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br></code></pre></td></tr></table></figure><p>Logger、Recovery 作用分别为：</p><ul><li>Logger：打印访问日志。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[GIN] 2022/06/17 - 18:03:53 | 404 |         646ns |       127.0.0.1 | GET      <span class="hljs-string">&quot;/&quot;</span><br>[GIN] 2022/06/17 - 18:04:02 | 200 |    1.556255ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br></code></pre></td></tr></table></figure><ul><li>Recovery：如果程序中出现 panic，没加入 Recovery ，服务器会直接无响应；加入 Recovery，服务器会返回 HTTP 500 错误。</li></ul><h2 id="2-路由">2.路由</h2><h3 id="2-1-路由分组">2.1 路由分组</h3><p>对于 URL 中的重复部分，可以使用 <code>Group</code> 进行路由分组。</p><p>例如：商品的增删改查，可以使用 “/goods” 进行分组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/goods/list&quot;</span>, goodsList)   <span class="hljs-comment">// 每个 URL 都要添加 goods，繁杂。</span><br>    r.POST(<span class="hljs-string">&quot;/goods/add&quot;</span>, createGoods)<br>    r.GET(<span class="hljs-string">&quot;/goods/3&quot;</span>, goodsDetail)<br>    r.Run()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routerWithGroup</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    routerGroup := r.Group(<span class="hljs-string">&quot;/goods&quot;</span>)   <span class="hljs-comment">// 路由分组</span><br>    &#123;  <span class="hljs-comment">// 将路由分组下的代码用括号括在一起，只是为了代码的易读性，可不加&#123;&#125;。</span><br>        routerGroup.GET(<span class="hljs-string">&quot;/list&quot;</span>, goodsList)  <span class="hljs-comment">// 访问：ip:8080/goods/list</span><br>        routerGroup.POST(<span class="hljs-string">&quot;/add&quot;</span>, createGoods)<br>        routerGroup.GET(<span class="hljs-string">&quot;/3&quot;</span>, goodsDetail)<br>    &#125;<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodsDetail</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createGoods</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodsList</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>例如：不同版本的 API，使用 “/v1” 和 “v2” 进行分组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routerWithGroup</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    v1 := r.Group(<span class="hljs-string">&quot;/v1&quot;</span>)  <span class="hljs-comment">// v1 版本 API</span><br>    &#123;<br>        v1.GET(<span class="hljs-string">&quot;/login&quot;</span>, login)  <span class="hljs-comment">// 访问：ip:8080/v1/login</span><br>        v1.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submit)<br>        v1.GET(<span class="hljs-string">&quot;/read&quot;</span>, read)<br>    &#125;<br><br>    v2 := r.Group(<span class="hljs-string">&quot;/v2&quot;</span>)   <span class="hljs-comment">// v2 版本 API</span><br>    &#123;<br>        v2.GET(<span class="hljs-string">&quot;/login&quot;</span>, login2)<br>        v2.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submit2)<br>        v2.GET(<span class="hljs-string">&quot;/read&quot;</span>, read2)<br>    &#125;<br><br>    r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-获取-URL-参数">2.2 获取 URL 参数</h3><p>路由中使用 <code>:id</code> 来匹配参数，使用 <code>*path</code> 来匹配路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    goodsGroup := r.Group(<span class="hljs-string">&quot;/goods&quot;</span>)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           URL:  http://127.0.0.1:8080/goods/3</span><br><span class="hljs-comment">           返回:  &#123;id&quot;:&quot;3&quot;&#125;</span><br><span class="hljs-comment">        */</span><br>        goodsGroup.GET(<span class="hljs-string">&quot;/:id&quot;</span>, goodsDetail)  <span class="hljs-comment">// 加一个参数 id</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           URL:  http://127.0.0.1:8080/goods/3/Add</span><br><span class="hljs-comment">           返回:  &#123;&quot;action&quot;:&quot;Add&quot;,&quot;id&quot;:&quot;3&quot;&#125;</span><br><span class="hljs-comment">        */</span><br>        goodsGroup.GET(<span class="hljs-string">&quot;/:id/:action&quot;</span>, goodsAction)  <span class="hljs-comment">// 加两个参数 id 和 action</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           URL:  http://127.0.0.1:8080/goods/file/net/aimtao/www/home/goods/file/</span><br><span class="hljs-comment">           返回:  &#123;&quot;path&quot;:&quot;/net/aimtao/www/home/goods/file/&quot;&#125;</span><br><span class="hljs-comment">        */</span><br>        goodsGroup.GET(<span class="hljs-string">&quot;/file/*path&quot;</span>, goodsFilePath)  <span class="hljs-comment">// : 只匹配到下一个 / 结束，* 直接匹配到最后</span><br>    &#125;<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodsDetail</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    id := context.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: id,<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodsAction</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    id := context.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>    action := context.Param(<span class="hljs-string">&quot;action&quot;</span>)<br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: id,<br>        <span class="hljs-string">&quot;action&quot;</span>: action,<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodsFilePath</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    path := context.Param(<span class="hljs-string">&quot;path&quot;</span>)<br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: path,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意匹配冲突，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 两个路由会冲突，输入 `http://127.0.0.1:8080/goods/list`，程序无法确认选择路由。</span><br>goodsGroup.GET(<span class="hljs-string">&quot;/list&quot;</span>, goodsList)<br>goodsGroup.GET(<span class="hljs-string">&quot;/:id&quot;</span>, goodsDetail)<br></code></pre></td></tr></table></figure><h3 id="2-3-URL-参数的表单验证">2.3 URL 参数的表单验证</h3><p>先对结构体变量用 tag 标记，形成约束条件。将 URL 中获取的参数，用 <code>context.ShouldBindUri</code> 进行验证该约束条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-comment">// uri:&quot;id&quot; 表示 Id 从 URL 参数 id 中取，参数 id 必须为 int 类型。</span><br>    <span class="hljs-comment">// binding 表示该参数的约束，required 为必选参数。</span><br>    Id <span class="hljs-type">int</span> <span class="hljs-string">`uri:&quot;id&quot; binding:&quot;required&quot;`</span><br>    <br>    <span class="hljs-comment">// uri:&quot;name&quot; 表示 Name 从 URL 参数 name 中取，参数 name 必须为 string 类型。</span><br>    <span class="hljs-comment">// binding 表示该参数的约束，required 为必选参数。</span><br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;name&quot; binding:&quot;required&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/:id/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br><br>        <span class="hljs-keyword">var</span> p Person<br>        <span class="hljs-keyword">if</span> err := context.ShouldBindUri(&amp;p); err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 从 context 中获取参数，进行验证后，赋值给 p。</span><br>            context.Status(http.StatusBadRequest)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Println(p)<br>        context.JSON(http.StatusOK, gin.H&#123;<br>            <span class="hljs-string">&quot;id&quot;</span>: p.Id,<br>            <span class="hljs-string">&quot;name&quot;</span>: p.Name,<br>        &#125;)<br>    &#125;)<br>    r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>context.ShouldBindUri</code> 的函数实现：从 context 中获取参数，进行验证后，赋值给 obj。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ShouldBindUri binds the passed struct pointer using the specified binding engine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ShouldBindUri(obj any) <span class="hljs-type">error</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> c.Params &#123;<br>        m[v.Key] = []<span class="hljs-type">string</span>&#123;v.Value&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> binding.Uri.BindUri(m, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-获取-GET-POST-参数">2.4 获取 GET/POST 参数</h3><p>GET 参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/person&quot;</span>, person)<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">person</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    id := context.Query(<span class="hljs-string">&quot;id&quot;</span>)  <span class="hljs-comment">// 获取 GET 参数 id</span><br>    name := context.DefaultQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>)  <span class="hljs-comment">// 获取 GET 参数 name，如果不存在，则使用默认值 anonymous。</span><br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: id,<br>        <span class="hljs-string">&quot;name&quot;</span>: name,<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    curl http://127.0.0.1:8080/person?id=1&amp;name=hh</span><br><span class="hljs-comment">    &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hh&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>POST 参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.POST(<span class="hljs-string">&quot;/person&quot;</span>, person)<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">person</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    id := context.PostForm(<span class="hljs-string">&quot;id&quot;</span>)  <span class="hljs-comment">// 获取 POST 参数 id</span><br>    name := context.DefaultPostForm(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>)  <span class="hljs-comment">// 获取 POST 参数 name，如果不存在，则使用默认值 anonymous。</span><br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: id,<br>        <span class="hljs-string">&quot;name&quot;</span>: name,<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    curl -X POST -d &quot;id=1&amp;name=hh&quot; http://127.0.0.1:8080/person</span><br><span class="hljs-comment">    &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hh&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>GET 和 POST 混合参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.POST(<span class="hljs-string">&quot;/person&quot;</span>, person)<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">person</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    id := context.Query(<span class="hljs-string">&quot;id&quot;</span>)  <span class="hljs-comment">// 获取 GET 参数</span><br>    name := context.DefaultPostForm(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>)  <span class="hljs-comment">// 获取 POST 参数</span><br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: id,<br>        <span class="hljs-string">&quot;name&quot;</span>: name,<br>    &#125;)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    curl -X POST -d &quot;name=hh&quot; http://127.0.0.1:8080/person?id=1</span><br><span class="hljs-comment">    &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hh&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="2-5-返回-JSON-和-ProtoBuf">2.5 返回 JSON 和 ProtoBuf</h3><p>除了使用 <code>gin.H</code> 返回 JSON，还可以返回整个 struct 作为 JSON。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/JSON&quot;</span>, returnJSON)<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnJSON</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> person <span class="hljs-keyword">struct</span>&#123;<br>        Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>        Age <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot;`</span><br>    &#125;<br>    person.Name = <span class="hljs-string">&quot;h&quot;</span><br>    person.Age  = <span class="hljs-number">10</span><br>    context.JSON(http.StatusOK, person)  <span class="hljs-comment">// 返回整个 struct</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    curl http://127.0.0.1:8080/JSON</span><br><span class="hljs-comment">    &#123;&quot;name&quot;:&quot;h&quot;,&quot;age&quot;:10&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>先定义 proto 文件，在生成处理 protobuf 的 bg.go 文件，其中包含  struct 的定义。初始化该 struct，并使用 <code>context.ProtoBuf</code> 返回即可。</p><p>注意：此处需传递实例化的 struct 地址。</p><p>为什么 <code>context.ProtoBuf</code> 需要传地址，而 <code>context.JSON</code> 不需要？</p><ul><li><code>context.JSON</code> 需要接收一个结构体，并将其处理为字符串即可。</li><li><code>context.ProtoBuf</code> 需要接收一个结构体指针，用这个指针去调用 <code>protoreflect.ProtoMessage</code> 方法。（bp.go 中，该结构体实现了 ProtoMessage 接口。）最终转化为 protobuf 格式。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r:= gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/Protobuf&quot;</span>, returnProtobuf)<br>    r.Run()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnProtobuf</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    course := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;go&quot;</span>,<span class="hljs-string">&quot;rpc&quot;</span>, <span class="hljs-string">&quot;gin&quot;</span>&#125;<br>    p := proto.Person&#123;<br>        Name: <span class="hljs-string">&quot;hh&quot;</span>,<br>        Course: course,<br>    &#125;<br>    context.ProtoBuf(http.StatusOK, &amp;p)  <span class="hljs-comment">// 注意：此处需传递实例化的 struct 地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-使用-validator-进行表单验证">2.6 使用 validator 进行表单验证</h3><p>gin 使用 <a href="https://github.com/go-playground/validator#usage-and-documentation">go-playground/validator</a> 验证参数。gin 将其封装成两套绑定方法。</p><ul><li><p>Must bind</p><ul><li>Methods：<code>Bind</code>、<code>BindJSON</code>、<code>BindXML</code>、<code>BindQuery</code>、<code>BindYAML</code></li><li>Behavior：这些方法底层使用 <code>MustBindWith</code>，如果验证错误，请求会被 <code>c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind)</code> 中止请求，响应状态码会设置为 400。（如果想自定义处理错误和请求响应，应使用 ShouldBind）</li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MustBindWith binds the passed struct pointer using the specified binding engine.</span><br><span class="hljs-comment">// It will abort the request with HTTP 400 if any error occurs.</span><br><span class="hljs-comment">// See the binding package.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> MustBindWith(obj any, b binding.Binding) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> err := c.ShouldBindWith(obj, b); err != <span class="hljs-literal">nil</span> &#123;<br>        c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) <span class="hljs-comment">//nolint: errcheck</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Should bind</p><ul><li>Methods：<code>ShouldBind</code>、<code>ShouldBindJSON</code>、<code>ShouldBindXML</code>、<code>ShouldBindQuery</code>、<code>ShouldBindYAML</code></li><li>Behavior：这些方法底层使用 <code>ShouldBindWith</code>，如果验证错误，则返回错误，由开发人员自定义处理错误和请求响应。</li></ul></li></ul><p>当调用  <code>Bind</code>、<code>ShouldBind</code> 两种方法时，Gin 会根据求的 Method 和 Content-Type 推断使用哪种绑定器，然后使用 <code>ShouldBindWith(obj any, b binding.Binding)</code> 或 <code>BindWith(obj any, b binding.Binding)</code>。具体如何调用及推断的逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ShouldBind checks the Method and Content-Type to select a binding engine automatically,</span><br><span class="hljs-comment">// Depending on the &quot;Content-Type&quot; header different bindings are used, for example:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    &quot;application/json&quot; --&gt; JSON binding</span><br><span class="hljs-comment">//    &quot;application/xml&quot;  --&gt; XML binding</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It parses the request&#x27;s body as JSON if Content-Type == &quot;application/json&quot; using JSON or XML as a JSON input.</span><br><span class="hljs-comment">// It decodes the json payload into the struct specified as a pointer.</span><br><span class="hljs-comment">// Like c.Bind() but this method does not set the response status code to 400 or abort if input is not valid.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ShouldBind(obj any) <span class="hljs-type">error</span> &#123;<br>    b := binding.Default(c.Request.Method, c.ContentType())   <span class="hljs-comment">// 推断使用哪种绑定器</span><br>    <span class="hljs-keyword">return</span> c.ShouldBindWith(obj, b)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Content-Type MIME of the most common data formats.</span><br><span class="hljs-keyword">const</span> (<br>    MIMEJSON              = <span class="hljs-string">&quot;application/json&quot;</span><br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">// Default returns the appropriate Binding instance based on the HTTP method</span><br><span class="hljs-comment">// and the content type.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">(method, contentType <span class="hljs-type">string</span>)</span></span> Binding &#123;<br>   <span class="hljs-keyword">if</span> method == http.MethodGet &#123;  <span class="hljs-comment">// GET 方法使用 ShouldBindForm 方法</span><br>        <span class="hljs-keyword">return</span> Form<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> contentType &#123;   <span class="hljs-comment">// 根据 contentType 判断使用哪种绑定器</span><br>    <span class="hljs-keyword">case</span> MIMEJSON:<br>        <span class="hljs-keyword">return</span> JSON<br>    <span class="hljs-keyword">case</span> MIMEXML, MIMEXML2:<br>        <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p><strong>举个例子</strong>： 对注册的表单进行验证。</p><ul><li>SignUpForm 使用 tag 配置约束条件。</li><li>使用 <code>context.ShouldBind(&amp;signUpForm)</code> 进行表单验证。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> SignUpForm <span class="hljs-keyword">struct</span> &#123;<br>    Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot; form:&quot;username&quot; binding:&quot;required,max=10&quot;`</span>  <span class="hljs-comment">// 约束条件:必填、最大长度10</span><br>    Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot; form:&quot;password&quot; binding:&quot;required,min=6&quot;`</span>  <span class="hljs-comment">// 约束条件:必填、最小长度6</span><br>    RePassword <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;repassword&quot; form:&quot;repassword&quot; binding:&quot;required,eqfield=Password&quot;`</span> <span class="hljs-comment">// 约束条件:必填、等于 Password 字段</span><br>    Age <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot; form:&quot;age&quot; binding:&quot;required&quot;`</span>  <span class="hljs-comment">// 约束条件:必填</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot; form:&quot;email&quot; binding:&quot;required,email&quot;`</span> <span class="hljs-comment">// 约束条件:必填、检查是否是邮箱</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gin.Default()<br>    engine.POST(<span class="hljs-string">&quot;SignUp&quot;</span>, Login)<br>    engine.Run(<span class="hljs-string">&quot;:8083&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Login</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> signUpForm SignUpForm<br><br>    <span class="hljs-comment">// 表单验证，验证不通过，ShouldBind 会返回 error。</span><br>    <span class="hljs-comment">// ShouldBind 会根据请求的 Method 和 Content-Type，自动选择 JSON、XML、Query 等等，此处会调用 ShouldBindJSON</span><br>    <span class="hljs-keyword">if</span> err := context.ShouldBind(&amp;signUpForm); err != <span class="hljs-literal">nil</span> &#123;<br>        context.JSON(http.StatusBadRequest, gin.H&#123;<br>            <span class="hljs-string">&quot;error&quot;</span>: err.Error(),<br>        &#125;)<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 验证错误记得 return，否则会在继续往下执行。</span><br>    &#125;<br><br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;signup success&quot;</span>,<br>        <span class="hljs-string">&quot;user&quot;</span>: signUpForm.Username,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>当有不符合条件的访问时，会返回 400 及错误原因。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## Request</span><br>curl -X <span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-string">&quot;http://127.0.0.1:8083/SignUp&quot;</span> \<br>     -H <span class="hljs-string">&#x27;Content-Type: application/json; charset=utf-8&#x27;</span> \<br>     -d $<span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;username&quot;: &quot;Tom&quot;,</span><br><span class="hljs-string">  &quot;password&quot;: &quot;123456&quot;,</span><br><span class="hljs-string">   &quot;repassword&quot;: &quot;12345&quot;,   # 重复密码不一致</span><br><span class="hljs-string">  &quot;age&quot;: 18,</span><br><span class="hljs-string">  &quot;email&quot;: &quot;123@123.com&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span><br><br><br><span class="hljs-comment"># 返回错误</span><br>HTTP/1.1 400 Bad Request<br>Content-Length: 108<br>Content-Type: text/plain; charset=utf-8<br>Connection: close<br><br>&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-string">&quot;Key: &#x27;SignUpForm.RePassword&#x27; Error:Field validation for &#x27;RePassword&#x27; failed on the &#x27;eqfield&#x27; tag&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-为-validator-配置翻译器">2.7 为 validator 配置翻译器</h3><ol><li>初始化语言环境</li><li>传入 语言环境，初始化通用翻译器</li><li>从通用翻译器中拿出中文翻译器</li><li>绑定中文验证器和翻译器</li><li>将验证器返回的 Error 转换为 <code>validator.ValidationErrors</code>，这样  Error 就有了 Translate 方法</li><li>使用 Translate 方法</li></ol><p>具体流程参照代码阅读。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin/binding&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-playground/locales/en&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-playground/locales/zh&quot;</span><br>    ut <span class="hljs-string">&quot;github.com/go-playground/universal-translator&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-playground/validator/v10&quot;</span><br>    en2 <span class="hljs-string">&quot;github.com/go-playground/validator/v10/translations/en&quot;</span><br>    zh2 <span class="hljs-string">&quot;github.com/go-playground/validator/v10/translations/zh&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> SignUpForm <span class="hljs-keyword">struct</span> &#123;<br>    Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot; form:&quot;username&quot; binding:&quot;required,max=10&quot;`</span>  <span class="hljs-comment">// 约束条件:必填、最大长度10</span><br>    Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot; form:&quot;password&quot; binding:&quot;required,min=6&quot;`</span>  <span class="hljs-comment">// 约束条件:必填、最小长度6</span><br>    RePassword <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;repassword&quot; form:&quot;repassword&quot; binding:&quot;required,eqfield=Password&quot;`</span> <span class="hljs-comment">// 约束条件:必填、等于 Password 字段</span><br>    Age <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot; form:&quot;age&quot; binding:&quot;required&quot;`</span>  <span class="hljs-comment">// 约束条件:必填</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot; form:&quot;email&quot; binding:&quot;required,email&quot;`</span> <span class="hljs-comment">// 约束条件:必填、检查是否是邮箱</span><br>&#125;<br><br><span class="hljs-keyword">var</span> translator ut.Translator  <span class="hljs-comment">// 定义全局的翻译器</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gin.Default()<br>    err := InitTrans(<span class="hljs-string">&quot;zh&quot;</span>)  <span class="hljs-comment">// 初始化中文翻译器</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    engine.POST(<span class="hljs-string">&quot;SignUp&quot;</span>, Login)<br>    engine.Run(<span class="hljs-string">&quot;:8083&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitTrans</span><span class="hljs-params">(locale <span class="hljs-type">string</span>)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>    translatorZh := zh.New()  <span class="hljs-comment">// 中文环境   //【1.初始化中文翻译器】</span><br>    translatorEn := en.New()  <span class="hljs-comment">// 英文环境</span><br>    uni := ut.New(translatorZh, translatorEn, translatorZh)  <span class="hljs-comment">// 【2.传入语言环境，初始化通用翻译器】  // 通用翻译器保存所有的语言环境和翻译数据。第一个参数是备用的语言环境，后面是应支持的语言环境</span><br>    <span class="hljs-keyword">var</span> found <span class="hljs-type">bool</span><br>    translator, found = uni.GetTranslator(locale)  <span class="hljs-comment">// 【3.根据 locale 拿到最终的翻译器】</span><br>    <span class="hljs-keyword">if</span> !found &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;uni.GetTranslator(%s)&quot;</span>, locale)<br>    &#125;<br><br>    <span class="hljs-comment">// 拿到 gin 的验证器</span><br>    validate := binding.Validator.Engine().(*validator.Validate)<br><br>    <span class="hljs-comment">// 【4.根据 locale，绑定验证器和翻译器】</span><br>    <span class="hljs-keyword">switch</span> locale &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;en&quot;</span>:<br>        err = en2.RegisterDefaultTranslations(validate, translator)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;zh&quot;</span>:<br>        err = zh2.RegisterDefaultTranslations(validate, translator)<br>    <span class="hljs-keyword">default</span>:<br>        err = en2.RegisterDefaultTranslations(validate, translator)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Login</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> signUpForm SignUpForm<br><br>    <span class="hljs-comment">// 表单验证，验证不通过，ShouldBind 会返回 error。</span><br>    <span class="hljs-comment">// ShouldBind 会根据请求的 Method 和 Content-Type，自动选择 JSON、XML、Query 等等，此处会调用 ShouldBindJSON</span><br>    <span class="hljs-keyword">if</span> err := context.Bind(&amp;signUpForm); err != <span class="hljs-literal">nil</span> &#123;<br>        errors := err.(validator.ValidationErrors)  <span class="hljs-comment">// 【5.类型转换为 validator.ValidationErrors】</span><br>        context.JSON(http.StatusOK, gin.H&#123;<br>            <span class="hljs-string">&quot;error&quot;</span>: errors.Translate(translator),  <span class="hljs-comment">// 【6.使用 Translate 方法】</span><br>        &#125;)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;signup success&quot;</span>,<br>        <span class="hljs-string">&quot;user&quot;</span>: signUpForm.Username,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>当有不符合条件的访问时，错误原因被翻译成中文。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## Request</span><br>curl -X <span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-string">&quot;http://127.0.0.1:8083/SignUp&quot;</span> \<br>     -H <span class="hljs-string">&#x27;Content-Type: application/json; charset=utf-8&#x27;</span> \<br>     -d $<span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;username&quot;: &quot;Tom&quot;,</span><br><span class="hljs-string">  &quot;password&quot;: &quot;123456&quot;,</span><br><span class="hljs-string">   &quot;repassword&quot;: &quot;12345&quot;,   # 重复密码不一致</span><br><span class="hljs-string">  &quot;age&quot;: 18,</span><br><span class="hljs-string">  &quot;email&quot;: &quot;123.com&quot;  # 邮箱格式错误 </span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span><br><br><br><span class="hljs-comment"># 返回错误</span><br>HTTP/1.1 400 Bad Request<br>Content-Length: 108<br>Content-Type: text/plain; charset=utf-8<br>Connection: close<br><br>&#123;<br>    <span class="hljs-string">&quot;error&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;SignUpForm.Email&quot;</span>:<span class="hljs-string">&quot;Email必须是一个有效的邮箱&quot;</span>,<br>        <span class="hljs-string">&quot;SignUpForm.RePassword&quot;</span>:<span class="hljs-string">&quot;RePassword必须等于Password&quot;</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-更改验证错误字段格式">2.8 更改验证错误字段格式</h3><p>上述错误原因虽然是中文的，但是字段格式不是 json 格式的。期望返回的是这样的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>    <span class="hljs-string">&quot;error&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;email必须是一个有效的邮箱&quot;</span>,<br>        <span class="hljs-string">&quot;repassword&quot;</span>:<span class="hljs-string">&quot;repassword必须等于password&quot;</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>主要需要做两件事：</p><ul><li><p>验证时，字段使用 tag 配置中的 json 格式。</p><p>在拿到 gin 的验证器时，注册一个获取 Tag Name 的方法</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 拿到 gin 的验证器</span><br>validate := binding.Validator.Engine().(*validator.Validate)<br>validate.RegisterTagNameFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(field reflect.StructField)</span></span> <span class="hljs-type">string</span> &#123;  <span class="hljs-comment">// 注册一个获取 Tag Name 的方法</span><br>    name := strings.SplitN(field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>), <span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-number">2</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment">// 获取 tag 中的 json 配置。</span><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;-&quot;</span> &#123;  <span class="hljs-comment">// 如果 tag 中的 json 配置为 - 时，说明配置为 空字符串。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> name<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>去掉 struct 名称。</p><p><code>errors.Translate(translator)</code> 返回的是 <code>ValidationErrorsTranslations</code> 类型，其实就是 <code>map[string]string</code> 类型。我们要进行字符串操作的就是这个 map 的 key。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在验证请求时</span><br><span class="hljs-keyword">if</span> err := context.Bind(&amp;signUpForm); err != <span class="hljs-literal">nil</span> &#123;<br>    errors := err.(validator.ValidationErrors) <br>    context.JSON(http.StatusOK, gin.H&#123;<br>        <span class="hljs-string">&quot;error&quot;</span>: removeTopStruct(errors.Translate(translator)),  <span class="hljs-comment">// 处理 map 的 key。</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如何处理？找到点的位置，进行切片操作。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeTopStruct</span><span class="hljs-params">(fields <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> &#123;<br>    rsp := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> field, err := <span class="hljs-keyword">range</span> fields &#123;<br>        rsp[field[strings.Index(field, <span class="hljs-string">&quot;.&quot;</span>)+<span class="hljs-number">1</span>:]] = err  <span class="hljs-comment">// 只要点后面的字符串：找到点的位置，进行切片操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> rsp<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-中间件">3.中间件</h2><h3 id="3-1-自定义中间件">3.1 自定义中间件</h3><p>中间件可以避免代码的侵入性。gin 的中间件使用很简便，只需提供一个 gin.HandlerFunc 类型的函数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用于计时的中间件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timing</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        t := time.Now()<br>        c.Set(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;1233&quot;</span>)<br><br>        c.Next() <span class="hljs-comment">// 执行真正的请求处理函数</span><br><br>        end := time.Since(t)<br>        fmt.Println(<span class="hljs-string">&quot;Duration: &quot;</span>, end)<br>        fmt.Println(<span class="hljs-string">&quot;Writer status: &quot;</span>, c.Writer.Status())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    engine := gin.New() <span class="hljs-comment">// gin.Default() 默认使用 Logger、Recovery 两个中间件</span><br>    engine.Use(gin.Logger(), gin.Recovery(), timing()) <span class="hljs-comment">// 使用计时的中间件</span><br>    engine.GET(<span class="hljs-string">&quot;/index&quot;</span>, index)<br>    engine.Run(<span class="hljs-string">&quot;:8083&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> value, exists := c.Get(<span class="hljs-string">&quot;number&quot;</span>); exists &#123;<br>        time.Sleep(time.Second)<br>        c.JSON(http.StatusOK, gin.H&#123;<br>            <span class="hljs-string">&quot;number&quot;</span>: value,<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-中间件队列原理">3.2 中间件队列原理</h3><p><img src="http://hutu.aimtao.net/mark/2023-08-01-pSDgYZ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>如图，RouterGroup 中维护了一个队列 Handlers，并将中间件及请求处理函数依次加入其中。处理请求时，依次执行队列中的函数，并使用 index 指向正在执行的函数。</p><ul><li><code>c.Next()</code>：表示 index ++，开始执行队列中后面的函数。</li><li><code>c.Abort()</code>：表示中止队列函数的执行。<strong>所以在中间件中，使用 return 并不能中止队列函数的执行，只能结束当前函数，index 还是会向后移动，并执行后面的函数。</strong></li></ul><p>我们来具体看下源码。</p><p>RouterGroup 中，维护一个函数数组 Handlers。这里的 HandlersChain 类型就是 <code>func(*Context)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// routergroup.go</span><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>    Handlers HandlersChain<br>    basePath <span class="hljs-type">string</span><br>    engine   *Engine<br>    root     <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gin.go</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><span class="hljs-keyword">type</span> HandlersChain []HandlerFunc<br></code></pre></td></tr></table></figure><p>当需要加入中间件时，<code>gin.Use</code> -&gt; <code>RouterGroup.Use</code>，将中间件加入队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// routergroup.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Use(middleware ...HandlerFunc) IRoutes &#123;<br>    group.Handlers = <span class="hljs-built_in">append</span>(group.Handlers, middleware...)<br>    <span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要加入请求处理函数时，<code>gin.GET</code> -&gt; <code>RouterGroup.handle</code> -&gt; <code>RouterGroup.combineHandlers</code>，创建一个新的队列，将原有的中间件和请求处理函数拷贝到其中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> combineHandlers(handlers HandlersChain) HandlersChain &#123;<br>    <br>    finalSize := <span class="hljs-built_in">len</span>(group.Handlers) + <span class="hljs-built_in">len</span>(handlers) <span class="hljs-comment">// 计算新的队列长度</span><br>    assert1(finalSize &lt; <span class="hljs-type">int</span>(abortIndex), <span class="hljs-string">&quot;too many handlers&quot;</span>)<br>    <br>    mergedHandlers := <span class="hljs-built_in">make</span>(HandlersChain, finalSize) <span class="hljs-comment">// 创建新队列</span><br>    <br>    <span class="hljs-built_in">copy</span>(mergedHandlers, group.Handlers)  <span class="hljs-comment">// 向新队列中增加原来的中间件</span><br>    <span class="hljs-built_in">copy</span>(mergedHandlers[<span class="hljs-built_in">len</span>(group.Handlers):], handlers)  <span class="hljs-comment">// 向新队列的尾部，增加请求处理函数</span><br>    <span class="hljs-keyword">return</span> mergedHandlers<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-其他">4.其他</h2><h3 id="4-1-模版功能">4.1 模版功能</h3><blockquote><p><a href="https://pkg.go.dev/html/template">https://pkg.go.dev/html/template</a></p></blockquote><p>处理请求时，gin 返回模版文件+变量数据。</p><p><strong>（1）最小实践</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── main.go<br>└── templates<br>    └── index.html<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br>    router.LoadHTMLFiles(<span class="hljs-string">&quot;templates/index.html&quot;</span>) <span class="hljs-comment">// 相对路径加载 HTML 文件。</span><br>    <br>    router.GET(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;index.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 将 title 传给 index.html</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;haha&quot;</span>,<br>        &#125;)<br>    &#125;)<br>    <br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--templates/index.html--&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 使用 gin 传递过来的 title。注意格式 &#123;&#123;.变量名&#125;&#125; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意相对路径问题：</p><ul><li>上述代码中，使用 <code>&quot;templates/index.html&quot;</code> 相对路径，直接在 IDE 中使用 go run 无法获取到相当路径，需要在当前路径下  go build 出可执行文件，再执行。</li><li>原因：go run 执行时，所在的目录是临时目录。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">dir, _ := filepath.Abs(filepath.Dir(os.Args[<span class="hljs-number">0</span>]))<br>fmt.Println(<span class="hljs-string">&quot;dir: &quot;</span>, dir)<br><br><span class="hljs-comment">// output：</span><br><span class="hljs-comment">// dir:  /private/var/folders/hr/2w_2q41n7mvb9jv1vrjsrzmh0000gn/T/GoLand  // 临时目录</span><br></code></pre></td></tr></table></figure><p><strong>（2）同时加载多个 HTML</strong></p><p>文件过多，可以使用 <code>LoadHTMLGlob</code> 加载整个目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── main.go<br>└── templates<br>    ├── goods.html<br>    └── index.html<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br>    router.LoadHTMLGlob(<span class="hljs-string">&quot;templates/*&quot;</span>) <span class="hljs-comment">// 加载整个目录下所有文件</span><br>    <span class="hljs-comment">// router.LoadHTMLFiles(&quot;templates/index.html&quot;, &quot;templates/goods.html&quot;) // 可变参数列表，一个一个加载</span><br><br>    router.GET(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;index.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 将 title 传给 index.html</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;haha&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.GET(<span class="hljs-string">&quot;/goods&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;goods.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 将 title 传给 goods.html</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;goods&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）处理文件名冲突问题</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── main.go<br>└── templates<br>    ├── goods<br>    │   └── list.html<br>    ├── index<br>    │   └── index.html<br>    └── user<br>        └── list.html<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br>    router.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/*&quot;</span>) <span class="hljs-comment">// 加载 templates 下的所有二级目录（只加载二级目录）</span><br><br>    router.GET(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;index/index.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 使用 /templates/index/index.html 中 define 的值</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;haha&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.GET(<span class="hljs-string">&quot;/user/list&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;user/list.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 使用 /templates/user/list.html 中 define 的值</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;users&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.GET(<span class="hljs-string">&quot;/goods/list&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;goods/list.html&quot;</span>, gin.H&#123; <span class="hljs-comment">// 使用 /templates/goods/list.html 中 define 的值</span><br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;goods&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><div class='fold collapsed'>        <div class='fold-title'>            goods/list.html        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;define &quot;goods/list.html&quot; &#125;&#125;   <span class="hljs-comment">&lt;!--定义文件名称--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>goods<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            index/index.html        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;define &quot;index/index.html&quot; &#125;&#125;   <span class="hljs-comment">&lt;!--定义文件名称--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 使用 gin 传递过来的 title。注意格式 &#123;&#123;.变量名&#125;&#125; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><div class='fold collapsed'>        <div class='fold-title'>            user/list.html        </div>        <div class='fold-content'>            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;define &quot;user/list.html&quot; &#125;&#125;   <span class="hljs-comment">&lt;!--定义文件名称--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 使用 gin 传递过来的 title。注意格式 &#123;&#123;.变量名&#125;&#125; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure>        </div>    </div><p>其中有几个问题需要说明一下：</p><ul><li><p><code>router.LoadHTMLGlob(&quot;templates/**/*&quot;)</code> 表示只能加载 templates 下的二级目录的所有内容，此时 templates 目录下的 html 文件是无法被加载的。</p><ul><li>解决：index.html 文件，也放在二级目录 index 目录下。</li></ul></li><li><p><code>goods/list.html</code> 和 <code>user/list.html</code> 的 文件重名，在使用 context.HTML 时，均传入的 list.html，会导致其中一个会失效。</p><ul><li>解决：在 html 文件中，使用 define 定义文件名称。gin 中使用时，使用 define 的名称。</li><li>优先找 define 的名称，没有 define 定义，使用默认的 LoadHTMLGlob 来找文件。</li></ul></li></ul><h3 id="4-2-静态文件处理">4.2 静态文件处理</h3><p>html 中需要引用大量的静态文件，使用 <code>router.Static(&quot;/static&quot;, &quot;./static&quot;)</code> 指明以 /static 开头的链接，均在 ./static 目录下找。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── main.go<br>├── static<br>│   └── css<br>│       └── index.css<br>└── templates<br>    └── index.html<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br>    router.LoadHTMLGlob(<span class="hljs-string">&quot;templates/*&quot;</span>)<br>    router.Static(<span class="hljs-string">&quot;/static&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>) <span class="hljs-comment">// 以 /static 开头的链接，均在 ./static 目录下找</span><br>    router.GET(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>        context.HTML(http.StatusOK, <span class="hljs-string">&quot;index.html&quot;</span>, gin.H&#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;haha&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- /templates/index.html --&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/static/css/index.css&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 引用静态文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 使用 gin 传递过来的 title。注意格式 &#123;&#123;.变量名&#125;&#125; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*template/static/css/index.css*/</span><br>*&#123;<br>    <span class="hljs-attribute">background-color</span>: burlywood;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-gin-的优雅退出">4.3 gin 的优雅退出</h3><blockquote><p><a href="https://gin-gonic.com/docs/examples/graceful-restart-or-stop/">https://gin-gonic.com/docs/examples/graceful-restart-or-stop/</a></p></blockquote><p>优雅退出的作用：当关闭程序时，应该做一些后续处理。比如：将没保存的数据做保存、保存日志、向注册中心告知当前服务已下线等等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;os/signal&quot;</span><br>    <span class="hljs-string">&quot;syscall&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br>    router.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.JSON(http.StatusOK, gin.H&#123;<br>            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World!&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 在 goroutine 中监听，让主进程等待 channel 信号。</span><br>    &#125;()<br><br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>    <span class="hljs-comment">// SIGINT 是 Crtl+C; SIGTERM 是 kill 命令不加参数。（kill -9 是 SIGKILL 无法捕获）</span><br>    <span class="hljs-comment">// 当收到 SIGINT、SIGTERM 信号时，像 channel 中写数据。</span><br>    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br><br>    &lt;-quit <span class="hljs-comment">// channel 收到数据，说明收到结束进程的信号。</span><br><br>    <span class="hljs-comment">// 处理退出逻辑，此处使用 print 模拟。</span><br>    fmt.Println(<span class="hljs-string">&quot;Closing server...&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;Unregistering service...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文探讨 Gin 的一些用法和源码。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mark" scheme="https://www.aimtao.net/categories/Mark/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="Gin" scheme="https://www.aimtao.net/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记｜GORM</title>
    <link href="https://www.aimtao.net/gorm/"/>
    <id>https://www.aimtao.net/gorm/</id>
    <published>2022-06-30T16:57:00.000Z</published>
    <updated>2022-06-30T16:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为实践 gorm 过程中的笔记，也是写给自己的简明教程（看书从厚到薄第一步）。官方文档写的已经很详细了，建议大家伙先查官方文档。</p></blockquote><span id="more"></span><h2 id="1-ORM">1.ORM</h2><h3 id="1-1-什么是-ORM">1.1 什么是 ORM</h3><p>ORM：Object Relational Mapping（对象关系映射）。</p><p>作用是在编码中，将对象的概念和数据库中表的概念对应起来。简单讲，定义一个对象，就对应着一张表，一个对象的实例，就对应着一条记录。</p><h3 id="1-2-常用-ORM">1.2 常用 ORM</h3><ul><li>gorm</li><li>ent</li><li>sqlx</li><li>xorm</li></ul><h3 id="1-3-ORM-优缺点">1.3 ORM 优缺点</h3><p><strong>优点</strong>：</p><ul><li>提高开发效率。</li><li>屏蔽 SQL 系列，自动将对象的成员变量和表的字段映射，无需直接使用 SQL 编码。</li><li>屏蔽各种数据库之间的差异。</li></ul><p><strong>缺点</strong>：</p><ul><li>ORM 会牺牲程序性能。</li><li>过于依赖 ORM 会导致开发者对于 SQL 理解不够。</li><li>过于依赖某个 ORM 会导致切换到其他 ORM 成本过高。</li></ul><h3 id="1-4-ORM-和-SQL-之间的关系">1.4 ORM 和 SQL 之间的关系</h3><ul><li>SQL 为主，ORM 为辅。</li><li>ORM 的主要目的是为了增加开发效率和代码可维护性。</li></ul><h2 id="2-GORM">2.GORM</h2><p>官方文档：<a href="https://gorm.io/zh_CN/docs/index.html">https://gorm.io/zh_CN/docs/index.html</a></p><h3 id="2-1-连接-MySQL">2.1 连接 MySQL</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/connecting_to_the_database.html">https://gorm.io/zh_CN/docs/connecting_to_the_database.html</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span>   <span class="hljs-comment">// mysql 驱动</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 参考 htps://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>    dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DSN (Data Source Name) 参数是打开数据库的配置，更多配置可以看 <a href="htps://github.com/go-sql-driver/mysql#dsn-data-source-name">dsn-data-source-name</a>。</li><li>要支持完整的 UTF-8 编码，您需要将 <code>charset=utf8</code> 更改为 <code>charset=utf8mb4</code>，查看 <a href="https://mathiasbynens.be/notes/mysql-utf8mb4">此文章</a> 获取详情。</li></ul><h3 id="2-2-设置全局的-logger">2.2 设置全局的 logger</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/logger.html">https://gorm.io/zh_CN/docs/logger.html</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">newLogger := logger.New(<br>    log.New(os.Stdout, <span class="hljs-string">&quot;\r\n&quot;</span>, log.LstdFlags), <span class="hljs-comment">// io writer（日志输出的目标，前缀和日志包含的内容——译者注）</span><br>    logger.Config&#123;<br>        SlowThreshold:             time.Second, <span class="hljs-comment">// 慢 SQL 阈值</span><br>        LogLevel:                  logger.Info, <span class="hljs-comment">// 日志级别</span><br>        IgnoreRecordNotFoundError: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 忽略ErrRecordNotFound（记录未找到）错误</span><br>        Colorful:                  <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 彩色打印</span><br>    &#125;,<br>)<br><br>db, err := gorm.Open(mysql.New(mysql.Config&#123;dsn&#125;), &amp;gorm.Config&#123;<br>    Logger: newLogger,<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>将 Logger 对象作为作为 gorm 的配置参数。</li></ul><h3 id="2-3-表结构定义">2.3 表结构定义</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/models.html">https://gorm.io/zh_CN/docs/models.html</a></p></blockquote><p>数据库中表结构，对应着 go 中的 struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code  <span class="hljs-type">string</span><br>    Price <span class="hljs-type">uint</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>GORM 倾向于约定优于配置。默认情况下，GORM 使用 <code>ID</code> 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名，并使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建、更新时间。</p></blockquote><p>gorm.Model 包含了四个功能字段，若要使用上述约定，将 gorm.Model 嵌入表结构中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gorm.Model 的定义</span><br><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">uint</span>           <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>    CreatedAt time.Time<br>    UpdatedAt time.Time<br>    DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-字段标签">2.4 字段标签</h3><blockquote><p>声明 model 时，tag 是可选的。 tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格。</p></blockquote><p>定义表结构时，可以使用 tag 来进行字段级权限控制。注意语法。</p><p>具体看<a href="https://gorm.io/zh_CN/docs/models.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9">这里</a>。</p><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>column</strong></td><td style="text-align:left">指定 db 列名</td></tr><tr><td style="text-align:left"><strong>type</strong></td><td style="text-align:left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td style="text-align:left">serializer</td><td style="text-align:left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td style="text-align:left">size</td><td style="text-align:left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td style="text-align:left"><strong>primaryKey</strong></td><td style="text-align:left">将列定义为主键</td></tr><tr><td style="text-align:left"><strong>unique</strong></td><td style="text-align:left">将列定义为唯一键</td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">定义列的默认值</td></tr><tr><td style="text-align:left">precision</td><td style="text-align:left">指定列的精度</td></tr><tr><td style="text-align:left">scale</td><td style="text-align:left">指定列大小</td></tr><tr><td style="text-align:left"><strong>not null</strong></td><td style="text-align:left">指定列为 NOT NULL</td></tr><tr><td style="text-align:left"><strong>autoIncrement</strong></td><td style="text-align:left">指定列为自动增长</td></tr><tr><td style="text-align:left">autoIncrementIncrement</td><td style="text-align:left">自动步长，控制连续记录之间的间隔</td></tr><tr><td style="text-align:left"><strong>embedded</strong></td><td style="text-align:left">嵌套字段</td></tr><tr><td style="text-align:left">embeddedPrefix</td><td style="text-align:left">嵌入字段的列名前缀</td></tr><tr><td style="text-align:left">autoCreateTime</td><td style="text-align:left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>/<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td style="text-align:left">autoUpdateTime</td><td style="text-align:left">创建/更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>/<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a>获取详情</td></tr><tr><td style="text-align:left">uniqueIndex</td><td style="text-align:left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td style="text-align:left">check</td><td style="text-align:left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td style="text-align:left"><strong>&lt;-</strong></td><td style="text-align:left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td style="text-align:left"><strong>-&gt;</strong></td><td style="text-align:left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td style="text-align:left"><strong>comment</strong></td><td style="text-align:left">迁移时为字段添加注释</td></tr></tbody></table><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>    UserID <span class="hljs-type">uint</span> <span class="hljs-string">`gorm:&quot;primarykey&quot;`</span><br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:user_name;type:varchar(50)&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-迁移-schema">2.5 迁移 schema</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/migration.html">https://gorm.io/zh_CN/docs/migration.html</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err = db.AutoMigrate(&amp;Product&#123;&#125;)  <span class="hljs-comment">// 传入实例化对象的地址，这是指明 db 操作哪张表的方式，后面会多次用到。</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>AutoMigrate 会根据传入的 struct 创建表、缺失的外键、约束、列和索引。</p><p>执行的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> products<br>(<br>    id  <span class="hljs-type">bigint</span> unsigned  auto_increment  <span class="hljs-keyword">primary key</span>,<br>    created_at datetime  <span class="hljs-keyword">null</span>,<br>    updated_at datetime  <span class="hljs-keyword">null</span>,<br>    deleted_at datetime  <span class="hljs-keyword">null</span>,<br>    code  <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)  <span class="hljs-keyword">null</span>,<br>    price  <span class="hljs-type">bigint</span> unsigned  <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">create</span> index idx_products_deleted_at<br>   <span class="hljs-keyword">on</span> products (deleted_at);<br></code></pre></td></tr></table></figure><h3 id="2-6-自定义表名">2.6 自定义表名</h3><p>需求一：自定义单个的表名</p><p>为 struct Product 增加 TableName 函数，在 AutoMigrate 时，就会使用自定义的表名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Product)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;my_product&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需求二：为所有表名增加批量的前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;<br>    NamingStrategy: schema.NamingStrategy&#123;   <span class="hljs-comment">// 在 gorm config 中增加命名策略的配置。</span><br>        TablePrefix: <span class="hljs-string">&quot;my_&quot;</span>,  <span class="hljs-comment">// 所有的表名前加前缀 &quot;my_&quot;</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-7-快速体验增删改查">2.7 快速体验增删改查</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/index.html#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">https://gorm.io/zh_CN/docs/index.html#快速入门</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create</span><br>db.Create(&amp;Product&#123;Code: <span class="hljs-string">&quot;D42&quot;</span>, Price: <span class="hljs-number">100</span>&#125;)<br><br><br><span class="hljs-comment">// Read</span><br><span class="hljs-keyword">var</span> p Product<br>db.First(&amp;p, <span class="hljs-number">1</span>)                 <span class="hljs-comment">// 根据整型主键查找</span><br>db.First(&amp;p, <span class="hljs-string">&quot;code = ?&quot;</span>, <span class="hljs-string">&quot;D42&quot;</span>) <span class="hljs-comment">// 根据其他字段查找：查找 code 字段值为 D42 的记录</span><br><br><br><span class="hljs-comment">// Update - 更新单个字段：将 product 的 price 更新为 200</span><br>db.Model(&amp;p).Update(<span class="hljs-string">&quot;Price&quot;</span>, <span class="hljs-number">200</span>)<br><span class="hljs-comment">// Update - 更新多个字段</span><br>db.Model(&amp;p).Updates(Product&#123;Price: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;F42&quot;</span>&#125;) <span class="hljs-comment">// 更新多个字段时，仅更新非零值字段</span><br>db.Model(&amp;p).Updates(Product&#123;Price: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;&quot;</span>&#125;) <span class="hljs-comment">// 无法将 Code 更新为空字符串，因为仅更新非零值字段</span><br>db.Model(&amp;p).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Price&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;F42&quot;</span>&#125;)<br><br><br><span class="hljs-comment">// Delete - 删除 product</span><br>db.Delete(&amp;p, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="2-8-更新零值问题">2.8 更新零值问题</h3><p><strong>为什么更新多个字段时，仅更新非零值？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Model(&amp;p).Updates(Product&#123;Price: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>在初始化的 Product 对象中，未明确值的字段，均为零值。当前的需求是想只更新 Price 和 Code 字段，所以其他未明确值的字段会被忽略，也就是零值字段会被忽略掉。所以如果 Price 和 Code 有零值字段，也会一并被忽略掉。</p><p><strong>通过 NullString 解决更新零值问题</strong></p><p>对于需要设置成空字符串的字段，gorm 提供了 <a href="https://pkg.go.dev/database/sql#NullString">NullString</a> 类型，NullString 定义如下，实际上是封装了一个 string，并使用一个 bool 变量表示该字段为空字符串还是未定义（未定义就是 NULL）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NullString <span class="hljs-keyword">struct</span> &#123;<br>    String <span class="hljs-type">string</span><br>    Valid  <span class="hljs-type">bool</span> <span class="hljs-comment">// Valid is true if String is not NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同理的还有 NullBool、NullByte、NullInt32 等结构体类型，他们在 <a href="https://pkg.go.dev/database/sql#NullString"><code>database/sql</code></a> 包中。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code  sql.NullString   <span class="hljs-comment">// 需要设置成空字符串的字段，类型改为 sql.NullString</span><br>    Price <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-comment">// 在删除的时候，传入 sql.NullString 结构体变量，将 Valid 设为 true，表示非 NULL。</span><br><span class="hljs-keyword">var</span> p Product<br>db.First(&amp;p, <span class="hljs-string">&quot;Price = ?&quot;</span>, <span class="hljs-number">200</span>)  <span class="hljs-comment">// 查找 Price=200 的记录</span><br>db.Model(&amp;p).Updates(Product&#123;Price: <span class="hljs-number">2000</span>, Code: sql.NullString&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>&#125;&#125;) <span class="hljs-comment">// 并将该记录的 Price 和 Code 进行修改，其中 Code 是零值。</span><br></code></pre></td></tr></table></figure><p><strong>通过指针解决更新零值问题</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code  *<span class="hljs-type">string</span>  <span class="hljs-comment">// 需要设置成空字符串的字段，类型改为指针类型</span><br>    Price <span class="hljs-type">uint</span><br>&#125;    <br><br><span class="hljs-keyword">var</span> p Product<br>db.First(&amp;p, <span class="hljs-string">&quot;price = ?&quot;</span>, <span class="hljs-number">100</span>)<br>empty := <span class="hljs-string">&quot;&quot;</span><br>db.Model(&amp;p).Updates(Product&#123;Code: &amp;empty, Price: <span class="hljs-number">200</span>&#125;)  <span class="hljs-comment">// 传入空字符串变量的地址</span><br></code></pre></td></tr></table></figure><h3 id="2-9-语法总结">2.9 语法总结</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Model(&amp;Proudct&#123;&#125;)  <span class="hljs-comment">// 表示操作的哪个表，如果后续的增删改查没有传入 Product 结构体变量，就需要使用 model 声明操作的那个表，否则不需要</span><br><br><span class="hljs-comment">// 创建可以只传入结构体</span><br>db.Create(&amp;Proudct&#123;Price: <span class="hljs-number">200</span>&#125;)<br><br><br><span class="hljs-comment">// 【查询】只传入结构体，默认使用主键，除此之外必须传入主键，或者使用 where</span><br><span class="hljs-keyword">var</span> p Proudct&#123;Price：<span class="hljs-number">200</span>&#125;<br>db.Find(&amp;p）  <span class="hljs-comment">// 默认查询所有的，并只返回第一条，不会只查询 Price = 200 的。</span><br><span class="hljs-comment">// ---</span><br>db.First(&amp;p） <span class="hljs-comment">// 同理，不会只查询 Price = 200 的。</span><br><br><br><span class="hljs-comment">// 【更新】update、save 同理（只传入结构体，默认使用主键），需要先查询出主键再更新，或者使用 where</span><br><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u) <span class="hljs-comment">// 先查询主键</span><br>u.Name = <span class="hljs-string">&quot;Tom_001&quot;</span><br>db.Save(&amp;u)  <span class="hljs-comment">// 再更新</span><br><span class="hljs-comment">// ---</span><br>db.Frist(&amp;u)  <span class="hljs-comment">// 先查询</span><br>db.Model(&amp;u).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>)  <span class="hljs-comment">// 再更改</span><br><span class="hljs-comment">// ---</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ? &quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>)<br><br><br><span class="hljs-comment">// 【删除】delete 同理（只传入结构体，默认使用主键），需要先查询出主键再删除，或者使用 where</span><br><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br>db.Delete(&amp;u)  <span class="hljs-comment">// 传入主键</span><br><span class="hljs-comment">// ---</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>).Delete(&amp;User&#123;&#125;)  <span class="hljs-comment">// 通过 where 查询</span><br></code></pre></td></tr></table></figure><h2 id="3-Create-创建">3.Create 创建</h2><blockquote><p><a href="https://gorm.io/zh_CN/docs/create.html">https://gorm.io/zh_CN/docs/create.html</a></p></blockquote><h3 id="3-1-根据-struct-创建">3.1 根据 struct 创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;Name:<span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>result := db.Create(&amp;u)   <span class="hljs-comment">// 传入地址</span><br><br>fmt.Println(u.ID)  <span class="hljs-comment">// 返回插入数据的主键，只有在调用 Create 方法之后才会自动生成 ID</span><br>fmt.Println(result.Error)  <span class="hljs-comment">// 返回错误结果</span><br>fmt.Println(result.RowsAffected)  <span class="hljs-comment">// 返回影响了多少行</span><br></code></pre></td></tr></table></figure><h3 id="3-2-根据-slice-批量创建">3.2 根据 slice 批量创建</h3><p>和一条一条数据传递给 mysql 处理的方式相比，批量创建是使用一条 sql，效率更高。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">users := []User&#123;&#123;Name:<span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">18</span>&#125;, &#123;Name:<span class="hljs-string">&quot;Bob&quot;</span>, Age: <span class="hljs-number">20</span>&#125;&#125;<br>result := db.Create(&amp;users)   <span class="hljs-comment">// 传入 slice 地址</span><br><br><span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>fmt.Println(user.ID)  <span class="hljs-comment">// 返回插入数据的主键，只有在调用 Create 方法之后才会自动生成 ID</span><br>&#125;<br>fmt.Println(result.Error)  <span class="hljs-comment">// 返回错误结果</span><br>fmt.Println(result.RowsAffected)  <span class="hljs-comment">// 返回影响了多少行</span><br></code></pre></td></tr></table></figure><h3 id="3-3-分批创建">3.3 分批创建</h3><p>使用 <code>CreateInBatches</code> 分批创建时，你可以指定每批的数量。</p><p>为什么要分批次？因为批量创建是使用一条 sql 进行创建。但一条 sql 是有长度限制的，所以需要进行分批创建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> users = []User&#123;&#123;name: <span class="hljs-string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="hljs-string">&quot;jinzhu_10000&quot;</span>&#125;&#125;<br><br><span class="hljs-comment">// 一次最多创建 100 个</span><br>db.CreateInBatches(users, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h3 id="3-4-根据-map-创建">3.4 根据 map 创建</h3><p><code>db.Model(&amp;User&#123;&#125;)</code> 会返回一个 db 指针。既可以单个创建也可以批量创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">result := db.Model(&amp;User&#123;&#125;).Create(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>&#125;)<br><br>fmt.Println(result.Error)  <span class="hljs-comment">// 返回错误结果</span><br>fmt.Println(result.RowsAffected)  <span class="hljs-comment">// 返回影响了多少行</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 批量创建</span><br>result := db.Model(&amp;User&#123;&#125;).Create([]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom000&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob000bj=-&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;,<br>&#125;)<br><br>fmt.Println(result.Error)  <span class="hljs-comment">// 返回错误结果</span><br>fmt.Println(result.RowsAffected)  <span class="hljs-comment">// 返回影响了多少行</span><br></code></pre></td></tr></table></figure><h3 id="3-5-默认值">3.5 默认值</h3><p>通过 <code>default</code> 为字段定义默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">int64</span><br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;default:Anonymous&quot;`</span><br>    Age  <span class="hljs-type">int64</span>  <span class="hljs-string">`gorm:&quot;default:18&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Query-查询">4.Query 查询</h2><blockquote><p><a href="https://gorm.io/zh_CN/docs/query.html">https://gorm.io/zh_CN/docs/query.html</a></p></blockquote><h3 id="4-0-传入参数不要多次使用">4.0 传入参数不要多次使用</h3><p><strong>一定要注意的地方。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u0 User<br>db.Find(&amp;u0, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 查询的是 id = 1</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`id` = 1</span><br>db.Find(&amp;u0, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 想查询的是 id = 2，实际上查询的是 id = 1 AND id = 2</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`id` = 2 AND `users`.`id` = 1</span><br></code></pre></td></tr></table></figure><p><code>u0</code> 是传出参数，在执行完 <code>db.Find(&amp;u0, 1)</code> 之后，<code>u0</code> 会带着这个条件 <code>id = 1</code>，重复使用传入参数 <code>u0</code> 时，则会带着这个条件继续查询。</p><h3 id="4-1-检索单个对象">4.1 检索单个对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取第一条记录（主键升序）</span><br><span class="hljs-keyword">var</span> u1 User<br>db.First(&amp;u1)<br>fmt.Println(u1)  <span class="hljs-comment">// u 是传出参数，查询到的值保存在 u 中。</span><br><span class="hljs-comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span><br><br><br><span class="hljs-comment">// 获取第一条记录，不指定排序字段</span><br><span class="hljs-keyword">var</span> u2 User<br>db.Take(&amp;u2)<br><span class="hljs-comment">// SELECT * FROM `users` LIMIT 1</span><br><br><br><span class="hljs-comment">// 获取最后一条记录（也就是主键降序的第一条记录）</span><br><span class="hljs-keyword">var</span> u3 User<br>db.Last(&amp;u3)<br><span class="hljs-comment">// SELECT * FROM `users` ORDER BY `users`.`id` DESC LIMIT 1</span><br></code></pre></td></tr></table></figure><p>如果查不到，怎么办？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u1 User<br>result := db.First(&amp;u1)<br>fmt.Println(result.Error)  <span class="hljs-comment">// 返回错误结果，没错误返回 nil</span><br>fmt.Println(result.RowsAffected)  <span class="hljs-comment">// 返回影响了多少行</span><br><span class="hljs-keyword">if</span>  errors.Is(result.Error, gorm.ErrRecordNotFound) &#123;   <span class="hljs-comment">// 未查询到会返回 gorm.ErrRecordNotFound</span><br>    fmt.Println(<span class="hljs-string">&quot;Not Found&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-根据主键检索">4.2 根据主键检索</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据主键检索</span><br><span class="hljs-keyword">var</span> u4 User<br>db.First(&amp;u4, <span class="hljs-number">10</span>)  <span class="hljs-comment">// 默认搜索 &#x27;主键 == 10&#x27; 的记录</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`id` = 10 ORDER BY `users`.`id` LIMIT 1</span><br><span class="hljs-comment">// 10 也可以使用 &quot;10&quot;</span><br><span class="hljs-comment">// db.First(&amp;u4, &quot;10&quot;)  // int 也可以用 string 传入</span><br><br><br><span class="hljs-comment">// 根据主键范围查找</span><br><span class="hljs-keyword">var</span> u5 User<br>db.Find(&amp;u5, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)  <span class="hljs-comment">// 传递数组，表示主键在该数组范围内。</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`id` IN (1,2,3)</span><br></code></pre></td></tr></table></figure><h3 id="4-3-检索全部对象">4.3 检索全部对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检索全部对象</span><br><span class="hljs-keyword">var</span> users []User<br>result := db.Find(&amp;users)   <span class="hljs-comment">// 全部记录会保存在 users 这个传出参数里</span><br><br><span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> users &#123;<br>    fmt.Println(u.ID, u.Age)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;总行数：&quot;</span>, result.RowsAffected)<br></code></pre></td></tr></table></figure><h3 id="4-4-条件查询">4.4 条件查询</h3><p>where 的常见用法，和 sql 类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取第一条匹配的记录，三种写法：string、struct、map</span><br><span class="hljs-keyword">var</span> u6 User<br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).First(&amp;u6)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name = &#x27;Tom&#x27; ORDER BY `users`.`id` LIMIT 1</span><br><span class="hljs-keyword">var</span> u66 User<br>db.Where(&amp;User&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>&#125;).First(&amp;u66)   <span class="hljs-comment">// 相同功能的写法，传入 User 结构体。</span><br><span class="hljs-keyword">var</span> u666 User<br>db.Where(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Tome&quot;</span>&#125;).First(&amp;u666)  <span class="hljs-comment">// 相同功能的写法，传入 map。</span><br><br><span class="hljs-comment">// 获取全部的匹配的记录</span><br><span class="hljs-keyword">var</span> u7 []User<br>db.Where(<span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Find(&amp;u7)  <span class="hljs-comment">// 查询全部匹配的记录，应该传入一个数组。如果传入一个结构体变量，只会保存第一条记录。</span><br><span class="hljs-comment">//  SELECT * FROM `users` WHERE name &lt;&gt; &#x27;Tom&#x27;</span><br><br><span class="hljs-comment">// IN</span><br><span class="hljs-keyword">var</span> u8 []User<br>db.Where(<span class="hljs-string">&quot;name IN ?&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>&#125;).Find(&amp;u8)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name IN (&#x27;Tom&#x27;,&#x27;Bob&#x27;)</span><br><br><span class="hljs-comment">// LIKE</span><br><span class="hljs-keyword">var</span> u9 []User<br>db.Where(<span class="hljs-string">&quot;name LIKE ?&quot;</span>, <span class="hljs-string">&quot;%Bob%&quot;</span>).Find(&amp;u9)<br><span class="hljs-comment">//  SELECT * FROM `users` WHERE name LIKE &#x27;%Bob%&#x27;</span><br><br><span class="hljs-comment">// AND</span><br><span class="hljs-keyword">var</span> u10 User<br>db.Where(<span class="hljs-string">&quot;name = ? AND age = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>).First(&amp;u10)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name = &#x27;Tom&#x27; AND age = &#x27;18&#x27; ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-comment">// Time</span><br><span class="hljs-keyword">var</span> u11 []User<br>db.Where(<span class="hljs-string">&quot;updated_at &gt; ?&quot;</span>, <span class="hljs-string">&quot;2000-01-01 00:00:00&quot;</span>).Find(&amp;u11)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;</span><br><br><span class="hljs-comment">// Between</span><br><span class="hljs-keyword">var</span> u12 []User<br>db.Where(<span class="hljs-string">&quot;age BETWEEN ? AND ?&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>).Find(&amp;u12)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE age BETWEEN 10 AND 20</span><br><br><span class="hljs-comment">// or 条件， 三种写法：string、struct、map</span><br><span class="hljs-keyword">var</span> u13 []User<br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Or(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>).Find(&amp;u13)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name = &#x27;Tom&#x27; OR name = &#x27;Bob&#x27;</span><br><br><span class="hljs-keyword">var</span> u133 []User<br>db.Where(User&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>&#125;).Or(User&#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>&#125;).Find(&amp;u133)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`name` = &#x27;Tom&#x27; OR `users`.`name` = &#x27;Bob&#x27;</span><br><br><span class="hljs-keyword">var</span> u1333 []User<br>db.Where(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom&quot;</span>&#125;).Or(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>&#125;).Find(&amp;u1333)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name = &#x27;Tom&#x27; OR name = &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>需要注意的地方</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *【1.字段名是大小写不敏感的】。</span><br><span class="hljs-comment"> */</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).First(&amp;u6)<br>db.Where(<span class="hljs-string">&quot;Name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).First(&amp;u6)  <span class="hljs-comment">// 与前者效果一致</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *【2.字段名是数据库中的名称，不是 struct 的结构体变量名】。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    MyName <span class="hljs-type">string</span>  <span class="hljs-string">`gorm:&quot;column:name&quot;`</span>  <span class="hljs-comment">// 使用 tag 设置数据库中列名为 name</span><br>&#125;<br><span class="hljs-comment">// db.Where(&quot;MyName = ?&quot;, &quot;Tom&quot;).First(&amp;u6)  // 错误！无法找到 my_name 这个列 </span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).First(&amp;u6)  <span class="hljs-comment">// 正确！使用 数据库列名称</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *【3.struct 查询会忽略零值，string 和 map 的方式查询不会忽略零值】。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> u6 User<br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).First(&amp;u6)  <span class="hljs-comment">// string 方式，不会忽略零值</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE name = &#x27;&#x27; ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-keyword">var</span> u66 User<br>db.Where(&amp;User&#123;Name: <span class="hljs-string">&quot;&quot;</span>&#125;).First(&amp;u66)  <span class="hljs-comment">// struct 式，忽略零值</span><br><span class="hljs-comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-keyword">var</span> u666 User<br>db.Where(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125;).First(&amp;u666)  <span class="hljs-comment">// map 方式，不会忽略零值</span><br><span class="hljs-comment">//  SELECT * FROM `users` WHERE `Name` = &#x27;&#x27; ORDER BY `users`.`id` LIMIT 1</span><br></code></pre></td></tr></table></figure><p>其他和 where 方法类似功能的用法，自行查看 <a href="https://gorm.io/zh_CN/docs/query.html#%E5%86%85%E8%81%94%E6%9D%A1%E4%BB%B6">内联条件</a>、<a href="https://gorm.io/zh_CN/docs/query.html#Not-%E6%9D%A1%E4%BB%B6">Not 条件</a>、<a href="https://gorm.io/zh_CN/docs/query.html#Limit-amp-Offset">Limit &amp; Offset</a>、<a href="https://gorm.io/zh_CN/docs/query.html#Group-By-amp-Having">Group By &amp; Having</a> 等。</p><h3 id="4-5-高级查询">4.5 高级查询</h3><p>本质上还是需要 sql 的功底：group、子查询、having、多表查询。</p><h2 id="5-Update-更新">5. Update 更新</h2><blockquote><p><a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p></blockquote><h3 id="5-1-保存所有字段">5.1 保存所有字段</h3><p>Save 集 update 和 insert 为一体的函数。</p><p><strong>更新</strong>：</p><p>保存所有字段意味着，</p><ul><li>更改的字段：更改后的值，即使更改为零值。</li><li>未更改的字段：保持原来的值。</li></ul><p>字段比较少的时候，可以选择这种方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 需要先查询出，需要更新的记录。</span><br><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br><br><span class="hljs-comment">// 设置值</span><br>u.Name = <span class="hljs-string">&quot;Tom_001&quot;</span><br>u.Age = <span class="hljs-number">0</span>  <span class="hljs-comment">// 可以更新零值</span><br><br><span class="hljs-comment">// 保存所有字段</span><br>db.Save(&amp;u)<br><span class="hljs-comment">//  UPDATE `users` SET `name`=&#x27;Tom_001&#x27;,`email`=&#x27;11@qq.com&#x27;,`age`=0,`birthday`=NULL,`member_number`=NULL,`activated_at`=NULL,`created_at`=&#x27;2022-02-19 17:15:06.408&#x27;,`updated_at`=&#x27;2022-03-22 23:44:39.833&#x27; WHERE `id` = 1</span><br></code></pre></td></tr></table></figure><p><strong>插入</strong>：</p><p>更新之前，需要查询出需要更改的记录。如果不查询，就默认为插入操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br><br>u.Name = <span class="hljs-string">&quot;Tom_001&quot;</span><br>u.Age = <span class="hljs-number">0</span><br>db.Save(&amp;u)<br><span class="hljs-comment">// INSERT INTO `users` (`name`,`email`,`age`,`birthday`,`member_number`,`activated_at`,`created_at`,`updated_at`) VALUES (&#x27;Tom_001&#x27;,NULL,0,NULL,NULL,NULL,&#x27;2022-03-22 23:48:14.375&#x27;,&#x27;2022-03-22 23:48:14.375&#x27;) RETURNING `id`</span><br></code></pre></td></tr></table></figure><h3 id="5-2-更新单个字段">5.2 更新单个字段</h3><p>Update 可以更新零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据条件选择值，更新</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ? &quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>)<br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom_002&#x27;,`updated_at`=&#x27;2022-03-23 00:04:09.841&#x27; WHERE name = &#x27;Tom&#x27; </span><br><br><br><span class="hljs-comment">// 根据 id 选择值，更新</span><br>db.Frist(&amp;u)  <span class="hljs-comment">// 先查询</span><br>db.Model(&amp;u).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>)  <span class="hljs-comment">// 再更改</span><br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom_002&#x27;,`updated_at`=&#x27;2022-03-23 00:08:09.696&#x27; WHERE `id` = 1</span><br><br><br><span class="hljs-comment">// 根据 id 和条件选择值，更新</span><br>db.Model(&amp;u).Where(<span class="hljs-string">&quot;Age &gt; ?&quot;</span>, <span class="hljs-number">20</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>)<br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom_002&#x27;,`updated_at`=&#x27;2022-03-23 00:08:40.8&#x27; WHERE Age &gt; 20 AND `id` = 1</span><br></code></pre></td></tr></table></figure><h3 id="5-3-更新多个字段">5.3 更新多个字段</h3><p>Updates 不能更新非零值。原因在「更新零值问题」中阐述过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br><br><span class="hljs-comment">// 根据 strut 更新</span><br>db.Model(&amp;u).Updates(User&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">10</span>&#125;)<br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom&#x27;,`age`=10,`updated_at`=&#x27;2022-03-23 00:19:02.321&#x27; WHERE `id` = 1</span><br><br><span class="hljs-comment">// 根据 map 更新</span><br>db.Model(&amp;u).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>&#125;) <br><span class="hljs-comment">// UPDATE `users` SET `age`=10,`name`=&#x27;Tom&#x27;,`updated_at`=&#x27;2022-03-23 00:19:02.406&#x27; WHERE `id` = 1</span><br></code></pre></td></tr></table></figure><h3 id="5-4-更新选定的字段">5.4 更新选定的字段</h3><ul><li>select：只更新 Select 选中的字段【可以更新零值字段】</li><li>Omit：忽略选中的字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Model(&amp;u).Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom&#x27;,`age`=0,`updated_at`=&#x27;2022-03-23 00:26:06.779&#x27; WHERE `id` = 1</span><br></code></pre></td></tr></table></figure><h3 id="5-5-更新-Hook">5.5 更新 Hook</h3><p>GORM 支持的 hook 点包括：<code>BeforeSave</code>, <code>BeforeUpdate</code>, <code>AfterSave</code>, <code>AfterUpdate</code>。</p><p>例子：更新记录前，判断要更新的年龄是否合法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeUpdate(tx *gorm.DB)(err <span class="hljs-type">error</span>)  &#123;<br>    <span class="hljs-keyword">if</span> u.Age &lt; <span class="hljs-number">18</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;be Not allowed to update&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>尝试更新，返回值得到预期的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br>result := db.Model(&amp;u).Updates(User&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>, Age: <span class="hljs-number">10</span>&#125;)<br>fmt.Println(result.Error, result.RowsAffected)  <span class="hljs-comment">// be Not allowed to update 0</span><br></code></pre></td></tr></table></figure><h3 id="5-6-批量更新">5.6 批量更新</h3><p>如果不通过 <code>Model</code> 指定记录的主键，则 GORM 会执行批量更新。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 struct 更新</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;Tom_001&quot;</span>, Age: <span class="hljs-number">28</span>&#125;)<br><span class="hljs-comment">// UPDATE `users` SET `name`=&#x27;Tom_001&#x27;,`age`=28,`updated_at`=&#x27;2022-03-23 00:44:12.596&#x27; WHERE name = &#x27;Tom&#x27;</span><br><br><br><span class="hljs-comment">// 根据 map 更新</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom_001&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">28</span>&#125;)<br><span class="hljs-comment">//  UPDATE `users` SET `age`=28,`name`=&#x27;Tom_001&#x27;,`updated_at`=&#x27;2022-03-23 00:45:26.133&#x27; WHERE name = &#x27;Tom&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="6-Delete-删除">6.Delete 删除</h2><blockquote><p><a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p></blockquote><h3 id="6-1-删除单条记录">6.1 删除单条记录</h3><p>删除对象时指定主键或通过 where 查询。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br>db.Delete(&amp;u)  <span class="hljs-comment">// 传入主键</span><br><span class="hljs-comment">// DELETE FROM `users` WHERE `users`.`id` = 1</span><br><br><br>db.Delete(&amp;User&#123;&#125;, <span class="hljs-number">10</span>)  <span class="hljs-comment">// 传入主键</span><br><span class="hljs-comment">// DELETE FROM users WHERE id = 10;</span><br><br><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom_002&quot;</span>).Delete(&amp;User&#123;&#125;)  <span class="hljs-comment">// 通过 where 查询</span><br><span class="hljs-comment">// DELETE FROM `users` WHERE name = &#x27;Tom_002&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="6-2-Delete-Hook">6.2 Delete Hook</h3><p>注意：hook 只能在传入结构体时才生效。（至于为啥不知道。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br><br>db.Delete(&amp;u)  <span class="hljs-comment">// hook 可以生效</span><br>db.Delete(&amp;User&#123;&#125;, <span class="hljs-number">28</span>)  <span class="hljs-comment">// hook 不生效</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom100&quot;</span>).Delete(&amp;User&#123;&#125;)  <span class="hljs-comment">// hook 不生效</span><br></code></pre></td></tr></table></figure><p>hook 写法：判断非法返回一个 error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeDelete(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> u.Name == <span class="hljs-string">&quot;Tom100&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;admin user not allowed to delete&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-软删除">6.3 软删除</h3><blockquote><p>也叫逻辑删除：<a href="https://gorm.io/zh_CN/docs/delete.html#%E8%BD%AF%E5%88%A0%E9%99%A4">https://gorm.io/zh_CN/docs/delete.html#软删除</a></p></blockquote><p><code>gorm.Model</code> 中包含 <code>gorm.deletedat</code> 字段，表结构定义时，包含 <code>gorm.Model</code> 则自动获得软删除的能力。</p><p>拥有软删除能力的模型调用 <code>Delete</code> 时，其实调用的事 <code>Update</code>，记录不会从数据库中被真正删除。但 GORM 会将 <code>DeletedAt</code> 置为当前时间， 并且不能再通过普通的查询方法找到该记录。</p><h2 id="7-关联">7.关联</h2><h3 id="7-1-Belong-to">7.1 Belong to</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/belongs_to.html">https://gorm.io/zh_CN/docs/belongs_to.html</a></p></blockquote><p><code>belongs to</code> 会与另一个模型建立了一对一的连接。</p><p>比如每个 user 对应一个 company，外键放在 user 表中。</p><h4 id="7-1-1-关联创建表">7.1.1 关联创建表</h4><p>创建 users 表时，会自动创建 companies 表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Name      <span class="hljs-type">string</span><br>    CompanyID <span class="hljs-type">int</span>  <span class="hljs-comment">// 外键</span><br>    Company   Company   <span class="hljs-comment">// 该字段并不是直接保存在 user 表中，go 中使用嵌套类型，便于 User 结构体直接使用 Company 中变量。</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Company <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">int</span><br>    Name <span class="hljs-type">string</span><br>&#125;<br><br>db.AutoMigrate(&amp;User&#123;&#125;)   <span class="hljs-comment">// 只需迁移 User，自动创建 users 表和 companies 表。</span><br></code></pre></td></tr></table></figure><h4 id="7-1-2-关联插入">7.1.2 关联插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Create(&amp;User&#123;<br>    Name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    Company: Company&#123;Name: <span class="hljs-string">&quot;Apple&quot;</span>&#125;,   <span class="hljs-comment">// 先创建 companies 表记录</span><br>&#125;)                                     <span class="hljs-comment">// 再创建 users 表记录</span><br><br>db.Create(&amp;User&#123;<br>    Name: <span class="hljs-string">&quot;Bob&quot;</span>,<br>    CompanyID: <span class="hljs-number">2</span>,   <span class="hljs-comment">// 已存在改 companies 记录，直接设置外键。</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="7-1-3-重写外键">7.1.3 重写外键</h4><p>默认情况下，外键的名字，使用拥有者的类型名称加上表的主键的字段名字。</p><p>一个 User 实体属于 Company 实体，那么外键的名字一般使用 CompanyID，代码可读性更好。</p><p>也可以自定义外键名字的方式，需要使用标签指明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Name      <span class="hljs-type">string</span><br>    CompanyRefer <span class="hljs-type">int</span><br>    Company   Company <span class="hljs-string">`gorm:&quot;foreignKey:CompanyRefer&quot;`</span>   <span class="hljs-comment">// 指明使用 CompanyRefer 作为外键。</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Company <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">int</span><br>    Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-4-关联查询">7.1.4 关联查询</h4><p>虽然 User 结构体中嵌套了 Company 结构体，但是查询时，只会 select Users 表，需要关联查询才能查到 Company 的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)   <span class="hljs-comment">// 只会 select Users 表</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`deleted_at` IS NULL ORDER BY `users`.`id` LIMIT 1</span><br>fmt.Println(u.Company.Name)<br></code></pre></td></tr></table></figure><p><strong>Preload 预加载</strong></p><blockquote><p><a href="https://gorm.io/zh_CN/docs/preload.html">https://gorm.io/zh_CN/docs/preload.html</a></p></blockquote><p>默认情况下，是预加载全部。也可以使用 <strong>内联条件</strong> 进行带条件的预加载。</p><p>Perload 参数填 user 结构体中嵌套的结构体变量名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Preload(<span class="hljs-string">&quot;Company&quot;</span>).First(&amp;u)  <span class="hljs-comment">// 两次查询</span><br><span class="hljs-comment">// SELECT * FROM `companies` WHERE `companies`.`id` = 1</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`deleted_at` IS NULL ORDER BY `users`.`id` LIMIT 1</span><br>fmt.Println(u.Company.Name)<br><br><br><span class="hljs-comment">// 带条件的预加载</span><br>db.Preload(<span class="hljs-string">&quot;Company&quot;</span>, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>).First(&amp;u)<br><br><span class="hljs-comment">// Where 是用来条件查询 users 表的，Preload 使用内联条件查询 companies 表</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Preload(<span class="hljs-string">&quot;Company&quot;</span>, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>).First(&amp;u)<br></code></pre></td></tr></table></figure><p><strong>Joins 预加载</strong></p><p>和 Preload 的区别是，Joins 预加载是使用 left join 的方式加载关联数据。</p><p>Joins 只适合 Belong to 和 Has one。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Joins(<span class="hljs-string">&quot;Company&quot;</span>).First(&amp;u)  <span class="hljs-comment">// 一次查询</span><br><span class="hljs-comment">// SELECT `users`.`id`,`users`.`created_at`,`users`.`updated_at`,`users`.`deleted_at`,`users`.`name`,`users`.`company_refer`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` `Company` ON `users`.`company_refer` = `Company`.`id` WHERE `users`.`deleted_at` IS NULL ORDER BY `users`.`id` LIMIT 1</span><br>fmt.Println(u.Company.Name)<br></code></pre></td></tr></table></figure><h3 id="7-2-Has-many">7.2 Has many</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/has_many.html">https://gorm.io/zh_CN/docs/has_many.html</a></p></blockquote><p><code>has many</code> 与另一个模型建立了一对多的连接。</p><p>比如每个 user 可以有多张 credit card，外键放在 credit_card 表中。</p><h4 id="7-2-1-创建关联表">7.2.1 创建关联表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 有多张 CreditCard，UserID 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    CreditCards []CreditCard<br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Number <span class="hljs-type">string</span><br>    UserID <span class="hljs-type">uint</span>   <span class="hljs-comment">// 外键</span><br>&#125;<br><br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;CreditCard&#123;&#125;)   <span class="hljs-comment">// 需要同时生成两张表，才会自动建立外键。</span><br></code></pre></td></tr></table></figure><h4 id="7-2-2-关联插入">7.2.2 关联插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按照 user struct 的逻辑创建，即可关联创建。</span><br>db.Create(&amp;User&#123;   <span class="hljs-comment">// 先创建 user 记录，再带着 UserID 这个外键值 创建 credit_cards 记录</span><br>     CreditCards: []CreditCard&#123;<br>         &#123;Number: <span class="hljs-string">&quot;001&quot;</span>&#125;,<br>         &#123;Number: <span class="hljs-string">&quot;002&quot;</span>&#125;,<br>    &#125;,<br>&#125;)<br><span class="hljs-comment">// INSERT INTO `users` (`created_at`,`updated_at`,`deleted_at`) VALUES (&#x27;2022-04-02 01:35:54.392&#x27;,&#x27;2022-04-02 01:35:54.392&#x27;,NULL) RETURNING `id`</span><br><span class="hljs-comment">// INSERT INTO `credit_cards` (`number`,`user_id`) VALUES (&#x27;2022-04-02 01:35:54.427&#x27;,&#x27;2023-04-02 01:35:54.427&#x27;,NULL,&#x27;001&#x27;,3),(&#x27;2022-04-02 01:35:54.427&#x27;,&#x27;2022-04-02 01:35:54.427&#x27;,NULL,&#x27;002&#x27;,3) ON DUPLICATE KEY UPDATE `user_id`=VALUES(`user_id`) RETURNING `id`</span><br><br><br><span class="hljs-comment">// 只创建 credit_cards 记录，并指定外键值。</span><br>db.Create(&amp;CreditCard&#123;<br>    Number: <span class="hljs-string">&quot;003&quot;</span>,<br>    UserID: <span class="hljs-number">1</span>,   <span class="hljs-comment">// 指定外键</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="7-2-3-重写外键">7.2.3 重写外键</h4><p>自定义外键名称，和 <code>Belong to</code> 一样，标签写在嵌入的结构体变量后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 有多张 CreditCard，UserID 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    CreditCards []CreditCard <span class="hljs-string">`gorm:&quot;foreignKey:UserRefer&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Number <span class="hljs-type">string</span><br>    UserRefer <span class="hljs-type">uint</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-2-4-关联查询">7.2.4 关联查询</h4><p>这里只能使用 Preload。（Jonis 只适合 Belong to 和 Has one）</p><p>Preload 参数为 User 结构体中，嵌套的 CreditCards 结构体变量名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>).First(&amp;u)<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> u.CreditCards &#123;<br>    fmt.Println(c.Number, c.UserID)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-3-Many-to-many">7.3 Many to many</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/many_to_many.html">https://gorm.io/zh_CN/docs/many_to_many.html</a></p></blockquote><p>Many to Many 会在两个 model 中添加一张连接表。</p><p>比如每个 user 可以会多门  language，一门 language 也可以被多个 user 使用。</p><h4 id="7-3-1-创建关联表">7.3.1 创建关联表</h4><p>使用标签指定 <code>many to many</code> 的关系，并会自动创建连接表，连接表中有两个外键，分别是 User 和 Language。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Languages []Language <span class="hljs-string">`gorm:&quot;many2many:user_languages;&quot;`</span>   <span class="hljs-comment">// 指定 many to many 的关系</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Language <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)   <span class="hljs-comment">// 自动创建 many to many 的连接表。</span><br></code></pre></td></tr></table></figure><h4 id="7-3-2-关联插入">7.3.2 关联插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按照 User 结构体的逻辑创建即可。</span><br>db.Create(&amp;User&#123;<br>    Languages: []Language&#123;<br>        &#123;Name: <span class="hljs-string">&quot;golang&quot;</span>&#125;,<br>        &#123;Name: <span class="hljs-string">&quot;java&quot;</span>&#125;,<br>    &#125;,<br>&#125;)<br><span class="hljs-comment">// 先创建 user 记录，再创建 language 记录，最后创建 连接表 记录。</span><br><br><span class="hljs-comment">// INSERT INTO `users` (`created_at`,`updated_at`,`deleted_at`) VALUES (&#x27;2022-04-02 02:13:47.389&#x27;,&#x27;2022-04-02 02:13:47.389&#x27;,NULL) RETURNING `id`</span><br><span class="hljs-comment">// INSERT INTO `languages` (`created_at`,`updated_at`,`deleted_at`,`name`) VALUES (&#x27;2022-04-02 02:13:47.423&#x27;,&#x27;2022-04-02 02:13:47.423&#x27;,NULL,&#x27;golang&#x27;),(&#x27;2022-04-02 02:13:47.423&#x27;,&#x27;2022-04-02 02:13:47.423&#x27;,NULL,&#x27;java&#x27;) ON DUPLICATE KEY UPDATE `id`=`id` RETURNING `id`</span><br><span class="hljs-comment">// INSERT INTO `user_languages` (`user_id`,`language_id`) VALUES (3,6),(3,7) ON DUPLICATE KEY UPDATE `user_id`=`user_id`</span><br></code></pre></td></tr></table></figure><h4 id="7-3-3-关联查询">7.3.3 关联查询</h4><p>和 <code>Has many</code> 一样，使用 Preload。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Preload(<span class="hljs-string">&quot;Languages&quot;</span>).First(&amp;u)<br><span class="hljs-keyword">for</span> _, language := <span class="hljs-keyword">range</span> u.Languages &#123;<br>    fmt.Println(language.Name)<br>&#125;<br><br><span class="hljs-comment">// 会查三张表。</span><br><span class="hljs-comment">// SELECT * FROM `user_languages` WHERE `user_languages`.`user_id` = 1</span><br><span class="hljs-comment">// SELECT * FROM `languages` WHERE `languages`.`id` IN (1,2) AND `languages`.`deleted_at` IS NULL</span><br><span class="hljs-comment">// SELECT * FROM `users` WHERE `users`.`deleted_at` IS NULL ORDER BY `users`.`id` LIMIT 1</span><br></code></pre></td></tr></table></figure><h3 id="7-4-关联模式">7.4 关联模式</h3><blockquote><p><a href="https://gorm.io/zh_CN/docs/associations.html">https://gorm.io/zh_CN/docs/associations.html</a></p></blockquote><p>关联模式包含一些在处理关系时有用的方法。</p><p>以 <code>many to many</code> 为例。</p><h4 id="7-4-1-查找关联">7.4.1 查找关联</h4><p>已经查到 user，需要查询该 user 的全部 language 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br><br><span class="hljs-comment">// 查看 u 的关联数据 languages。</span><br><span class="hljs-keyword">var</span> l []Language<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Find(&amp;l)<br><span class="hljs-keyword">for</span> _, language := <span class="hljs-keyword">range</span> l &#123;<br>    fmt.Println(language.Name)<br>&#125;<br><span class="hljs-comment">//SELECT `languages`.`id`,`languages`.`created_at`,`languages`.`updated_at`,`languages`.`deleted_at`,`languages`.`name` FROM `languages` JOIN `user_languages` ON `user_languages`.`language_id` = `languages`.`id` AND `user_languages`.`user_id` = 1 WHERE `languages`.`deleted_at` IS NULL</span><br></code></pre></td></tr></table></figure><h4 id="7-4-2-添加关联">7.4.2 添加关联</h4><p>已经查到 user，需要新增该 user 的全部 language 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.First(&amp;u)<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Append([]Language&#123;&#123;Name: <span class="hljs-string">&quot;python&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;html&quot;</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><p>替换关联、删除关联、清空关联等等不再赘述，见<a href="https://gorm.io/zh_CN/docs/associations.html#%E5%85%B3%E8%81%94%E6%A8%A1%E5%BC%8F">官方文档</a>。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为实践 gorm 过程中的笔记，也是写给自己的简明教程（看书从厚到薄第一步）。官方文档写的已经很详细了，建议大家伙先查官方文档。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mark" scheme="https://www.aimtao.net/categories/Mark/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="微服务" scheme="https://www.aimtao.net/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="GORM" scheme="https://www.aimtao.net/tags/GORM/"/>
    
  </entry>
  
  <entry>
    <title>值得分享的软件和技巧</title>
    <link href="https://www.aimtao.net/worth-sharing/"/>
    <id>https://www.aimtao.net/worth-sharing/</id>
    <published>2022-06-26T10:05:00.000Z</published>
    <updated>2022-06-26T10:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好产品值得推广，持续更新。</p></blockquote><span id="more"></span><p>遇见一些有趣的产品，如同发现宝藏一般，与君分享。</p><h2 id="1-Mac-专属">1.Mac 专属</h2><h3 id="1-1-关闭内建显示器使用触控板">1.1 关闭内建显示器使用触控板</h3><p><strong>（1）背景</strong></p><ul><li>macOS：12.3.1</li><li>连接电源线+外接显示器+外接键盘</li></ul><p><strong>（2）需求</strong></p><ul><li>外接显示器时想使用触控板。</li><li>关闭内建显示器：因为外接显示器足够大，不需要内建显示器，只渲染外接显示器可以降低集成显卡的负载，以及有效的控制温度。</li><li>拔掉外接显示器后，内建显示器能正常使用。</li></ul><p><strong>（3）解决</strong></p><ol><li>进入恢复模式：重启，在屏幕出现苹果 log 之前，按住 <code>command</code> + <code>R</code>。</li><li>打开终端：顶部菜单栏 – 其他 – 终端。</li><li>输入命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 10.10及以后版本输入这个：</span><br>nvram boot-args=<span class="hljs-string">&quot;niog=1&quot;</span><br><br><span class="hljs-comment"># 10.10以前版本输入这个：</span><br>nvram boot-args=<span class="hljs-string">&quot;iog=0x0&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>重启，并<strong>立即合上 macbook</strong> 。</li><li>使用外接键盘+外接显示器，输入密码进入桌面后，<strong>再打开 macbook</strong>。此时已关闭内建显示器但可以使用触控板。</li><li>拔掉外接显示器可以正常使用内建显示器。</li></ol><p>PS：以上顺序不要乱，尤其是一定要盒盖后，外接显示器进入桌面后，再打开笔记本。</p><p><strong>（5）关闭特性</strong></p><p>进入恢复模式，打开终端，输入 <code>nvram -d boot-args</code> 即可关闭此特性。</p><h3 id="1-2-反转鼠标滚动方向">1.2 反转鼠标滚动方向</h3><p><strong>（1）背景</strong></p><ul><li>mac 的触控板滚动方向和鼠标滚轮的滚动方向是一致的。<ul><li>鼠标滚轮向前滚动：页面向上滚动。</li><li>触控板向前滑动：页面向上滚动。</li></ul></li></ul><p><strong>（2）需求</strong></p><ul><li>按照滑手机屏幕的习惯，触控板向前滑动画面应该向下滚动。</li></ul><p><strong>（3）解决</strong></p><p>使用 <a href="https://github.com/Caldis/Mos">Mos</a> 单独反转鼠标滚动方向，还可以调整滚动速率，非常 nice。</p><h3 id="1-3-Mac-连接-Android-设备">1.3 Mac 连接 Android 设备</h3><p>使用 Android 官方工具：<a href="https://www.android.com/filetransfer/">Android File Transfer</a>，支持各品牌 Android 设备。</p><h3 id="1-4-防火墙-LuLu">1.4 防火墙 LuLu</h3><p>防火墙 <a href="https://github.com/objective-see/LuLu">LuLu</a>，可以对各 APP 的每个网络连接进行控制（提醒、阻止、放行、设置规则）。开源免费、简洁强大。</p><h2 id="2-文件处理">2.文件处理</h2><h3 id="2-1-视频格式转换-压缩">2.1 视频格式转换/压缩</h3><p><a href="https://handbrake.fr">handBrake</a> 基于 ffmpeg 开发的开源软件，支持全平台。</p><h3 id="2-2-图片压缩">2.2 图片压缩</h3><p><a href="https://squoosh.app">Squoosh</a>：Google 开源的在线压缩工具，压缩能力强。除在线网页版外，还有<a href="https://squoosh-desktop.vercel.app">离线版全平台应用</a>，甚至还有 <a href="https://github.com/GoogleChromeLabs/squoosh">CLI 和 API</a>。</p><h2 id="3-易用性">3.易用性</h2><h3 id="3-1-排查电脑卡顿-发热问题">3.1 排查电脑卡顿/发热问题</h3><p><strong>（1）背景</strong></p><ul><li>intel 芯片。</li></ul><p><strong>（2）需求</strong></p><ul><li>当功耗高时，温度会快速上升，到达一定温度就会触发 CPU/GPU 限频，导致卡顿。</li><li>所以当出现卡顿/发热问题，风扇嗡嗡转，此时需查看 CPU 的<strong>功耗、频率、温度</strong>。</li></ul><p><strong>（3）解决</strong></p><ul><li>intel 芯片都可以使用 intel 厂商提供的软件 Inter Power Gadget 查看一手数据。</li><li>接下来做两个动作：<strong>给电脑提供良好的散热环境 + 关闭不使用的后台程序</strong>。</li><li>从 Inter Power Gadget 可以直观看到 Power 在下降后，Temperature 也有所缓和。</li></ul><p>PS：条件允许可以关闭微信，功耗很高诶。</p><h3 id="3-2-拦截广告-跟踪">3.2 拦截广告/跟踪</h3><p>屏蔽网页中出现的广告和跟踪程序。</p><p>Safari 浏览器插件：<a href="https://adguard.com/en/adguard-safari/overview.html">AdGuard for Safari</a></p><p>谷歌浏览器插件：<a href="https://adguard.com/en/adguard-browser-extension/chrome/overview.html">AdGuard extension for Chrome</a></p><p>开源免费，效果拔群。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好产品值得推广，持续更新。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Practice" scheme="https://www.aimtao.net/categories/Practice/"/>
    
    
    <category term="macOS" scheme="https://www.aimtao.net/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核｜内存管理</title>
    <link href="https://www.aimtao.net/memory-management/"/>
    <id>https://www.aimtao.net/memory-management/</id>
    <published>2022-06-17T07:43:00.000Z</published>
    <updated>2022-06-17T07:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文结合了诸多资料，以更加结构化的方式构建内存管理的知识体系，从虚拟内存布局到物理内存分配，全面地描述了内存管理中最重要的三件事。</p></blockquote><span id="more"></span><h2 id="1-前言">1.前言</h2><p><a href="https://0xax.gitbooks.io/linux-insides/content/MM/linux-mm-1.html">《linux-insides》</a>作者说内存管理是操作系统内核中最复杂的部分。</p><p>概括来讲，Linux 内存管理主要有三件事，全文也会按照这三件事来叙述。</p><ul><li><strong>虚拟内存管理</strong>：将虚拟内存分成大小相等的页。</li><li><strong>物理内存管理</strong>：将物理内存分成大小相等的页。</li><li><strong>虚拟内存和物理内存的映射</strong>：通过页表将虚拟内存也和物理内存映射起来，并且在物理内存紧张的时候可以换出到硬盘中。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-7KaFZP.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="2-虚拟内存管理">2.虚拟内存管理</h2><p><img src="https://hutu.aimtao.net/mark/2022-06-21-v7rsy4.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>每个进程创建时，都会分配一个虚拟内存空间，如图所示，虚拟内存空间分为用户空间和内核空间。</p><h3 id="2-1-用户空间和内核空间的划分">2.1 用户空间和内核空间的划分</h3><p>在 Linux 里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构 <code>task_struct</code> 进行管理。<code>task_struct</code> 中使用了 <code>mm_struct</code> 结构来管理内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br></code></pre></td></tr></table></figure><p><code>mm_struct</code> 中定义了用户态大小。<code>highest_vm_end</code>存储当前虚拟内存地址的最大地址。<code>task_size</code>则是用户态的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>......<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;    <span class="hljs-comment">/* size of task vm space */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> highest_vm_end;   <span class="hljs-comment">/* highest vma end address */</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>当创建一个新的进程的时候，会做以下的设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">current-&gt;mm-&gt;task_size = TASK_SIZE;<br></code></pre></td></tr></table></figure><p><code>TASK_SIZE</code> 定义如下，也就是 <code>PAGE_OFFSET</code>，其中 32 位系统和 64 位系统分开来看，重点看代码中的注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_32</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * User space process size: 3GB (default).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE    PAGE_OFFSET</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE_MAX    TASK_SIZE</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">config PAGE_OFFSET</span><br><span class="hljs-comment">        hex</span><br><span class="hljs-comment">        default 0xC0000000</span><br><span class="hljs-comment">        depends on X86_32</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * User space process size. 47bits minus one guard page.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE_MAX  ((1UL &lt;&lt; 47) - PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_SIZE    (test_thread_flag(TIF_ADDR32) ? \</span><br><span class="hljs-meta">          IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span><br>......<br></code></pre></td></tr></table></figure><p><strong>（1）32 位系统</strong></p><ul><li>对于 32 位系统，最大能够寻址 2^32=4G。</li><li>从注释看，用户态最大地址默认是 0xC0000000。故用户态是 3G，内核态是 1G。</li></ul><p><strong>（2）64 位系统</strong></p><ul><li>对于 64 位系统，虚拟地址只使用了 48 位，2^48=256T。</li><li>其中用户态是 128T - 1K，内核态是 128T，用户态和内核态之间隔着很大的空隙，以此来进行隔离。</li><li><strong><code>#define TASK_SIZE_MAX ((1UL &lt;&lt; 47) - PAGE_SIZE)</code></strong> <strong>解释</strong>：1 左移 47 位，0x800000000000 = 128T，还需要再减去一页保护页，大小为 <code>PAGE_SIZE</code>，也就是 1K。</li></ul><h3 id="2-2-用户空间的布局">2.2 用户空间的布局</h3><p><img src="https://hutu.aimtao.net/mark/2022-06-21-X6OG7i.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（1）受保护区域</strong></p><p>这个区域很小，用户不可操作，在 C 语言中，NULL 其实是宏定义，<code>#define NULL (void*)0</code>，也就是说，空指针其实指的就是这个地址。</p><p><strong>（2）ELF</strong></p><p>ELF 段 = test 段 + data 段 + bss 段。其作用分别是：</p><ul><li>Text Segment：存放二进制可执行代码。</li><li>Data Segment：存放已初始化的 static 常量、全局变量。</li><li>BSS Segment，Block Started by Symbol：存放未初始化的 static 变量、全局变量。</li></ul><p>Linux 可执行程序的文件格式是 ELF。每次执行都是从 main 函数位置开始执行，即 test 段。</p><p>PS：可以使用 file 命令来查看文件类型。比如，查看可执行文件 zsh，如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜ ~ file /bin/zsh<br>zsh: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=dc4d89bbb8fb95d61a21500ba5c100d04a0fa8d5, stripped<br></code></pre></td></tr></table></figure><p><strong>（3）Heap</strong></p><ul><li>堆的大小是不固定的，它是从地址往高地址增长的。</li><li>Heap 用来动态分配内存的区域，使用 malloc 申请<strong>小内存</strong>（128K以内），就是通过系统调用 brk 在Heap 分配的。</li></ul><p><strong>（4）Memory Mapping Segment</strong></p><ul><li>内存映射区，可以将文件映射进内存中。</li><li>执行二进制文件时需要链接某些动态链接库，可以把相应的 so 文件映射进此区域。</li><li>使用 mmap 可以将文件映射到内存映射区，可以快速地更改磁盘文件或进行进程间通信。</li><li>malloc 申请<strong>大内存</strong>，是通过系统调用 mmap 在 <strong>内存映射区</strong> 分配大块虚拟内存空间。</li><li>使用 munmap 释放内存映射区。</li></ul><p><strong>（5）Stack</strong></p><ul><li>普通局部变量，自动管理内存，后进先出 LIFO。</li><li>函数调用的函数栈就是用这里的。</li></ul><h3 id="2-3-用户空间的数据结构">2.3 用户空间的数据结构</h3><blockquote><p><code>mm_struct</code>：<a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/include/linux/mm_types.h#L380">/include/linux/mm_types.h</a></p><p>vm：virtual memory.</p><p>vma：virtual memory areas.</p></blockquote><h4 id="2-3-1-位置信息">2.3.1 位置信息</h4><p>用户空间里面有各个数据段，例如代码、堆、栈、内存映射区等。在 mm_struct 中定义了这些区域的统计信息和位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>......    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;    <span class="hljs-comment">/* base of mmap area */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_legacy_base; <span class="hljs-comment">/* base of mmap area in bottom-up allocations */</span>    <br>......<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_rss; <span class="hljs-comment">/* High-watermark of RSS usage */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_vm;  <span class="hljs-comment">/* High-water virtual memory usage */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> total_vm;    <span class="hljs-comment">/* Total pages mapped */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_vm;   <span class="hljs-comment">/* Pages that have PG_mlocked set */</span><br>    <span class="hljs-type">atomic64_t</span>    pinned_vm;   <span class="hljs-comment">/* Refcount permanently increased */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_vm;     <span class="hljs-comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm;     <span class="hljs-comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_vm;    <span class="hljs-comment">/* VM_STACK */</span>    <br>    <span class="hljs-type">spinlock_t</span> arg_lock; <span class="hljs-comment">/* protect the below fields */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="hljs-comment">/* for /proc/PID/auxv */</span>    <br>......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>mmap_base</code>：内存映射区的起始地址，内存映射区是从高地址到低地址增长的。</li><li><code>total_vm</code>：映射的总页数。当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，会被锁定，不能换出。</li><li><code>locked_vm</code>：被锁定不能换出的页数。</li><li><code>pinned_vm</code>：不能换出也不能移动的页数。</li><li><code>data_vm</code>：存放数据的页数。</li><li><code>exec_vm</code>：存放可执行文件的页数。</li><li><code>stack_vm</code>：存放栈的页数。</li><li><code>start_code 和 end_code</code>： 可执行代码的开始和结束位置</li><li><code>start_data 和 end_data</code> ：已初始化数据的开始位置和结束位置</li><li><code>start_brk</code> ：堆的起始位置</li><li><code>brk</code> ：堆当前的结束位置</li><li><code>start_stack</code> ：栈的起始位置，栈的结束位置在寄存器的栈顶指针中</li><li><code>arg_start 和 arg_end</code> ：参数列表的位置，位于栈中最高地址的地方。</li><li><code>env_start 和 env_end</code> ：环境变量的位置，位于栈中最高地址的地方。</li></ul><h4 id="2-3-2-属性信息">2.3.2 属性信息</h4><p>除了位置信息之外，还有一个重要结构 vm_area_struct，专门来描述这些代码、全局变量、堆、栈、内存映射区等区域的属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> &#123;</span><br>        <span class="hljs-comment">/* The first cache line has the info for VMA tree walking. */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;                <span class="hljs-comment">/* Our start address within vm_mm. */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;                <span class="hljs-comment">/* The first byte after our end address within vm_mm. */</span><br>        <span class="hljs-comment">/* linked list of VM areas per task, sorted by address */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vm_next</span>, *<span class="hljs-title">vm_prev</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">vm_rb</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span>        <span class="hljs-comment">/* The address space we belong to. */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">anon_vma_chain</span>;</span> <span class="hljs-comment">/* Serialized by mmap_sem &amp;</span><br><span class="hljs-comment">                                          * page_table_lock */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anon_vma</span> *<span class="hljs-title">anon_vma</span>;</span>        <span class="hljs-comment">/* Serialized by page_table_lock */</span><br>        <span class="hljs-comment">/* Function pointers to deal with this struct. */</span><br>        <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> *<span class="hljs-title">vm_ops</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">vm_file</span>;</span>                <span class="hljs-comment">/* File we map to (can be NULL). */</span><br>        <span class="hljs-type">void</span> * vm_private_data;                <span class="hljs-comment">/* was vm_pte (shared mem) */</span><br><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><ul><li><code>vm_start</code> 和 <code>vm_end</code>：指定了该区域在用户空间中的起始和结束地址。</li><li><code>vm_next</code> 和 <code>vm_prev</code>：如下图，将当前区域串在链表 mmap 上。</li><li><code>vm_rb</code>：对应一颗红黑树的节点，这颗红黑树将所有<code>vm_area_struct</code>组合起来，便于增删查找。</li><li><code>vm_ops</code>：对这个内存区域可以做的操作的定义。</li><li><code>anon_vma</code>：匿名映射。虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，映射到文件需要 <code>vm_file</code> 指定被映射文件，<code>vm_pgoff</code> 存储偏移量。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-t75Inq.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>在上图可以看到，在 mm_struct 中定义了两个指针，mmap 和 mm_rb。</p><ul><li>mmap 指向一个通过<code>vm_next</code>和<code>vm_prev</code>组合而成的双向链表，将各个区域 <code>vm_area_struct</code> 串联起来。</li><li>mm_rb 指向一颗红黑树，这颗红黑树将所有<code>vm_area_struct</code>组合起来，便于增删查找。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>......    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">mmap</span>;</span>        <span class="hljs-comment">/* list of VMAs */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span>  <br>......    <br>&#125;<br></code></pre></td></tr></table></figure><p>mm_rb 的类型是 rb_root；vm_rb 的类型是 rb_node。二者定义如下，可以看出 mm_rb 就是 <code>struct rb_node *</code>类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  __rb_parent_color;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rb_right</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rb_left</span>;</span><br>&#125; __attribute__((aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>))));<br>    <span class="hljs-comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rb_node</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-4-用户空间内存映射的建立">2.4 用户空间内存映射的建立</h3><blockquote><p><code>load_elf_binary</code> ：<a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/binfmt_elf.c#L61">/fs/binfmt_elf</a></p></blockquote><blockquote><p><strong>换句话问</strong>：<code>mm_struct</code> 中各区域的位置、属性信息是如何与众多 <code>vm_area_struct</code> 联系起来的呢？</p><p><strong>一句话答</strong>：在 <code>load_elf_binary</code> 中完成。<code>load_elf_binary</code> 中定义了一个 <code>mm_struct</code> 类型指针变量 <code>mm</code>，并指向 <code>current-&gt;mm</code>（当前进程的 <code>mm_struct</code>）。通过对 mm 的赋值，完成内存映射的建立。</p></blockquote><p>无论是加载内核、调用第一个用户态进程 init，还是 exec 运行一个二进制程序都需要加载 ELF 文件，即调用 <code>load_elf_binary</code> 函数。</p><p>在 <code>load_elf_binary</code> 中，加载 ELF 文件后，会建立内存映射，主要做以下几件事：</p><ul><li>调用 <code>setup_new_exec</code>，设置内存映射区 <code>mmap_base</code>；</li><li>调用 <code>setup_arg_pages</code>，设置栈的 <code>vm_area_struct</code>，这里面设置了 <code>mm-&gt;arg_start</code> 是指向栈底的，<code>current-&gt;mm-&gt;start_stack</code> 就是栈底；</li><li><code>elf_map</code> 会将 ELF 文件中的代码部分映射到内存中来；</li><li><code>set_brk</code> 设置了堆的 <code>vm_area_struct</code>，这里面设置了 <code>current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk</code>，也就是说，堆里面还是空的；</li><li><code>load_elf_interp</code> 将依赖的 so 文件映射到内存中的内存映射区域。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_elf_binary</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br>......<br>  setup_new_exec(bprm);  <span class="hljs-comment">// 设置内存映射区 mmap_base</span><br>......<br>  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),<br>                                 executable_stack);  <span class="hljs-comment">// 设置栈的 vm_area_struct</span><br>......<br>  error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,<br>                                elf_prot, elf_flags, total_size);  <span class="hljs-comment">// 加载 ELF 中代码</span><br>......<br>  retval = set_brk(elf_bss, elf_brk, bss_prot); <span class="hljs-comment">// 设置了堆的 vm_area_struct</span><br>......<br>  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,<br>                                            interpreter,<br>                                            &amp;interp_map_addr,<br>                                            load_bias, interp_elf_phdata);<br>......<br>  mm = current-&gt;mm;<br>  <span class="hljs-comment">// current 是 get_current() 的宏，current 就是当前进程的指针。</span><br>  <span class="hljs-comment">// mm 指向 current-&gt;mm，也就是说，之后的所有操作，都是在操作进程的 mm_struct。</span><br>  <br>  current-&gt;mm-&gt;end_code = end_code;<br>  current-&gt;mm-&gt;start_code = start_code;<br>  current-&gt;mm-&gt;start_data = start_data;<br>  current-&gt;mm-&gt;end_data = end_data;<br>  current-&gt;mm-&gt;start_stack = bprm-&gt;p;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-内核空间的布局">2.5 内核空间的布局</h3><blockquote><p>到了内核里面，并不会直接使用物理内存地址了，依然使用虚拟地址，以下讨论的均是虚拟地址。</p></blockquote><p>在看内核态布局之前，先明确四个重要概念。</p><p><strong>（1）进程无法访问内核空间</strong></p><p>进程无法访问，只能通过调用系统调用，进入内核。</p><p><strong>（2）创建进程时内核态会创建 <code>task_struct</code> 实例</strong></p><p>进程创建需要使用系统调用，此时内核态会在直接映射区创建 <code>task_struct</code> 实例。<code>task_struct</code> 中有 <code>mm_struct</code> 来管理虚拟地址空间。</p><p><strong>（3）内核空间是共享的</strong></p><ul><li>内核态的虚拟地址空间和进程是无关的，所有进程通过系统调用进入到内核之后，看到的虚拟地址空间都是一样的。</li><li>在内核空间中，每个进程都有独立的内核栈，内核栈是各用各的。但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-21-oUOM3S.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（4）内核里面也会有内核的代码</strong></p><ul><li>内核同样有 Text Segment、Data Segment 和 BSS Segment。</li><li>内核启动的时候，内核代码也是 ELF 格式的。</li></ul><blockquote><p>在内核态，32 位和 64 位的布局差别比较大，主要是因为 32 位内核态空间太小了，下面分别讨论。</p></blockquote><h4 id="2-5-1-32-位内核态布局">2.5.1 32 位内核态布局</h4><p><img src="https://hutu.aimtao.net/mark/2022-06-21-yXBZMv.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（1）直接映射区</strong></p><p>32 位的内核态虚拟地址空间一共就 1G，占绝大部分的前 896M 就是直接映射区。直接映射区和物理内存的一整块空间直接映射。虚拟内存地址减去 3G，就得到物理内存的位置。</p><p>内核中有两个宏用于虚拟地址和物理地址之间的转化：</p><ul><li>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址。</li><li>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 目录：/source/arch/alpha/include/asm/page.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)    ((unsigned long) (x) - PAGE_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __va(x)    ((void *)((unsigned long) (x) + PAGE_OFFSET))</span><br></code></pre></td></tr></table></figure><p>直接映射区主要有三部分：</p><ul><li><strong>ELF 段</strong>：在系统启动的时候，物理内存的前 1M 已经被占用了。因为直接映射区是直接映射到物理内存的 0 - 896M 区域，所以虚拟内存空间中，也是从 1M 之后加载 txt、data、bss 段。</li><li><strong><code>task_struct</code></strong> <strong>实例</strong>：在内核运行的过程中，如果碰到系统调用创建进程，会创建 <code>task_struct</code> 实例，内核的进程管理代码会将实例创建在 3G 至 3G+896M 的虚拟空间中，当然也会被放在物理内存里面的前 896M 里面，相应的页表也会被创建。</li><li><strong>内核栈</strong>：在内核运行的过程中，会涉及内核栈的分配，内核的进程管理的代码会将内核栈创建在 3G 至 3G+896M 的虚拟空间中，当然也就会被放在物理内存里面的前 896M 里面，相应的页表也会被创建。</li></ul><p><strong>补充</strong>：一个物理内存的概念: <strong>高端内存</strong></p><ul><li>x86 架构中将物理地址空间划分三部分，也叫区域（后面在讲 物理内存的组织方式 会详细提到区域。）：<code>ZONE_DMA</code>、<code>ZONE_NORMAL</code> 和 <code>ZONE_HIGHMEM</code>。<code>ZONE_HIGHMEM</code> 被称为高端内存，也就是 896M 到 4G 之间的这段物理内存（32 位最大寻址空间为 4G）。</li><li>内核中除了内存管理模块外，其余均操作虚拟地址。但是 896M 到 1G ，只有这 128M 虚拟地址空间，无法直接映射/访问到所有的高端内存。</li><li>这 128M 虚拟地址空间分为内核动态映射空间、持久内核映射区、固定映射区、临时映射区。通过这四个区进行动态映射，达到访问所有高端内存的目的。</li><li>访问高端内存的最基本思想：在 128M 虚拟地址空间中，借一段虚拟地址空间，建立临时地址映射，用完后释放，这段虚拟地址空间可以循环使用，访问所有物理内存。</li></ul><p><strong>（2）内核动态映射空间（noncontiguous memory allocation）</strong></p><ul><li>VMALLOC_START 到 VMALLOC_END 之间称为内核动态映射空间，，在内核里可以使用 vmalloc 来申请内存。</li><li>例子：假设物理内存中 896M 到 1.5G 之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核 vmalloc 的时候，只能从分配物理内存 1.5G 开始，就需要使用内核动态映射空间的虚拟地址进行映射，映射关系放在专门给内核自己用的页表里面。</li></ul><p><strong>（3）持久内核映射区（permanent kernel mapping）</strong></p><ul><li><code>PKMAP_BASE</code> 到 <code>FIXADDR_START</code> 的空间称为持久内核映射，这个地址范围是 4G-8M 到 4G-4M 之间。</li><li>使用 <code>alloc_pages()</code> 函数的时候，在物理内存的高端内存得到 <code>struct page</code> 结构，可以调用 <code>kmap()</code> 将其在映射到这个区域。</li><li>因为允许永久映射的数量有限，当不再需要高端内存时，应该解除映射，这可以通过<code>kunmap()</code>函数来完成。</li></ul><p><strong>（4）固定映射区（fixing mapping）</strong></p><ul><li>FIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为固定映射区域。</li><li>主要用于满足特殊需求。</li></ul><p><strong>（5）临时映射区（temporary kernel mapping）</strong></p><ul><li>在固定映射区中，会使用一些空间当作临时映射区。</li><li>临时内核映射通过 <code>kmap_atomic</code> 和 <code>kunmap_atomic</code> 实现，主要用于当需要写入物理内存或主存时的操作，如将文件从主存写入内存或者将文件从内存写入主存时使用。</li><li>例子：用户态需要将一个文件映射到虚拟地址空间中。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-21-ZqZn1x.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="2-5-2-63-位内核态布局">2.5.2 63 位内核态布局</h4><blockquote><p>注意：下图引用自《趣谈 Linux 操作系统》，作者在做图时，部分地址偏移了1 Byte，但不影响整体叙述逻辑（我这边太懒了，就不重画了）。</p><p>打个比方，一个 16 Byte 的空间，首地址是 0x00，最后一块地址应该是 0x0F，作者写成了 0x10。</p><p>比如在图中，<code>VMALLOC_START</code> 是 vmalloc 区域的首地址，<code>VMALLOC_END</code> 是 vmalloc 区域的最后一块地址。Vmalloc 区域是 32T，所以 <code>VMALLOC_END</code> 应该是 <code>0xFFFF E8FF FFFF FFFF</code>。</p></blockquote><p><img src="https://hutu.aimtao.net/mark/2022-06-23-t7BQDc.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>64 位的内核布局反而简单，因为虚拟空间实在是太大了，根本不需要高端内存，因为内核虚拟地址空间是 128T，根本不可能有物理内存超过这个值。</p><p>64 位的内核主要包含以下几个部分：</p><ul><li>从 <code>0xFFFF 8000 0000 0000</code> 开始就是内核的部分，只不过一开始有 8T 的空档区域。</li><li>从 <code>__PAGE_OFFSET_BASE(0xFFFF 8800 0000 0000)</code> 开始的 64T 的虚拟地址空间是直接映射区域，减去 <code>PAGE_OFFSET</code>（即内核态与用户态的分界线） 就是物理地址。</li></ul><p>注意：因为 64 位的直接映射区 64T 足够大，足以直接映射整个物理内存。但大部分情况下，虚拟地址和物理地址之间的映射还是会通过建立页表的方式进行映射。</p><ul><li>从 <code>VMALLOC_START（0xFFFF C900 0000 0000）</code>开始到 <code>VMALLOC_END（0xFFFF E900 0000 0000）</code>的 32T 的空间是给 <code>vmalloc</code> 的。</li><li>从 <code>VMEMMAP_START（0xFFFF EA00 0000 0000）</code> 开始的 1T 空间用于存放物理页面的描述结构 <code>struct page</code>的。</li><li>从 <code>__START_KERNEL_map（0xFFFF FFFF 8000 0000）</code> 开始的 512M 用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 <code>__START_KERNEL_map</code> 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空档区域，早就过了内核代码在物理内存中加载的位置。</li></ul><h3 id="2-6-一张图总结">2.6 一张图总结</h3><h4 id="32-位">32 位</h4><p>创建进程时，内核态会在直接映射区创建 <code>task_struct</code> 用来管理进程。<code>task_struct</code> 中有 <code>mm_struct</code> 来管理虚拟地址空间。</p><p>下图中，直接映射区有 <code>task_struct</code>、<code>mm_struct</code>、<code>vm_area_struct</code> 来表示虚拟地址空间。但需要注意的是，一个系统中有多个进程，直接映射区中也是有多个 <code>task_struct</code>，而不是只对应一个虚拟内存空间。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-P0b4XG.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="64-位">64 位</h4><p>与 32 位相比，64位的内核态简单得多，并且内核态代码有专门的代码段。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-AaSTfx.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="3-地址映射之分段机制">3.地址映射之分段机制</h2><p>在 <a href="https://www.aimtao.net/boot/">Linux 内核｜启动</a> 中，有提到分段机制，规划虚拟空间的时候，也是将空间分成多个段（Segment）进行保存。</p><h3 id="3-1-分段机制的原理">3.1 分段机制的原理</h3><p><img src="https://hutu.aimtao.net/mark/2022-06-23-33FqP1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。</p><ul><li>段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。</li><li>虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><p>例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示。</p><p>如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-sZnOOr.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="3-2-分段机制在-Linux-中的使用">3.2 分段机制在 Linux 中的使用</h3><p>段表全称段描述符表（segment descriptors），放在全局描述符表 GDT（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项。从 <code>GDT_ENTRY_INIT</code> 宏可以看出，一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">        .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">        .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">            ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">&#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>在下面代码中可以看到，无论 64 位的还是 32 位的，都使用 <code>GDT_ENTRY_INIT</code> 定义了内核代码段、内核数据段、用户代码段和用户数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_PER_CPU_PAGE_ALIGNED(<span class="hljs-keyword">struct</span> gdt_page, gdt_page) = &#123; .gdt = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>    [GDT_ENTRY_KERNEL32_CS]     = GDT_ENTRY_INIT(<span class="hljs-number">0xc09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_KERNEL_CS]       = GDT_ENTRY_INIT(<span class="hljs-number">0xa09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_KERNEL_DS]       = GDT_ENTRY_INIT(<span class="hljs-number">0xc093</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_DEFAULT_USER32_CS]   = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_DEFAULT_USER_DS] = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_DEFAULT_USER_CS] = GDT_ENTRY_INIT(<span class="hljs-number">0xa0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    [GDT_ENTRY_KERNEL_CS]       = GDT_ENTRY_INIT(<span class="hljs-number">0xc09a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_KERNEL_DS]       = GDT_ENTRY_INIT(<span class="hljs-number">0xc092</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_DEFAULT_USER_CS] = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fa</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>    [GDT_ENTRY_DEFAULT_USER_DS] = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>......<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; &#125;;<br>EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);<br></code></pre></td></tr></table></figure><p>值得注意的是，上面代码中 <code>GDT_ENTRY_INIT</code> 第二个参数 base 都是 0，也就是说，所有的段的起始地址都是一样的，<strong>都是 0</strong>。</p><ul><li>在 Linux 操作系统中，并没有使用到全部的分段功能。</li><li>那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_CS         (GDT_ENTRY_KERNEL_CS*8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_DS         (GDT_ENTRY_KERNEL_DS*8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_DS           (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_CS           (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span><br></code></pre></td></tr></table></figure><p>Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。</p><h2 id="4-地址映射之分页机制">4.地址映射之分页机制</h2><h3 id="4-1-物理内存分页">4.1 物理内存分页</h3><p>操作系统把物理内存分成一块一块大小相同的页，这样更方便管理。有的内存页面长时间不用了，可以暂时写到硬盘上，称为<strong>换出</strong>。一旦需要的时候，再加载进来，叫作<strong>换入</strong>。<strong>好处</strong>：这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p><p>换入和换出都是以页为单位的，页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-UD0J7A.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="4-2-虚拟内存分页">4.2 虚拟内存分页</h3><p>虚拟内存地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p><p>虚拟内存中的页通过页表映射到物理内存中的页。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-cvc5SF.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="4-3-问题：页表过大">4.3 问题：页表过大</h3><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于 1G 的内核态来讲，页表太大 。</p><p>而且页表中所有页表项必须提前建好，并且要求虚拟地址里面的页号是连续的。否则无法通过虚拟地址里面的页号找到对应的页表项。</p><h3 id="4-4-解决：多级页表">4.4 解决：多级页表</h3><p><strong>（1）什么是多级页表</strong></p><p>4G 的虚拟地址空间需要 4M 的页表来储存映射。将这 4M 的空间进行分页，则需要 4K 的页表来储存映射，这 4K 的页表称为页目录页。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-21-QOlPey.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）多级页表需要多少内存来映射</strong></p><p>如上图所示，4G 的虚拟地址空间需要使用 4M + 4K 的内存来映射。但实际上并不会给一个进程分配所有的内存。</p><p>当某进程需要一页数据时，如果只使用页表，1M 个页表项，就需要 4M 的内存来储建立页表。但如果使用页目录表，只需要使用 8K，也就是上图中红色区域。</p><p>为什么呢？保存 1K 个页目录项，需要 4K 内存。通过页目录项，就可以定位到页表项的大致范围，这个大致范围就是页表项所在的页表项页，而页表项页只需 4K。所以加起来只需要 4K + 4K = 8K。</p><p><strong>（3）如何找到映射的物理地址</strong></p><p>一个虚拟地址 4 Byte，32 bit。其中，页目录项 10 bit，页表项 10 bit，页内偏移 12 bit。（仔细想想，10bit/10bit/12bit 完全够用，可以定位虚拟内存/物理内存的任何一个位置）</p><ul><li>通过 <code>前 10bit</code> 在页目录表中找到页目录项。页目录项中记录了一整页页表的物理地址。</li><li>通过 <code>中间 10bit</code> 在这页页表中，找到页表项。页表项中记录了虚拟地址的页，所对应的物理地址页。</li><li>通过 <code>最后 12bit</code> 的页内偏移量，在物理地址页中定位到想要的数据。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-4kzPw4.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="4-5-64-位的四级目录">4.5 64 位的四级目录</h3><p>对于 64 位的系统，两级也不够用，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-rdCOLQ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="5-物理内存管理之组织方式">5.物理内存管理之组织方式</h2><h3 id="5-1-三种内存模型的演进">5.1 三种内存模型的演进</h3><blockquote><p>下面关于内存模型的三张图出自 <a href="https://chasinglulu.github.io/2019/05/29/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%8Cmemory-model%E3%80%8D/">内存模型</a> 这篇文章，写的非常详尽。</p></blockquote><h4 id="5-1-1-什么是内存模型">5.1.1 什么是内存模型</h4><ul><li>物理内存被划分成一个个大小为 4K 的页帧（Page Frame），每个页帧都有唯一的编号，叫PFN(Page Frame Number)。</li><li>对于每个物理页帧，内核都会创建一个 <code>struct page</code> 的数据结构来封装每个物理页帧的状态，因此物理页帧与 <code>page</code> 之间存在着1:1的关系。</li><li>系统必须提供两者之间相互转换的方式，即系统可以通过 PFN 拿到对应的 <code>struct page</code>, 也可以通过 <code>struct page</code> 得到对应的 PFN, 内核中提供了两个宏来完成该转换，分别是 <code>page_to_pfn</code> 与 <code>pfn_to_page</code>。</li><li>内存模型是指 Linux 内核用怎么样的方式去管理物理内存，其主要解决的问题就是如何组织内存页帧，使得 PFN 与 <code>struct page</code> 转换能够高效便捷地实现。</li></ul><h4 id="5-1-2-平坦内存模型-FLATMEM">5.1.2 平坦内存模型 FLATMEM</h4><blockquote><p>FLAT memory mode</p></blockquote><ul><li>理想情况下，物理内存是一块地址连续的存储空间，这样物理页帧的PFN也是连续的，因此最简单直接地方式是将所有的 <code>struct page</code> 保存在全局变量 <code>mem_map</code> 中。每个 <code>struct page</code> 的索引就是对应物理页帧的PFN。因而对于任何一个地址，只要直接除一下每页的大小，很容易直接算出在哪一页。</li><li>如果是这样，整个物理内存的布局就非常简单、易管理，这就是最经典的平坦内存模型（Flat Memory Model）。</li><li>Linux早期使用的就是这种内存模型，比如下面所讲的 SMP / UMA 就是使用的 FLATMEM。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-YVGzgD.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="5-1-3-不连续内存模型-DISCONTIGMEM">5.1.3 不连续内存模型 DISCONTIGMEM</h4><blockquote><p>Discontiguous Memory Model</p></blockquote><ul><li>如果物理内存存在大块的不连续区间，由于 <code>mem_map</code> 使用PFN作为 <code>page</code> 的索引，那么这些不连续区间对应的PFN就也会占用 <code>mem_map</code> 中的位置，形成空洞（hole），造成大量的内存空间浪费。</li><li>比如后面讲的 NUMA 就是非连续内存模型。</li><li>为了解决以上问题，对于每个 NUMA 的内存节点，Linux都构造一个独立的内存管理子系统，由 struct pglist_data 表示。pg_data_t 包含 node_mem_map 数组，它映射属于该节点的物理页面。</li><li>每个 node_mem_map 数组其实就是一个 FLATMEM。</li><li>DISCONTIGMEM是个稍纵即逝的内存模型，在SPARSEMEM出现后即被完全替代。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-rYzIh5.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="5-1-4-稀疏内存模型-SPARSEMEM">5.1.4 稀疏内存模型 SPARSEMEM</h4><blockquote><p>Sparse Memory Model</p></blockquote><ul><li>DISCONTIGMEM 的本意是应对非连续的物理内存，但其又将NUMA架构下的每个 node 看着是连续的，这其实并不合理，特别是在支持内存热插拔的系统当中。</li><li>系统需要一种机制能够更灵活地管理粒度更小的连续内存区块，这种内存模型叫着稀疏内存模型（Sparse Memory Model）。</li><li>SPARSEMEM 已经完全覆盖了前两个内存模型的所有功能，特别是可以完全替代不够灵活的 DISCONTIGMEM，SPARSEMEM 是当前内核默认的选择。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-2IsFHr.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="5-2-两种多处理器计算机体系架构">5.2 两种多处理器计算机体系架构</h3><blockquote><p>下面描述的对称多处理器与非对称多处理器中，<strong>所指的处理器是物理 CPU 的意思</strong>（是硬件概念，和在软件看来多核和多线程就是多个处理器），多处理器就是主板上有多个 CPU 插槽（socket）。家用 PC 通常是单 socket，服务器通常可支持 2 socket（也常称为“双路”），也有 4 或者 8 socket。</p></blockquote><h4 id="5-2-1-易混概念">5.2.1 易混概念</h4><blockquote><p>有关处理器 processor、CPU、核心 Core、线程 Threads 可以看这个<a href="https://www.zhihu.com/question/321291471/answer/660183713">知乎问题下 </a>「知乎用户G0K17q」 和 「木头龙」 的回答。</p></blockquote><p><strong>（1）处理器 processor</strong></p><p>对程序指令进行处理的设备。一开始是指那一小片物理处理器。随着技术发展，有了多核多线程处理器。在软件角度来看，多核多线程和多个物理处理器没有区别，能处理程序指令就是处理器。（所以常说的 processor 数、CPU数其实就是下面讲的线程数 threads ）</p><p><strong>（2）CPU</strong></p><p>某些计算机因为通用处理器的性能无法满足应用的性能需要，可以通过加装特殊的专用处理器来提供特定应用的性能。比如图形处理器 GPU 就是专用处理器。 这些专用处理器有一个统一的名词叫 Coprocessor，协处理器。为了与协处理器区分，传统的处理器一般称之为CPU（Central Process Unit，中央处理器）。</p><p><strong>（3）核心 Core</strong></p><p>物理核心，指 CPU 上完整、可独立执行控制流的处理单元，也是操作系统调度进程的单位。x86 的核包含了CPU运算的基本部件，如逻辑运算单元(ALU), 浮点运算单元(FPU), L1和L2缓存。 一个Socket里可以有多个Core。</p><p><strong>（4）线程 Threads</strong></p><p>也被常称为<strong>逻辑核心 logical core 、虚拟核心 virtual core、逻辑处理器 logical processor、processor 数、CPU 数</strong>（茴字的四种写法，咳咳）。CPU利用超线程(Hyper-Threading)技术，在一个物理核心 Core 内部引入了额外的硬件设计模拟了两个逻辑处理器 (Logical Processor)。 每个逻辑处理器都有独立的处理器状态，但共享Core内部的计算资源，如ALU，FPU，L1，L2缓存。</p><p><strong>（5）CPU 线程和程序线程</strong></p><p>这两个线程并不是一回<strong>事。<strong>程序的线程是软件概念，一个程序有多个线程，可以在处理器上轮流</strong>并发</strong>执行。CPU的线程是硬件的概念，线程数就是逻辑核心数。16线程就是能让16个线程<strong>并行</strong>执行。</p><p><strong>（6）常用查询命令</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"># 查看物理 cpu 数：<br>cat /proc/cpuinfo| grep <span class="hljs-string">&quot;physical id&quot;</span>| sort| uniq| wc -l<br><br># 查看每个物理 cpu 中 核心数(core 数)：<br>cat /proc/cpuinfo | grep <span class="hljs-string">&quot;cpu cores&quot;</span> | uniq<br><br># 查看总的逻辑 cpu 数（processor 数）：<br>cat /proc/cpuinfo| grep <span class="hljs-string">&quot;processor&quot;</span>| wc -l<br><br># 查看 cpu 型号：<br>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c<br></code></pre></td></tr></table></figure><h4 id="5-2-2-对称多处理器-SMP">5.2.2 对称多处理器 SMP</h4><blockquote><p>Symmetric multiprocessing</p></blockquote><p>对称多处理器架构，是目前最常见的多处理器计算机架构。CPU 是通过总线去访问内存的，这就是最经典的内存使用方式。（题外话：youtube 一个博主–笔记本维修厮，录修电脑的视频，很有意思。在他的维修案例中，经常会换南桥、北桥。实际上南桥、北桥就是下图中的 IO 芯片）</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-zDZpqb.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>在这种模式下，CPU 也会有多个，在总线的一侧。所有的内存条组成一大片内存，在总线的另一侧，所有的 CPU 访问内存都要过总线，而且距离都是一样的，这种模式称为 SMP。</p><h4 id="5-2-3-非对称多处理器-AMP">5.2.3 非对称多处理器 AMP</h4><blockquote><p>Asymmetric Multiprocessing</p></blockquote><p>非对称多处理器架构，则是与SMP相对的概念。举个 AMP 的例子，大部分手机都有两个处理器，AP（Application Processor，应用处理器）负责运算，BP（Baseband Processor，基带处理器）负责通信。AP 和 BP 两个处理器架构不一样，也叫异构。</p><p><strong>再次说明</strong>：SMP 和 AMP 讨论的只计算机系统层面的，关注对称与非对称，指的是多个物理处理器是否对称，也就是说多个物理处理器是否相同，而不关注处理器内部的设计。比如骁龙888处理器中有大小核，也就是说里面的物理核心 core 是不同，所以也叫做异构。但这不是我们探讨的范围，<strong>我们不关心物理处理器内部。</strong></p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-9dWvPQ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="5-2-4-SMP-和-AMP-区别">5.2.4 SMP 和 AMP 区别</h4><ul><li>SMP 的多个处理器都是同构的，使用相同架构的 CPU；而 AMP 的多个处理器则可能是异构的。</li><li>SMP 的多个处理器共享同一内存地址空间；而AMP的每个处理器则拥有自己独立的地址空间。</li><li>SMP 的多个处理器操通常共享一个操作系统的实例；而 AMP 的每个处理器可以有或者没有运行操作系统， 运行操作系统的CPU也是在运行多个独立的实例。</li><li>SMP 的多处理器之间可以通过共享内存来协同通信；而 AMP 则需要提供一种处理器间的通信机制。</li><li>x86多处理器服务器都是 SMP 架构的， 而很多嵌入式系统则是 AMP 架构的。</li></ul><h3 id="5-3-SMP-系统的两种内存架构">5.3 SMP 系统的两种内存架构</h3><p>SMP 系统中有两种模式 UMA 和 NUMA，这是根据处理器对共享内存的访问的距离来区分的。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-23-i5dEL5.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="5-3-1-UMA-一致性内存访问">5.3.1 UMA 一致性内存访问</h4><blockquote><p>Uniform memory access</p></blockquote><ul><li>UMA 模式下，处理器对共享内存的访问距离和时间是相同的。但UMA 有一个显著的缺点，就是总线会成为瓶颈，因为数据都要走它。</li><li>起初，SMP 系统都是 UMA 模式，UMA 是 SMP 架构系统最经典的内存架构。所以很多在表述时，UMA 和 SMP 可以相互替换。</li></ul><h4 id="5-3-2-NUMA-非一致内存访问">5.3.2 NUMA 非一致内存访问</h4><blockquote><p>Non-uniform memory access</p></blockquote><ul><li>为了提高性能和可扩展性，后来有了一种更高级的模式，NUMA（Non-uniform memory access），非一致内存访问。</li><li>在这种模式下，内存不是一整块。内存的访问时间是依赖于处理器和内存之间的相对位置的。 这种设计里存在和处理器相对近的内存，通常被称作本地内存；还有和处理器相对远的内存， 通常被称为非本地内存。</li><li>每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多。在本地内存不足的情况下，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。</li></ul><h3 id="5-4-NUMA-架构的节点、区域、页">5.4 NUMA 架构的节点、区域、页</h3><p>这里主要分析当前的主流场景，NUMA 方式。</p><h4 id="节点">节点</h4><p><strong>（1）概念</strong></p><ul><li>每个 CPU 和本地内存在一起，称为一个 NUMA 节点。</li><li>内存被分成了多个节点，每个节点再被分成一个一个的页。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，页号也就不再连续了。</li><li>于是内存模型就变成了非连续内存模型（后来被稀疏内存模型替代），管理起来就复杂一些。</li></ul><p><strong>（2）数据结构</strong></p><p>NUMA 节点用 <code>typedef struct pglist_data pg_data_t</code> 这个结构来表示，主要有以下的成员变量：</p><ul><li><code>node_id</code>：每一个节点都有自己的 ID。</li><li><code>node_mem_map</code>：当前节点的 <code>struct page</code> 数组，用于描述这个节点里面的所有的页。</li><li><code>node_start_pfn</code>：当前节点的起始页号。</li><li><code>node_spanned_pages</code>：当前节点中包含不连续的物理内存地址的页面数。</li><li><code>node_present_pages</code>：真正可用的物理页面的数目。</li><li><code>nr_zones</code>：当前节点的区域的数量。（区域下面会描述）</li><li><code>node_zonelists</code>：备用节点和它的内存区域的情况。如果本节点内存不够怎么办，就需要在备用节点中分配内存。</li></ul><p>举个例子：64M 物理内存隔着一个 4M 的空洞，然后是另外的 64M 物理内存。这样换算成页面数目就是，16K 个页面隔着 1K 个页面，然后是另外 16K 个页面。这种情况下，<code>node_spanned_pages</code> 就是 33K 个页面，<code>node_present_pages</code> 就是 32K 个页面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> <span class="hljs-title">node_zones</span>[<span class="hljs-title">MAX_NR_ZONES</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> <span class="hljs-title">node_zonelists</span>[<span class="hljs-title">MAX_ZONELISTS</span>];</span><br>    <span class="hljs-type">int</span> nr_zones;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">node_mem_map</span>;</span>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">/* total number of physical pages */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">/* total size of physical page range, including holes */</span><br>    <span class="hljs-type">int</span> node_id;<br>    <span class="hljs-type">wait_queue_head_t</span> kswapd_wait;<br>    <span class="hljs-type">wait_queue_head_t</span> pfmemalloc_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">kswapd</span>;</span> <span class="hljs-comment">/* Protected by mem_hotplug_begin/end() */</span><br>    <span class="hljs-type">int</span> kswapd_order;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">kswapd_classzone_idx</span>;</span><br>    <span class="hljs-type">int</span> kswapd_failures;        <span class="hljs-comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span><br>......<br>&#125; <span class="hljs-type">pg_data_t</span>;<br></code></pre></td></tr></table></figure><p><strong>（3）节点数组</strong></p><p>整个内存被分成了多个节点，多个 <code>pglist_data</code> 放在一个数组里面。每个节点一项，就像下面代码里面一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">node_data</span>[<span class="hljs-title">MAX_NUMNODES</span>] __<span class="hljs-title">read_mostly</span>;</span><br></code></pre></td></tr></table></figure><h4 id="区域">区域</h4><blockquote><p>区域是针对物理内存的。</p></blockquote><p><strong>（1）概念</strong></p><p>每一个节点分成多个区域 zone，放在数组 <code>node_zones</code> 里面。这个数组的大小为 <code>MAX_NR_ZONES</code>。</p><p><strong>（2）区域的类型</strong></p><p>区域的类型有如下几种，在上面描述 32 位内核态布局时，在高端内存部分已简单提过，这里详细说明。</p><ul><li><code>ZONE_DMA</code>：指可用于作 DMA（Direct Memory Access，直接内存存取）的内存。DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。</li><li><code>ZONE_DMA32</code>：对于 64 位系统，有两个 DMA 区域。除了上面说的 <code>ZONE_DMA</code>，还有<code>ZONE_DMA32</code>。</li><li><code>ZONE_NORMAL</code>：直接映射区，在上文 32 位内核态布局这部分有提到过，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射。</li><li><code>ZONE_HIGHMEM</code>：高端内存区，对于 32 位系统来说超过 896M 的地方，对于 64 位没必要有的一段区域。</li><li><code>ZONE_MOVABLE</code>：可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>    ZONE_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA32</span><br>    ZONE_DMA32,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ZONE_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    ZONE_HIGHMEM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ZONE_MOVABLE,<br>    __MAX_NR_ZONES<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）区域的数据结构</strong></p><p>区域的实现数据结构为<code>zone</code>。</p><ul><li><code>zone_start_pfn</code>：在一个 zone 里面，zone_start_pfn 表示属于这个 zone 的第一个页。</li><li><code>spanned_pages</code>：区域总共跨多少页。代码注释中有描述，spanned_pages = zone_end_pfn - zone_start_pfn，也即 spanned_pages 指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</li><li><code>present_pages</code>：区域在物理内存中真实存在的页数。代码注释中有描述，present_pages = spanned_pages - absent_pages(pages in holes)，区域总共跨多少页减去物理空洞，得到区域中真实的页。</li><li><code>managed_pages</code>：区域被伙伴系统管理的所有页数。代码注释中有描述，managed_pages present_pages - reserved_pages。</li><li><code>per_cpu_pageset</code>：用于区分冷热页。如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个 CPU 都有自己的高速缓存，因而 per_cpu_pageset 也是每个 CPU 一个。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>......<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span>  *<span class="hljs-title">zone_pgdat</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">pageset</span>;</span><br> <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       zone_start_pfn;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * spanned_pages is the total pages spanned by the zone, including</span><br><span class="hljs-comment">     * holes, which is calculated as:</span><br><span class="hljs-comment">     *  spanned_pages = zone_end_pfn - zone_start_pfn;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * present_pages is physical pages existing within the zone, which</span><br><span class="hljs-comment">     * is calculated as:</span><br><span class="hljs-comment">     *  present_pages = spanned_pages - absent_pages(pages in holes);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * managed_pages is present pages managed by the buddy system, which</span><br><span class="hljs-comment">     * is calculated as (reserved_pages includes pages allocated by the</span><br><span class="hljs-comment">     * bootmem allocator):</span><br><span class="hljs-comment">     *  managed_pages = present_pages - reserved_pages;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       managed_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       spanned_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       present_pages;<br> <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>      *name;<br>......<br>    <span class="hljs-comment">/* free areas of different sizes */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>    <span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br> <br>    <span class="hljs-comment">/* zone flags, see below */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       flags;<br> <br>    <span class="hljs-comment">/* Primarily protects free_area */</span><br>    <span class="hljs-type">spinlock_t</span>      lock;<br>......<br>&#125; ____cacheline_internodealigned_in_<br></code></pre></td></tr></table></figure><h4 id="页">页</h4><p><strong>（1）概念</strong></p><p>页是组成物理内存的基本单位。</p><p><strong>（2）数据结构</strong></p><p>页的数据结构是 <code>struct page</code>。这是一个很复杂的结构，里面使用了很多的 union 联合体。union 结构是在 C 语言中被用于同一块内存根据情况保存不同类型数据的一种方式。之所以用了 union，是因为一个物理页面使用模式有多种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span>  <br>        <span class="hljs-type">void</span> *s_mem;            <span class="hljs-comment">/* slab first object */</span><br>        <span class="hljs-type">atomic_t</span> compound_mapcount; <span class="hljs-comment">/* first tail page */</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">pgoff_t</span> index;      <span class="hljs-comment">/* Our offset within mapping. */</span><br>        <span class="hljs-type">void</span> *freelist;     <span class="hljs-comment">/* sl[aou]b first free object */</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> counters;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">atomic_t</span> _mapcount;<br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> active;        <span class="hljs-comment">/* SLAB */</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">/* SLUB */</span><br>                    <span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>                    <span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>                    <span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>                &#125;;<br>                <span class="hljs-type">int</span> units;          <span class="hljs-comment">/* SLOB */</span><br>            &#125;;<br>            <span class="hljs-type">atomic_t</span> _refcount;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span>   <span class="hljs-comment">/* Pageout list  */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pagemap</span> *<span class="hljs-title">pgmap</span>;</span> <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-comment">/* slub per cpu partial pages */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">/* Next partial slab */</span><br>            <span class="hljs-type">int</span> pages;  <span class="hljs-comment">/* Nr of partial slabs left */</span><br>            <span class="hljs-type">int</span> pobjects;   <span class="hljs-comment">/* Approximate # of objects */</span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> compound_head; <span class="hljs-comment">/* If bit zero is set */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compound_dtor;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compound_order;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span>  <span class="hljs-comment">/* SL[AU]B: Pointer to slab */</span><br>    &#125;;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-物理页的两种使用模式">5.5 物理页的两种使用模式</h3><p>物理页的使用方式不同，union 中也会使用不同的变量。</p><h4 id="第一种模式：要用就用一整页">第一种模式：要用就用一整页</h4><p><strong>（1）概念</strong></p><p>这一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为匿名页（Anonymous Page）。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</p><p><strong>（2）数据结构</strong></p><p>如果某一页是这种使用模式，<code>struct page</code> 会使用 union 中的以下变量：</p><ul><li><code>struct address_space *mapping</code>：用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0。</li><li><code>pgoff_t index</code>：在映射区的偏移量。</li><li><code>atomic_t _mapcount</code>：每个进程都有自己的页表，这里指有多少个页表项指向了这个页。</li><li><code>struct list_head lru</code>：表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中。</li><li><code>compound</code> 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li></ul><h4 id="第二种模式：仅需分配小块内存">第二种模式：仅需分配小块内存</h4><blockquote><p>目前内核中有三种方式来实现小块内存分配：slab, slub, slob。最先有 slab 分配器，slub/slob 分配器是改进版，slob 分配器适用于小内存嵌入式设备，而 slub 分配器目前已逐渐成为主流块分配器。</p></blockquote><p>有时候，我们不需要一下子分配这么多的内存，例如分配一个 <code>task_struct</code> 结构，只需要分配小块的内存，去存储这个进程描述结构的对象。</p><p><strong>（1）slab</strong></p><p>为了满足对这种小内存块的需要，Linux 系统采用了一种被称为 slab allocator 的技术，用于分配称为 slab 的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 / 被放回池子 / 应该被回收）。</p><p>如果某一页是用于分割成一小块一小块的内存进行分配的使用模式，则会使用 union 中的以下变量：</p><ul><li>s_mem 是已经分配了正在使用的 slab 的第一个对象。</li><li>freelist 是池子中的空闲对象。</li><li>rcu_head 是需要释放的列表。</li></ul><p><strong>（2）slub</strong></p><p>正是因为 slab allocator 对于队列的维护过于复杂，后来就有了一种不使用队列的分配器 slub allocator，后面我们会解析这个分配器。</p><p><strong>（3）slob</strong></p><p>还有一种小块内存的分配器称为slob，非常简单，主要使用在内存比较小的小型嵌入式系统。</p><h2 id="6-物理内存管理之页的分配">6.物理内存管理之页的分配</h2><h3 id="6-1-伙伴系统">6.1 伙伴系统</h3><p>对于要分配比较大的内存，分配页级别的，可以使用伙伴系统（Buddy System）。伙伴系统在 <a href="https://www.aimtao.net/operating-system/#5-6-Linux-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">学习笔记｜操作系统</a> 中有形象的描述过。</p><h4 id="6-1-1-特点">6.1.1 特点</h4><ul><li>Linux 中的内存管理的“页”大小为 4KB。</li><li>把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512、1024 个连续页的页块。最大可以申请 1024 个连续页，对应 4MB 大小的连续内存。</li><li>每个页块的第一个页的物理地址是该页块大小的整数倍。</li><li>第 i 个页块链表中，每个页块中页的数目为 2^i。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-UVwOjm.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>在 struct zone 里面有定义了 <code>struct free_area</code> 类型的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>    <span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>MAX_ORDER</code> 是 11，表示最大可以申请到 2^(11-1) = 1024 个连续页。在 <code>free_area[10]</code> 所指向的页块链表中，页块都是由 1024 个连续页组成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER 11</span><br></code></pre></td></tr></table></figure><h4 id="6-1-2-分配方式">6.1.2 分配方式</h4><ul><li>当向内核请求分配 (2^(i-1)，2^i] 数目的页块时，按照 2^i 页块请求处理。</li><li>如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。</li><li>当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。</li><li>例如：要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。</li></ul><p>上面这个过程，我们可以在分配页的函数 <code>alloc_pages</code> 中看到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">alloc_pages</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> alloc_pages_current(gfp_mask, order);<br>&#125;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  alloc_pages_current - Allocate pages.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  @gfp:</span><br><span class="hljs-comment"> *      %GFP_USER   user allocation,</span><br><span class="hljs-comment"> *          %GFP_KERNEL kernel allocation,</span><br><span class="hljs-comment"> *          %GFP_HIGHMEM highmem allocation,</span><br><span class="hljs-comment"> *          %GFP_FS     don&#x27;t call back into a file system.</span><br><span class="hljs-comment"> *          %GFP_ATOMIC don&#x27;t sleep.</span><br><span class="hljs-comment"> *  @order: Power of two of allocation size in pages. 0 is a single page.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  Allocate a page from the kernel page pool.  When not in</span><br><span class="hljs-comment"> *  interrupt context and apply the current process NUMA policy.</span><br><span class="hljs-comment"> *  Returns NULL when no page can be allocated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">alloc_pages_current</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp, <span class="hljs-type">unsigned</span> order)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *<span class="hljs-title">pol</span> =</span> &amp;default_policy;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>......<br>    page = __alloc_pages_nodemask(gfp, order,<br>                policy_node(gfp, pol, numa_node_id()),<br>                policy_nodemask(gfp, pol));<br>......<br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（1）首先</strong>， <code>alloc_pages</code> 会调用 <code>alloc_pages_current</code>，<code>alloc_pages_current</code> 的参数的注释很详细。参数 order，表示分配 2 的 order 次方个页；参数 gfp 表示希望在哪个区域中分配这个内存：</p><ul><li><code>GFP_USER</code> 用于分配一个页映射到用户进程的虚拟地址空间，并且希望直接被内核或者硬件访问，主要用于一个用户进程希望通过内存映射的方式，访问某些硬件的缓存，例如显卡缓存。</li><li><code>GFP_KERNEL</code> 用于内核中分配页，主要分配 <code>ZONE_NORMAL</code> 区域，即直接映射区。</li><li><code>GFP_HIGHMEM</code>，顾名思义就是主要分配高端区域的内存。</li></ul><p><strong>（2）接下来</strong>，调用 <code>__alloc_pages_nodemask</code>。这是伙伴系统的核心方法。</p><ul><li>它会调用 <code>get_page_from_freelist</code>。这里面的逻辑就是，在一个循环中先看当前节点的 zone。如果找不到空闲页，则再看备用节点的 zone。每一个 zone，都有伙伴系统维护的各种大小的队列，就像上面伙伴系统原理里讲的那样。</li><li><code>get_page_from_freelist</code> 最后调用 <code>rmqueue</code> 就是找到合适大小的那个队列，把页面取下来。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">get_page_from_freelist</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> alloc_context *ac)</span><br>&#123;<br>......<br>    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx, ac-&gt;nodemask) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>......<br>        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,<br>                gfp_mask, alloc_flags, ac-&gt;migratetype);<br>......<br></code></pre></td></tr></table></figure><p><strong>（3）最后</strong>，进入 <code>rmqueue</code> 的调用链：<code>rmqueue-&gt;__rmqueue-&gt;__rmqueue_smallest</code>。在这里可以看到伙伴系统的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class">                        <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><br>    <span class="hljs-comment">/* Find a page of the appropriate size in the preferred list */</span><br>    <span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>        area = &amp;(zone-&gt;free_area[current_order]);<br>        page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],<br>                            <span class="hljs-keyword">struct</span> page, lru);<br>        <span class="hljs-keyword">if</span> (!page)<br>            <span class="hljs-keyword">continue</span>;<br>        list_del(&amp;page-&gt;lru);<br>        rmv_page_order(page);<br>        area-&gt;nr_free--;<br>        expand(zone, page, order, current_order, area, migratetype);<br>        set_pcppage_migratetype(page, migratetype);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从当前的 order，也即指数开始，在伙伴系统的 free_area 找 2^order 大小的页块。</li><li>如果链表的第一个不为空，就找到了；如果为空，就到更大的 order 的页块链表里面去找。</li><li>找到以后，将页块从链表中取下来，当前页块链表的空闲空间 <code>nr_free</code> 计时减 1。</li><li>除此之外，我们还要把多余的的部分放到其他页块链表里面。</li></ul><p><code>__rmqueue_smallest</code> 最后调用 <code>expand</code>就是将多余的的部分放到其他页块链表里面。</p><ul><li><code>area--</code> 就是伙伴系统那个表里面的前一项。</li><li>前一项里面的页块大小是当前项的页块大小除以 2，size 右移一位也就是除以 2。</li><li>list_add 就是加到链表上，<code>nr_free++</code> 就是计数加 1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-keyword">struct</span> free_area *area,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br>    <span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>        area--;<br>        high--;<br>        size &gt;&gt;= <span class="hljs-number">1</span>;<br>    ......<br>        list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]);<br>        area-&gt;nr_free++;<br>        set_page_order(&amp;page[size], high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-3-一张图总结">6.1.3 一张图总结</h4><ul><li>如果有多个 CPU，那就有多个节点。每个节点用 <code>struct pglist_data</code> 表示，放在一个数组里面。</li><li>每个节点分为多个区域，每个区域用 <code>struct zone</code> 表示，也放在一个数组里面。</li><li>每个区域分为多个页。为了方便分配，空闲页放在 struct free_area 里面，使用伙伴系统进行管理和分配，每一页用 <code>struct page</code> 表示。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-23-rIR25V.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="6-2-Slub-allocator">6.2 Slub allocator</h3><p>除了整页分配，对于小内存的分配，会使用 slub 分配器。在上文中提到 slub 分配器目前是主流块分配器，下面具体来看一下 slub 的工作原理。</p><blockquote><p>这篇文章<a href="https://blog.csdn.net/lukuen/article/details/6935068"> slub 算法</a> 写的非常清晰形象，下面的图片都来自于这篇文章。</p></blockquote><h4 id="6-2-1-基本框架">6.2.1 基本框架</h4><p>一切源于 <code>kmalloc_caches[12]</code> 这个数组，该数组的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">struct kmem_cache kmalloc_caches[PAGE_SHIFT] __cacheline_aligned;<br></code></pre></td></tr></table></figure><p><code>kmalloc_caches[12]</code> 这个数组中有 12 个 <code>kmem_cache</code> 结构体，每个结构体负责分配一种大小的内存，分别是 2^3、2^4、…2^11个字节，另外还有两个特殊的组，分别是 96B 和 192B，共11组。</p><p>比如进程创建时，需要创建 <code>task_struct</code>、<code>mm_struct</code>、<code>fs_struct</code> 等不同大小的小内存块，就可以使用对应大小的 <code>kmem_cache</code> 来分配。</p><p><code>kmalloc_caches</code> 用于管理 slab 缓存。slab 缓存包含多个 slab 页面，一个 slab 页面包含多个页，并将这块内存划分成大小相同的对象 object。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-kLUUQh.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><code>kmalloc_caches</code> 中有两个结构体 <code>kmem_cache_cpu</code> 和 <code>kmem_cache_node</code>，每个NUMA节点都对应一个，分别是缓存分配的<code>fast path</code>和<code>slow path</code>。</p><ul><li><code>struct kmem_cache_cpu</code>：用于管理每个 CPU 的 slab 页面，可以使用无锁访问，提高缓存对象分配速度。<code>kmem_cache_cpu</code> 中只保留 1 个 slab 页面。</li><li><code>struct kmem_cache_node</code>：用于管理每个 Node 的 slab 页面，由于每个 Node 的访问速度不一致，slab 页面由 Node 来管理。</li></ul><p>下图是整个 slub 系统的框图：</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-0zmEtp.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="6-2-2-object-的数据结构">6.2.2 object 的数据结构</h4><p><img src="https://hutu.aimtao.net/mark/2022-06-28-7NhsEp.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>一个物理页被划分成多个 object，多个空闲 object 形成一个链表，如图，<code>object_size</code> 表示某内存块的大小，<code>size</code> 表示该内存块加上指针的总大小，<code>offset</code>表示下一个空闲内存块的指针的偏移量。</p><p>上图是指针外置的方式，实际上还有指针内置的方式。在可用内存块中，使用前 8 个字节储存指针变量。因为当这块内存被分配出去后，当前 object 就会从空闲链表里删除，就无需保留指针。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-jmKKMm.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="6-2-3-分配过程">6.2.3 分配过程</h4><p>每个NUMA节点都有一个 <code>kmem_cache_cpu</code>、<code>kmem_cache_node</code>，分别是缓存分配的<code>fast path</code>和<code>slow path</code>。</p><p>每次分配的时候，要先从 <code>kmem_cache_cpu</code> 进行分配。如果 <code>kmem_cache_cpu</code> 里面没有空闲的块，那就到 <code>kmem_cache_node</code> 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p><p><strong>（1）第一次分配</strong></p><ul><li><p>slub 系统刚刚创建出来，<code>kmem_cache_cpu</code> 和 <code>kmem_cache_node</code> 没有 slab 页面可以用来分配。</p></li><li><p>只能向伙伴系统申请一个或多个 page，并将其分成多个 object。</p></li><li><p>取出一个 object 返回给进程，其余的标记为空闲放入 <code>kmem_cache_cpu</code> 的一个 slab 页面中保存。</p></li><li><p><code>kmem_cache_cpu</code> 的 freelist 变量保存着下一个空闲 objetc 的地址。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-28-9bJhuQ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）</strong> <strong><code>kmem_cache_cpu</code></strong>  <strong>保存的 slab 页面中有空闲的 object。</strong></p><p>这种最简单，直接将 <code>kmem_cache_cpu</code> 中 slab 页面的空闲 object 返回给进程。freelist 指向下一个空闲的 object。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-pEK2QB.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（3）</strong> <strong><code>kmem_cache_cpu</code></strong> <strong>中没有空闲的 object，但</strong> <strong><code>kmem_cache_node</code></strong> <strong>的 partial 中有空闲的 object。</strong></p><ul><li><p><code>kmem_cache_node</code> 中有多个 slab 页面。其中 full 指向已经分配完毕的 slab 页面，partial 指向未分配完的 slab 页面。</p></li><li><p><code>kmem_cache_cpu</code> 中无可用 slab 页面，则将这个用完的 slab 页面转移到 full 指向的链表下。</p></li><li><p>将 partial 的未分配完的 slab 页面转移到 <code>kmem_cache_cpu</code> 下。</p></li><li><p><code>kmem_cache_cpu</code> 中找出空闲的 object 返回给进程。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-28-SOWkrW.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-ZIrDyA.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-sFfk5J.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（4）</strong> <strong><code>kmem_cache_cpu</code></strong>  <strong>和</strong> <strong><code>kmem_cache_node</code></strong> <strong>上均没有空闲的 object。</strong></p><ul><li><p><code>kmem_cache_cpu</code> 中已分配完的 slab 页面转移到 partial 所指向的链表中。</p></li><li><p>向伙伴系统申请一个或多个 page，并将其分成多个 object。</p></li><li><p>将其中一个空闲 object 返回给用户使用，freelist 指向下一个空闲 object。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2022-06-28-2pM6i1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-UPoTde.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-J9spdz.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="6-2-4-释放过程">6.2.4 释放过程</h4><p><strong>（1）object 释放前，所在的 slab 页面是 full 状态。</strong></p><p>释放该 object 后，当前 slab 页面就是 partial 状态，此时 slab 页面会转移到 partial 链表下。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-MfzMME.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-TPhaMx.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）object 释放前，所在的 slab 页面是 partial 状态。</strong></p><p>释放该 object 后，将 object 加入到该 slab 的空闲链表中即可。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-t1NEks.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-76lOxd.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（3）object 释放后，所在 slab 页中的 object 全部空闲。</strong></p><p>该 object 释放后，产生了一个全部空闲的 slab 页面，还需将该 slab 页面释放掉。</p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-L1Zv5M.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-Y1YQEI.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://hutu.aimtao.net/mark/2022-06-28-4KxSWl.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="6-3-页面换出">6.3 页面换出</h3><h2 id="7-内存映射之用户态内存映射">7.内存映射之用户态内存映射</h2><h2 id="8-内存映射之内核态内存映射">8.内存映射之内核态内存映射</h2><h2 id="参考">参考</h2><ul><li><a href="https://fanlv.wiki/2021/07/25/linux-mem/">https://fanlv.wiki/2021/07/25/linux-mem/</a></li><li><a href="https://ilinuxkernel.com/?p=1013">https://ilinuxkernel.com/?p=1013</a></li><li><a href="https://ty-chen.github.io/linux-kernel-mm-mgr/">https://ty-chen.github.io/linux-kernel-mm-mgr/</a></li><li><a href="http://www.wowotech.net/memory_management/fixmap.html">http://www.wowotech.net/memory_management/fixmap.html</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/52705178">https://blog.csdn.net/gatieme/article/details/52705178</a></li><li><a href="https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.3-wu-li-nei-cun-mo-xing">https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.3-wu-li-nei-cun-mo-xing</a></li><li><a href="https://www.tsz.wiki/linux/memory/common/modle/modle.html">https://www.tsz.wiki/linux/memory/common/modle/modle.html</a></li><li><a href="https://blog.csdn.net/lukuen/article/details/6935068">https://blog.csdn.net/lukuen/article/details/6935068</a></li><li><a href="http://www.wowotech.net/memory_management/426.html">http://www.wowotech.net/memory_management/426.html</a></li><li>趣谈 Linux 操作系统</li><li>Linux 内核设计与实现</li><li>深入理解 Linux 虚拟内存管理</li></ul><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文结合了诸多资料，以更加结构化的方式构建内存管理的知识体系，从虚拟内存布局到物理内存分配，全面地描述了内存管理中最重要的三件事。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Kernel" scheme="https://www.aimtao.net/categories/Kernel/"/>
    
    
    <category term="Linux" scheme="https://www.aimtao.net/tags/Linux/"/>
    
    <category term="kernel" scheme="https://www.aimtao.net/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>微服务｜RPC/gRPC</title>
    <link href="https://www.aimtao.net/rpc/"/>
    <id>https://www.aimtao.net/rpc/</id>
    <published>2022-05-27T00:32:00.000Z</published>
    <updated>2023-01-12T17:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文回答了 RPC 是什么、为什么使用 RPC 等问题，并详细探讨了 protobuf 协议和 gRPC 框架。</p><span id="more"></span><h2 id="1-RPC">1.RPC</h2><h3 id="1-1-RPC-是什么">1.1 RPC 是什么</h3><ul><li>RPC（Remote Procedure Call）远程过程调用。简单说就是，一个节点请求另一个节点提供的服务。</li><li>函数调用是最常见的本地过程调用。</li><li>RPC 就是将本地过程调用，变成远程过程调用。</li></ul><h3 id="1-2-RPC-需要解决的问题">1.2 RPC 需要解决的问题</h3><p>将本地函数放在服务器上运行，有三个主要问题需要解决。</p><p><strong>（1）Call 的 ID 映射</strong></p><ul><li>本地调用是通过函数指针来调用。</li><li>在 RPC 中，所有函数必须有自己的 ID，且 ID 在所有进程中是唯一的。</li><li>客户端与服务端分别维护一个函数与 Call ID 的映射表，二者的表不一定相同，但相同函数对应的 Call ID 必须相同。</li><li>当客户端需要进行远程调用时，查表得到 Call ID，并传给服务端；服务端通过 Call ID 查表得到所调用的函数，并执行对应的函数代码。</li></ul><p><strong>（2）序列化和反序列化</strong></p><ul><li>序列化：把对象转化为字节流，进行网络传输。</li><li>反序列化：把网络中接收的字节流转化为对象。</li></ul><p><strong>（3）网络传输</strong></p><ul><li>大部分 RPC 框架都基于 TCP/UDP 协议进行封装。</li><li>HTTP 1.x 一旦对方返回结果，就会断开连接，因此存在性能问题。</li><li>gRPC 是基于 HTTP 2.0 的，HTTP 2.0 支持长连接。</li></ul><h3 id="1-3-通过-HTTP-完成-Add-服务">1.3 通过 HTTP 完成 Add 服务</h3><p>通过 net/http 库，使用 get 请求完成远程的 add 服务。在这个过程中需要完成 RPC 的三件重要事情：</p><ul><li>Call ID 的映射：使用特定的请求路径来标识，r.URL.path</li><li>序列化和序列化：使用 json.Marshal 完成。</li><li>网络传输：使用 http 发送 get 请求。</li></ul><p>使用 http 的方式完成 RPC 的问题有两点，这是 RPC 框架需要解决的问题。</p><ul><li>写业务逻辑比较麻烦，每个函数都需要写一个请求。</li><li>客户端和服务端需要清晰地明确参数是如何传递的。</li></ul><p><strong>（1）服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/add&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;<br>        <span class="hljs-comment">// 解析并获取参数</span><br>        _ = request.ParseForm()<br>        fmt.Println(<span class="hljs-string">&quot;path: &quot;</span>, request.URL.Path)<br>        a, _ := strconv.Atoi(request.Form[<span class="hljs-string">&quot;a&quot;</span>][<span class="hljs-number">0</span>])<br>        b, _ := strconv.Atoi(request.Form[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-number">0</span>])<br>        <br>        <span class="hljs-comment">// 构造请求头</span><br>        writer.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>        <br>        <span class="hljs-comment">// 序列化成 []byte 类型</span><br>        bytes, _ := json.Marshal(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-string">&quot;data&quot;</span>: a + b,<br>        &#125;)<br>        <br>        <span class="hljs-comment">// 写入 respond</span><br>        _, _ = writer.Write(bytes)<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 监听 8080 端口</span><br>    _ = http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResponseData <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;data&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <br>    <span class="hljs-comment">// 发送 get 请求</span><br>    response, _ := http.Get(fmt.Sprintf(<span class="hljs-string">&quot;http://127.0.0.1:8000/%s?a=%d&amp;b=%d&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, a, b))<br>    <span class="hljs-keyword">defer</span> response.Body.Close()  <span class="hljs-comment">// 程序结束关闭 body</span><br>    <br>    <span class="hljs-comment">// 读取 body</span><br>    body, _ := ioutil.ReadAll(response.Body)<br>    responseData := ResponseData&#123;&#125;  <span class="hljs-comment">// 初始化结构体</span><br>    json.Unmarshal(body, &amp;responseData)   <span class="hljs-comment">// 反序列化 json，并将数据存入结构体</span><br>    <br>    <span class="hljs-keyword">return</span> responseData.Data<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-RPC-开发的要素">1.4 RPC 开发的要素</h3><p><strong>（1）RPC 开发的四大要素</strong></p><ul><li>client：负责发起服务调用，传递参数。</li><li>clent stub：运行在客户端机器上，负责存储要调用的服务端地址等信息，还负责将客户端的请求打包成数据包，发送给服务端。</li><li>server：有客户端要调用的方法，负责执行调用的方法。</li><li>server stub：运行在服务端机器上，负责接受客户端的数据包，并调用在 server 上的方法，并将调用结果进行数据处理，打包返回给客户端。</li></ul><p><strong>（2）原理图</strong></p><p><img src="https://hutu.aimtao.net/mark/2022-07-03-CaL2S1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（3）过程</strong></p><ul><li>client：client 想要发起远程过程调用，通过调用 client stub 的方式，传递想要调用的方法及参数。</li><li>client stub：接收到 client 的调用请求，将 client 请求调用的方法名、参数等信息序列化，打包成数据包；并查找到远程服务器的 IP 地址及端口。</li><li>socket：，通过 socket 协议，将数据包发送给服务端。</li><li>server stub：接受客户端的数据包，并通过约定好的协议进行反序列化，得到请求的方法名和参数；并调用 server 对应的方法，并传入参数。</li><li>server：执行被调用的方法，处理业务；并将结果返回给 server stub。</li><li>server stub：将 server 返回的结果按照约定的协议，进行序列化，打包成数据包。</li><li>socket：通过 socket 协议，将数据包发送给服务端。</li><li>client stub：接收到返回的数据，按照约定进行反序列化，并将调用结果传给 client。</li><li>client：得到调用结果。</li></ul><p>至此，整个 RPC 调用完成。</p><p><strong>（4）动态代理技术</strong></p><p>在 client stub 和 server stub 中，会使用 <strong>动态代理技术</strong> 自动生成一段代码，这样我们就可以更专注于业务的编码，不用对每个函数调用进行都进行封装一遍。</p><h3 id="1-5-使用-go-内置的-RPC">1.5 使用 go 内置的 RPC</h3><p>下面简单介绍 go 内置的 RPC，主要用到 <code>net</code> 、<code>net/rpc</code> 这两个包。</p><p><strong>（1）服务端</strong></p><ol><li>实例化 server</li><li>将函数注册到 RPC 中</li><li>启动服务</li></ol><p>RPC 主要解决了的问题：call id、序列化和反序列化（使用的 Gob 协议）。listen 和 accept 的都是 net 包完成的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// reply 传出参数</span><br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;CommonHelloService&quot;</span>, &amp;HelloService&#123;&#125;) <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    第一个参数：是服务的名字，随便起，与结构体 HelloService 命名无关，只要 client/server 在 Call 和 RegisterName 时保持一致就行。</span><br><span class="hljs-comment">    第二个参数：为什么这里要取地址？因为结构体指针实现了 interface。具体原因，见下文。</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept()  <span class="hljs-comment">// conn 是 ServerCodec 类型，里面封装了读/写/关闭操作。</span><br><br>    rpc.ServeConn(conn)<br>&#125;<br></code></pre></td></tr></table></figure><p>补充：<strong>为什么 RegisterName 的第二个参数要取地址？</strong></p><p>这里接收 &amp;HelloService{} 是一个 interface 变量，传给 interface 变量值还是指针，由 HelloService 在实现函数时，用的指针接受者还是值接受者决定。所以，</p><ul><li>如果定义成 <code>func (s *HelloService) Hello(...)</code>，此处只能传递指针类型 <code>&amp;HelloService&#123;&#125;</code>。</li><li>如果定义成 <code>func (s HelloService) Hello(...)</code>，此处可以传递指针类型 <code>&amp;HelloService&#123;&#125;</code> 或值类型 <code>HelloService&#123;&#125;</code>。</li></ul><p>如果不知道为什么，建议阅读 <a href="https://www.aimtao.net/go/#5-5-%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B">接口的值类型</a></p><p><strong>（2）客户端</strong></p><ol><li>建立连接</li><li>远程调用函数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1. 建立连接</span><br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;connect fail.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;CommonHelloService.Hello&quot;</span>, <span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-序列化格式使用-json">1.6 序列化格式使用 json</h3><p>RPC 使用的序列化协议是 Gob，而 json 是使用更加广泛的格式，为了满足跨语言的需求，一般会使用 json 格式来编解码数据。下面将其换成 json。</p><p><strong>（1）服务端</strong></p><p>只需要将 <code>rpc.ServeConn</code> 换成 <code>rpc.ServeCodec</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// reply 传出参数</span><br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, &amp;HelloService&#123;&#125;) <span class="hljs-comment">// 如上文所述原因，需传递指针变量。</span><br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept() <span class="hljs-comment">// conn 是 ServerCodec 类型，里面封装了读/写/关闭操作。</span><br><br>    rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) <span class="hljs-comment">// ServeCodec: 使用指定的编解码器来解码请求和编码响应。这里传入使用 json 编解码的 ServerCodec。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><p>需要将 <code>rpc.Dial</code> 换成 <code>net.Dial</code>，否则使用 <code>rpc.Dial</code> 会使用 Gob 的协议进行编解码。并通过 conn 生成一个  ClientCodec。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1. 建立连接</span><br>    conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br>    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))  <span class="hljs-comment">// 使用json 编解码的 ClientCodec。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;connect fail.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;HelloService.Hello&quot;</span>, <span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7-监听端口使用-http">1.7 监听端口使用 http</h3><p>内置的 RPC 监听的是 TCP 端口，跨语言完成调用时，客户端需要使用 socket 来传递 TCP 数据报。如果监听 http 请求，客户端只需发送 Get/Post 请求即可。</p><p><strong>（1）服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, &amp;HelloService&#123;&#125;) <span class="hljs-comment">// 如上文所述原因，需传递指针变量。</span><br><br>    <span class="hljs-comment">// 2.http 处理函数</span><br>    http.HandleFunc(<span class="hljs-string">&quot;/jsonrpc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> conn io.ReadWriteCloser = <span class="hljs-keyword">struct</span> &#123;<br>            io.Writer<br>            io.ReadCloser<br>        &#125;&#123;<br>            ReadCloser: request.Body,<br>            Writer:     writer,<br>        &#125;<br>        rpc.ServeRequest(jsonrpc.NewServerCodec(conn)) <span class="hljs-comment">// rpc.ServeRequest 只要拿到带有 writer/reader 的 conn 就可以。</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 3.监听 http 端口</span><br>    http.ListenAndServe(<span class="hljs-string">&quot;:8899&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><p>// 待补充</p><h3 id="1-8-封装-Stub">1.8 封装 Stub</h3><p>需求：</p><ol><li>client 使用 <code>client.Hello(request, &amp;reply)</code> 的格式优雅远程调用。</li><li>client/server 使用同一个服务命令，手动写可能出现服务名称不一致/服务名称冲突的错误。</li><li>server 可以专注业务逻辑。</li><li>sever 无序关注服务名称、结构体类型。</li></ol><p>解决：</p><ul><li>需求一，使用 clientStub 将 Dial 和 Call 过程进行封装。</li><li>需求二，使用共同的 handler 文件，在 handler 中将服务名称定义成常量。</li><li>需求三，将业务逻辑部分抽离出来，放到其他文件中（这里为了方便演示，放在了 handler 中，其实不能放在 handler 中，handler 是共有文件，应该新建一个文件。）。</li><li>需求四，使用 serverStub 将 <code>rpc.RegisterName</code> 进行封装，并使用接口接收结构体指针，使 serverStub 与结构体类型解耦。</li></ul><p><strong>（1）handler</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> handler<br><br><span class="hljs-keyword">const</span> HelloServiceName = <span class="hljs-string">&quot;handler/CommonHelloService&quot;</span>   <span class="hljs-comment">// 这是服务的名字，随便起，与结构体 HelloService 命名无关，只要 client/server 在 Call 和 RegisterName 时保持一致就行。</span><br><br><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实际的业务逻辑（真正被远程调用的函数）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）clientStub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> clientStub<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HelloServiceStub <span class="hljs-keyword">struct</span> &#123;<br>    *rpc.Client <span class="hljs-comment">// 最终用来 call 调用函数的是 *rpc.Client。这里封装成 HelloServiceStub，便于在 client 中，直接使用 HelloServiceStub.Hello 的形式调用。</span><br>&#125;<br><br><span class="hljs-comment">// NewHelloServiceClient go 中没有类、对象，所以没有初始化方法。这里需要写一个 New 方法，获取到 *rpc.Client，实例化一个 HelloServiceStub。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHelloServiceClient</span><span class="hljs-params">(protocol, address <span class="hljs-type">string</span>)</span></span> (HelloServiceStub, <span class="hljs-type">error</span>) &#123;<br>    conn, err := rpc.Dial(protocol, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> HelloServiceStub&#123;conn&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c HelloServiceStub)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;  <span class="hljs-comment">// 实现要调用的方法</span><br>    err := c.Call(handler.HelloServiceName+<span class="hljs-string">&quot;.Hello&quot;</span>, request, reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/RPCWithStub/clientStub&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.建立连接，获取到一个 *rpc.Client。</span><br>    client, _ := clientStub.NewHelloServiceClient(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err := client.Hello(<span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply) <span class="hljs-comment">// 实现优雅调用。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）serverStub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> serverStub<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-comment">// 使用接口，将 RegisterHelloService 形参类型 与 handler 中的结构体类型解耦。</span><br><span class="hljs-keyword">type</span> HelloServer <span class="hljs-keyword">interface</span> &#123;<br>    Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterHelloService</span><span class="hljs-params">(srv HelloServer)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 只要实现了 Hello 方法，都可以将结构体传给 HelloServer 类型的接口变量。</span><br>    <span class="hljs-keyword">return</span> rpc.RegisterName(handler.HelloServiceName, srv)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（5）server</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;learngo/RPCWithStub/serverStub&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    <span class="hljs-comment">// 此处封装了注册过程中结构体的类型，结构体的类型不重要，重点是 Hello 这个函数，只要带有 Hello 方法的结构体即可。</span><br>    _ = serverStub.RegisterHelloService(&amp;handler.HelloService&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept()<br><br>    rpc.ServeConn(conn)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-9-总结">1.9 总结</h3><p>为什么要花篇幅来分析内置 RPC 的使用？因为以上所解决的问题，就是 gRPC 或其他 RPC 框架所解决的问题。</p><p>更重要的是 <strong>serverStub/clientStub 可以通过 protobuf 自动生成</strong>，并且可以生成多语言版本。</p><h2 id="2-protobuf">2.protobuf</h2><blockquote><p>Reference Documents：<a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p></blockquote><h3 id="2-1-是什么">2.1 是什么</h3><p>Protocol Buffer，是 google 退出的一种轻量高效的结构化数据存储格式。和 json、xml 作用一样，但 protobuf 的性能远超 json、xml，数据压缩比比较高。</p><p>protobuf 经历了 protobuf2 和 protobuf3，目前主流版本是 protobuf3。</p><blockquote><p>同类的格式还有：java 中的 dubbo/rmi/hessian，python 中的 messagepack，go 中的 gob。</p></blockquote><h3 id="2-2-protobuf-优缺点">2.2 protobuf 优缺点</h3><p>优点：</p><ul><li>性能：压缩性好（压缩得越小，传输越快），序列化/反序列化快（比 json、xml 快 2-100 倍）。</li><li>便捷性：使用简单（自动生成序列化/反序列化代码），维护成本低（只需要维护 proto 文件），向后兼容（增加内容，可以不破坏旧格式），加密性好（二进制流）。</li><li>跨语言：跨平台，支持各种主流语言。</li></ul><p>缺点：</p><ul><li>通用型差：任何语言都支持 json，但是 protobuf 需要专门的解析库。</li><li>自解释性差：加密成了二进制流，只要通过 proto 文件才能了解数据结构。</li></ul><h3 id="2-3-环境配置">2.3 环境配置</h3><p>需要安装 <a href="https://grpc.io/docs/protoc-installation/">protoc</a>，下载 <a href="https://grpc.io/docs/languages/go/quickstart/">protoc-gen-go</a> 依赖包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install protobuf  <span class="hljs-comment">#  这是 macOS 的安装命令，其他系统在上面的链接中自行查找。</span><br>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest   <span class="hljs-comment"># 生成 go 源代码用的。</span><br>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest <span class="hljs-comment">#支持生成 grpc 部分代码</span><br></code></pre></td></tr></table></figure><h3 id="2-4-最小实践">2.4 最小实践</h3><p>protobuf 最原始的功能就是数据编码，使用主要分三步；</p><ol><li>使用 proto 文件约束数据类型。（也就是结构体。）</li><li>自动生成源代码。</li><li>使用 <code>github.com/golang/protobuf/proto</code> 对数据进行序列化/反序列化。</li></ol><p>注意：使用 proto 只能进行数据编码，加上 grpc 插件后，可以定义一些服务。</p><p><strong>（1）使用 proto 文件约束数据类型</strong></p><p>注意：1 是编号不是值，编码时只认编号不认变量名。（<strong>坑</strong>：联调时两个人编号不一致。）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;  <span class="hljs-comment">// 使用 proto3 的语法</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;  <span class="hljs-comment">// 生成源码文件的包名，只影响 go 语言。具体使用见 2.6 go_package 的作用</span><br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">SayHello</span> &#123;  <span class="hljs-comment">// 定义服务（也就是方法接口）  // 使用 grpc 插件才可以使用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Hello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;   <span class="hljs-comment">// 定义消息类型（也就是结构体类型）</span><br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 1 是编号不是值，编码时只认编号不认变量名。坑：联调时两个人编号不一致。</span><br>&#125;<br><br><span class="hljs-keyword">message  </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）自动生成 go 源码</strong></p><p>已经废弃的写法：</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . helloworld.proto --go_out=plugins=grpc:.<br></code></pre></td></tr></table></figure><ul><li><code>-I .</code>：表示 include 当前目录。在当前目录寻找 helloworld.proto。</li><li><code>--go_out</code>：表示生成 go 的源码，<code>--java_out</code> 即可生成 java 的源码。等号后面可以加选项，选项使用键值对表示。</li><li><code>plugins=grpc</code>：一个键值对，表示使用 grpc 插件。</li><li><code>:.</code>：使用 <code>:</code> 将前面的键值对和路径隔开。<code>.</code> 表示在当前目录下生成 <code>bp.go</code> 文件</li></ul></blockquote><p>推荐的写法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . helloworld.proto --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative<br></code></pre></td></tr></table></figure><ul><li><code>-I .</code>：表示 include 当前目录。在当前目录寻找 helloworld.proto。</li><li><code>--go_out=.</code>：表示生成用于 protobuf 编码的 go 源码，<code>--java_out</code> 即可生成 java 的源码。等号后面是生成 bp.go 的路径。</li><li><code> --go_opt=</code>：等号后面可以加选项，选项使用键值对表示。</li><li><code>--go-grpc_out=.</code>：表示生成 grpc 的源码。等号后面是生成 grpc 的 bp.go 的路径。</li><li><code>--go-grpc_opt=</code>：等号后面可以加选项，选项使用键值对表示。只对 grpc 部分代码有效。</li></ul><p>主要有两个变化：</p><ul><li>将键值对选项和生成路径分开： <code>--go_out</code> 只表示生成 bp.go 的路径，另用 <code>--go_opt</code> 表示键值对选项。</li><li>将用于 protobuf 编码的 go 源码和 grpc 的源码分开生成：<code>--go_out</code> 表示前者，<code>go-grpc_out</code> 表示后者。</li></ul><p><strong>（4）使用 protobuf 编解码</strong></p><p>使用 proto 序列化/反序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/golang/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 实例化一个 struct</span><br>    req := helloworld.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// 编码</span><br>    bytes, _ := proto.Marshal(&amp;req)<br>    fmt.Println(bytes) <span class="hljs-comment">// [10 3 84 111 109] // 编码后自解释性差</span><br><br>    <span class="hljs-comment">// 解码</span><br>    newBytes := helloworld.HelloRequest&#123;&#125;<br>    _ = proto.Unmarshal(bytes, &amp;newBytes) <span class="hljs-comment">// 传入一个空 struct 作为传出参数</span><br>    fmt.Println(newBytes.Name)            <span class="hljs-comment">// Tom  // 成功复原</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-基本类型和默认值">2.5 基本类型和默认值</h3><p><strong>（1）基本类型</strong></p><blockquote><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">https://developers.google.com/protocol-buffers/docs/proto3#scalar</a></p></blockquote><table><thead><tr><th style="text-align:left">proto Type</th><th>Notes</th><th style="text-align:left">Go Type</th></tr></thead><tbody><tr><td style="text-align:left">double</td><td></td><td style="text-align:left">float64</td></tr><tr><td style="text-align:left">float</td><td></td><td style="text-align:left">float32</td></tr><tr><td style="text-align:left">int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.使用可变长度编码。编码负数效率低下——如果您的字段可能具有负值，请使用 sint32。</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.使用可变长度编码。编码负数效率低下——如果您的字段可能具有负值，请使用 sint64。</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">uint32</td><td>Uses variable-length encoding.使用可变长度编码。</td><td style="text-align:left">uint32</td></tr><tr><td style="text-align:left">uint64</td><td>Uses variable-length encoding.</td><td style="text-align:left">uint64</td></tr><tr><td style="text-align:left">sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.使用可变长度编码。有符号的 int 值。这些比常规 int32 更有效地编码负数。</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.使用可变长度编码。有符号的 int 值。这些比常规 int64 更有效地编码负数。</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 228.总是四个字节。如果值通常大于228，则比uint32更有效率。</td><td style="text-align:left">uint32</td></tr><tr><td style="text-align:left">fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 256.总是八字节。如果值通常大于256，则比uint64更有效率。</td><td style="text-align:left">uint64</td></tr><tr><td style="text-align:left">sfixed32</td><td>Always four bytes.</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">sfixed64</td><td>Always eight bytes.</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">bool</td><td></td><td style="text-align:left">bool</td></tr><tr><td style="text-align:left">string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过232。</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">bytes</td><td>May contain any arbitrary sequence of bytes no longer than 232.可以包含任何不超过232的任意字节序列。</td><td style="text-align:left">[]byte</td></tr></tbody></table><p><strong>（2）默认值</strong></p><blockquote><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#default">https://developers.google.com/protocol-buffers/docs/proto3#default</a></p></blockquote><p>当解析消息时，如果编码的消息不包含特定的 singular 元素，则解析对象中的相应字段将设置为该字段的默认值。</p><table><thead><tr><th>.proto Type</th><th>default</th></tr></thead><tbody><tr><td>string</td><td>“”</td></tr><tr><td>byte</td><td>‘’</td></tr><tr><td>bool</td><td>false</td></tr><tr><td>数值类型</td><td>0</td></tr><tr><td>enum</td><td>默认时第一个定义的枚举值，必须为 0</td></tr><tr><td>message</td><td>默认值根据使用的语言确定的</td></tr></tbody></table><h3 id="2-6-指定字段规则">2.6 指定字段规则</h3><p><strong>（1）option</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;../common/stream/proto/v1;helloworld&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>../common/stream/proto/v1</code>：指定生成 pb.go 文件所在的路径。</li><li><code>helloworld</code>：生成 pb.go 文件的包名。</li><li>注：go_package 只会对 go 进行约束，不会影响其他语言。</li></ul><p>在开发过程中，会将 proto 文件和 pb.go 文件分开存放。文件结构如下，其中生成的 bp.go 文件可能是公共的，并且分目录和版本。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<br>├── <span class="hljs-keyword">common</span><br>│   └── stream<br>│       └── proto<br>│           └── v1<br>│               └── stream.pb.go<br>├── proto<br>│   └── stream.proto<br>├── <span class="hljs-keyword">client</span><br>│   └── <span class="hljs-keyword">client</span>.go<br>└── <span class="hljs-keyword">server</span><br>    └── <span class="hljs-keyword">server</span>.go<br></code></pre></td></tr></table></figure><p><strong>（2）singular</strong></p><p>单数，表示字段出现 0 次或 1 次。proto3 每个字段的修饰符默认是 singular。</p><p><strong>（3）repeated</strong></p><p>复数，表示该字段可重复，对应的 go 中的切片。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">hello</span> &#123;<br>    <span class="hljs-keyword">repeated</span> <span class="hljs-type">int32</span> num = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 在 go 中为 []int</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-嵌套-proto-文件">2.7 嵌套 proto 文件</h3><p>（<strong>1）为什么需要嵌套 proto 文件？</strong></p><ul><li>消息类型可能比较多，不可能只写一个 proto 文件。</li><li>有些 meassage 类型可能通用，比如 <a href="https://github.com/golang/protobuf/tree/master/ptypes">protobuf 就内置了一些 message</a>（<a href="http://github.com/golang/protobuf/ptypes%EF%BC%89%E3%80%82">github.com/golang/protobuf/ptypes）。</a></li></ul><p><strong>（2）实际的例子：empty message 的应用</strong></p><p><strong>需求</strong>：Ping 是一个测试是否连通的服务，发送请求时无需传入参数。但 service 定义时必须传入 message，此时就可以使用 Empty message。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-comment">// Ping 是一个用于测试是否连通的服务，发送请求时无需传入参数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;   <span class="hljs-comment">// rpc 服务必须传入一个 message，但函数本意并无需传入参数，所以只能写一个 Empty message。</span><br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Empty 是一个空的 message，很多 proto 文件中都会需要。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Empty</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个很常见的需求，无需每个 proto 文件中都定义一个 Empty message，会冲突。</p><p><strong>解决</strong>：定义一个公共的 proto 文件，base.proto。在 hello.proto 中 improt base.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// base.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Empty 是一个空的 message，很多 proto 文件中都会需要。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Empty</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;base.proto&quot;</span>;   <span class="hljs-comment">// 【import 同目录下的 proto 文件】</span><br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-comment">// Ping 是一个用于测试是否连通的服务，发送请求时无需传入参数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;   <span class="hljs-comment">// rpc 服务必须传入一个 message，但函数本意并无需传入参数，所以只能写一个 Empty message。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）使用 protobuf 内置的 message</strong></p><p>注意 proto 文件中的导入方式。improt 时用路径表示，使用时用点表示</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/empty.proto&quot;</span>;   <span class="hljs-comment">// 【improt 内置的 message】</span><br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(google.protobuf.Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>go 文件使用 Empty message 类型时，需导入 empty.proto 文件中 go_package 路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/golang/protobuf/ptypes/empty&quot;</span>   <span class="hljs-comment">// empty.proto 文件中 go_package 路径。</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    empty.Empty&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）improt 路径问题</strong></p><p>improt 同目录下的 proto 文件可直接导入。但是导入不同目录下的 proto 文件，需要注意 import 不能使用相对路径。</p><p>解决：可以写 proto 文件名，并在 protoc 时使用 <code>-I</code> 参数在指定目录下寻找该 proto 文件。</p><p>比如在 3.5 验证器 小节，hello.proto 文件中需要 import validate.proto 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . -I <span class="hljs-variable">$GOPATH</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/  hello.proto --go_out=. <br></code></pre></td></tr></table></figure><p><code>-I . -I $GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/</code>：表示在当前目录和  <code>$GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/</code> 这两个目录下，寻找 hello.proto 和 import 的文件。</p><h3 id="2-8-嵌套-message-对象">2.8 嵌套 message 对象</h3><p><strong>（1）第一种方式</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> url = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">repeated</span> Result data = <span class="hljs-number">2</span>;   <span class="hljs-comment">// Result 数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）第二种方式</strong></p><p>内部嵌套，嵌套的 message 只用一次，防止 proto 文件中定义过多 message。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">repeated</span> Result data = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>        <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// Result 的序号和 Reply 的序号有很好的隔离性，互不干扰。</span><br>        <span class="hljs-type">string</span> url = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上有些特殊，pb.go 文件里会定义为 Reply_Result，所以 go 中实例化时需要使用 Reply_Result。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reply_Result <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br><br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br>    Url  <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,opt,name=url,proto3&quot; json:&quot;url,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-enum-类型">2.9 enum 类型</h3><p><strong>（1）proto 文件定义</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;enum&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    Gender gender = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">enum </span><span class="hljs-title class_">Gender</span> &#123;   <span class="hljs-comment">// 定义枚举类型</span><br>    MALE = <span class="hljs-number">0</span>;<br>    FEMALE = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用枚举类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;learngo/repeated/enum&quot;</span>   <span class="hljs-comment">// 导入 bp.go 所在目录</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := enum.Reply&#123;<br>        Message: <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Gender:  enum.Gender_MALE,   <span class="hljs-comment">// 使用 枚举类型 赋值</span><br>    &#125;<br>    fmt.Println(r)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-10-map-类型">2.10 map 类型</h3><p>map 虽然方便，但是不要大量写 map，在传入参数和接收参数时，不知道具体字段是什么。</p><p><strong>（1）proto 文件定义</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;enum&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloReply</span> &#123;<br>    map&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; m = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 定义类型，传错类型会报错。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用 map 类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    mapproto <span class="hljs-string">&quot;learngo/repeated/map_proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reply := mapproto.HelloReply&#123;<br>        M: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>:    <span class="hljs-string">&quot;Tom&quot;</span>,<br>            <span class="hljs-string">&quot;company&quot;</span>: <span class="hljs-string">&quot;xiaomi&quot;</span>,<br>        &#125;,<br>    &#125;<br>    fmt.Println(reply.M)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-11-timestamp-类型">2.11 timestamp 类型</h3><p>时间戳类型，protobuf 扩展的类型。</p><p><strong>（1）proto 文件定义</strong></p><p>timestamp 定义在 google/protobuf/timestamp.proto 文件中。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;hello&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/timestamp.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    google.protobuf.Timestamp requestTime= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用 timestamp 类型</strong></p><p>自动生成的 bp.go 中是这样定义的，RequestTime 是 <code>timestamppb.Timestamp</code> 指针类型。</p><p><code>timestamppb.Timestamp</code> 导入的是 <code>timestamppb &quot;google.golang.org/protobuf/types/known/timestamppb&quot;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hello.pb.go</span><br><span class="hljs-keyword">type</span> Reply <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br><br>    RequestTime *timestamppb.Timestamp <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=requestTime,proto3&quot; json:&quot;requestTime,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以在 go 中，需要导入 <code>timestamppb &quot;google.golang.org/protobuf/types/known/timestamppb&quot;</code>。</p><p>具体使用如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    hello <span class="hljs-string">&quot;learngo/timestamp/proto&quot;</span><br><br>    timestamppb <span class="hljs-string">&quot;google.golang.org/protobuf/types/known/timestamppb&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reply := hello.Reply&#123;<br>        RequestTime: timestamppb.New(time.Now()),  <span class="hljs-comment">// 【获取当前的时间戳】</span><br>    &#125;<br>    fmt.Println(reply.RequestTime)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-gRPC">3.gRPC</h2><h3 id="3-1-最小实践">3.1 最小实践</h3><p>目的：server 实现一个 SayHello 的函数，client 进行远程调用。</p><p>实现：</p><ol><li>使用 proto 文件，约定传输的消息类型、函数接口。</li><li>使用 protoc 生成 stub 文件 helloworld.pb.go 和 helloworld_gpc.pb.go，生成的主要内容是：<ul><li>消息类型的编解码；</li><li>client stub：实例化 client 的函数、client interface（用于封装远程调用函数）；</li><li>server stub：server interface（用于封装远程调用函数）、注册 server 的函数。</li></ul></li><li>server 端：完成具体的业务逻辑来实现接口 + 实例化 grpc server、注册、监听。</li><li>client 端：拨号、实例化 client、远程调用。</li></ol><p><strong>（1）helloworld.proto</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option go_package = <span class="hljs-string">&quot;.;helloworld&quot;</span>;<br><br>service Greeter &#123;  <span class="hljs-comment">// 定义服务（也就是 interface）</span><br>    rpc SayHello(HelloRequest) returns (HelloResponse);<br>&#125;<br><br>message HelloRequest &#123;   <span class="hljs-comment">// 定义消息类型（也就是结构体类型）</span><br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 1 是编号不是值</span><br>&#125;<br><br>message  HelloResponse &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span> <span class="hljs-comment">// 自带的</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span> <span class="hljs-comment">// 三方的</span><br><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span> <span class="hljs-comment">// 自己的</span><br>)<br><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// SayHello 是 server 的接口，虽然在 proto 文件中没有定义 Context、error，但需要强制加上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> SayHello(ctx context.Context, request *helloworld.HelloRequest) (*helloworld.HelloResponse, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 具体业务逻辑</span><br>    <span class="hljs-keyword">return</span> &amp;helloworld.HelloResponse&#123;<br>        Reply: <span class="hljs-string">&quot;hello &quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.实例化一个 grpc 的 server</span><br>    g := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册</span><br>    <span class="hljs-comment">// RegisterGreeterServer 是自动生成的函数。利用鸭子类型类传递实例化的结构体。</span><br>    helloworld.RegisterGreeterServer(g, &amp;Server&#123;&#125;)<br><br>    <span class="hljs-comment">//3.启动监听</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to listen:&quot;</span> + err.Error())<br>    &#125;<br>    err = g.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to start: &quot;</span> + err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to dial: &quot;</span> + err.Error())<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123; <span class="hljs-comment">// 连接用完需关闭，使用闭包的方式。</span><br>        err := conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to close: &quot;</span> + err.Error())<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    <span class="hljs-comment">// NewGreeterClient 是自动生成的代码。</span><br>    client := helloworld.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    response, err := client.SayHello(context.Background(), &amp;helloworld.HelloRequest&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to call: &quot;</span> + err.Error())<br>    &#125;<br>    fmt.Println(response.Reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-流模式">3.2 流模式</h3><h4 id="3-2-1-四种模式">3.2.1 四种模式</h4><p><strong>（1）简单模式（Simple RPC）</strong></p><p>客户端发起一次请求，服务端响应一次数据。</p><p><strong>（2）服务端数据流模式（Server-side streaming RPC）</strong></p><p>客户端发起一次请求，服务端返回一段连续的数据流。例如：客户端向服务端发送一个股票代码，服务端就把该股票的实时数据持续地返回给客户端。</p><p><strong>（3）客户端数据流模式（Client-side streaming RPC）</strong></p><p>客户端持续向服务端发送数据流，发送结束后，服务端返回一个响应。例如：传感器向服务端上报数据。</p><p><strong>（4）双向数据流模式（Bidirectional streaming RPC）</strong></p><p>客户端与服务端都可以向对方发送数据流，可以同时互相发送，实现实时交互。例如聊天机器人。</p><h4 id="3-2-2-流模式最小实践">3.2.2 流模式最小实践</h4><p><strong>（1）stream.proto</strong></p><p>在 service 中，以流模式发送的数据使用 stream 关键字定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br>option go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br>service Greeter &#123;<br>    rpc GetStream(StreamRequestData) returns (stream StreamResponseData);    <span class="hljs-comment">// 服务端流模式，返回 response 是 stream</span><br>    rpc PostStream(stream StreamRequestData) returns (StreamResponseData);   <span class="hljs-comment">// 客户端流模式</span><br>    rpc AllStream(stream StreamRequestData) returns ( stream StreamResponseData);   <span class="hljs-comment">// 双向流模式</span><br>&#125;<br><br>message StreamRequestData &#123;<br>    <span class="hljs-type">string</span> data = <span class="hljs-number">1</span>;<br>&#125;<br><br>message StreamResponseData &#123;<br>    <span class="hljs-type">string</span> data = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）server.go</strong></p><p>流模式和普通 PRC 相比，server 有三点差异：</p><ul><li>参数：使用 stream 标记的参数，在函数实现时，需使用 protoc 自动生成的 streamServer 代替。（不</li><li>发送数据流：使用 streamServer 类型的参数，调用 send 函数。</li><li>接收数据流：使用 streamServer 类型的参数，调用 send 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>     <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/streamingGrpc/proto&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;:8088&quot;</span><br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// GetStream 实现服务端流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> GetStream(req *proto.StreamRequestData, res proto.Greeter_GetStreamServer) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 使用 流模式 传输的数据，使用 proto 中自动生成的 streamServer 代替函数中的参数。</span><br>    fmt.Println(<span class="hljs-string">&quot;\nServer-side streaming RPC&quot;</span>)<br>    fmt.Println(req.Data)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        _ = res.Send(&amp;proto.StreamResponseData&#123; <span class="hljs-comment">// Send 函数发送数据</span><br>            Data: fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, time.Now().Unix()),<br>        &#125;)<br>        time.Sleep(time.Second)<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// PostStream 实现客户端流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> PostStream(clientStream proto.Greeter_PostStreamServer) <span class="hljs-type">error</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;\nClient-side streaming RPC&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> recv, err := clientStream.Recv(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// Recv 函数接收数据</span><br>            fmt.Println(err)<br>            <span class="hljs-keyword">break</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(recv.Data)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AllStream 实现双向流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> AllStream(allStream proto.Greeter_AllStreamServer) <span class="hljs-type">error</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;\nBidirectional streaming RPC&quot;</span>)<br>    wg := sync.WaitGroup&#123;&#125;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        <span class="hljs-keyword">for</span> &#123;<br>            msg, err := allStream.Recv()<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                fmt.Println(err)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            fmt.Println(<span class="hljs-string">&quot;msg from client: &quot;</span> + msg.Data)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            _ = allStream.Send(&amp;proto.StreamResponseData&#123;<br>                Data: fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, time.Now().Unix()),<br>            &#125;)<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;()<br><br>    wg.Wait()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.实例化 grpc server</span><br>    s := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册 server</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.监听端口，启动 server</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, PORT)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    _ = s.Serve(listen)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client.go</strong></p><p>流模式和普通 PRC 相比，client 有三点差异：</p><ul><li>参数：使用 stream 标记的参数，函数调用时，无需提供。调用函数后获得返回值为对应的 streamClient。</li><li>发送数据流：使用 streamClient 类型的函数返回值，调用 send 函数。</li><li>接收数据流：使用 streamClient 类型的函数返回值，调用 send 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>     <span class="hljs-string">&quot;learngo/streamingGrpc/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.拨号连接</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;:8088&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err := conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化一个 client。（client 结构体中变量为 conn，使用 grpc.ClientConnInterface 接收参数 conn）</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.通过 client 来分别调用不同的流模式 RPC。</span><br>    <span class="hljs-comment">// 服务端流模式</span><br>    fmt.Println(<span class="hljs-string">&quot;\nServer-side streaming RPC&quot;</span>)<br>    <span class="hljs-comment">// 返回值为 Greeter_GetStreamClient，可以调用 Recv 函数。</span><br>    res, _ := client.GetStream(context.Background(), &amp;proto.StreamRequestData&#123;Data: <span class="hljs-string">&quot;tell me time&quot;</span>&#125;)<br>    <span class="hljs-keyword">for</span> &#123;<br>        data, err := res.Recv()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        fmt.Println(data)<br>    &#125;<br><br>    <span class="hljs-comment">// 客户端流模式</span><br>    fmt.Println(<span class="hljs-string">&quot;\nClient-side streaming RPC&quot;</span>)<br>    postStream, err := client.PostStream(context.Background())<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        _ = postStream.Send(&amp;proto.StreamRequestData&#123;<br>            Data: fmt.Sprintf(<span class="hljs-string">&quot;client send count: %d&quot;</span>, i),<br>        &#125;)<br>        time.Sleep(time.Second)<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 双向流模式</span><br>    <span class="hljs-comment">// 为了保证双向流模式，需使用2个协程分别发送和接收。</span><br>    fmt.Println(<span class="hljs-string">&quot;\nBidirectional streaming RPC&quot;</span>)<br>    allStream, err := client.AllStream(context.Background())<br>    wg := sync.WaitGroup&#123;&#125;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        <span class="hljs-keyword">for</span> &#123;<br>            msg, _ := allStream.Recv()<br>            fmt.Println(<span class="hljs-string">&quot;msg form server: &quot;</span> + msg.Data)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            _ = allStream.Send(&amp;proto.StreamRequestData&#123;<br>                Data: fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i),<br>            &#125;)<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;()<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-metadata-机制">3.3 metadata 机制</h3><p><strong>（1）metadata 是什么？</strong></p><p>在 HTTP 数据传输中，除了 get/post 的参数，还有些参数会通过 metadata 来传输。</p><p><strong>（2）新建 metadata</strong></p><p>注意：虽然写的的是 <code>map[string]string</code>，但实际上是 <code>map[string][]string</code>，每一个 key 对应的 value 都是一个 <code>map[string]string</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建 metadata 数据的第一种方式</span><br>md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-string">&quot;Username&quot;</span>: <span class="hljs-string">&quot;admin2&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>&#125;)<br><span class="hljs-comment">// 创建 metadata 数据的第二种方式</span><br>md = metadata.Pairs(<br>    <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin2&quot;</span>, <span class="hljs-comment">// &quot;username&quot; will have map value []string&#123;&quot;admin&quot;, &quot;admin2&quot;&#125;</span><br>    <span class="hljs-string">&quot;Password&quot;</span>, <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>)<br></code></pre></td></tr></table></figure><p><strong>（3）发送 metadata</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := metadata.NewOutgoingContext(context.Background(), md) <span class="hljs-comment">// 创建一个传出 metadata 数据的 context。</span><br></code></pre></td></tr></table></figure><p><strong>（4）接收 metadata</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从 context 中获取 metadata 数据</span><br>md, ok := metadata.FromIncomingContext(ctx)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(<span class="hljs-string">&quot;get metadata success.&quot;</span>)<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> md &#123;<br>        fmt.Println(key, val)<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;get metadata error.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/* 打印 metadata 的内容：</span><br><span class="hljs-comment">user-agent [grpc-go/1.47.0]</span><br><span class="hljs-comment">username [admin admin2]    // 注意：每一个 key 对应的 value 都是一个 map[string]string。</span><br><span class="hljs-comment">password [Qwer123]</span><br><span class="hljs-comment">:authority [127.0.0.1:8080]</span><br><span class="hljs-comment">content-type [application/grpc]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>（5）完整例子</strong></p><p><strong>metadata.proto</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/metadata&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/metadata/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 从 context 中获取 metadata 数据</span><br>    md, ok := metadata.FromIncomingContext(ctx)<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get metadata success.&quot;</span>)<br>        <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> md &#123;<br>            fmt.Println(key, val)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get metadata error.&quot;</span>)<br>    &#125;<br><br>    response := &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;hello, &quot;</span> + request.Name,<br>    &#125;<br>    <span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 grpc server</span><br>    s := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册服务</span><br>    proto.RegisterGreeterServer(s, server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.监听并启动 grpc server</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/metadata&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>        <br>    <span class="hljs-string">&quot;learngo/metadata/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 创建 metadata 数据的第一种方式</span><br>    md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;Username&quot;</span>: <span class="hljs-string">&quot;admin2&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>    &#125;)<br>    <span class="hljs-comment">// 创建 metadata 数据的第二种方式</span><br>    md = metadata.Pairs(<br>        <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin2&quot;</span>, <span class="hljs-comment">// &quot;username&quot; will have map value []string&#123;&quot;admin&quot;, &quot;admin2&quot;&#125;</span><br>        <span class="hljs-string">&quot;Password&quot;</span>, <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>    )<br>    ctx := metadata.NewOutgoingContext(context.Background(), md) <span class="hljs-comment">// 创建一个传出 metadata 数据的 context。</span><br><br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(ctx, &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Interceptor-拦截器">3.4 Interceptor 拦截器</h3><p><strong>（1）拦截器分类</strong></p><p>grpc 的拦截器可以实现在 server 端，也可以实现在 client 端。</p><ul><li><p>server 端拦截器：在接收到请求后，在真正处理请求的前后，在拦截器中进行一些处理。</p></li><li><p>client 端拦截器：在发送请求的前后，在拦截器中进行一些处理。</p></li></ul><blockquote><p>第三方库 <a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a> 实现了很多拦截器的功能：认证（auth）、 日志（ logging）、监控（monitoring）等，可以直接使用，值得借鉴学习。</p></blockquote><p>由于 unary 方法和 stream 方法参数不同，拦截器又分为一元拦截器（unary interceptor）和流拦截器（stream interceptor）。所以共有 4 种类型变量，每个变量都是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义在 google.golang.org/grpc@v1.51.0/interceptor.go</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// grpc.UnaryServerInterceptor</span><br><span class="hljs-keyword">type</span> UnaryServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// grpc.StreamServerInterceptor</span><br><span class="hljs-keyword">type</span> StreamServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// grpc.UnaryClientInterceptor</span><br><span class="hljs-keyword">type</span> UnaryClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// grpc.StreamClientInterceptor</span><br><span class="hljs-keyword">type</span> StreamClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="hljs-type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><strong>（2）拦截器流程</strong></p><p>主要流程是：</p><ol><li>定义拦截器<ul><li>预处理 pre-processing</li><li>调用RPC方法 invoking RPC method</li><li>后处理 post-processing</li></ul></li><li>合适的时机指定拦截器<ul><li>server：实例化 grpc server 时，作为  ServerOption 传入。</li><li>client：拨号时，作为 DialOption 传入。</li></ul></li></ol><p><strong>（3） server 端的 unary 拦截器</strong></p><p>如何找到该实现的函数：</p><ol><li>看 <code>grpc.UnaryInterceptor</code> 定义源码，需传入参数 <code>i UnaryServerInterceptor</code> 。</li><li>查看参数 <code>UnaryServerInterceptor</code> 定义源码，复制具体的函数，进行实现。</li></ol><p>需求：在处理请求前后，打印两句 log。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/interceptor/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;hello,&quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>        fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)              <span class="hljs-comment">// 在处理请求前进行处理，（预处理 pre-processing）</span><br>        resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求，（调用RPC方法 invoking RPC method）</span><br>        fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理，（后处理 post-processing）</span><br>        <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>    &#125;<br>    opt := grpc.UnaryInterceptor(interceptor) <span class="hljs-comment">// 将 UnaryServerInterceptor 作为参数，new 一个 ServerOption 变量。</span><br>    s := grpc.NewServer(opt)                  <span class="hljs-comment">// 实例化 grpc server 时，可以传入多个 ServerOption。（可变参数列表），这个指定拦截器。</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了上述写法，也可以将 UnaryServerInterceptor 拦截器方法单独拿出来，如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    opt := grpc.UnaryInterceptor(interceptor) <span class="hljs-comment">// 将 UnaryServerInterceptor 作为参数，new 一个 ServerOption 变量。</span><br>    s := grpc.NewServer(opt)                  <span class="hljs-comment">// 实例化 grpc server 时，可以传入多个 ServerOption。（可变参数列表），这个指定拦截器。</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>    fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)              <span class="hljs-comment">// 在处理请求前进行处理，（预处理 pre-processing）</span><br>    resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求，（调用RPC方法 invoking RPC method）</span><br>    fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理，（后处理 post-processing）</span><br>    <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）client 端的 unary 拦截器</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/interceptor/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>        start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间，（预处理 pre-processing）</span><br>        err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求，（调用RPC方法 invoking RPC method）</span><br>        duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间，（后处理 post-processing）</span><br>        fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// 返回 server 响应的数据</span><br>    &#125;<br><br>    opts := []grpc.DialOption&#123; <span class="hljs-comment">// 建立一个 DialOption 列表，拨号时传入</span><br>        grpc.WithTransportCredentials(insecure.NewCredentials()), <span class="hljs-comment">// 使用不安全的凭证</span><br>        grpc.WithUnaryInterceptor(interceptor),                   <span class="hljs-comment">// 指定 UnaryClientInterceptor 拦截器</span><br>    &#125;<br><br>    <span class="hljs-comment">//1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, opts...) <span class="hljs-comment">// 可变参数列表传入多个 DialOption</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">//2.实例化client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">//3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(context.Background(), &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）使用 metadata 和 interceptor 实现 auth 认证</strong></p><ul><li>在 client interceptor 中，使用 metadata 传递 appid/appkey；</li><li>在 server interceptor 中验证 appid/appkey 是否存在/合法；</li><li>如果不存在/不合法，使用 grpc 自带的 <code>status.Error</code> 返回状态码和错误信息。</li></ul><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>    fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)           <span class="hljs-comment">// 在处理请求前进行处理</span><br>    md, ok := metadata.FromIncomingContext(ctx) <span class="hljs-comment">// 获取 metadata 数据，并验证</span><br>    <span class="hljs-keyword">if</span> ok &#123;<br>        appid := md[<span class="hljs-string">&quot;appid&quot;</span>][<span class="hljs-number">0</span>]<br>        appkey := md[<span class="hljs-string">&quot;appkey&quot;</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> appid != <span class="hljs-string">&quot;123&quot;</span> || appkey != <span class="hljs-string">&quot;456&quot;</span> &#123;<br>            err = status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;invalid token.&quot;</span>)<br>            <span class="hljs-keyword">return</span> resp, err<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        status.Error(codes.Unauthenticated, <span class="hljs-string">&quot;Token no exist.&quot;</span>)<br>        <span class="hljs-keyword">return</span> resp, err<br>    &#125;<br>    resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求</span><br>    fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理</span><br>    <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>    md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123; <span class="hljs-comment">// 创建 metadata 数据</span><br>        <span class="hljs-string">&quot;appid&quot;</span>:  <span class="hljs-string">&quot;123&quot;</span>,<br>        <span class="hljs-string">&quot;appkey&quot;</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>    &#125;)<br>    ctx = metadata.NewOutgoingContext(ctx, md)           <span class="hljs-comment">// 传输 metadata 数据</span><br>    start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间</span><br>    err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求</span><br>    duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间</span><br>    fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）grpc 内置的自定义认证接口</strong></p><blockquote><p><a href="https://github.com/grpc/grpc-go/blob/v1.51.0/dialoptions.go#L331">WithPerRPCCredentials </a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithPerRPCCredentials returns a DialOption which sets credentials and places</span><br><span class="hljs-comment">// auth state on each outbound RPC.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithPerRPCCredentials</span><span class="hljs-params">(creds credentials.PerRPCCredentials)</span></span> DialOption &#123;<br>    <span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> &#123;<br>        o.copts.PerRPCCredentials = <span class="hljs-built_in">append</span>(o.copts.PerRPCCredentials, creds)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>client 无需在拦截器中设置 appid/appkey， <a href="https://github.com/grpc/grpc-go/blob/v1.51.0/dialoptions.go#L331">WithPerRPCCredentials </a> 可以将传入的 <code>credentials.PerRPCCredentials</code> 转化为  <code>DialOption</code>。查看 <code>credentials.PerRPCCredentials</code> 源码可以看到，PerRPCCredentials 是一个接口，实现其两个方法，就可以实现该接口。</p><ul><li>GetRequestMetadata：获取当前请求认证所需的元数据（metadata）</li><li>RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输</li></ul><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/auth/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Credential <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Credential)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 获取当前请求认证所需的 metadata</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;appid&quot;</span>:  <span class="hljs-string">&quot;123&quot;</span>,<br>        <span class="hljs-string">&quot;appkey&quot;</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Credential)</span></span> RequireTransportSecurity() <span class="hljs-type">bool</span> &#123;  <span class="hljs-comment">// 是否需要基于 TLS 认证进行安全传输</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>        start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间</span><br>        err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求</span><br>        duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间</span><br>        fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// 返回 server 响应的数据</span><br>    &#125;<br><br>    opts := []grpc.DialOption&#123; <span class="hljs-comment">// 建立一个 DialOption 列表，拨号时传入</span><br>        grpc.WithTransportCredentials(insecure.NewCredentials()), <span class="hljs-comment">// 使用不安全的凭证</span><br>        grpc.WithUnaryInterceptor(interceptor),                   <span class="hljs-comment">// 指定 UnaryClientInterceptor 拦截器</span><br>        grpc.WithPerRPCCredentials(Credential&#123;&#125;),  <span class="hljs-comment">// 传入凭证</span><br>    &#125;<br><br>    <span class="hljs-comment">//1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, opts...) <span class="hljs-comment">// 可变参数列表传入多个 DialOption</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">//2.实例化client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">//3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(context.Background(), &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-验证器">3.5 验证器</h3><p><strong>（1）一个开源项目</strong></p><p><a href="https://github.com/bufbuild/protoc-gen-validate">protoc-gen-validate</a>，该项目目前处于 alpha 阶段，功能是对于 protobuf 中的 message，进行数据验证。</p><p>下面简单跑通一下。</p><p><strong>（2）原理</strong>：</p><ol><li>定义规则：proto 中定义了 HelloRequest 这种 message 类型，并在其中标记数据规则。</li><li>生成验证规则的代码：protoc-gen-validate 会为 HelloRequest 类型，生成多个结构体方法，其中有一个 Validate 方法。在 Validata 方法，根据设置的数据规则，验证数据。</li><li>使用：在实际使用中，HelloRequest.Validate 就可以验证数据。</li></ol><p><strong>（3）安装 protoc-gen-validate  二进制文件</strong></p><p>注意看 README 文件，可能有更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># fetches this repo into $GOPATH</span><br>go get -d github.com/envoyproxy/protoc-gen-validate   <span class="hljs-comment"># -d 表示只下载源码不安装</span><br>git <span class="hljs-built_in">clone</span> https://github.com/bufbuild/protoc-gen-validate.git<br><span class="hljs-comment"># installs PGV into $GOPATH/bin</span><br><span class="hljs-built_in">cd</span> protoc-gen-validate &amp;&amp; make build<br><span class="hljs-comment"># build bin 文件后，删除 protoc-gen-validate 仓库就可以。</span><br><br><span class="hljs-comment"># go get 下载的 protoc-gen-validate 源码在 $GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/</span><br></code></pre></td></tr></table></figure><p>在 README 文件里有这样一段话，用以说明为什么使用上面的方式下载源码和构建二进制文件。</p><blockquote><p>Yes, our go module path is <code>github.com/envoyproxy/protoc-gen-validate</code> <strong>not</strong> <code>bufbuild</code> this is intentional.</p><p>Changing the module path is effectively creating a new, independent module. We would prefer not to break our users. The Go team are working on better <code>cmd/go</code> support for modules that change paths, but progress is slow. Until then, we will continue to use the <code>bufbuild</code> module path.</p></blockquote><p>补充说明：实际使用过程中，需要部分源码，也需要二进制文件 protoc-gen-validate。源码使用 <code>go get -d</code> 下载在 <code>$GOPATH/pkg/mod/github.com/envoyproxy/</code> 目录下，二进制文件在新的文件夹里编译后放在 <code>$GOPATH/bin</code> 目录下。</p><p><strong>（4）导入 proto 文件并生成 bp.go 文件</strong></p><p><strong>hello.proto</strong></p><p>在 message 中设置验证条件。<a href="https://github.com/bufbuild/protoc-gen-validate#constraint-rules">Constraint Rules</a></p><p><code>import &quot;validate.proto&quot;;</code> 可能会显示找不到文件。没关系，后面使用 protoc 生成代码时，指定该文件的目录。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;validate.proto&quot;</span>;<br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">uint64</span> id = <span class="hljs-number">1</span> [(validate.rules).<span class="hljs-type">uint64</span>.gt = <span class="hljs-number">999</span>];   <span class="hljs-comment">// id &gt; 999</span><br>    <span class="hljs-type">string</span> email = <span class="hljs-number">2</span> [(validate.rules).<span class="hljs-type">string</span>.email = <span class="hljs-literal">true</span>];  <span class="hljs-comment">// email 符合邮件规则</span><br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成代码命令</strong></p><p>注意使用 <code>-I</code> 指定在哪个目录中找 validate.proto 。使用 go get -d 下载的代码，会在  <code>$GOPATH/pkg/mod/</code> 目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . \   <span class="hljs-comment"># 当前目录中寻找 hello.proto</span><br>-I <span class="hljs-variable">$GOPATH</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/  \  <span class="hljs-comment"># 这个目录中寻找 import 的 proto 文件</span><br>--go_out=. \  <span class="hljs-comment"># pb.go 的生成目录</span><br>--go-grpc_out=. \  <span class="hljs-comment"># grpc.pb.go 的生成目录</span><br>--validate_out=<span class="hljs-string">&quot;lang=go:.&quot;</span> \   <span class="hljs-comment"># pb.validate.go 的生成目录</span><br>--go-grpc_opt=require_unimplemented_servers=<span class="hljs-literal">false</span> \   <span class="hljs-comment"># 该方法是为了向前兼容，这里关闭该方法的生成</span><br>hello.proto<br></code></pre></td></tr></table></figure><p><strong>server.go</strong></p><p>在拦截器中验证数据，注意这里的类型转化。</p><ul><li>传入的时 <code>interface&#123;&#125;</code> 类型，不能直接调用 Validate 函数，需要转化为具体的类型（这个类型实现了 Validate 方法）。</li><li>为了扩展更多的类型，拦截器中又不能转换为 HelloRequest（虽然也能跑，但是这个拦截器就只能验证 HelloRequest 这一种数据了），而应该转换为一个接口类型。</li><li>只要这个接口内包含 Validate 方法就可以，所以我们声明一个 Validator 类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/codes&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/status&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/validate/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;NO.&quot;</span> + strconv.FormatUint(request.Id, <span class="hljs-number">10</span>) + <span class="hljs-string">&quot; email is &quot;</span> + request.Email,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化带有 interceptor 的 grpc server</span><br>    option := grpc.UnaryInterceptor(interceptor)<br>    s := grpc.NewServer(option)<br><br>    <span class="hljs-comment">// 2.注册</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.启动并监听</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Validator <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// 写一个接口，任何实现 Validate 方法的变量，都可以转成 Validator 类型，再调用 Validate 方法。</span><br>    Validate() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// 在拦截器中，验证传入的数据是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> validator, ok := req.(Validator); ok &#123; <span class="hljs-comment">// interface&#123;&#125; 类型转换为 HelloRequest 类型。但是这里可能需要判断多种数据类型，不能直接写死成 req.(HelloRequest)，需要使用转成 Validator 接口类型。</span><br>        <span class="hljs-keyword">if</span> err := validator.Validate(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 因为在 hello.pb.validate.go 中 HelloRequest 实现了 Validate 方法。也就直接实现了 Validator 接口，可以通过 Validator 接口调用 Validate 方法。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, err.Error())  <span class="hljs-comment">// 返回的 error 为 统一的错误码 + 具体的错误信息。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> handler(ctx, req)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/validate/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(clientConn *grpc.ClientConn)</span></span> &#123;<br>        err := clientConn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    response, err := client.SayHello(context.Background(), &amp;proto.HelloRequest&#123;<br>        Id:     <span class="hljs-number">1000</span>,<br>        Email:  <span class="hljs-string">&quot;1234@gmail.com&quot;</span>,<br>        Mobile: <span class="hljs-string">&quot;130000000000&quot;</span>,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-状态码">3.6 状态码</h3><p>grpc 官方定义了状态码：<a href="https://github.com/grpc/grpc/blob/master/doc/statuscodes.md">https://github.com/grpc/grpc/blob/master/doc/statuscodes.md</a></p><h3 id="3-7-错误处理">3.7 错误处理</h3><p>go 中的错误处理主要是 status 包内。Status 类型中封装了 Error 类型。<code>status.Error()</code> 内部就是 new 一个 status 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/codes&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/status&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 生成 error</span><br>    err := status.Error(codes.NotFound, <span class="hljs-string">&quot;未找到记录&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到记录</span><br><br>    err = status.New(codes.NotFound, <span class="hljs-string">&quot;未找到记录&quot;</span>).Err()<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到记录</span><br><br>    err = status.Errorf(codes.NotFound, <span class="hljs-string">&quot;未找到%s记录&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到Tom记录</span><br><br>    err = status.Newf(codes.NotFound, <span class="hljs-string">&quot;未找到%s记录&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Err()<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到Tom记录</span><br><br>    <span class="hljs-comment">// 解析 error</span><br>    <span class="hljs-keyword">if</span> fromError, ok := status.FromError(err); ok &#123;<br>        fmt.Println(fromError.Code())    <span class="hljs-comment">// 打印错误码    // NotFound</span><br>        fmt.Println(fromError.Message()) <span class="hljs-comment">// 打印错误信息  //未找到Tom记录</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-超时机制">3.8 超时机制</h3><p>使用 <code>context.WithTimeout(context.Background(), time.Second*3)</code> 生成带有 deadline 功能的 contex，在远程调用时使用。</p><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/deadline/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Reply: <span class="hljs-string">&quot;hello, &quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1. 实例化 grpc server</span><br>    opt := grpc.UnaryInterceptor(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>        time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// 等待 5s，模拟 server 超时</span><br>        <span class="hljs-keyword">return</span> handler(ctx, req)<br>    &#125;)<br>    s := grpc.NewServer(opt)<br><br>    <span class="hljs-comment">// 2. 注册</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3. 监听启动</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listen)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/deadline/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(clientConn *grpc.ClientConn)</span></span> &#123;<br>        err := clientConn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化客户端</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    <span class="hljs-comment">// 超时机制</span><br>    <span class="hljs-comment">//ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*3)</span><br>    <span class="hljs-comment">// 直接调用 cancelFunc 可以主动取消 goroutine。下面的代码用不到，使用 _ 代替。</span><br>    ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="hljs-number">3</span>)<br>    response, err := client.SayHello(ctx, &amp;proto.HelloRequest&#123;Name: <span class="hljs-string">&quot;Golang&quot;</span>&#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-server-client-stub-解析">3.8 server/client stub 解析</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的 hello.proto 为例，protoc 生成的 go 源码是 hello_grpc.pb.go 文件。</p><p><strong>（1）server stub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterServer <span class="hljs-keyword">interface</span> &#123;<br>    SayHello(context.Context, *HelloRequest) (*HelloResponse, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 GreeterServer 接口，里面封装了 SayHello 函数。</li><li>在服务端中，我们会声明一个结构体 server，让 server 实现 GreeterServer 接口，也就是为 server 定义结构体方法 SayHello 函数。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">RegisterGreeterServer</span>(s grpc.ServiceRegistrar, srv GreeterServer) &#123;<br>    s<span class="hljs-selector-class">.RegisterService</span>(&amp;Greeter_ServiceDesc, srv)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 GreeterServer 注册到 grpc server 中。</li><li>在服务端中，因为 server 实现了 GreeterServer 接口，也就可以将 server 注册到 grpc server 中。</li></ul><p><strong>（2）client stub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterClient <span class="hljs-keyword">interface</span> &#123;<br>    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 GreeterClient 接口，里面封装了 SayHello 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> greeterClient <span class="hljs-keyword">struct</span> &#123;<br>    cc grpc.ClientConnInterface<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *greeterClient)</span></span> SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    out := <span class="hljs-built_in">new</span>(HelloResponse)<br>    err := c.cc.Invoke(ctx, <span class="hljs-string">&quot;/Greeter/SayHello&quot;</span>, in, out, opts...)  <span class="hljs-comment">// 实际上是利用 grpc.ClientConnInterface 的Invoke 方法进行远程调用。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> out, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 greeterClient 结构体，里面包含着 grpc.ClientConnInterface 变量，也就是可以使用 grpc.ClientConnInterface 的方法。</li><li>并为 greeterClient 结构体实现了 SayHello 方法，所以 greeterClient 结构体实现了 GreeterClient 接口。</li><li><strong>为什么 greeterClient 结构体里面要包含一个 grpc.ClientConnInterface 变量？</strong><ul><li>远程调用 server 端 SayHello 时，实际上调用的是 grpc.ClientConnInterface 的 Invoke 方法。</li><li>在 Invoke 方法的参数中，有 context、路径（call ID）、传入参数、穿出参数、远程调用的选项。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGreeterClient</span><span class="hljs-params">(cc grpc.ClientConnInterface)</span></span> GreeterClient &#123;<br>    <span class="hljs-keyword">return</span> &amp;greeterClient&#123;cc&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里是实例化 greeterClient 结构体的方法，提供给客户端使用。</li><li>注意：这里返回的是 GreeterClient 接口变量，实际上返回的是 greeterClient 结构体变量，因为在上面 greeterClient 结构体实现了 GreeterClient 接口。</li></ul><h2 id="Reference">Reference</h2><p>grpc API：<a href="https://pkg.go.dev/google.golang.org/grpc">https://pkg.go.dev/google.golang.org/grpc</a></p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文回答了 RPC 是什么、为什么使用 RPC 等问题，并详细探讨了 protobuf 协议和 gRPC 框架。&lt;/p&gt;</summary>
    
    
    
    <category term="Mark" scheme="https://www.aimtao.net/categories/Mark/"/>
    
    
    <category term="Go" scheme="https://www.aimtao.net/tags/Go/"/>
    
    <category term="RPC" scheme="https://www.aimtao.net/tags/RPC/"/>
    
    <category term="微服务" scheme="https://www.aimtao.net/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核｜系统调用</title>
    <link href="https://www.aimtao.net/system-call/"/>
    <id>https://www.aimtao.net/system-call/</id>
    <published>2022-04-12T10:01:00.000Z</published>
    <updated>2022-04-12T10:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以最常见的系统调用 open， 打开一个文件为线索，展示 32/64 位系统调用的实现方式。</p></blockquote><span id="more"></span><p>在 <a href="https://www.aimtao.net/init/#7-1-%E6%9D%83%E9%99%90%E5%88%86%E5%B1%82%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">Linux 内核｜初始化</a> 中提到过，用户态代码无法执行更高权限的指令，要想访问核心资源，需要通过系统调用来访问。整个过程如图：</p><p><img src="https://hutu.aimtao.net/mark/2022-01-23-yp8k9D.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="1-流程概述">1.流程概述</h2><blockquote><p>再看具体的代码之前，先看一下大概的流程。这里引用这篇<a href="https://linux.fasionchan.com/zh_CN/latest/system-programming/syscall/principle.html">文章</a>的描述， 言简意赅。</p></blockquote><p><img src="https://hutu.aimtao.net/mark/2022-07-02-lV00T9.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ol><li><strong>应用程序</strong> 代码调用系统调用( xyz )，该函数是一个包装系统调用的 <strong>库函数</strong> ；</li><li><strong>库函数</strong> ( xyz )负责准备向内核传递的参数，并触发 <strong>软中断</strong> 以切换到内核；（64 位是调用 寄存器 MSR_LSTAR 中的函数 <code>entry_SYSCALL_64</code> 进入内核的。）</li><li>CPU 被 <strong>软中断</strong> 打断后，执行 <strong>中断处理函数</strong> ，即 <strong>系统调用处理函数</strong> ( system_call )；</li><li><strong>系统调用处理函数</strong> 调用 <strong>系统调用服务例程</strong> ( sys_xyz )，真正开始处理该系统调用；</li></ol><blockquote><p>应用程序：<em>application program</em><br>库函数：<em>libc</em><br>系统调用处理函数：<em>system call handler</em><br>系统调用服务例程：<em>system call service routine</em></p></blockquote><h2 id="2-封装系统调用的库函数glibc">2.封装系统调用的库函数glibc</h2><h3 id="2-1-什么是-glibc">2.1 什么是 glibc</h3><p>glibc 是 GNU 旗下的 C 标准库，后来逐渐成为了 Linux 的标准 C 库。glibc 提供很多 API，比如 open、read、write、malloc、printf 等。</p><h3 id="2-2-fopen-到-DO-CALL">2.2 fopen 到 DO_CALL</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">255</span>];<br><br>    fp = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fgets(buff, <span class="hljs-number">255</span>, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buff);<br>    fclose(fp);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个打开文件的程序，其中调用 glibc 库中的 fopen 打开文件，实际上最后调用的是 open 函数，glibc 库中的 open 函数的定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span><br></code></pre></td></tr></table></figure><p>glibc 库中有个文件 syscalls.list，里面列着所有 glibc 的函数对应的系统调用。下面是 open 函数所对应的系统调用。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Perl"><span class="hljs-comment"># File name Caller Syscall name Args Strong name Weak names</span><br><span class="hljs-keyword">open</span> - <span class="hljs-keyword">open</span> Ci:siv __libc_open __open <span class="hljs-keyword">open</span><br></code></pre></td></tr></table></figure><p>根据上述配置文件，glibc会调用脚本 make_syscall.sh 将其封装为宏，如 <code>#define SYSCALL_NAME open</code> 的形式。</p><p>这些宏会通过 <code>T_PSEUDO</code> 来调用（位于syscall-template.S）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)<br>    ret<br><span class="hljs-title function_">T_PSEUDO_END</span> <span class="hljs-params">(SYSCALL_SYMBOL)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_PSEUDO(SYMBOL, NAME, N)       PSEUDO (SYMBOL, NAME, N)</span><br></code></pre></td></tr></table></figure><p>这里的 PSEUDO 也是一个宏。从下面代码中可以看出，对于任何一个系统调用，最终会调用 <code>DO_CALL(syscall_name, args)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSEUDO(name, syscall_name, args)      \</span><br><span class="hljs-meta">  .text;                                      \</span><br><span class="hljs-meta">  ENTRY (name)                                \</span><br><span class="hljs-meta">    DO_CALL (syscall_name, args);             \</span><br><span class="hljs-meta">    cmpl $-4095, %eax;                        \</span><br><span class="hljs-meta">    jae SYSCALL_ERROR_LABEL</span><br></code></pre></td></tr></table></figure><p><code>DO_CALL</code> 这个宏 32 位和 64 位的定义是不一样的，下面我们对于 32 位和 64 位分开来讨论。</p><h2 id="3-32-位系统调用过程">3.32 位系统调用过程</h2><h3 id="3-1-DO-CALL-到-ENTER-KERNEL">3.1 DO_CALL 到 ENTER_KERNEL</h3><p>在32位系统中，<code>DO_CALL()</code> 位于i386 目录下的 sysdep.h 文件中，定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 注释里可以看到，这些寄存器是和参数的对应关系。</span><br><span class="hljs-comment">/* Linux takes system call arguments in registers:</span><br><span class="hljs-comment">    syscall number  %eax     call-clobbered</span><br><span class="hljs-comment">    arg 1       %ebx         call-saved</span><br><span class="hljs-comment">    arg 2       %ecx         call-clobbered</span><br><span class="hljs-comment">    arg 3       %edx         call-clobbered</span><br><span class="hljs-comment">    arg 4       %esi         call-saved</span><br><span class="hljs-comment">    arg 5       %edi         call-saved</span><br><span class="hljs-comment">    arg 6       %ebp         call-saved</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CALL(syscall_name, args)               \</span><br><span class="hljs-meta">    PUSHARGS_##args                               \</span><br><span class="hljs-meta">    DOARGS_##args                                 \</span><br><span class="hljs-meta">    movl $SYS_ify (syscall_name), %eax;           \</span><br><span class="hljs-meta">    ENTER_KERNEL                                  \</span><br><span class="hljs-meta">    POPARGS_##args</span><br></code></pre></td></tr></table></figure><p>代码主要逻辑是：将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 eax 里面，然后执行 <code>ENTER_KERNEL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENTER_KERNEL int $0x80</span><br></code></pre></td></tr></table></figure><p>这里面的 <code>ENTER_KERNEL</code> 定义如下，int 就是 interrupt，表示中断，<code>int $0x80</code> 表示触发一个软中断。<code>ENTER_KERNEL</code> 实际调用的是80软中断，以此陷入（trap）内核。</p><h3 id="3-2-软中断-entry-INT80-32">3.2 软中断 entry_INT80_32</h3><p>80 软中断是一个软中断的陷入门，是在<a href="https://www.aimtao.net/init/#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E6%96%AD">内核启动</a>的时候初始化的。<a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/kernel/traps.c#L963">trap_init()</a> 通过 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/kernel/idt.c#L263">idt_setup_traps()</a> 设置了很多的中断门（Interrupt Gate)，用于处理各种中断，如系统调用的中断门：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32);<br></code></pre></td></tr></table></figure><p>当接收到一个系统调用的时候，<code>entry_INT80_32</code> 就被调用了，从而从用户态陷入（trap）内核态。</p><p><code>entry_INT80_32</code> 定义如下，进入内核之前，要保存所有的寄存器，即通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在 pt_regs 结构里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">ENTRY(entry_INT80_32)<br>        ASM_CLAC<br>        pushl   %eax                    <span class="hljs-comment">/* pt_regs-&gt;orig_ax */</span><br>        SAVE_ALL pt_regs_ax=$-ENOSYS    <span class="hljs-comment">/* save rest */</span><br>        movl    %esp, %eax<br>        call    do_syscall_32_irqs_on  <span class="hljs-comment">//最终会调用 do_syscall_32_irqs_on</span><br>.Lsyscall_32_done:<br>......<br>.Lirq_return:<br>    INTERRUPT_RETURN   <span class="hljs-comment">// 返回用户态</span><br></code></pre></td></tr></table></figure><p>保存完用户态寄存器数据后，会调用 <code>do_syscall_32_irqs_on</code>。</p><h3 id="3-3-do-syscall-32-irqs-on">3.3 do_syscall_32_irqs_on</h3><p><code>do_syscall_32_irqs_on</code> 定义如下。</p><ul><li>该函数将系统调用号从 eax 里面取出来。</li><li>根据系统调用号，在 <code>ia32_sys_call_table</code> （就是系统调用表）中找到相应的函数进行调用。</li><li>并将寄存器中保存的参数取出来，作为函数参数。(仔细比对就能发现，这些参数所对应的寄存器，和 <code>DO_CALL()</code> 的注释是一样的)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_syscall_32_irqs_on</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> *<span class="hljs-title">ti</span> =</span> current_thread_info();<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;orig_ax;  <span class="hljs-comment">// 取出系统调用号</span><br>......<br>    <span class="hljs-keyword">if</span> (likely(nr &lt; IA32_NR_syscalls)) &#123;<br>        regs-&gt;ax = ia32_sys_call_table[nr](   <span class="hljs-comment">// 从寄存器中取出函数参数</span><br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;bx, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;cx,<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;dx, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;si,<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;di, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)regs-&gt;bp);<br>    &#125;<br>    syscall_return_slowpath(regs);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，这个 <code>ia32_sys_call_table</code> 定义如下，实际上就是 <code>sys_call_table</code> 系统调用表，系统调用放在这个表里面。至于这个表是如何形成的，在本文后面会描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ia32_sys_call_table sys_call_table</span><br></code></pre></td></tr></table></figure><h3 id="3-4-返回用户态-INTERRUPT-RETURN">3.4 返回用户态 INTERRUPT_RETURN</h3><p>在 <code>entry_INT80_32</code> 定义中可以看到，当系统调用结束之后，紧接着调用的是 INTERRUPT_RETURN，也就是 iret 指令，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERRUPT_RETURN    iret</span><br></code></pre></td></tr></table></figure><p>iret 指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。</p><h3 id="3-5-一张图总结">3.5 一张图总结</h3><p><img src="https://hutu.aimtao.net/mark/2022-07-02-2xwXTw.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="4-64-位系统调用过程">4.64 位系统调用过程</h2><h3 id="4-1-DO-CALL-到-syscall">4.1 DO_CALL 到 syscall</h3><p>在 64 位系统中，<code>DO_CALL</code> 位于x86_64 目录下的 sysdep.h 文件中，定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* The Linux/x86-64 kernel expects the system call parameters in</span><br><span class="hljs-comment">   registers according to the following table:</span><br><span class="hljs-comment">    syscall number  rax</span><br><span class="hljs-comment">    arg 1       rdi</span><br><span class="hljs-comment">    arg 2       rsi</span><br><span class="hljs-comment">    arg 3       rdx</span><br><span class="hljs-comment">    arg 4       r10</span><br><span class="hljs-comment">    arg 5       r8</span><br><span class="hljs-comment">    arg 6       r9</span><br><span class="hljs-comment">......</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_CALL(syscall_name, args)                       \</span><br><span class="hljs-meta">  lea SYS_ify (syscall_name), %rax;                       \</span><br><span class="hljs-meta">  syscall</span><br></code></pre></td></tr></table></figure><p>和 32 位系统类似，还是将系统调用名称转换为系统调用号，放到寄存器 rax。这里是真正进行调用，不是用中断了，而是改用 <code>syscall</code> 指令了。（通过注释可以看到，传递参数的寄存器也变了）</p><h3 id="4-2-syscall-到-entry-SYSCALL-64">4.2 syscall 到 entry_SYSCALL_64</h3><p>syscall 指令使用了一种特殊的寄存器，叫特殊模块寄存器（Model Specific Registers，简称 MSR）。这种寄存器是 CPU 为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p><p>在系统初始化的时候，<code>trap_init()</code> 除了初始化上面的中断模式，还会调用 <code>cpu_init-&gt;syscall_init()</code>。这里面有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">wrmsrl(MSR_LSTAR, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)entry_SYSCALL_64);<br></code></pre></td></tr></table></figure><ul><li>rdmsr 和 wrmsr 是用来读写特殊模块寄存器的。</li><li>MSR_LSTAR 就是一个特殊的寄存器，当 syscall 指令被调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用 <code>entry_SYSCALL_64</code>。</li></ul><h3 id="4-3-entry-SYSCALL-64">4.3 entry_SYSCALL_64</h3><p>在 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S </a>中定义了 <code>entry_SYSCALL_64</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C">ENTRY(entry_SYSCALL_64)<br>        <span class="hljs-comment">/* Construct struct pt_regs on stack */</span><br>        pushq   $__USER_DS                      <span class="hljs-comment">/* pt_regs-&gt;ss */</span><br>        pushq   <span class="hljs-title function_">PER_CPU_VAR</span><span class="hljs-params">(rsp_scratch)</span>        <span class="hljs-comment">/* pt_regs-&gt;sp */</span><br>        pushq   %r11                            <span class="hljs-comment">/* pt_regs-&gt;flags */</span><br>        pushq   $__USER_CS                      <span class="hljs-comment">/* pt_regs-&gt;cs */</span><br>        pushq   %rcx                            <span class="hljs-comment">/* pt_regs-&gt;ip */</span><br>        pushq   %rax                            <span class="hljs-comment">/* pt_regs-&gt;orig_ax */</span><br>        pushq   %rdi                            <span class="hljs-comment">/* pt_regs-&gt;di */</span><br>        pushq   %rsi                            <span class="hljs-comment">/* pt_regs-&gt;si */</span><br>        pushq   %rdx                            <span class="hljs-comment">/* pt_regs-&gt;dx */</span><br>        pushq   %rcx                            <span class="hljs-comment">/* pt_regs-&gt;cx */</span><br>        pushq   $-ENOSYS                        <span class="hljs-comment">/* pt_regs-&gt;ax */</span><br>        pushq   %r8                             <span class="hljs-comment">/* pt_regs-&gt;r8 */</span><br>        pushq   %r9                             <span class="hljs-comment">/* pt_regs-&gt;r9 */</span><br>        pushq   %r10                            <span class="hljs-comment">/* pt_regs-&gt;r10 */</span><br>        pushq   %r11                            <span class="hljs-comment">/* pt_regs-&gt;r11 */</span><br>        sub     $<span class="hljs-params">(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>)</span>, %rsp                    <span class="hljs-comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br>        movq    <span class="hljs-title function_">PER_CPU_VAR</span><span class="hljs-params">(current_task)</span>, %r11<br>        testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, <span class="hljs-title function_">TASK_TI_flags</span><span class="hljs-params">(%r11)</span><br>        jnz     entry_SYSCALL64_slow_path<br>......<br>entry_SYSCALL64_slow_path:<br>        <span class="hljs-comment">/* IRQs are off. */</span><br>        SAVE_EXTRA_REGS<br>        movq    %rsp, %rdi<br>        call    do_syscall_64    <span class="hljs-comment">// 进入内核态       /* returns with IRQs disabled */</span><br>return_from_SYSCALL_64:<br>    RESTORE_EXTRA_REGS<br>    TRACE_IRQS_IRETQ<br>    movq    <span class="hljs-title function_">RCX</span><span class="hljs-params">(%rsp)</span>, %rcx<br>    movq    <span class="hljs-title function_">RIP</span><span class="hljs-params">(%rsp)</span>, %r11<br>    movq    <span class="hljs-title function_">R11</span><span class="hljs-params">(%rsp)</span>, %r11<br>......<br>syscall_return_via_sysret:<br>    <span class="hljs-comment">/* rcx and r11 are already restored (see code above) */</span><br>    RESTORE_C_REGS_EXCEPT_RCX_R11<br>    movq    <span class="hljs-title function_">RSP</span><span class="hljs-params">(%rsp)</span>, %rsp<br>    USERGS_SYSRET64     <span class="hljs-comment">// 返回用户态</span><br></code></pre></td></tr></table></figure><p>这里先保存了很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数的寄存器。</p><p>最后会调用 <code>entry_SYSCALL64_slow_path-&gt;do_syscall_64</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">__visible <span class="hljs-type">void</span> <span class="hljs-title function_">do_syscall_64</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> *<span class="hljs-title">ti</span> =</span> current_thread_info();<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr = regs-&gt;orig_ax;<br>......<br>        <span class="hljs-keyword">if</span> (likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) &#123;<br>                regs-&gt;ax = sys_call_table[nr &amp; __SYSCALL_MASK](<br>                        regs-&gt;di, regs-&gt;si, regs-&gt;dx,<br>                        regs-&gt;r10, regs-&gt;r8, regs-&gt;r9);<br>        &#125;<br>        syscall_return_slowpath(regs);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>do_syscall_64</code> 里面，主要流程是：</p><ul><li>从 rax 里面拿出系统调用号。</li><li>根据系统调用号，在系统调用表 <code>sys_call_table</code> 中找到相应的函数进行调用。</li><li>将寄存器中保存的参数取出来，作为函数参数。(仔细比对就能发现，与 32 位系统类似，这些参数所对应的寄存器，和 <code>DO_CALL()</code> 的注释又是一样的)</li></ul><h3 id="4-4-返回用户态-USERGS-SYSRET64">4.4 返回用户态 USERGS_SYSRET64</h3><p>在 <code>entry_SYSCALL_64</code> 的定义中可以看到，64 位的系统调用返回的时候，执行的是 <code>USERGS_SYSRET64</code>。定义如下，返回用户态的指令变成了 sysretq。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USERGS_SYSRET64    \</span><br><span class="hljs-meta">    swapgs;                \</span><br><span class="hljs-meta">    sysretq;</span><br></code></pre></td></tr></table></figure><h3 id="4-5-一张图总结">4.5 一张图总结</h3><p><img src="https://hutu.aimtao.net/mark/2022-07-02-uVE4Xx.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="5-系统调用表">5.系统调用表</h2><p>前面我们重点关注了系统调用的流程，32/64 位系统最终都需要根据系统调用号，在系统调用表 <code>sys_call_table</code> 中查找相应的函数。下面来看看系统调用表。</p><h3 id="5-1-sys-call-table-的内容">5.1 sys_call_table 的内容</h3><p>32 位的系统调用表定义在面 arch/x86/entry/syscalls/syscall_32.tbl 文件里。例如 open 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">5</span>    i386    open    sys_open  compat_sys_open<br></code></pre></td></tr></table></figure><p>64 位的系统调用定义在另一个文件 arch/x86/entry/syscalls/syscall_64.tbl 里。例如 open 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">2</span>    common    open    sys_open<br></code></pre></td></tr></table></figure><ul><li>第一列的数字是系统调用号。可以看出，32 位和 64 位的系统调用号是不一样的。</li><li>第三列是系统调用的名字。</li><li>第四列是系统调用在内核的实现函数。不过，它们都是以 sys_ 开头。</li></ul><h3 id="5-2-声明-syscalls-h">5.2 声明 syscalls.h</h3><p>系统调用在内核中的实现函数要有一个声明。声明往往在 include/linux/syscalls.h 文件中。例如 <code>sys_open</code> 的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *filename,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> flags, <span class="hljs-type">umode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-3-实现-open-c">5.3 实现 open.c</h3><p>真正的实现这个系统调用，一般在一个.c 文件里面，例如 sys_open 的实现在 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/open.c">fs/open.c</a> 里面，例如 <code>sys_open</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">SYSCALL_DEFINE3(open, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, filename, <span class="hljs-type">int</span>, flags, <span class="hljs-type">umode_t</span>, mode)<br>&#123;<br>    <span class="hljs-keyword">if</span> (force_o_largefile())<br>        flags |= O_LARGEFILE;<br>    <span class="hljs-keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SYSCALL_DEFINE3</code> 是一个有三个参数的宏系统调用。定义如下：<code>SYSCALL_DEFINE</code> 最多六个参数，根据参数的数目选择不同的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)                      \</span><br><span class="hljs-meta">    SYSCALL_METADATA(sname, x, __VA_ARGS__)                 \</span><br><span class="hljs-meta">    __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)                             \</span><br><span class="hljs-meta">    asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \</span><br><span class="hljs-meta">            __attribute__((alias(__stringify(SyS##name))));         \</span><br><span class="hljs-meta">    static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));  \</span><br><span class="hljs-meta">    asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));      \</span><br><span class="hljs-meta">    asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))       \</span><br><span class="hljs-meta">    &#123;                                                               \</span><br><span class="hljs-meta">            long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));  \</span><br><span class="hljs-meta">            __MAP(x,__SC_TEST,__VA_ARGS__);                         \</span><br><span class="hljs-meta">            __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));       \</span><br><span class="hljs-meta">            return ret;                                             \</span><br><span class="hljs-meta">    &#125;                                                               \</span><br><span class="hljs-meta">    static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>如果我们把所有宏展开之后，实现如下，和声明的是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user * filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode)</span><br>&#123;<br>    <span class="hljs-type">long</span> ret;<br><br>    <span class="hljs-keyword">if</span> (force_o_largefile())<br>    flags |= O_LARGEFILE;<br><br>    ret = do_sys_open(AT_FDCWD, filename, flags, mode);<br>    asmlinkage_protect(<span class="hljs-number">3</span>, ret, filename, flags, mode);<br>    <span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><h3 id="5-4-编译-syscalls-32-64-h">5.4 编译  syscalls_32/64.h</h3><p>在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。生成方式在 arch/x86/entry/syscalls/Makefile 中。</p><p>这里面会使用两个脚本：</p><ul><li>第一个脚本 arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成 <code>#define __NR_open</code>。</li><li>第二个脚本 arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成 <code>__SYSCALL(__NR_open, sys_open)</code>。</li></ul><p>这样最终生成 syscalls_32.h 和 syscalls_64.h 就保存了系统调用号和系统调用实现函数之间的对应关系，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">__SYSCALL_COMMON(<span class="hljs-number">0</span>, sys_read, sys_read)<br>__SYSCALL_COMMON(<span class="hljs-number">1</span>, sys_write, sys_write)<br>__SYSCALL_COMMON(<span class="hljs-number">2</span>, sys_open, sys_open)<br>__SYSCALL_COMMON(<span class="hljs-number">3</span>, sys_close, sys_close)<br>__SYSCALL_COMMON(<span class="hljs-number">5</span>, sys_newfstat, sys_newfstat)<br>...<br></code></pre></td></tr></table></figure><p>其中<code>__SYSCALL_COMMON</code>宏定义如下，主要是将对应的数字序号和系统调用名对应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_COMMON(nr, sym, compat) __SYSCALL_64(nr, sym, compat)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_64(nr, sym, compat) [nr] = sym,</span><br></code></pre></td></tr></table></figure><p>最终形成的表如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Prolog">asmlinkage const sys_call_ptr_t sys_call_table[<span class="hljs-symbol">__NR_syscall_max</span>+<span class="hljs-number">1</span>] = &#123;<br>    [<span class="hljs-number">0</span> ... <span class="hljs-symbol">__NR_syscall_max</span>] = &amp;sys_ni_syscall,<br>    [<span class="hljs-number">0</span>] = sys_read,<br>    [<span class="hljs-number">1</span>] = sys_write,<br>    [<span class="hljs-number">2</span>] = sys_open,<br>    ...<br>    ...<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-5-使用-syscall-32-64-c">5.5 使用 syscall_32/64.c</h3><p>在文件 arch/x86/entry/syscall_32.c，定义了这样一个表，里面 include 了这个头文件 syscalls_32.h，从而所有的 sys_ 系统调用都在这个表里面了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">__visible <span class="hljs-type">const</span> <span class="hljs-type">sys_call_ptr_t</span> ia32_sys_call_table[__NR_syscall_compat_max+<span class="hljs-number">1</span>] = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Smells like a compiler bug -- it doesn&#x27;t work</span><br><span class="hljs-comment">    * when the &amp; below is removed.</span><br><span class="hljs-comment">    */</span><br>    [<span class="hljs-number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/syscalls_32.h&gt;</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>同理，在文件 arch/x86/entry/syscall_64.c，定义了这样一个表，里面 include 了这个头文件syscalls_64.h，这样所有的 sys_ 系统调用就都在这个表里面了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* System call table for x86-64. */</span><br>asmlinkage <span class="hljs-type">const</span> <span class="hljs-type">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="hljs-number">1</span>] = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Smells like a compiler bug -- it doesn&#x27;t work</span><br><span class="hljs-comment">    * when the &amp; below is removed.</span><br><span class="hljs-comment">    */</span><br>    [<span class="hljs-number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/syscalls_64.h&gt;</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-一张图总结">6.一张图总结</h2><p>以64位系统为例</p><p><img src="https://hutu.aimtao.net/mark/2022-07-02-8lGmTh.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="7-参考">7.参考</h2><ul><li><a href="https://ty-chen.github.io/linux-kernel-system-call/">https://ty-chen.github.io/linux-kernel-system-call/</a></li><li><a href="https://linux.fasionchan.com/zh_CN/latest/system-programming/syscall/principle.html">https://linux.fasionchan.com/zh_CN/latest/system-programming/syscall/principle.html</a></li><li>趣谈Linux操作系统</li><li>Linux 内核设计与实现</li></ul><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以最常见的系统调用 open， 打开一个文件为线索，展示 32/64 位系统调用的实现方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Kernel" scheme="https://www.aimtao.net/categories/Kernel/"/>
    
    
    <category term="Linux" scheme="https://www.aimtao.net/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://www.aimtao.net/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核｜初始化</title>
    <link href="https://www.aimtao.net/init/"/>
    <id>https://www.aimtao.net/init/</id>
    <published>2022-01-19T13:00:00.000Z</published>
    <updated>2022-01-19T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Linux 内核启动后，完成了实模式到保护模式的切换，并做好了各种准备工作。接下来进入内核初始化，我们主要关注初始化的流程。</p></blockquote><span id="more"></span><h2 id="1-概述">1.概述</h2><p>内核的启动从入口函数 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L791">start_kernel()</a> 开始。在 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c">init/main.c</a> 文件中，start_kernel 相当于内核的 main 函数。这个函数里，就是各种各样初始化函数 XXXX_init。其中的主要流程有以下内容：</p><ol><li>创建0号进程：<code>INIT_TASK(init_task)</code></li><li>异常处理类中断服务程序挂接：<code>trap_init()</code></li><li>初始化内存：<code>mm_init()</code></li><li>初始化进程调度器：<code>sched_init()</code></li><li>初始化基于内存的文件系统：<code>vfs_caches_init()</code></li><li>初始化其他内容：<code>rest_init()</code></li></ol><h2 id="2-创建-0-号进程">2.创建 0 号进程</h2><blockquote><p><code>start_kernel()</code>：/init/mian.c</p><p><code>init_task</code>：/init/init_task.c</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L791">start_kernel()</a> 函数体一开始就会运行 <code>set_task_stack_end_magic(&amp;init_task)</code> 来创建初始进程，其中参数 <code>init_task</code>，它的定义是 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/init_task.c#L57">struct task_struct init_task = INIT_TASK(init_task)</a>。</p><p>0 号进程：系统创建的第一个进程，也是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表（Procese List）的第一个。</p><ul><li><strong>只在内核中</strong>：<code>init_task</code> 是静态定义的进程，当内核被放入内存时，它就已经存在，它没有自己的用户空间，一直处于内核空间中运行，并且也只处于内核空间运行。</li><li><strong>作用</strong>：0 号进程用于包括内存、页表、必要数据结构、信号、调度器、硬件设备等的初始化。</li><li><strong>创建 1 号进程和 2 号进程</strong>：当它执行到最后（初始化剩余内容）时，将 <code>start_kernel</code> 中所有的初始化执行完成后，会在内核中启动一个 <code>kernel_init</code> 内核线程和一个 <code>kthreadd</code> 内核线程。<ul><li><code>kernel_init</code> 内核线程执行到最后会通过 <code>execve</code> 系统调用执行转变为我们所熟悉的 <code>init</code> 进程（1 号进程）。</li><li><code>kthreadd</code> 内核线程是内核用于管理调度其他的内核线程的守护线程（2 号进程）。</li></ul></li><li><strong>idle 进程</strong>：在最后<code>init_task</code>将变成一个 idle 进程，用于在 CPU 没有进程运行时运行它，它在此时仅仅用于空转。</li></ul><blockquote><p>补充：为什么需要 idle 进程？</p><p>就绪队列结构中含 idle 指针，指向 idle 进程，当调度器发现就绪队列为空时，调用 idle 进程执行，此时 cpu 设置为低功耗省电模式。</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/init_task.c#L57">init_task</a> 的定义，这里只节选了部分，采用了 gcc 的结构体初始化方式为其进行了直接赋值生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set up the first task table, touch at your own risk!. Base=0,</span><br><span class="hljs-comment"> * limit=0x1fffff (=2MB)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> <span class="hljs-title">init_task</span></span><br><span class="hljs-class">#<span class="hljs-title">ifdef</span> <span class="hljs-title">CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span><br><span class="hljs-class">    __<span class="hljs-title">init_task_data</span></span><br><span class="hljs-class">#<span class="hljs-title">endif</span></span><br><span class="hljs-class">=</span> &#123;<br>    ......<br>    .state             = <span class="hljs-number">0</span>,<br>    .<span class="hljs-built_in">stack</span>             = init_stack,<br>    .usage             = REFCOUNT_INIT(<span class="hljs-number">2</span>),<br>    .flags             = PF_KTHREAD,<br>    .prio             = MAX_PRIO - <span class="hljs-number">20</span>,<br>    .static_prio     = MAX_PRIO - <span class="hljs-number">20</span>,<br>    .normal_prio     = MAX_PRIO - <span class="hljs-number">20</span>,<br>    .policy             = SCHED_NORMAL,<br>    .cpus_ptr         = &amp;init_task.cpus_mask,<br>    .cpus_mask         = CPU_MASK_ALL,<br>    .nr_cpus_allowed = NR_CPUS,<br>    .mm                 = <span class="hljs-literal">NULL</span>,<br>    .active_mm         = &amp;init_mm,<br>    ......<br>    .thread_pid         = &amp;init_struct_pid,<br>    .thread_group     = LIST_HEAD_INIT(init_task.thread_group),<br>    .thread_node     = LIST_HEAD_INIT(init_signals.thread_head),<br>    ......<br>&#125;;<br>EXPORT_SYMBOL(init_task);<br></code></pre></td></tr></table></figure><p><code>set_task_stack_end_magic(&amp;init_task)</code> 函数如下，通过 <code>end_of_stack()</code> 获取栈边界地址，然后把栈底地址设置为STACK_END_MAGIC，作为栈溢出的标记。每个进程创建的时候，系统会为这个进程创建2个页大小的内核栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_task_stack_end_magic</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *stackend;<br><br>    stackend = end_of_stack(tsk);<br>    *stackend = STACK_END_MAGIC;    <span class="hljs-comment">/* for overflow detection */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-初始化中断">3.初始化中断</h2><blockquote><p><code>trap_init()</code>：/arch/x86/kernel/traps.c</p><p><code>idt_setup_traps()</code>：/arch/x86/kernel/idt.c</p><p>IDT：Interrupt Descriptor Table，中断描述符表</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/kernel/traps.c#L963">trap_init()</a> 通过 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/kernel/idt.c#L263">idt_setup_traps()</a> 设置了很多的中断门（Interrupt Gate)，用于处理各种中断，如系统调用的中断门<a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/arch/x86/kernel/idt.c#L72">set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)</a>，系统调用也是通过发送中断的方式进行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The default IDT entries which are set up in trap_init() before</span><br><span class="hljs-comment"> * cpu_init() is invoked. Interrupt stacks cannot be used at that point and</span><br><span class="hljs-comment"> * the traps which use them are reinitialized with IST after cpu_init() has</span><br><span class="hljs-comment"> * set up TSS.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> __initconst <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">idt_data</span> <span class="hljs-title">def_idts</span>[] =</span> &#123;<br>    <span class="hljs-comment">// 每一个 INTG 就是设置一个 idt_data 表项（第一个参数是中断向量）</span><br>    INTG(X86_TRAP_DE,        divide_error),<br>    INTG(X86_TRAP_NMI,        nmi),<br>    INTG(X86_TRAP_BR,        bounds),<br>    INTG(X86_TRAP_UD,        invalid_op),<br>    INTG(X86_TRAP_NM,        device_not_available),<br>    INTG(X86_TRAP_OLD_MF,        coprocessor_segment_overrun),<br>    INTG(X86_TRAP_TS,        invalid_TSS),<br>    INTG(X86_TRAP_NP,        segment_not_present),<br>    INTG(X86_TRAP_SS,        stack_segment),<br>    INTG(X86_TRAP_GP,        general_protection),<br>    INTG(X86_TRAP_SPURIOUS,        spurious_interrupt_bug),<br>    INTG(X86_TRAP_MF,        coprocessor_error),<br>    INTG(X86_TRAP_AC,        alignment_check),<br>    INTG(X86_TRAP_XF,        simd_coprocessor_error),<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_32</span><br>    TSKG(X86_TRAP_DF,        GDT_ENTRY_DOUBLEFAULT_TSS),<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    INTG(X86_TRAP_DF,        double_fault),<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    INTG(X86_TRAP_DB,        debug),<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_MCE</span><br>    INTG(X86_TRAP_MC,        &amp;machine_check),<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    SYSG(X86_TRAP_OF,        overflow),<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_IA32_EMULATION)</span><br>    SYSG(IA32_SYSCALL_VECTOR,    entry_INT80_compat),<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_X86_32)</span><br>    SYSG(IA32_SYSCALL_VECTOR,    entry_INT80_32),    <span class="hljs-comment">// x86_32 的系统调用 int 0x80</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-初始化内存模块">4.初始化内存模块</h2><blockquote><p><code>mm_init()</code>：/init/main.c</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L764">mm_init()</a> 就是用来初始化内存管理模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * page_ext requires contiguous pages,</span><br><span class="hljs-comment">    * bigger than MAX_ORDER unless SPARSEMEM.</span><br><span class="hljs-comment">    */</span><br>    page_ext_init_flatmem();<br>    init_debug_pagealloc();<br>    report_meminit();<br>    mem_init();<br>    kmem_cache_init();<br>    kmemleak_init();<br>    pgtable_init();<br>    debug_objects_mem_init();<br>    vmalloc_init();<br>    ioremap_huge_init();<br>    <span class="hljs-comment">/* Should be run before the first non-init thread is created */</span><br>    init_espfix_bsp();<br>    <span class="hljs-comment">/* Should be run after espfix64 is set up. */</span><br>    pti_init();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用的函数功能基本如名字所示，主要进行了以下初始化设置：</p><ul><li><code>page_ext_init_flatmem()</code> 和 cgroup 的初始化相关，该部分是 docker 技术的核心部分；</li><li><code>mem_init()</code> 初始化内存管理的伙伴系统；</li><li><code>kmem_cache_init()</code> 完成内核 slub 内存分配体系的初始化；</li><li><code>pgtable_init()</code> 完成页表初始化；</li><li><code>vmalloc_init()</code> 完成 vmalloc 的初始化；</li><li><code>ioremap_huge_init()</code>  ioremap 实现 I/O 内存资源由物理地址映射到虚拟地址空间，此处为其功能的初始化；</li><li><code>init_espfix_bsp()</code> 和 <code>pti_init()</code> 完成 PTI（page table isolation）的初始化。</li></ul><h2 id="5-初始化进程调度器">5.初始化进程调度器</h2><blockquote><p><code>sched_init()</code>：/kernel/sched/core.c</p><p><code>set_load_weight(struct task_struct *p, bool update_load)</code>：/kernel/sched/core.c</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/kernel/sched/core.c#L6574">sched_init()</a> 就是用于初始化调度模块。</p><ul><li><p>对相关数据结构分配内存；</p></li><li><p>初始化 <code>root_task_group</code>：</p><ul><li>内核维护了一个全局链表 <code>task_groups</code>，创建的 <code>task_group</code> 会添加到这个链表中；</li><li>内核定义了 <code>root_task_group</code> 全局结构，充当 <code>task_group</code> 的根节点，以它为根构建树状结构；</li><li>将 <code>kzalloc</code> 分配的空间用于其初始化，主要结构 <code>task_group</code> 包含以下几个重要组成部分：<code>se</code>, <code>rt_se</code>, <code>cfs_rq</code> 以及 <code>rt_rq</code>。</li><li>补充：</li></ul><blockquote><ul><li>task_struct：进程</li><li>task_group：进程组</li><li>cfs_rq  和 rt_rq 表示 <code>run queue</code>，就绪队列。</li></ul></blockquote></li><li><p>调用<code>for_each_possible_cpu()</code>初始化每个<code>possible</code>CPU 的<code>runqueue</code>队列；</p></li><li><p>调用<code>set_load_weight(&amp;init_task)</code>，将<code>init_task</code>进程转变为idle进程。</p><ul><li>实际上是调整进程的优先级权重；</li><li>只有到最后<code>init_task</code>进程开启了<code>kernel_init</code>和<code>kthreadd</code>进程之后，才转变为真正意义上的<code>idle</code>进程。</li></ul></li></ul><h2 id="6-初始化基于内存的文件系统">6.初始化基于内存的文件系统</h2><blockquote><p><code>vfs_caches_init()</code> ：/fs/dcache.c</p><p><code>mnt_init()</code>：/fs/namespace.c</p><p><code>init_rootfs()</code>：/init/do_mounts.c</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/dcache.c#L3206">vfs_caches_init()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/namespace.c#L3738">mnt_init()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/do_mounts.c#L704">init_rootfs()</a> 用于初始化基于内存的文件系统 rootfs。</p><p>为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。</p><h2 id="7-初始化剩余内容">7.初始化剩余内容</h2><blockquote><p><code>rest_init()</code>：/init/main.c</p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L621">rest_init()</a> 进行了两件重要的事：</p><ul><li>创建 1 号进程 kernel_init：内核态是kernel_init，到用户态是 init 进程，是用户态所有进程的祖先；</li><li>创建 2 号进程 kthreadd：负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</li></ul><h3 id="7-1-权限分层与保护模式">7.1 权限分层与保护模式</h3><p>1 号进程对于操作系统来讲，有“划时代”的意义，因为它将运行一个用户进程。有了用户进程，系统运行模式就要发生一定的变化。</p><ul><li>没有用户进程：不会有进程抢占资源，也不会有进程恶意破坏、恶意使用硬件资源。</li><li>有用户进程：需要做一定的区分。</li></ul><p>x86 提供了分层的权限机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为内核态（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为用户态（User Mode）。</p><p><img src="https://hutu.aimtao.net/mark/2022-01-23-sA3KWR.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>在 <a href="https://www.aimtao.net/boot/#3-%E5%88%87%E6%8D%A2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">内核启动</a> 的过程中，从实模式切换到保护模式，除了可访问空间大一些，还有另一个重要功能，就是“保护”。用户态的代码无法执行更高权限的指令，想要访问核心资源，需要通过 <strong>系统调用</strong> 来访问。</p><p><strong>例</strong>：当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包的过程：</p><ol><li><p>把程序运行到一半的情况保存下来，主要是 CPU 寄存器的数据。</p><ul><li><p>内存的数据：内存是用来保存程序运行时候的中间结果的， 现在要暂时停下来，这些中间结果不能丢，因为再次运行的时候，还要基于这些中间结果接着来。</p></li><li><p>寄存器的数据：当前运行到代码的哪一行了，当前的栈在哪里，这些都是在寄存器里面的。</p></li><li><p>暂停的那一刻，要把当时 CPU 的寄存器的值全部暂存到一个地方，这个地方可以放在进程管理系统很容易获取的地方。（后面讨论进程管理数据结构的时候，再详细说。）</p><p><img src="https://hutu.aimtao.net/mark/2022-01-23-EzisMM.webp-s" srcset="/img/loading.gif" lazyload alt=""></p></li></ul></li><li><p>内核将从系统调用传过来的包，在网卡上排队，轮到的时候就发送。</p></li><li><p>发送完后，系统调用就结束了，返回用户态，让暂停运行的程序接着运行。</p></li></ol><p>系统调用过程：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，接着运行。</p><p><img src="https://hutu.aimtao.net/mark/2022-01-23-yp8k9D.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="7-2-创建-1-号进程">7.2 创建 1 号进程</h3><blockquote><p><code>kernel_init()</code>：/init/main.c</p><p><code>kernel_init_freeable()</code>：/init/main.c</p><p><code>run_init_process()</code>：/init/main.c</p></blockquote><p>kernel_thread 的参数是一个函数 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L1353">kernel_init</a>，也就是这个进程会运行这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel_thread(kernel_init, <span class="hljs-literal">NULL</span>, CLONE_FS);<br></code></pre></td></tr></table></figure><p>在 kernel_init 里面，会调用 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L1309">kernel_init_freeable()</a>，里面有这样的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!ramdisk_execute_command)<br>    ramdisk_execute_command = <span class="hljs-string">&quot;/init&quot;</span>;   <span class="hljs-comment">// ramdisk 的 init</span><br></code></pre></td></tr></table></figure><p>先忽略 ramdisk，ramdisk 是基于内存的文件系统，后面会说；<a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L1353">kernel_init</a> 里面有类似的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ramdisk_execute_command) &#123;<br>    ret = run_init_process(ramdisk_execute_command);    <span class="hljs-comment">// 先尝试运行  ramdisk 的“/init”</span><br>    <span class="hljs-keyword">if</span> (!ret)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>......<br>&#125;<br>......<br> <span class="hljs-comment">// 再尝试运行普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”</span><br><span class="hljs-keyword">if</span> (!try_to_run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>打开 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L1278">run_init_process</a> 函数，会发现它调用的是 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/exec.c#L1938">do_execve</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_init_process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *init_filename)</span><br>&#123;<br>    argv_init[<span class="hljs-number">0</span>] = init_filename;<br>    <span class="hljs-keyword">return</span> do_execve(getname_kernel(init_filename),     <span class="hljs-comment">// 系统调用</span><br>        (<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *<span class="hljs-type">const</span> __user *)argv_init,<br>        (<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *<span class="hljs-type">const</span> __user *)envp_init);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>execve 是一个系统调用，它的作用是运行一个执行文件。加一个 do_ 的往往是内核系统调用的实现。</li><li>系统调用会先尝试运行 ramdisk 的“/init”，再尝试运行普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。</li><li>不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。</li></ul><p>结论：<strong>1 号进程运行的是一个文件。</strong></p><h3 id="7-3-从内核态到用户态">7.3 从内核态到用户态</h3><blockquote><p>do_execve、do_execveat_common、exec_binprm、search_binary_handler：/fs/exec.c</p><p>elf_format、load_elf_binary、start_thread：/fs/binfmt_elf.c</p></blockquote><p>在创建 1 号进程，之前程序一直运行在内核态，如何从内核态到用户态呢？</p><p>答案：<strong>系统利用执行 init 文件的机会，从内核态回到用户态。</strong></p><ul><li>系统调用过程：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态。</li><li>运行 init 文件，是调用 do_execve，正是系统调用过程的后半部分，从内核态执行系统调用开始。</li></ul><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/exec.c#L1938">do_execve</a> -&gt; do_execveat_common -&gt; exec_binprm -&gt; <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/exec.c#L1695">search_binary_handler</a>，这里面会调用这段内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">search_binary_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br>    ......<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">fmt</span>;</span>   <span class="hljs-comment">// 二进制文件的格式</span><br>    ......<br>    retval = fmt-&gt;load_binary(bprm);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行一个程序，需要加载这个二进制文件；</li><li>二进制文件是有一定格式的；</li><li>Linux 下常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。</li></ul><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/binfmt_elf.c#L93">ELF</a> 格式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> <span class="hljs-title">elf_format</span> =</span> &#123;<br>    .module    = THIS_MODULE,<br>    .load_binary    = load_elf_binary,<br>    .load_shlib    = load_elf_library,<br>    .core_dump    = elf_core_dump,<br>    .min_coredump    = ELF_EXEC_PAGESIZE,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>如代码所写的，会先调用 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/binfmt_elf.c#L685">load_elf_binary</a>，在  load_elf_binary 函数的最后调用 <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/fs/binfmt_elf.c#L1154">start_thread</a>。</p><p>来看看这个 start_thread：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">start_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> new_ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> new_sp)</span><br>&#123;<br>    set_user_gs(regs, <span class="hljs-number">0</span>);<br>    regs-&gt;fs    = <span class="hljs-number">0</span>;<br>    regs-&gt;ds    = __USER_DS;                  <span class="hljs-comment">// 接下来就是保存用户态时寄存器数据的步骤</span><br>    regs-&gt;es    = __USER_DS;<br>    regs-&gt;ss    = __USER_DS;<br>    regs-&gt;cs    = __USER_CS;<br>    regs-&gt;ip    = new_ip;<br>    regs-&gt;sp    = new_sp;<br>    regs-&gt;flags    = X86_EFLAGS_IF;<br>    force_iret();    <span class="hljs-comment">// 返回用户态</span><br>&#125;<br>EXPORT_SYMBOL_GPL(start_thread);<br></code></pre></td></tr></table></figure><ul><li>struct pt_regs，看名字里的 register，就是寄存器；</li><li>pt_regs 这个结构是在系统调用一开始，内核中保存用户态运行上下文的，里面将用户态的代码段 CS 设置为 <code>__USER_CS</code>，将用户态的数据段 DS 设置为 <code>__USER_DS</code>，以及指令指针寄存器 IP、栈指针寄存器 SP；（<strong>这里就是系统调用过程中，保存寄存器的步骤</strong>）；</li><li>iret 用于从系统调用中返回，并将寄存器恢复至用户态。</li></ul><p>至此，下一条指令，就从用户态开始运行了。</p><h3 id="7-4-ramdisk-的作用">7.4 ramdisk 的作用</h3><p><strong>（1）什么是 ramdisk？</strong></p><ul><li>先到用户态的是 ramdisk 的 init，它会再启动真正根文件系统上的 init，真正根文件系统上的 init 成为所有用户态进程的祖先；</li><li>内核启动的时候，配置过这个参数 <code>initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img</code>，这就是 ramdisk，一个基于内存的文件系统。</li></ul><p><strong>（2）为什么需要基于内存的文件系统 ramdisk？</strong></p><ul><li>init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘；</li><li>Linux 访问存储设备，要有驱动才能访问，程序现在在内核态，所以驱动只能放在内核里；</li><li>但所有市面上的存储系统的驱动不能默认都放进内核。</li><li>只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这就是 ramdisk。</li></ul><p><strong>（3）ramdisk 初始化文件系统的流程</strong></p><ul><li>在内核态时，ramdisk 是根文件系统。</li><li>运行 ramdisk 上的 /init 之后，就已经在用户态了。</li><li>ramdisk 上的 /init 会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。</li><li>有了真正的根文件系统，ramdisk 上的 /init 会启动文件系统上的 init。</li></ul><p>接下来就是各种系统的初始化；启动系统的服务，启动控制台，用户就可以登录进来了。</p><h3 id="7-5-创建-2-号进程">7.5 创建 2 号进程</h3><p><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c#L644">rest_init</a> 第二件事就是创建第三个进程，2 号进程 kthreadd。</p><p>kthreadd 负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">kernel_thread(kthreadd, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">CLONE_FS</span> | <span class="hljs-built_in">CLONE_FILES</span>)<br></code></pre></td></tr></table></figure><p>这里函数名 thread 可以翻译成“线程”，为什么这里创建的是进程，函数名却是线程呢？</p><ul><li>从用户态来看，创建进程就是申请一份资源，多个线程，共用一份资源，并行执行不同的部分，这叫多线程（Multithreading）。如果只有一个线程，那它就是这个进程的主线程。</li><li>但从内核态来看，无论是进程，还是线程，都统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。</li></ul><h2 id="参考">参考</h2><ul><li><a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c">https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c</a></li><li><a href="https://www.cnblogs.com/LoyenWang/p/12459000.html">https://www.cnblogs.com/LoyenWang/p/12459000.html</a></li><li><a href="https://ty-chen.github.io/linux-kernel-zero-process/">https://ty-chen.github.io/linux-kernel-zero-process/</a></li><li><a href="https://www.cnblogs.com/crybaby/p/14316147.html">https://www.cnblogs.com/crybaby/p/14316147.html</a></li><li>趣谈 Linux 操作系统</li><li>Linux 内核设计与实现</li></ul><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在 Linux 内核启动后，完成了实模式到保护模式的切换，并做好了各种准备工作。接下来进入内核初始化，我们主要关注初始化的流程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Kernel" scheme="https://www.aimtao.net/categories/Kernel/"/>
    
    
    <category term="Linux" scheme="https://www.aimtao.net/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://www.aimtao.net/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记｜TypeScript</title>
    <link href="https://www.aimtao.net/typescript/"/>
    <id>https://www.aimtao.net/typescript/</id>
    <published>2021-12-26T07:34:00.000Z</published>
    <updated>2021-12-26T07:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript 是一种基于 JavaScript 的强类型编程语言。——来自官网描述。</p></blockquote><h2 id="1-是什么-为什么">1.是什么 &amp; 为什么</h2><p><strong>TypeScript 是什么</strong>：微软在 JavaScript 的基础上，添加了一些类型的定义，推出了 TypeScript。</p><p><strong>为什么要使用 TypeScript，而不使用 JavaScript</strong>：</p><ul><li>JavaScript 的缺点<ul><li>JavaScript 1995 年被开发，至今版本很多（ES5、ES6）。</li><li>JavaScript 是弱类型语言。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举几个例子</span><br><span class="hljs-comment">// 很灵活，可以随便改变类型，并添加字段。</span><br>a = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;js&#x27;</span>,<br>&#125;<br><br>a.<span class="hljs-property">number</span> = <span class="hljs-number">2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// &#123;name: &#x27;js&#x27;, number: 2&#125;</span><br><br><span class="hljs-comment">// 坑</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> == <span class="hljs-string">&#x27;2&#x27;</span>)   <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> + <span class="hljs-number">20</span>)   <span class="hljs-comment">// 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;20&#x27;</span>) <span class="hljs-comment">// &quot;1020&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] + <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;1,2,34&quot;</span><br></code></pre></td></tr></table></figure><ul><li>TypeScript 的优点<ul><li>有类型定义。</li><li>兼容 JavaScript，是 JavaScript 的超集。</li><li>兼容的方式：将 TypeScript 编译成 JavaScript 运行。</li></ul></li></ul><p><strong>补充：静态语言、动态语言、强类型语言、弱类型语言</strong></p><p>静态语言与动态语言区别在于：何时得到数据的类型。（静态绑定：编译时绑定；动态绑定：运行时绑定）</p><ul><li>静态语言：编译时检查类型。定义是需指明类型。</li><li>动态语言：运行时检查类型。定义时不需要指明类型。</li></ul><p>强弱类型区别在于：运算过程中，当值的类型不符合运算规则时，是否能进行隐式转换。（隐式转换就是系统自动转换。）</p><ul><li>强类型：报错。</li><li>弱类型：会猜测后，进行隐式转换。</li></ul><h2 id="2-TypeScript-的基础语法">2.TypeScript 的基础语法</h2><blockquote><p>大部分与 JavaScript 类似。</p></blockquote><h3 id="2-1-代码规范">2.1 代码规范</h3><blockquote><p>整个项目规范要统一。</p></blockquote><p>行末分号：加不加分号均可。</p><p>字符串的引号：双引号、单引号均可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Tom&#x27;</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Tom&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br></code></pre></td></tr></table></figure><h3 id="2-2-基础数据类型">2.2 基础数据类型</h3><p><strong>（1）变量定义</strong></p><p>只使用 let、const，不要使用 var。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> anExampleVariable = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">const</span> anExampleNum = <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><strong>（3）声明类型</strong></p><p>变量名后面接类型。但是最好不要写，影响代码简洁，让编译器来推断。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">anExampleVariable</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">anExampleNum</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">anExampleBool</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>（2）数据类型</strong></p><ul><li><p>string</p></li><li><p>number</p></li><li><p>boolean</p></li><li><p>literal type</p><p>类似于枚举类型，变量只能是这些类型。</p><p>这样在编写代码的时候，就会有提示和内容限制。JavaScript 就需要花费精力去判断 变量 有哪些可能出现的值。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 限制变量赋值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">httpStatus</span>: <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">500</span> | <span class="hljs-string">&#x27;200&#x27;</span> | <span class="hljs-string">&#x27;404&#x27;</span> | <span class="hljs-string">&#x27;500&#x27;</span> = <span class="hljs-string">&#x27;200&#x27;</span><br><br><span class="hljs-comment">// 限制函数参数，其他非法参数传入会报错。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">answer</span>: <span class="hljs-string">&#x27;yes&#x27;</span> | <span class="hljs-string">&#x27;no&#x27;</span> | <span class="hljs-string">&#x27;maybe&#x27;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(answer)<br>&#125;<br><br><span class="hljs-comment">// 注意</span><br><span class="hljs-keyword">let</span> s1 = httpStatus  <span class="hljs-comment">// 此时 s1 的类型是 &#x27;200&#x27;。因为编译器判断此时 httpStatus 只可能是 &#x27;200&#x27;。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s2</span>: <span class="hljs-built_in">string</span> = httpStatus  <span class="hljs-comment">// 此时 s2 的类型是 string。</span><br><br>httpStatus = s1  <span class="hljs-comment">// 正确</span><br>httStatus = s2  <span class="hljs-comment">// 报错：Type &#x27;string&#x27; is not assignable to type &#x27;200 | 404 | 500 | &quot;200&quot; | &quot;404&quot; | &quot;500&quot;&#x27;.  因为此时 s2 是 string 类型，无法赋值给 literal type。</span><br></code></pre></td></tr></table></figure><ul><li>union of types<br>可能是多种类型。例如：status 可能是 string，也可能是 number。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">httpStatus</span>: <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">500</span> | <span class="hljs-string">&#x27;200&#x27;</span> | <span class="hljs-string">&#x27;404&#x27;</span> | <span class="hljs-string">&#x27;500&#x27;</span></span>) &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = httpStatus<br>   <span class="hljs-comment">// let status: string = httpStatus   // 错误，因为 httpStatus 可能是 string，也可能是 number。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>any<br>动态类型，意味着放弃 TypeScript 的所有类型检查，和 JavaScript 一样。<br>放弃类型检查，编写时不报错，但是运行时会报错。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;abc&#x27;</span><br>a = <span class="hljs-number">123</span>  <span class="hljs-comment">// 放弃类型检查。</span><br>a.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;123&#x27;</span>  <span class="hljs-comment">// 运行时会报错。</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br></code></pre></td></tr></table></figure><ul><li>undefined<br>undefined 类型变量不能被赋值为任何类型。可以与 literal type 结合使用，在对象类型、函数、接口中都会用到。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br>s = <span class="hljs-string">&quot;111&quot;</span>  <span class="hljs-comment">// 会报错：Type &#x27;&quot;111&quot;&#x27; is not assignable to type &#x27;undefined&#x27;.</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)  <span class="hljs-comment">// 但也会打印出 &quot;111&quot;</span><br><br><span class="hljs-comment">// 正确使用方式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">answer</span>: <span class="hljs-string">&#x27;yes&#x27;</span> | <span class="hljs-string">&#x27;no&#x27;</span> | <span class="hljs-string">&#x27;maybe&#x27;</span> | <span class="hljs-literal">undefined</span></span>) &#123;   <span class="hljs-comment">// answer 可能是 undefined。</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(answer)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-逻辑控制">2.3 逻辑控制</h3><p><strong>（1）if</strong></p><p>一律使用 <code>===</code> 或 <code>!==</code> 。因为 <code>==</code> 不同类型的变量也可以比较。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 传入参数限定后，不用担心传入其他字符。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-string">&#x27;200&#x27;</span> | <span class="hljs-string">&#x27;404&#x27;</span> | <span class="hljs-string">&#x27;500&#x27;</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;200&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;404&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;not found&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;500&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;internal server error&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-string">&#x27;200&#x27;</span>)<br><br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-string">&#x27;201&#x27;</span>)   <span class="hljs-comment">// 运行会报错，Argument of type &#x27;&quot;201&quot;&#x27; is not assignable to parameter of type &#x27;&quot;200&quot; | &quot;404&quot; | &quot;500&quot;&#x27;.</span><br></code></pre></td></tr></table></figure><p>例：如果需要将传入的 number，全部转化为 string。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-string">&#x27;200&#x27;</span> | <span class="hljs-string">&#x27;404&#x27;</span> | <span class="hljs-string">&#x27;500&#x27;</span> | <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">500</span></span>) &#123;<br>    <br>    <span class="hljs-comment">// key code: string to number.</span><br>    <span class="hljs-keyword">let</span> statusStr = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        statusStr = s.<span class="hljs-title function_">toString</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        statusStr = s<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (statusStr === <span class="hljs-string">&#x27;200&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusStr === <span class="hljs-string">&#x27;404&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;not found&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusStr === <span class="hljs-string">&#x27;500&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;internal server error&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-string">&#x27;200&#x27;</span>)<br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p>其中，转换为 strng 的代码也可以写成三元表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 由于 statusStr 定义之后，就不需要修改了，所以使用 const 修饰。</span><br><span class="hljs-keyword">const</span> statusStr = <span class="hljs-keyword">typeof</span> s === <span class="hljs-string">&#x27;string&#x27;</span> ? s.<span class="hljs-title function_">toString</span>() : s<br></code></pre></td></tr></table></figure><p><strong>（2）switch</strong></p><p>case 动作后需要加 break。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-string">&#x27;200&#x27;</span> | <span class="hljs-string">&#x27;404&#x27;</span> | <span class="hljs-string">&#x27;500&#x27;</span> | <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">500</span></span>) &#123;<br>    <br>    <span class="hljs-comment">// key code: string to number.</span><br>    <span class="hljs-keyword">let</span> statusStr = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        statusStr = s.<span class="hljs-title function_">toString</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        statusStr = s<br>    &#125;<br>    <br>    <span class="hljs-keyword">switch</span>(statusStr) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;200&#x27;</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;404&#x27;</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;not found&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;500&#x27;</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;internal server error&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;unknown error&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-string">&#x27;200&#x27;</span>)<br><span class="hljs-title function_">processHttpStatus</span>(<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><strong>（3）for</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    sum += i<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br></code></pre></td></tr></table></figure><p><strong>（4）while</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) &#123;<br>    sum += i<br>    i++<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br></code></pre></td></tr></table></figure><p><strong>（5）try/catch</strong></p><p>例：如果 i 是 17 的倍数，就抛出错误。使用 try/catch 就能保证，即使出错，程序也不会立即退出。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        sum += i<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">17</span> === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">`bad number <span class="hljs-subst">$&#123;i&#125;</span>`</span>   <span class="hljs-comment">// 反引号中，使用 $&#123;&#125; 来标记变量。</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br></code></pre></td></tr></table></figure><h3 id="2-4-枚举">2.4 枚举</h3><blockquote><p>枚举类型是 typesript 特有的数据类型，javascript 只能通过类来模拟枚举类型。</p><p>实际使用中，可以使用 literal type 或 enum。</p></blockquote><ul><li>枚举类型定义时，每个类型用 逗号 分隔。</li><li>不给每个类型设定值，默认是 0、1、2…</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HTTPStatus</span> &#123;<br>    <span class="hljs-variable constant_">OK</span>,<br>    <span class="hljs-variable constant_">NOT_FOUNT</span>,<br>    <span class="hljs-variable constant_">INTERNAL_SERVER_ERROR</span>,<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processHTTPStatus</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-title class_">HTTPStatus</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)  <span class="hljs-comment">// 0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">HTTPStatus</span>[s]) <span class="hljs-comment">// &#x27;OK&#x27;</span><br>&#125;<br><br><span class="hljs-title function_">processHTTPStatus</span>(<span class="hljs-title class_">HTTPStatus</span>.<span class="hljs-property">OK</span>)<br></code></pre></td></tr></table></figure><ul><li>可以给每个类型设定值。<br>值既可以是数字，也可以是字符串。但是字符串的时候，无法使用 HTTPStatus[s]，因为字符串不能作为索引。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HTTPStatus</span> &#123;<br>    <span class="hljs-variable constant_">OK</span> = <span class="hljs-number">200</span>,<br>    <span class="hljs-variable constant_">NOT_FOUNT</span> = <span class="hljs-number">404</span>,<br>    <span class="hljs-variable constant_">INTERNAL_SERVER_ERROR</span> = <span class="hljs-number">500</span>,<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processHTTPStatus</span>(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-title class_">HTTPStatus</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)  <span class="hljs-comment">// 200</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">HTTPStatus</span>[s]) <span class="hljs-comment">// &#x27;OK&#x27;</span><br>&#125;<br><br><span class="hljs-title function_">processHTTPStatus</span>(<span class="hljs-title class_">HTTPStatus</span>.<span class="hljs-property">OK</span>)<br></code></pre></td></tr></table></figure><h3 id="2-5-数组">2.5 数组</h3><p><strong>（1）定义</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-comment">// 此时编译器判断 arr 的类型是 number[]</span><br></code></pre></td></tr></table></figure><p><strong>（2）类型限定</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">true</span>]  <span class="hljs-comment">// 任意类型</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, ,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>（3）数组长度</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>)  <span class="hljs-comment">// 数组长度</span><br></code></pre></td></tr></table></figure><p><strong>（4）取值</strong></p><p>注：数组下标越界，不会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 1, 2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">4</span>])  <span class="hljs-comment">// 数组下标越界了，并不会报错，会打印出 undefined</span><br></code></pre></td></tr></table></figure><p><strong>（5）空数组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = []   <span class="hljs-comment">// 空数组定义，一定要声明类型，否则默认类型为 any[]。</span><br></code></pre></td></tr></table></figure><p>通过长度判断是否为空数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = []<br><br><span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr is not empty&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr is empty&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）尾部插入 push</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p><strong>（7）尾部删除 pop</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">pop</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>（8）首部插入 unshift</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [4, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>（9）首部删除 shift</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.<span class="hljs-title function_">shift</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>（10）数组的 const</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 正确，可以更改当前数组内容</span><br><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment">// 错误，不能赋值（类似于 cpp 中指针，不可以指到别的数组）</span><br></code></pre></td></tr></table></figure><p><strong>（11）截取</strong></p><p>slice 左闭右开，返回截取出来的数组，不会修改原数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">//  [2, 3, 4] ，范围是 [2, 5)</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>))  <span class="hljs-comment">// 2 到 末尾，[2, 3, 4, 5, 6]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>))  <span class="hljs-comment">// 数组下标越界，不会报错，还是 2 到 末尾</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">// 不会修改原数组，[0, 1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p><strong>（12）更改部分元素</strong></p><ul><li>2 个参数是删除元素</li></ul><p>​splice 删除部分元素，并返回被删除的元素。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-keyword">let</span> deleted = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)   <span class="hljs-comment">// 从下标为 3 的元素开始，删除 2 个元素</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deleted)  <span class="hljs-comment">// [3, 4]  // 删除的元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)   <span class="hljs-comment">// [0, 1, 2, 5, 6] </span><br></code></pre></td></tr></table></figure><ul><li>3 个以上元素是删除，并添加元素。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-keyword">let</span> deleted = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment">// 从下标为 3 的元素开始，删除 2 个元素，并在这个位置添加三个 0</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deleted)  <span class="hljs-comment">// [3, 4]  // 删除的元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)   <span class="hljs-comment">// [0, 1, 2, 0, 0, 0, 5, 6] </span><br></code></pre></td></tr></table></figure><p><strong>（13）查找元素</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">4</span>))    <span class="hljs-comment">// 2  // 查找元素 4，返回 下标值。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 6  // 从下标为 3 开始查找。 </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">4</span>))     <span class="hljs-comment">// 6  // 从后往前找</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">// 2  // 从下标为 5 开始，从后往前找</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>))     <span class="hljs-comment">// -1  // 找不到返回 -1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">3</span>)) <span class="hljs-comment">// -1  // 找不到返回 -1</span><br></code></pre></td></tr></table></figure><p><strong>（14）排序</strong></p><ul><li>直接调用 sort 是按照字典序排序，主要是用来排字符串的。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)   <span class="hljs-comment">//  [1, 14, 2, 8]   // 字典序，排序</span><br></code></pre></td></tr></table></figure><ul><li>排序 number 数组，需要传入回调函数。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareNumber</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br><br><span class="hljs-keyword">const</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><br>a.<span class="hljs-title function_">sort</span>(compareNumber)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><br></code></pre></td></tr></table></figure><p><strong>（15）元组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> [a1, a2, a3] = arr<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1, a2, a3)<br></code></pre></td></tr></table></figure><p><strong>（16）分隔 split</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;a,b,c,d,1,2,3,&#x27;</span><br><br><span class="hljs-keyword">let</span> arr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&quot;] </span><br></code></pre></td></tr></table></figure><p><strong>（17）连接 join</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>())  <span class="hljs-comment">// &quot;1,2,3&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>))  <span class="hljs-comment">// &quot;1-2-3&quot;  // join 参数表示 分隔符</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// &quot;123&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-对象">2.6 对象</h3><blockquote><p>不需要有类，可以直接手写对象 object。</p></blockquote><p><strong>（1）定义</strong></p><p>对于没有初值的字段，可以赋值为 undefined；但该字段类型并不真的是 undefined，所以需要指明类型为 union of types。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-title function_">as</span> (<span class="hljs-string">&#x27;male&#x27;</span> | <span class="hljs-string">&#x27;female&#x27;</span>),<br>    <span class="hljs-attr">salary</span>: <span class="hljs-number">8000</span>,<br>    <span class="hljs-attr">bonus</span>: <span class="hljs-literal">undefined</span> <span class="hljs-title function_">as</span> (<span class="hljs-literal">undefined</span> | <span class="hljs-built_in">number</span>)   <span class="hljs-comment">// bonus 还未定义，需要指定类型为 (undefined | number)。</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1)   <span class="hljs-comment">// &#123; name: &#123; first: &#x27;san&#x27;, last: &#x27;zhang&#x27; &#125;, gender: &#x27;male&#x27;, salary: 8000, bonus: undefined &#125;</span><br></code></pre></td></tr></table></figure><p><strong>（2）嵌套</strong></p><p>变量的值可以是 object、数组等各种类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;san&#x27;</span>,<br>        <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1)  <span class="hljs-comment">// &#123; name: &#123; first: &#x27;san&#x27;, last: &#x27;zhang&#x27; &#125;, gender: &#x27;male&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p><strong>（3）取值</strong></p><p>可根据关系，直接 “点” 出来，或使用键值对的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1.<span class="hljs-property">name</span>.<span class="hljs-property">frist</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1[<span class="hljs-string">&#x27;name&#x27;</span>])<br></code></pre></td></tr></table></figure><p><strong>（4）JSON</strong></p><p>JSON = JavaScript Object Notation。</p><ul><li>在 JSON 中，键必须是字符串，由双引号包围。<code>&#123; &quot;name&quot;:&quot;Bill Gates&quot; &#125;</code></li><li>在 JavaScript 中，键可以是字符串、数字或标识符名称。<code>&#123; name:'Bill Gates' &#125;</code></li></ul><p><strong>（5）JSON 与 string 转化</strong></p><p><code>JSON.stringify(object)</code> 和 <code>JSON.parse(string)</code>。</p><p>注意： 下面的例子中，emp2 只能是 any 类型，因为编译器无法判断 <code>JSON.parse(string)</code> 会返回什么类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;san&#x27;</span>,<br>        <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1)<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(emp1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br><br><span class="hljs-keyword">const</span> emp2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(s)    <span class="hljs-comment">// emp2 是 any 类型。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp2)<br></code></pre></td></tr></table></figure><p><strong>（6）对象的比较</strong></p><p>不能直接比较，只能分别比较不同的字段。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;san&#x27;</span>,<br>        <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">const</span> emp2 = &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;san&#x27;</span>,<br>        <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1 === emp2)  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="2-7-函数">2.7 函数</h3><p><strong>（1）函数定义</strong></p><p>函数返回值可以声明，也可以不声明；但如果声明了返回值类型，不返回将报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;  <span class="hljs-comment">// 声明返回值</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) &#123;  <span class="hljs-comment">// 未声明返回值</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p><strong>（2）可选参数</strong></p><p>可选参数后加 <code>?</code> ，下面代码中，如果 c 未传入，类型就是 undefined，所以需要判断一下。</p><p>判断可选参数的简便写法：<code>return c ? a + b + c : a + b</code>，<code>return a + b + (c || 0)</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">c</span>?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;  <span class="hljs-comment">//  c 是可选参数</span><br>    <span class="hljs-keyword">if</span> (c) &#123;<br>        <span class="hljs-keyword">return</span> a + b + c    <span class="hljs-comment">// 编译器非常聪明，判断之后，此处 c 的类型是 number。</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><p><strong>（3）默认参数</strong></p><p>参数可以设置默认值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">c</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">d</span>: <span class="hljs-built_in">number</span>=<span class="hljs-number">0</span></span>): <span class="hljs-built_in">number</span> &#123;   <span class="hljs-comment">// d 是默认参数</span><br>    <span class="hljs-keyword">if</span> (c) &#123;<br>        <span class="hljs-keyword">return</span> a + b + c + d<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b + d<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p><strong>（4）可变参数列表</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">c</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">d</span>: <span class="hljs-built_in">number</span>=<span class="hljs-number">0</span>, ...<span class="hljs-attr">e</span>: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;   <span class="hljs-comment">// e 是可变参数</span><br>    <span class="hljs-keyword">let</span> sum = a + b + (c || <span class="hljs-number">0</span>) + d<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += e[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p><strong>（5）数组参开当可选参数列表</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, ...<span class="hljs-attr">e</span>:<span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = a + b<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += e[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-keyword">const</span> numberList = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...numberList))  <span class="hljs-comment">// 只需要在 数组变量 前加 ...</span><br></code></pre></td></tr></table></figure><p><strong>（6）函数重载（不推荐使用）</strong></p><blockquote><p>推荐使用可变参数列表、默认参数、可选参数、union type。</p></blockquote><p>typescript 的函数重载很：有多个声明，但只有一个函数实现，这个函数要兼容所有函数声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 例子一</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>):<span class="hljs-built_in">number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, ...<span class="hljs-attr">e</span>:<span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>, ...<span class="hljs-attr">e</span>:<span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = a + b<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += e[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-keyword">const</span> numberList = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...numberList))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-comment">// 例子二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">y</span>:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span></span>):<span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> (+x) + (+y);  <span class="hljs-comment">// string 转 number，也可以写成：Number(x) + Number(y)</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + (y <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>);   <span class="hljs-comment">// 这里要说明一下 y 是 number，因为前面只判断了 x 的类型。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>))<br></code></pre></td></tr></table></figure><p><strong>（7）对象类型作为参数</strong></p><p>不使用对象类型参数时，调用函数时，参数太多，写代码和看代码的人都不容易明确每个参数的含义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 不使用对象类型参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendRequest</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span> | <span class="hljs-string">&#x27;POST&#x27;</span> | <span class="hljs-string">&#x27;PUT&#x27;</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">header</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">requireAuth</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">retey</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">retryTimeout</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;success&quot;</span>)<br>    &#125;<br><br><span class="hljs-title function_">sendRequest</span>(<span class="hljs-string">&#x27;https://www.bing.com&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>, &#123;<span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,&#125;, <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;john&quot;&#125;&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">300000</span>)   <span class="hljs-comment">// 不便写和读</span><br></code></pre></td></tr></table></figure><p>使用对象类型参数时，增加代码可读性。params：Parameters，参数。</p><p>TypeScript/JavaScript 创建对象很方便，所以要有使用对象类型的意识。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用对象类型参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendRequest</span>(<span class="hljs-params"><span class="hljs-attr">params</span>: &#123;     // params</span><br><span class="hljs-params">        url: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">        method: <span class="hljs-string">&#x27;GET&#x27;</span> | <span class="hljs-string">&#x27;POST&#x27;</span> | <span class="hljs-string">&#x27;PUT&#x27;</span>,</span><br><span class="hljs-params">        header: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">        data: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">        requireAuth: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">        retey: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">        retryTimeout: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">    &#125;</span>) &#123;<br>        <span class="hljs-comment">// ....</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;success&quot;</span>)<br>    &#125;<br><br><span class="hljs-title function_">sendRequest</span>(&#123;     <span class="hljs-comment">// 参数明确，有良好可读性。</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://www.bing.com&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-attr">header</span>: &#123;<br>        <span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;john&quot;&#125;&#x27;</span>,<br>    <span class="hljs-attr">requireAuth</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">retey</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">retryTimeout</span>: <span class="hljs-number">300000</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="2-8-对象的方法">2.8 对象的方法</h3><p>对象中可以定义方法，this 关键字指代当前大括号的这个对象。</p><p>注意：this 有坑，当嵌套的对象过多时，this 指代谁就不一定了。解决办法：函数式编程可以解决。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-title function_">as</span> (<span class="hljs-string">&#x27;male&#x27;</span> | <span class="hljs-string">&#x27;female&#x27;</span>),<br>    <span class="hljs-attr">salary</span>: <span class="hljs-number">8000</span>,<br>    <span class="hljs-attr">bonus</span>: <span class="hljs-literal">undefined</span> <span class="hljs-title function_">as</span> (<span class="hljs-literal">undefined</span> | <span class="hljs-built_in">number</span>),<br>    <span class="hljs-attr">performance</span>: <span class="hljs-number">3.5</span>,<br>    <span class="hljs-title function_">updateBonus</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">bonus</span>) &#123;   <span class="hljs-comment">// this 指代 emp1</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">bonus</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">salary</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">performance</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1.<span class="hljs-property">bonus</span>)<br>emp1.<span class="hljs-title function_">updateBonus</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1.<span class="hljs-property">bonus</span>)<br></code></pre></td></tr></table></figure><h2 id="3-函数式编程">3.函数式编程</h2><blockquote><p>初学者很难理解函数式编程的优势，在学习过程中，可以先理解逻辑，在实际编码中了解其优势。</p></blockquote><pre><code class=" mermaid">graph LRA(函数式编程)--&gt; B1(函数是一等公民)B1 --&gt; C1(变量类型可以是函数)B1 --&gt; C2(值可以是函数)B1 --&gt; C3(对象字段的值可以是函数)B1 --&gt; C4(函数参数可以是函数)B1 --&gt; C5(函数返回值可以是函数)A --&gt; B2(高阶函数)A --&gt; B3(闭包)A --&gt; B4(部分应用函数)A --&gt; B5(惰性计算)A --&gt; B6(引用透明性)A --&gt; B7(无副作用)</code></pre><h3 id="3-1-函数是一等公民">3.1 函数是一等公民</h3><p><strong>（1）变量可以是函数</strong></p><ul><li><p>定义变量时，变量类型为：<code>let compareNumber: (a: number, b: number) =&gt; number</code>，第一出现时，编译器根据函数，确定了这个函数的参数和返回值类型。</p></li><li><p>再给 compareNumber 赋值的时候，只能赋值 <code>(a: number, b: number) =&gt; number</code> 类型函数。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 排序数组 a</span><br><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><br><span class="hljs-keyword">let</span> compareNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) &#123;  <span class="hljs-comment">// 变量 compareNumber 是函数</span><br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br>a.<span class="hljs-title function_">sort</span>(compareNumber)<br><br>compareNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> b - a<br>&#125;<br>a.<span class="hljs-title function_">sort</span>(compareNumber)<br></code></pre></td></tr></table></figure><p><strong>（2）值（literal）可以是函数</strong></p><p>如上面的代码，函数在等号右边，是作为值。</p><p><strong>（3）对象的字段的值可以是函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> emp1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>,<br>    <span class="hljs-attr">salary</span>: <span class="hljs-number">8000</span>,<br>    <span class="hljs-attr">getBonus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">performance</span>: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-comment">// 对象字段是函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">salary</span> * performance<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emp1.<span class="hljs-title function_">getBonus</span>(<span class="hljs-number">1.1</span>))<br></code></pre></td></tr></table></figure><p><strong>（4）函数参数可以是函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 排序数组 a</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareNumber</span>(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a - b<br>&#125;<br><br><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br>a.<span class="hljs-title function_">sort</span>(compareNumber)  <span class="hljs-comment">// 函数 compareNumber 是参数</span><br></code></pre></td></tr></table></figure><p><strong>（5）函数返回值可以是函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 排序数组 a</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareNumber</span>(<span class="hljs-params"><span class="hljs-attr">params</span>: &#123;smallerFirst: <span class="hljs-built_in">boolean</span>&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-property">smallerFirst</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;   <span class="hljs-comment">// 函数 compareNumber() 的返回值是函数</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>            <span class="hljs-keyword">return</span> a - b<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;   <span class="hljs-comment">// 函数 compareNumber() 的返回值是函数</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>            <span class="hljs-keyword">return</span> b - a<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br>a.<span class="hljs-title function_">sort</span>(<span class="hljs-title function_">compareNumber</span>(&#123;<span class="hljs-attr">smallerFirst</span>:<span class="hljs-literal">true</span>&#125;))<br></code></pre></td></tr></table></figure><h3 id="3-2-补充：lambda-expression">3.2 补充：lambda expression</h3><blockquote><p>expression：表达式</p><p>在 JS/TS 中，叫 Arrow Function（箭头函数）</p></blockquote><ul><li>箭头后面直接接表达式。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">compareNumber</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt; a-b  <span class="hljs-comment">// 箭头函数</span><br>a.<span class="hljs-title function_">sort</span>(compareNumber)<br></code></pre></td></tr></table></figure><ul><li>箭头后面接一个函数体</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">42</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">compareNumber</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt; &#123;   <span class="hljs-comment">// 箭头函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>    <span class="hljs-keyword">return</span> a-b<br>&#125;<br>a.<span class="hljs-title function_">sort</span>(compareNumber)<br></code></pre></td></tr></table></figure><h3 id="3-2-高阶函数">3.2 高阶函数</h3><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入；</li><li>输出一个函数。</li></ul><p>在 3.1 函数是一等公民 中，可以看到，TS 有高阶函数的能力。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">TypeScript 是一种基于 JavaScript 的强类型编程语言。</summary>
    
    
    
    <category term="Mark" scheme="https://www.aimtao.net/categories/Mark/"/>
    
    
    <category term="前端" scheme="https://www.aimtao.net/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://www.aimtao.net/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Crontab｜Linux 的定时任务</title>
    <link href="https://www.aimtao.net/crontab/"/>
    <id>https://www.aimtao.net/crontab/</id>
    <published>2021-12-19T11:04:00.000Z</published>
    <updated>2021-12-19T11:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在 <a href="https://www.aimtao.net/slef-wake-leancloud/">Gtihub Action｜一行命令解决 LeanCloud 流控问题</a> 中提到，我已经使用 crontab 命令代替 Github Action 帮我执行自动化任务了。</p><p>踩了一些坑，记录下来。</p></blockquote><h2 id="1-介绍">1.介绍</h2><p>Linux 系统启动时，init 进程会启动 cron 进程，corn 会执行定时任务表 crontab 中的定时任务。所以只要系统开机，就会自动执行定时任务。</p><h2 id="2-编辑">2.编辑</h2><p>crontab有2种编辑方式：直接编辑 <code>/etc/crontab</code> 文件与 <code>crontab –e</code>，其中，</p><ul><li>/etc/crontab 里的计划任务是系统中的计划任务。</li><li>crontab –e 用来编辑用户的计划任务。</li></ul><p>每个用户都有自己的 crontab 文件，每次编辑完某个用户的 crontab 后，cron 自动在 /var/spool/cron 下生成一个与此用户同名的文件，此用户的 cron 信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用 crontab -e 来编辑。</p><h2 id="2-格式">2.格式</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*    </span>*    *    *    *  command<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2022-01-11-8ZMgyB.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>在以上各个字段中，还可以使用以下特殊字符：</p><ul><li><p>*  代表所有的取值范围内的数字，如月份字段为 *，则表示每月；</p></li><li><p>/  代表每一定时间间隔的意思，如分钟字段为 */10，表示每10分钟执行1次。</p></li><li><p>-  代表从某个区间范围，是闭区间。如 “2-5” 表示 “2,3,4,5” ，小时字段中 0-23/2 表示在 0~23 点范围内每 2 个小时执行 1 次。</p></li><li><p>,  用于分散的数字（不一定连续），如1,2,3,4,7,9。</p></li></ul><p>注：由于各个地方每周第一天不一样，因此Sunday=0（第一天）或Sunday=7（最后1天）。</p><h2 id="3-启动">3.启动</h2><p>修改完后，终端提示 crontab: installing new crontab 后，就会自动执行。</p><p>如果不确定是否成功，可以用下面的任务测试一下。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> date <span class="hljs-string">&quot;+<span class="hljs-char escape_">\%</span>D <span class="hljs-char escape_">\%</span>H:<span class="hljs-char escape_">\%</span>M:<span class="hljs-char escape_">\%</span>S&quot;</span> <span class="hljs-operator">&gt;</span><span class="hljs-operator">&gt;</span> ~<span class="hljs-operator">/</span>test.log<br></code></pre></td></tr></table></figure><h2 id="4-停止">4.停止</h2><ul><li>在 macOS 中，cron 进程是无法停止的，使用 <code>crontab -e</code> 删除定时任务即可。</li><li>在 ubunut 中，通过 <code>service cron stop</code> 可关闭 cron 服务。</li></ul><p>注：删除定时任务时，记得每个用户都有自己的 crontab，如果发现定时任务没停止，<code>sudo crontab -e</code> 查看一下超级用户是否有定时任务。</p><h2 id="5-易出现的问题">5.易出现的问题</h2><h3 id="5-1-权限">5.1 权限</h3><p>定时任务执行过程中，可能有权限问题，比如读写文件等等，最好直接设定高级管理员的定时任务：<code>sudo crontab -e</code></p><h3 id="5-2-路径">5.2 路径</h3><p>crontab 中的 command 尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。</p><h3 id="5-3-需转义">5.3 % 需转义</h3><p><strong>% 在crontab文件中表示 “换行”，因此假如脚本或命令含有 %,需要使用 % 来进行转义。</strong></p><h3 id="5-4-查看-cron-log：">5.4 查看 cron log：</h3><p>cron 运行日志在 /var/log/cron.log，如果没有找到是因为 ubuntu 默认没有开 cron 日志，开启日志的步骤如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1. 打开配置文件，找到cron.log相关行，将前面注释符#去掉，保存退出，重启rsyslog：</span><br><span class="hljs-built_in">sudo</span> vim /etc/rsyslog.d/50-default.conf<br><span class="hljs-comment"># 2.重启rsyslog</span><br><span class="hljs-built_in">sudo</span>  service rsyslog  restart<br></code></pre></td></tr></table></figure><h3 id="5-5-cron-任务不执行">5.5 cron 任务不执行</h3><p><strong>现象</strong>：cron 任务不执行，查看 /var/log/cron.log，发现报错：MAIL (mailed 53 bytes of output but got status 0x004b from MTA#012)。</p><p><strong>原因</strong>：</p><ul><li><p>定时任务中的命令，执行正确有内容需要输出，或执行错误有报错要输出。前者应该输出到标准输出 stdout，后者应该输出到标准错误输出 stderr。</p></li><li><p>stdout、stderr 都是显示器，但定时任务执行时是后台进程，没有显示器，所以系统就给你发邮件了，但是你系统邮件又没配置，邮件也发不出去。</p></li><li><p>（如果你配置了邮件，或者你是 macOS，终端输入 <code>mail</code> 命令，即可查看系统邮件。）</p></li></ul><p><strong>解决</strong>：</p><ul><li><code>data &amp;&gt;&gt; ~/my_cron.log</code> 比如每次 <code>data</code> 执行完，不管 <code>data </code>命令执行正确还是执行错误，都将结果输出到 <code>~/my_cron.log</code> 文件中保留。</li><li>也可以重定向到黑洞，输出不保存在任何地方：<code>data &amp;&gt;&gt; /dev/null</code></li></ul><p><strong>更多</strong>：如果你想看看输出重定向，可以看这里 <a href="https://www.aimtao.net/linux/#4-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">Linux 命令 | 输出重定向</a>。</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">Linux 系统启动时，init 进程会启动 cron 进程，corn 会执行定时任务表 crontab 中的定时任务。所以只要系统开机，就会自动执行定时任务。</summary>
    
    
    
    <category term="Practice" scheme="https://www.aimtao.net/categories/Practice/"/>
    
    
    <category term="Linux" scheme="https://www.aimtao.net/tags/Linux/"/>
    
    <category term="定时任务" scheme="https://www.aimtao.net/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>全站 webp 最佳实践</title>
    <link href="https://www.aimtao.net/img-to-webp/"/>
    <id>https://www.aimtao.net/img-to-webp/</id>
    <published>2021-10-07T12:25:00.000Z</published>
    <updated>2022-07-03T07:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>22.7.3 的更新：<a href ="#qiniuyun">七牛云的坑</a></p></blockquote><p>昨天更新了 Safari，一看版本 15.0，想起来 Safari 14.0 就已经兼容 webp了。到目前为止，Chrome、Safari、Egde、Firefox、微信/QQ 内置 webview 等主流浏览器都兼容 webp 有一段时间了。</p><p>那么，是时候全站使用 webp 了。</p><p>另外值得注意的是，gif 也可以转为 webp 格式，所以替换图片链接后缀也是极为方便的，全部转为 webp 即可。</p><h2 id="1-方案">1.方案</h2><p>其实七牛云自带图片处理的服务（阿里云腾讯云又拍云都支持），还免费，只需配置图片样式即可。但既然打算使用 webp，自然想一步到位，用 webp 储存和分发。</p><h5 id="（1）下载所有图床所有图片">（1）下载所有图床所有图片</h5><ul><li>还好只有 400+，使用七牛云自带的客户端，可以按路径批量下载，很方便。</li></ul><h5 id="（2）批量转-webp">（2）批量转 webp</h5><ul><li><p>之前存储的时候也比较杂，文件后缀各种都有，png、PNG、jpg、JPG、jpeg、JPEG、gif、GIF，自己写了一个 shell 脚本，有需要自取。</p></li><li><p>使用脚本之前，需要安装 cwebp、gifwebp 等命令。</p></li><li><p>【注意使用路径】比如需要将 post 文件夹中的所有图片转为 webp 格式，则只需将脚本文件拷贝到 post 文件夹内，<code>./towebp.sh</code> 即可，无需增加参数。</p></li><li><p>-q 表示质量，这里使用 90% 的质量，一般来说，80% 质量肉眼基本看不出来。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/sh</span><br><br><span class="hljs-keyword">for</span> FILE <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span>); <span class="hljs-keyword">do</span><br>    FILENAME=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$FILE</span> | <span class="hljs-built_in">cut</span> -d . -f1)<br>    SAVE=<span class="hljs-variable">$&#123;FILENAME&#125;</span>.webp<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$FILE</span> <span class="hljs-keyword">in</span><br>        *.jpg|*.JPG)<br>            cwebp -q 90 <span class="hljs-variable">$FILE</span> -o <span class="hljs-variable">$SAVE</span>;;<br>        *.png|*.PNG)<br>            cwebp -q 90 <span class="hljs-variable">$FILE</span> -o <span class="hljs-variable">$SAVE</span>;;<br>        *.jpeg|*.JPEG) <br>            cwebp -q 90 <span class="hljs-variable">$FILE</span> -o <span class="hljs-variable">$SAVE</span>;;<br>        *.gif|*.GIF)<br>            gif2webp -q 90 <span class="hljs-variable">$FILE</span> -o <span class="hljs-variable">$SAVE</span>;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><h5 id="（3）批量上传">（3）批量上传</h5><ul><li>使用七牛云客户端，即可上传整个文件夹了。</li></ul><h5 id="（4）替换文中的图片链接">（4）替换文中的图片链接</h5><ul><li>推荐使用 VSCode 替换字符串，或者 notepad++ 也可以。</li><li>查找时，开启正则表达式选项，<code>png|PNG|jpg|JPG|jpeg|JPEG|gif|GIF</code>，就可以安心替换了，一步到位。</li></ul><h2 id="2-遇到的问题">2.遇到的问题</h2><h5 id="（1）七牛云客户端批量下载慢">（1）七牛云客户端批量下载慢</h5><ul><li>不是批量下载慢，是当客户端失去焦点时，就下载速度慢，所以一定要放前台下载。</li></ul><h5 id="（2）下载-webp-不包含-gif2webp、vwebp">（2）下载 webp 不包含 gif2webp、vwebp</h5><ul><li><p>mac 使用 <code>brew install webp</code> 即可安装官方的转换脚本，但是 brew 安装的并不包含 gif2webp、vwebp 等命令。</p></li><li><p>可以通过链接下载，👉 <a href="https://developers.google.com/speed/webp/download?hl=en">webp 的下载链接</a> ，再将其放入 bin 目录就行。</p></li></ul><h5 id="（3）替换后，无法正确显示图片。">（3）替换后，无法正确显示图片。</h5><ul><li>我替换之后就直接显示这样，全变成 404-error 了，甚至看起来还有点搞笑。</li><li>【解决】清除浏览器缓存 + 刷新 CDN 缓存。</li></ul><p><img src="https://hutu.aimtao.net/post/img-to-webp-1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="3-未解决的问题">3.未解决的问题</h2><p>我是使用 uPic 进行图片上传的，（优秀 App，推荐），所以现在上传之前，如果原图是 png、jpg，需要手动的先转为 webp，目前还没什么简便的方案。</p><ul><li>上传前，uPic 自动转为 webp；</li><li>上传到七牛云，七牛云帮忙转为 webp 存储；</li></ul><h2 id="4-更新">4.更新</h2><h3 id="4-1-工具">4.1 工具</h3><p>好用的图片转换/压缩工具：<a href="https://squoosh.app">squoosh.app</a></p><p><a name = "qiniuyun"></a></p><h3 id="4-2七牛云的坑">4.2七牛云的坑</h3><p>我使用了七牛云提供的文字样式服务，会给图片自动添加水印。目前发现的问题是：webp 格式图片，添加水印后大小会暴增 5倍，而其他的格式并不会这样。</p><p>全站 webp 本来是为了更小的大小，更快的加载，没想到现在竟然在开倒车。目前已提工单，不知道后续会不会优化这个令人震惊的问题。</p><p>（终于知道为什么 CDN 费用翻倍了，卒）</p><p>PS：可以使用有的推广链接：<a href="https://s.qiniu.com/EnErYb">https://s.qiniu.com/EnErYb</a></p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">是时候全站使用 webp 了。</summary>
    
    
    
    <category term="Practice" scheme="https://www.aimtao.net/categories/Practice/"/>
    
    
    <category term="图床" scheme="https://www.aimtao.net/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="webp" scheme="https://www.aimtao.net/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>质能方程推导的一点点想法</title>
    <link href="https://www.aimtao.net/mass-energy-equation/"/>
    <id>https://www.aimtao.net/mass-energy-equation/</id>
    <published>2021-09-20T15:47:00.000Z</published>
    <updated>2021-09-20T15:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>闲暇看了李永乐老师的视频，记录一下自己的想法，仅当娱乐。</p><span id="more"></span><h2 id="1-准备">1.准备</h2><h3 id="1-1-动量守恒">1.1 动量守恒</h3><p>1687年，牛顿在他的《<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E5%93%B2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86">自然哲学的数学原理</a>》提出动量公式，<br>$$<br>P = mv<br>$$<br>静止的火箭向后喷气，（火箭质量 m<sub>1</sub>，速度 v<sub>1</sub>，气体质量 m<sub>2</sub>，速度 v<sub>2</sub>），由动量定理可知，<br>$$<br>m_1v_1 - m_2v_2 = 0<br>$$<br>如果我们同时乘上时间 t，<code>s = vt</code>，得到<br>$$<br>m_1s_1 - m_2s_2 = 0<br>$$</p><h3 id="1-2-电磁波能量动量关系">1.2 电磁波能量动量关系</h3><p>由经典电磁波理论可知，<br>$$<br>E = Pc<br>$$<br>其中，E —— 能量，P —— 动量，c —— 光速。</p><h2 id="2-推导——爱因斯坦思想实验">2.推导——爱因斯坦思想实验</h2><p>1906 年，爱因斯坦为了更好的推导质能公式，提出了一个思想实验。</p><ul><li>箱子里左边发射一束光，箱子的质量是 M，长度为 L，光子的质量是 m，能量是 E。</li><li>光子有向右的速度 c，t 时间后光子撞到箱子右侧。</li><li>根据动量定理，箱子也应该有向左的速度。</li></ul><p><img src="https://hutu.aimtao.net/post/Mass-energy-equation.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>我们根据能量动量关系，可得出光子的动量 P<sub>1</sub> 为，<br>$$<br>P_1 = \frac{E}{c}<br>$$<br>由于动量守恒，箱子的动量 P<sub>2</sub> 和 P<sub>1</sub> 相同，<br>$$<br>P_2 = P_1 = \frac{E}{c} \<br>$$<br>知道了 P<sub>2</sub>，根据动量定义，我们可以计算出箱子向左速度 v 的大小，<br>$$<br>v = \frac{P_2}{M} = \frac{E}{Mc}<br>$$<br>因为 v &lt;&lt; c，相对于光子，箱子的位移很小，那光子的位移 s<sub>1</sub> 可以近似于 L。<br>$$<br>s_1 \approx L<br>$$<br>那么光子运动时间 t 可表示为，<br>$$<br>t = \frac{L}{c}<br>$$<br>由此可求出箱子的位移 s<sub>2</sub>，<br>$$<br>s_2 = vt = \frac{E}{Mc} t = \frac{E}{Mc} \times  \frac{L}{c}<br>$$<br>最后将上述变量代入动量守恒方程,<br>$$<br>ms_1 - Ms_2 = 0<br>$$<br>代入可得，<br>$$<br>mL - M\times\frac{E}{Mc} \times  \frac{L}{c} = 0<br>$$<br>化简得到质能方程，<br>$$<br>E= mc^2<br>$$</p><h2 id="3-验证——核反应">3.验证——核反应</h2><ul><li>核裂变</li></ul><p>$$<br>n + _{}^{235}U \longrightarrow  _{}^{92}Kr + _{}^{141}Ba + 3n<br>$$</p><ul><li>核聚变</li></ul><p>$$<br>_{1}^{2}H + _{1}^{3}H \longrightarrow  _{2}^{4}He + n<br>$$</p><p>二者都会释放能量，对核反应前后的静质量进行测算，核反应后，均发生质量亏损，满足质能方程。</p><p>PS：所谓的质量亏损并不知说质量转化为能量。静止的物体也是有能量的，当质量发生亏损，能量也发生亏损（释放出来），核反应亏损的便是原子能。</p><h2 id="4-一点点想法">4.一点点想法</h2><p>在惯性系中，牛顿用三大定律，统一了质点运动的描述。对于天体运动，天文学家物理学家建立各种模型来描述，最终开普勒三大定律统一了对天体运动的描述。牛顿用三大定律，结合万有引力，又将地面上的运动和天体运动统一起来，证明了开普勒三大定律。</p><p>在电磁学领域，奥斯特实验发现了电生磁，法拉第由磁生电提出法拉第电磁感应定律。基于“库伦定律”、“毕奥-萨伐尔定律”和“法拉第电磁感应定律”， 麦克斯韦提出了麦克斯韦方程组，用数学语言将把看起来表现截然不同的“电、磁、光”现象统一起来。</p><p>为了用牛顿的经典力学来解释电磁波，麦克斯韦提出了“以太”，以太在空间中无处不在，电磁波通过以太的起伏振荡来传播。</p><p>插一句，基于以太的说法。声波传播靠空气振动，光也是波，那光的传播为什么不需要介质，实际上传播的介质便是以太。那什么是波呢？想想水波，站在海边，远处的浪滚滚而来，冲上沙滩，淹没了你的脚丫子。你想，是远处的水滚滚而来，淹没你的脚丫子吗？不是的，是远处的水的能量以波的形式传递过来。</p><p>1905 年爱因斯坦建立了狭义相对论，彻底抛弃 了“以太”假定；基于相对性原理和光速不变原理，把时间和空间统一成平直的四维时空。爱因斯坦到了晚年还在研究用统一的理论来解释释电磁力和引力。而用统一的理论来描述四大力（强作用力、弱作用力、电磁力、引力）也是现代物理学的追求。</p><p>自以为绝大部分事物都可以被一套理论或者模型所统一，比如所有生命都可以用细胞（DNA）来统一，所有元素都可以用元素周期中的族（质子和核外电子数）来统一。</p><p>甚至任何的算法，都最终演化成 for loop，if else，只不过在这个过程中，找出相似子结构。在人文社科上也是这样，为什么历史总是惊人的相似，为什么人类会发明各种各样的语言却有很多相似之处，为什么各种文明的数字进制都是十，为什么全球人民都一天吃三顿。如果有一天真的能用最底层的原理和模型来解释一切事物，那就真离未来不远了。</p><p>那鸿蒙系统将手机、电脑、手表、电视、汽车等一切终端统一起来，这不是和爱因斯坦在干同一件事嘛 :)</p><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;闲暇看了李永乐老师的视频，记录一下自己的想法，仅当娱乐。&lt;/p&gt;</summary>
    
    
    
    <category term="Life" scheme="https://www.aimtao.net/categories/Life/"/>
    
    
    <category term="随想" scheme="https://www.aimtao.net/tags/%E9%9A%8F%E6%83%B3/"/>
    
    <category term="质能方程" scheme="https://www.aimtao.net/tags/%E8%B4%A8%E8%83%BD%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核｜启动</title>
    <link href="https://www.aimtao.net/boot/"/>
    <id>https://www.aimtao.net/boot/</id>
    <published>2021-09-06T02:00:00.000Z</published>
    <updated>2021-09-19T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计算机工作模式">1.计算机工作模式</h2><h3 id="1-1-CPU-三大构成">1.1 CPU 三大构成</h3><ul><li><p>运算单元：做加法、做位移等等。不知道算哪些数据、结果存哪里。</p></li><li><p>数据单元：包括CPU内部缓存 + 寄存器组，暂时存放数据 + 运算结果。</p></li><li><p>控制单元：获取指令、执行指令。这个指令会指导运算单元从数据单元取某个数，并执行某个运算，最后存入数据单元的某个地方</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-09-19-ioOqZW.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="1-2-控制单元工作原理">1.2 控制单元工作原理</h3><p>CPU 在执行程序时，控制单元完成其工作？（知道取哪些数、执行哪个运算、存到哪里）</p><ul><li><p><strong>指令指针寄存器</strong>：存有下一条指令在内存中的地址。</p></li><li><p><strong>指令寄存器</strong>：控制单元会按照 <strong>指令指针寄存器</strong> 中的地址，从内存中取出指令，存入 <strong>指令寄存器</strong>。</p></li></ul><p>PS：<strong>指令</strong>分为两个部分：<strong>操作码</strong>（运算类型） + <strong>操作数</strong>（运算数据的地址或运算数据本身），操作码交给运算单元，告诉运算单元做什么运算，操作数交给数据单元，让数据单元去读取运算数据。</p><h3 id="1-3-进程切换">1.3 进程切换</h3><p>CPU 中有两个寄存器 CS、DS，分别保存<strong>当前进程</strong>代码段的起始位置、数据段的起始位置。</p><p>例：当进程 A 切换成进程 B 时，CS、DS 便会分别储存进程 B 的代码段起始位置、数据段起始位置。</p><h3 id="1-4-地址总线和数据总线">1.4 地址总线和数据总线</h3><p>CPU 和内存使用总线（Bus）来传输数据。</p><ul><li><p><strong>地址总线（Address Bus）</strong>：传输的是地址数据。</p></li><li><p><strong>数据总线（Data Bus）</strong>：传输的是真正的操作数据。</p></li></ul><p><strong>位数</strong>：</p><ul><li><p><strong>地址总线的位数</strong>：决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。</p><ul><li>32 位系统表示，地址总线为 32 位，地址范围为 232，约 4G 大小。32 位系统最多使用 4G 的内存。</li><li>64 位系统表示，地址总线为 64 位，地址范围为 264，约 16EB 大小。</li></ul></li><li><p><strong>数据总线的位数</strong> = <strong>CPU位宽</strong> = <strong>CPU 内部通用寄存器的位宽</strong>：决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位的 int，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。</p></li></ul><p><strong>补充</strong>：</p><p>除了地址总线和数据总线，还有片内总线、控制总线、通信总线。</p><ul><li><p>片内总线：CPU 芯片内部寄存器与寄存器之间、寄存器与运算单元之间的公共连接线。</p></li><li><p>控制总线：传输控制信息，包括 CPU 发送出去的控制命令、主存（或外设）返回 CPU 的反馈信号。</p></li><li><p>通信总线（外部总线）：不同设备之间信息传输的总线。</p></li></ul><h3 id="1-5-8086-处理器">1.5 8086 处理器</h3><p>8086 处理器如下图：</p><p><img src="https://hutu.aimtao.net/mark/2021-09-19-ZLm3EZ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="1-5-1-数据单元">1.5.1 数据单元</h4><p>由 8 个 16 位的通用寄存器（AX、BX、CX、DX、SP、BP、SI、DI）组成。</p><ul><li><p><strong>AX，BX，CX，DX 作为数据寄存器</strong>：</p><ul><li>AX (Accumulator)：累加寄存器，也称之为累加器</li><li>BX (Base)：基地址寄存器</li><li>CX (Count)：计数器寄存器</li><li>DX (Data)：数据寄存器</li></ul><p>AX、BX、CX、DX 可以分为两个 8 位的寄存器来使用。比如 AX 可以分为 AH、AL 两个寄存器，H 表示 High 高位，L 表示 Low 低位。（优点：既可以储存长数据，也可以储存短数据。也是为了兼容以前基于 8080 等 8 位微处理器的程序。）</p></li><li><p><strong>SP 和 BP 作为指针寄存器</strong>：</p><ul><li>SP (Stack Pointer)：堆栈指针寄存器</li><li>BP (Base Pointer)：基指针寄存器</li></ul></li><li><p><strong>SI 和 DI 作为变址寄存器</strong>：</p><ul><li>SI (Source Index)：源变址寄存器</li><li>DI (Destination Index)：目的变址寄存器</li></ul></li></ul><h4 id="1-5-2-控制单元">1.5.2 控制单元</h4><p>由 2 个控制寄存器（IP、FLAG）和 4 个段寄存器（CS、DS、SS、ES）组成。</p><ul><li><p><strong>控制寄存器</strong>：</p><ul><li>IP (Instruction Pointer)：指令指针寄存器，IP 寄存器存储代码段中下一个指令的地址（实际上是地址偏移量 Offset）。CPU 不断通过 IP 寄存器，将指令从内存的代码段中，加载到 CPU 指令队列缓存器中，然后通过运算单元执行。</li><li>FLAG：标志寄存器</li></ul></li><li><p><strong>段寄存器</strong>：</p><ul><li>CS (Code Segment)：代码段寄存器，代码段在内存中的起始地址。</li><li>DS (Data Segment)：数据段寄存器，数据段在内存中的起始地址。</li><li>SS (Stack Segment)：堆栈段寄存器，实现函数调用时的压栈入栈。</li><li>ES (Extra Segment)：附加段寄存器。</li></ul></li></ul><h4 id="1-5-3-问题">1.5.3 问题</h4><ul><li><p><strong>Q：如何加载内存的数据？</strong></p><p><strong>A</strong>：真实地址 = 16 位的基地址 + 16 位的偏移地址。对于一个段，有一个起始的地址（基地址），而段内的具体位置，我们称为偏移量（Offset）。在 CS 和 DS 中都存放着一个段的起始地址。代码段的偏移量在 IP 寄存器中，数据段的偏移量会放在通用寄存器中。</p></li><li><p><strong>Q：CS、DS 均为 16 位寄存器，能储存的最大地址为 216，地址总线为 20 位，寻址能力为 220，如何提高存储的最大地址？</strong></p><p><strong>A</strong>：原本是16 位的基地址 + 16 位的偏移地址，现在将 CS 和 DS 的值左移 4 位，即<strong>16 位基地址 × 24 + 16位偏移量</strong>。即可满足220的寻址需求。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-09-19-IhmoAr.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p><strong>Q：一个数据段多大？</strong></p><p><strong>A</strong>：偏移量是 16 位，所以一个段最大的大小是 216 = 64KB。</p></li></ul><h3 id="1-6-x86-架构">1.6 x86 架构</h3><p>1985年，intel 推出 80386 处理器，32位处理器，如何继续使用 x86 架构呢？</p><p>为了保证向后兼容（backward），intel 在原来的 x86 架构进行扩展，如下图。</p><p><img src="https://hutu.aimtao.net/mark/2021-09-19-mAdD20.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>通用寄存器从 8 个 16 位扩展为 8 个 32 位，同时依然保持了 16 位和 8 位的使用方式。</li><li>IP 寄存器扩展成 32 位，同时兼容 16 位。</li><li>段寄存器依然保持 16 位，但不再是段的起始地址。<ul><li>段的起始地址放在内存中的<strong>段描述符表</strong>，表中含有多个<strong>段描述符</strong>（Segment Descriptor），分别对应着不同的段起始地址。</li><li>段寄存器中存储的则是表格中的索引，称为<strong>选择子</strong>（Selector）。</li><li>段寄存器将 段起始地址 从内存中拿到CPU的段描述符缓存器中，以便 CPU 更快的取到段起始地址。</li></ul></li></ul><p><strong>Q：为什么段寄存器不扩展成 32 位，以便向后兼容？</strong></p><p><strong>A</strong>：232 已经有 4G 大小的寻址能力，是否还需要保留左移 4 位操作，所以不如重新设计。</p><p>但是这样更改，<strong>段寄存器如何向后兼容呢？</strong></p><ul><li><p><strong>实模式</strong>（Real Pattern）：段寄存器储存段起始地址。</p></li><li><p><strong>保护模式</strong>（Protected Pattern）：段寄存器储存段描述表的选择子。</p></li></ul><p>当系统刚启动时，CPU 处于实模式，可以向后兼容。当需要更多的内存时（超过 220 的寻址能力，1M），可以切换到保护模式。</p><h3 id="1-7-实模式与保护模式">1.7 实模式与保护模式</h3><ul><li><p>实模式（Real Mode）：又名 Real Address Mode，地址访问的是真实地内存地址所在位置。在此模式下，可以使用 20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。</p></li><li><p>保护模式（Protected Mode）：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。</p></li></ul><h2 id="2-启动流程">2.启动流程</h2><h3 id="2-1-初始化-BIOS">2.1 初始化 BIOS</h3><p>开机后，按特定的组合键就能进入 BIOS 界面了。</p><p>在主板上，有个 ROM（Read Only Memory，只读存储器），ROM 是只读的，上面固化了初始化程序 BIOS（Basic Input and Output System，基本输入输出系统）。</p><ol><li><p><strong>启动电源</strong></p><p>当按下电源键，主板会发向电源组发出信号，接收到信号后，电源会提供合适的电压给计算机。</p></li><li><p><strong>重置寄存器</strong></p><p>当主板收到电源正常启动的信号后，主板会启动CPU，CPU重置所有寄存器数据，并设置初始化数据，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000。</p></li><li><p><strong>初始化 BIOS</strong></p><p>根据 CS 和 IP 寄存器，计算出的第一个指令地址为 0xFFFF0，这条 JMP 指令会跳到 ROM 中做初始化工作的代码，开始 BIOS 的初始化工作。</p></li></ol><p><strong>Q：为什么要将 CS 设置为 0xFFFF，将 IP 设置为 0x0000？</strong></p><p><strong>A</strong>：这是初始化 BIOS 的指令地址。</p><ul><li><p>实模式启动最多可使用 0 - 0xFFFFF 的 1M 内存空间，由于只有16位寄存器，最大地址只能表示为 0xFFFFF（64KB)，因此不得不采取将内存按段划分为 64KB 的方式来充分利用 1M 内存。</p></li><li><p>在主板上，有个只读的 ROM ，上面固化了初始化程序 BIOS。将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM。</p></li><li><p>根据 CS 和 IP 寄存器的值计算出的地址便在 ROM 区中（0xFFFF × 16 + 0x0000 = 0xFFFF0）。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-12-13-rP98n7.jpg-s" srcset="/img/loading.gif" lazyload alt="2021-12-13-rP98n7"></p><h3 id="2-2-构建中断向量表">2.2 构建中断向量表</h3><p><img src="https://hutu.aimtao.net/mark/2021-09-19-Jst3y4.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>如上图，1M 的具体分区可以分为，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table    <span class="hljs-comment"># 中断向量表</span><br> 0x00000400 - 0x000004FF - BIOS Data Area   <span class="hljs-comment"># BIOS  数据区</span><br> 0x00000500 - 0x00007BFF - Unused<br> 0x00007C00 - 0x00007DFF - Our Bootloader<br> 0x00007E00 - 0x0009FFFF - Unused<br> 0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory<br> 0x000B0000 - 0x000B7777 - Monochrome Video Memory<br> 0x000B8000 - 0x000BFFFF - Color Video Memory<br> 0x000C0000 - 0x000C7FFF - Video ROM BIOS<br> 0x000C8000 - 0x000EFFFF - BIOS Shadow Area<br> 0x000F0000 - 0x000FFFFF - System BIOS<br></code></pre></td></tr></table></figure><ul><li>BIOS 程序在内存最开始的位置（0x00000）用1KB 的内存空间（0x00000～0x003FF）构建<strong>中断向量表</strong>。</li><li>在此位置之后，用 256 字节的内存空间构建 BIOS 数据区（0x00400～0x004FF）。</li><li>并在大约 57KB 以后的位置（0x0E05B）加载了8KB 左右的与中断向量表相应的若干中断服务程序。</li><li>中断向量表中有 256 个中断向量，每个中断向量占 4 字节，其中两个字节是 CS 的值，两个字节是 IP 的值。每个中断向量都指向一个具体的中断服务程序。</li></ul><h3 id="2-3-加载-BootLoader">2.3 加载 BootLoader</h3><blockquote><p>要想启动操作系统，BIOS 需要找到引导盘的第一个扇区——主引导扇区 MBR ，并执行 MBR 的一段代码 BootLoader（引导程序）。</p></blockquote><h4 id="2-3-1-主引导扇区">2.3.1 主引导扇区</h4><ul><li>引导盘（Bootable Disk）第一个扇区是主引导扇区（MBR，Master Boot Record），占 512 个字节，通常是在 /dev/sda 或者 /dev/hda。</li><li>由 446 字节的 MBR引导代码、64 字节的分区表和 2 字节的结束标志组成。最后两个字节为 0x55、0xAA（小端方式存储，实际值为 0xAA55）。</li><li>主引导扇区中最后两个字节，是检验主引导记录是否有效的标志。</li></ul><h4 id="2-3-2-BootLoader-的工作">2.3.2 BootLoader 的工作</h4><p>boot.img 就是 Linux 的 BootLoader 引导程序，位于 MBR 中；由 boot.img 来加载其他 img 文件。</p><ol><li><p><strong>加载 boot.img</strong></p><ul><li>boot.img 由 boot.S 编译而成，512字节，在 MBR 中。</li><li>BIOS 将 boot.img 从 MRB 中加载到内存的 0x7c00 的位置，并执行 boot.img 的代码。至此，BIOS 将控制权交给 boot.img</li></ul></li><li><p>加载 core.img</p><ul><li>core.img 由 lzma_decompress.img、diskboot.img、kernel.img 和一系列的模块组成。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-09-19-x8ZTSu.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p>boot.img 先加载 core.img 的第一个扇区，即 diskboot.img，对应代码为 diskboot.S。至此，boot.img 将控制权交给 diskboot.img 。</p></li><li><p>diskboot.img 的任务就是将 core.img 的其他部分加载进来。</p><ul><li>diskboot.img 先加载 lzma_decompress.img，它是解压缩程序，用于解压缩 kernel.img，应的代码是 startup_raw.S。</li></ul><blockquote><p>因为实模式 1M 的地址空间太小，在解压缩 kernel.img 之前，<strong>需要将实模式切换成保护模式</strong>（下文具体描述如何切换）。</p></blockquote><ul><li>切换成保护模式后，对压缩过的 kernel.img 进行解压缩，对应的代码是 startup.S 以及一堆 c 文件。（kernel.img 不是 Linux 的内核，而是 grub 的内核。）</li><li>最后加载各个模块 module 对应的映像。</li></ul></li></ul></li><li><p><strong>启动 grub_main 函数</strong></p><ul><li>在 startup.S 中会调用 grub_main，这是 grub kernel 的主函数。</li><li>grub_main 函数初始化控制台，计算模块基地址，设置 root 设备。</li><li>grub_main 函数调用 <code>grub_load_config()</code> 函数，对 grub.conf 文件里的配置信息进行解析。</li><li>如果是正常启动，grub_main 函数调用 <code>grub_command_execute (“normal”, 0, 0)</code> 将 GRUB 置于 normal 模式。</li><li>在 normal 模式中， <code>grub-core/normal/main.c</code> 中的 <code>grub_normal_execute</code> 函数将被调用，以完成最后的准备工作，并调用 <code>grub_show_menu()</code> 显示一个菜单列出所用可用的操作系统。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-09-19-qWhuay.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>当某个操作系统被选择之后，``grub_menu_execute_entry<code>开始执行</code>grub_command_execute (“boot”, 0, 0)`，它将调用 GRUB 的 boot 命令，来引导被选中的操作系统。</li></ul></li></ol><p>至此，系统终于启动了。</p><h2 id="3-切换保护模式">3.切换保护模式</h2><blockquote><p>lzma_decompress.img 调用 <code>real_to_prot</code> 函数，从实模式切换到保护模式。</p></blockquote><p><strong>两大主要事件</strong>：</p><ul><li><strong>启用分段</strong>：在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li><li><strong>启动分页</strong>：将内存分成相等大小的块，详见内存管理部分。</li></ul><h3 id="3-1-新旧中断的交替">3.1 新旧中断的交替</h3><ol><li><strong>屏蔽中断</strong><ul><li>在 16 位实模式下的中断由 BIOS 处理，进入保护模式后，中断将交给中断描述符表 IDT 里规定的函数处理。</li><li>在刚进入保护模式时，中断描述符表寄存器（IDTR）的初始值为 0，一旦发生中断（例如BIOS的时钟中断）就将导致CPU发生异常，所以需要首先屏蔽中断。</li><li>屏蔽中断可以使用 cli 指令。</li></ul></li></ol><blockquote><p>全局描述符表寄存器 GDTR、中断描述符表寄存器 IDTR、局部描述符表寄存器 LDTR、任务寄存器 TR。</p></blockquote><ol start="2"><li><strong>初始化全局描述符表 GDT</strong></li></ol><blockquote><ul><li><p>GDT（Global Descriptor Table，全局描述符表），在系统中唯一的存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表，其中存放每一个任务（task）局部描述符表（LDT, Local Descriptor Table）地址和任务状态段（TSS, Task Structure Segment）地址，完成进程中各段的寻址、现场保护与现场恢复。GDTR 是 GDT 基地址寄存器，当程序通过段寄存器引用一个段描述符时，需要取得 GDT 的入口，GDTR 标识的即为此入口。在操作系统对 GDT 的初始化完成后，可以用 LGDT（Load GDT）指令将 GDT 基地址加载至 GDTR。</p></li><li><p>IDT（Interrupt Descriptor Table，中断描述符表），保存保护模式下所有中断服务程序的入口地址，类似于实模式下的中断向量表。IDTR（IDT 基地址寄存器），保存 IDT 的起始地址。</p></li></ul></blockquote><p><strong>Q：为什么要建立全局描述符表 GDT？</strong></p><p><strong>A</strong>：16 位空间无法存储 64 位的段描述符。</p><ul><li>在保护模式中，段与段之间是互相隔离的，当访问的地址超出段的界限时处理器就会阻止这种访问。</li><li>因此每个段都需要有<strong>起始地址、范围、访问权限以及其他属性</strong>四个部分，这四个部分合在一起叫做段描述符（Segment Descriptor），总共需要 8 个字节来描述。</li><li>但 Intel 为了保持向后兼容，将段寄存器仍然规定为16 位，我们无法用16 位的段寄存器来直接存储 64 位的段描述符。</li><li>解决的办法是将所有 64 位的段描述符放到一个数组中，将 16 位段寄存器的值作为下标来访问这个数组（以字节为单位），获取 64位 的段描述符，这个数组就叫做全局描述符表（Global Descriptor Table, GDT）。</li></ul><h3 id="3-2-启用-Gate-A20">3.2 启用 Gate A20</h3><blockquote><p>16 位实模式，20 根总线最多访问 1M 的内存空间，现在切换 32 位保护模式，需要开启第 21 根地址线的控制线。</p></blockquote><p>lzma_decompress.img 调用 <code>real_to_prot()</code> 函数启动。打开A20，意味着CPU可以进行 32 位寻址，最大寻址空间为 4 GB。</p><ul><li>实模式下，当程序寻址超过 0xFFFFF 时，CPU将“回滚”至内存地址起始处寻址（注意，在只有20根地址线的条</li></ul><p>件下，0xFFFFF+1=0x00000，最高位溢出）</p><ul><li>此处对A20地址线的启用相当于关闭CPU在实模式下寻址的“回滚”机制。</li></ul><h2 id="4-GRUB2">4.GRUB2</h2><blockquote><p>Grub2（Grand Unified Bootloader Version 2）</p></blockquote><blockquote><p>澄清：</p><ul><li>boot.img、core.img 等 img 文件，属于 Grub2 这个工具的，</li><li>grub2 将 boot.img 转换后的内容安装到 MBR 中，将 core.img 等文件安装在硬盘的其他指定位置。</li></ul></blockquote><p>Linux 内核通过 <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">Boot Protocol</a> 定义如何实现 BootLoader ，有如 Grub2 和 syslinux 等具体实现方式。</p><ul><li><strong>作用</strong>：Grub2 将 boot.img 安装在 MRB 中，作为 BootLoader（引导程序）。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">grub2-install /dev/sda  <span class="hljs-comment"># /dev/sda 为引导盘。</span><br></code></pre></td></tr></table></figure><ul><li>查看系统启动的配置信息：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Shell   grub2-mkconfig -o /boot/grub2/grub.cfg     <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">menuentry <span class="hljs-string">&#x27;CentOS Linux (3.10.0-862.el7.x86_64) 7 (Core)&#x27;</span> --class centos --class gnu-linux --class gnu --class os --unrestricted <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-3.10.0-862.el7.x86_64-advanced-b1aceb95-6b9e-464a-a589-bed66220ebee&#x27;</span> &#123;<br>        load_video<br>        <span class="hljs-built_in">set</span> gfxpayload=keep<br>        insmod gzio<br>        insmod part_msdos<br>        insmod ext2<br>        <span class="hljs-built_in">set</span> root=<span class="hljs-string">&#x27;hd0,msdos1&#x27;</span><br>        <span class="hljs-keyword">if</span> [ x<span class="hljs-variable">$feature_platform_search_hint</span> = xy ]; <span class="hljs-keyword">then</span><br>          search --no-floppy --fs-uuid --<span class="hljs-built_in">set</span>=root --hint=<span class="hljs-string">&#x27;hd0,msdos1&#x27;</span>  b1aceb95-6b9e-464a-a589-bed66220ebee<br>        <span class="hljs-keyword">else</span><br>          search --no-floppy --fs-uuid --<span class="hljs-built_in">set</span>=root b1aceb95-6b9e-464a-a589-bed66220ebee<br>        <span class="hljs-keyword">fi</span><br>        linux16 /boot/vmlinuz-3.10.0-862.el7.x86_64 root=UUID=b1aceb95-6b9e-464a-a589-bed66220ebee ro console=tty0 console=ttyS0,115200 crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet <br>        initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上配置在系统启动时，形成一个列表，选择从哪个系统启动。显示效果如下图。</p><p><img src="https://hutu.aimtao.net/mark/2021-09-19-qWhuay.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="参考">参考</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/02/booting.html">https://www.ruanyifeng.com/blog/2013/02/booting.html</a></li><li><a href="https://www.cnblogs.com/boyxiao/archive/2010/11/20/1882716.html">https://www.cnblogs.com/boyxiao/archive/2010/11/20/1882716.html</a></li><li><a href="https://ty-chen.github.io/linux-kernel-bootstrap/">https://ty-chen.github.io/linux-kernel-bootstrap/</a></li><li><a href="http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html">http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7094693.html#auto_id_0">https://www.cnblogs.com/f-ck-need-u/p/7094693.html#auto_id_0</a></li><li>趣谈 Linux 操作系统</li></ul><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">电脑按下开机键发生了什么？</summary>
    
    
    
    <category term="Kernel" scheme="https://www.aimtao.net/categories/Kernel/"/>
    
    
    <category term="Linux" scheme="https://www.aimtao.net/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://www.aimtao.net/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记｜repo</title>
    <link href="https://www.aimtao.net/repo/"/>
    <id>https://www.aimtao.net/repo/</id>
    <published>2021-08-23T15:32:00.000Z</published>
    <updated>2021-08-23T15:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>repo 是 python 脚本，为便于管理一个项目中的多个 git 仓库。</p><p>重要：无特殊情况，使用 python3 版本 repo。</p></blockquote><h2 id="1-清单库">1.清单库</h2><p>manifest.git 是清单库 。一个清单库包含多个清单文件，代表着不同的 git 版本库和分支。</p><h2 id="2-清单文件">2.清单文件</h2><p>清单文件在目录 <code>.repo/manifest/</code> 中。清单文件为 xml 格式，元素如下表：</p><table><thead><tr><th>元素</th><th>含义</th></tr></thead><tbody><tr><td>remote</td><td>远程 git 库。</td></tr><tr><td>project</td><td>项目在 git 库中的相对路径。</td></tr><tr><td>default</td><td>设置默认 git 库和分支。</td></tr></tbody></table><h2 id="3-拉取清单文件">3.拉取清单文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo init -u ssh://your_name@your_server.com/project_name/manifest.git -b dev -m feature-dev.xml<br></code></pre></td></tr></table></figure><ul><li>-u：指定一个URL，其连接到一个 manifest 仓库</li><li>-b：选择 manifest 仓库中的一个分支。</li><li>-m：在 manifest 仓库中选择一个 xml 文件。</li></ul><h2 id="4-同步代码">4.同步代码</h2><p>参照清单文件 .repo/manifest.xml 克隆并同步版本库。如果项目版本库不存在，则执行 <code>repo sync</code> 命令相当于执行 <code>git clone</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo <span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><h2 id="5-创建分支">5.创建分支</h2><p>为单个项目或所有项目，以清单文件中已设定的分支为基础，在本地创建新的分支。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo start branche_name<br></code></pre></td></tr></table></figure><blockquote><p>从这条之下的所有命令，都是在单个项目中运行。</p></blockquote><h2 id="6-查看分支">6.查看分支</h2><p>查看单个项目下各模块的分支信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo branches<br></code></pre></td></tr></table></figure><h2 id="7-切换分支">7.切换分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo checkout branche_name<br></code></pre></td></tr></table></figure><h2 id="8-查看文件差异">8.查看文件差异</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo diff<br></code></pre></td></tr></table></figure><h2 id="9-查看文件状态">9.查看文件状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo status<br></code></pre></td></tr></table></figure><ul><li><p>每个小节的第一行显示的是项目名称和所在的分支名称。</p><ul><li>-：没有改变</li><li>A：添加（不在HEAD中，在暂存区中）</li><li>M：修改（在HEAD中，在暂存区中，内容不同）</li><li>D：删除（在HEAD中，不在暂存区）</li><li>R：重命名（不在HEAD中，在暂存区，路径修改）</li><li>C：拷贝（不在HEAD中，在暂存区，从其他文件拷贝）</li><li>T：文件状态改变（在HEAD中，在暂存区，内容相同）</li><li>U：未合并，需要冲突解决</li></ul></li><li><p>每个小节的第二行第一个字母表示暂存区文件修改的状态，第二个字母表示工作去文件的更改状态。</p><ul><li>-：新/未知（不在暂存区，在工作区）</li><li>m：修改（在暂存区，在工作区，被修改）</li><li>d：删除（在暂存区，不在工作区</li></ul></li></ul><h2 id="10-删除指定分支">10.删除指定分支</h2><p>该命令实质是对 <code>git branch -d</code> 的封装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo abandon branche_name<br></code></pre></td></tr></table></figure><h2 id="11-删除已经合并分支">11.删除已经合并分支</h2><p>该命令实质是对 <code>git branch -d</code> 的封装，用于扫描项目的各个分支，并删除已经合并的分支。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo prune<br></code></pre></td></tr></table></figure><h2 id="12-将文件添加到-index-表中">12.将文件添加到 index 表中</h2><p>该命令实质是对 <code>git add –interactive</code> 命令的封装，用于将项目工作区中的改动添加到暂存区。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo stage -i <br></code></pre></td></tr></table></figure><ul><li>-i 表示 –interactive，给出个界面让用户选择。</li></ul><h2 id="13-设置远程仓库">13.设置远程仓库</h2><p>根据 xml 文件添加的远程分支，方便于向服务器提交代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo remote addd remote_name url<br><br><span class="hljs-comment"># 例如： </span><br><span class="hljs-comment"># repo remote add org ssh://your_server.com/git_repo</span><br></code></pre></td></tr></table></figure><h2 id="14-遍历当前项目下的所有-git-仓库">14.遍历当前项目下的所有 git 仓库</h2><p>该命令相当于一个迭代器，会遍历当前项目下所有的 git 仓库，在所有指定的项目中执行同一个 shell 命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo forall -c 命令<br></code></pre></td></tr></table></figure><ul><li><p>-c：后面可以带的任何可以被系统支持的shell命令（ls，cp，pwd等）。</p></li><li><p>-p：在shell命令输出之前列出项目名称。</p></li><li><p>-v：列出执行shell指令输出的错误信息。</p></li><li><p>该命令还可以添加环境变量：（环境变量的参数有如下几种）</p><ul><li>REPO_PROJECT:指定项目的名称。</li><li>REPO_PATH:指定项目在工作区的相对路径。</li><li>REPO_REMOTE:指定项目远程仓库的名称。</li><li>REPO_LREV:指定项目最后一次提交服务器仓库对应的哈希值。</li><li>REPO_RREV:指定项目在克隆时的指定分支，manifest 里的 revision 属性。</li></ul></li><li><p>如果 -c 后面的 shell 指令是上述的环境变量，则需要用单引号把 shell 指令括起来。</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo forall –c ‘<span class="hljs-built_in">echo</span> <span class="hljs-variable">$REPO_PROJECT</span>’<br></code></pre></td></tr></table></figure><h2 id="15-合并分支">15.合并分支</h2><p>先将所有项目都切换到 master 分支，再将 local 分支合并到 master 分支上。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo forall -p -c git merge <span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure><h2 id="16-设置-tag">16.设置 tag</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo forall -c git tag 标签名   <span class="hljs-comment"># 在所有项目下打标签</span><br></code></pre></td></tr></table></figure><h2 id="17-显示-repo-版本号">17.显示 repo 版本号</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo version  <span class="hljs-comment"># 查看版本号</span><br></code></pre></td></tr></table></figure><h2 id="18-帮助文档">18.帮助文档</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">repo <span class="hljs-built_in">help</span> <span class="hljs-comment"># 找到总结所有命令的文档</span><br></code></pre></td></tr></table></figure><script type="text/javascript">(function (document) {    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {        panel.getElementsByClassName('fold-title')[0].onclick = function() {            panel.classList.toggle("collapsed");            panel.classList.toggle("expanded");        }    });})(document);</script>]]></content>
    
    
    <summary type="html">repo 是 python 脚本，为便于管理一个项目中的多个 git 仓库。</summary>
    
    
    
    <category term="Mark" scheme="https://www.aimtao.net/categories/Mark/"/>
    
    
    <category term="Git" scheme="https://www.aimtao.net/tags/Git/"/>
    
    <category term="repo" scheme="https://www.aimtao.net/tags/repo/"/>
    
  </entry>
  
</feed>
