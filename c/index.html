<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="C 语言的知识点不多，但是比较杂。本文系统地对 C 语言进行补充学习。"><title>查漏补缺｜C 语言 - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2020-02-22-c.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="查漏补缺｜C 语言"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-02-22 22:34" pubdate>2020-02-22 PM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 45k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 34 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">查漏补缺｜C 语言</h1><p class="note note-info">本文最后更新于：5 years ago</p><div class="markdown-body"><blockquote><p>C 语言的知识点不多，但是比较杂。本文系统地对 C 语言进行补充学习。</p></blockquote><span id="more"></span><h2 id="001-C语言的简洁">001.C语言的简洁</h2><p>32个关键字、9中控制语句、34个运算符。</p><table><thead><tr><th>short</th><th>int</th><th>float</th><th>double</th><th>char</th><th>unsigned</th></tr></thead><tbody><tr><td>long</td><td>enum</td><td>void</td><td>auto</td><td>for</td><td>while</td></tr><tr><td>do</td><td>if</td><td>else</td><td>switch</td><td>case</td><td>break</td></tr><tr><td>continue</td><td>goto</td><td>return</td><td>sizeof</td><td>const</td><td>typedef</td></tr><tr><td>static</td><td>struct</td><td>default</td><td>union</td><td>register</td><td>signed</td></tr><tr><td>extern</td><td>volatile</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>If-else</th><th>for</th><th>while</th></tr></thead><tbody><tr><td>do-while</td><td>continue</td><td>break</td></tr><tr><td>switch</td><td>goto</td><td>Return</td></tr></tbody></table><h2 id="002-编译过程">002.编译过程</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc hello.c     <span class="hljs-comment"># 默认生成名为 a.out 的可执行文件</span><br><br>gcc hello.c -o hello     <span class="hljs-comment"># 生成名为 hello 的可执行文件</span><br>gcc -o hello hello.c     <span class="hljs-comment"># 生成名为 hello 的可执行文件【只要 -o 后接可执行文件名称即可】</span><br></code></pre></td></tr></table></figure><h3 id="1-分步编译的四步">1.分步编译的四步</h3><ol><li><strong>预处理</strong>：宏定义展开、头文件展开、条件编译、删除注释、不会检查语法错误，生成 <code>*.i 文件</code> 。</li><li><strong>编译</strong>：词法分析、语法分析、语义分析、优化后生成相应的汇编代码。检查语法错误，将 <code>*.i 文件</code> 编译成汇编文件 <code>*.s 文件</code>。</li><li><strong>汇编</strong>：将 <code>*.s 文件</code> 生成 目标文件<code>*.o 文件</code>（二进制文件）。</li><li><strong>链接</strong>：C语言程序需要依赖各种库，编译后需要把库链接到可执行文件<code>*.out</code> 或者 <code>*.exe</code>中。【主要是动态库即DLL文件(Dynamic Link Library)】。</li></ol><h3 id="2-编译命令">2.编译命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -E hello.c -o hello.i    <span class="hljs-comment"># 预处理</span><br>gcc -S hello.i -o hello.s    <span class="hljs-comment"># 编译</span><br>gcc -c hello.s -o hello.o    <span class="hljs-comment"># 汇编</span><br>gcc hello.o -o hello         <span class="hljs-comment"># 链接</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-E</td><td>只进行预处理</td></tr><tr><td>-S</td><td>只进行预处理、编译</td></tr><tr><td>-c</td><td>只进行预处理、编译、汇编</td></tr><tr><td>-o</td><td>指定输出文件的文件名</td></tr></tbody></table><p>PS：助记，选项是ESC，后缀是iso。</p><h3 id="3-文件包含处理">3.文件包含处理</h3><p><code>include &lt;&gt;</code> 用于包含库函数的头文件。</p><p><code>include &quot;&quot;</code> 用于包含自定义函数的头文件。</p><h3 id="4-条件编译">4.条件编译</h3><blockquote><p>条件编译在预处理阶段展开。</p></blockquote><h4 id="（1）测试存在">（1）测试存在</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> 标示符</span><br>    程序段<span class="hljs-number">1</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  标示符</span><br>    程序段<span class="hljs-number">2</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>举个例子</strong>：</p><p>如果存在变量 a，则打印上面一句，如果不存在变量a，则打印下面一句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;存在 变量a&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不存在 变量a&quot;</span>);    <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//存在 变量a</span><br></code></pre></td></tr></table></figure><h4 id="（2）测试不存在">（2）测试不存在</h4><blockquote><p><code>ifndef</code> 比 <code>ifdef</code> 多一个 n。</p><p>多用于 防止头文件重复包含。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> 标示符</span><br>    程序段<span class="hljs-number">1</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  标示符</span><br>    程序段<span class="hljs-number">2</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>举个例子</strong>：</p><p>自定义头文件 <code>test.h</code>。为防止头文件重复包含，可以使用以下条件编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _TEST_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEST_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>也可以防止头文件重复包含。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 保证头文件只被编译一次。</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><h4 id="（3）根据表达式定义">（3）根据表达式定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 表达式</span><br>    程序段<span class="hljs-number">1</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>    程序段<span class="hljs-number">2</span>；<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>举个例子</strong>：</p><p>用来调试代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-comment">// 此处代码不会被执行。</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="003-system函数">003.system函数</h2><p><strong>用途</strong>：在程序中，执行DOS命令 / Linux命令 /外部程序。</p><p>常见的有：</p><p><code>system(“PAUSE”)</code> 暂停屏幕</p><p><code>system(“CLS”)</code>：清屏</p><p><code>system(&quot;shutdown -s -t 3&quot;)</code>：三秒后关机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Command is coming:&quot;</span>);<br>    system(<span class="hljs-string">&quot;ls&quot;</span>);      <span class="hljs-comment">//调用Linux命令</span><br>    system(<span class="hljs-string">&quot;./hello&quot;</span>)  <span class="hljs-comment">//执行外部可执行文件hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p>PS：Windows的两个框架：QT / MFC，故可用QT / MFC调用system函数，执行 DOS命令 或者 外部程序。</p><h2 id="004-数据类型">004.数据类型</h2><img src="https://hutu.aimtao.net/mark/2020-02-29-dObvkl.webp-s" srcset="/img/loading.gif" lazyload style="zoom:60%"><h3 id="1-作用">1.作用</h3><p>编译器预算变量分配的内存空间大小。</p><h3 id="2-本质">2.本质</h3><p>数据类型的本质：固定内存大小的别名</p><h3 id="3-补充">3.补充</h3><ul><li>变量命名不能以数字开头。</li><li>char 类型本质上是 1字节大小的整型，存储的是ASCII码。</li></ul><h3 id="4-数组类型">4.数组类型</h3><p>数组也是一种数据类型，由 <strong>元素个数</strong> 和 <strong>元素对应类型</strong> 决定。</p><p><code>int a[10];</code>，a 的数据类型是 <code>int [10]</code>。</p><h3 id="5-sizeof">5.sizeof</h3><h4 id="（1）sizeof是用来求数据类型的字节数的。">（1）sizeof是用来求数据类型的字节数的。</h4><p>如 <code>int a;</code> 那么无论 <code>sizeof(int)</code> 或者是 <code>sizeof(a)</code> 都是等于4，因为 <code>sizeof(a)</code> 其实就是 <code>sizeof(type of a)</code>。</p><ul><li>对于 <code>char str[] = &quot;ab&quot;;</code> 就有 <code>sizeof(str) == 3</code>， 因为 str 的数据类型是 <code>char [3]</code> 。</li><li>对于 <code>sizeof(&quot;ab&quot;) == 3</code>，因为 <code>&quot;ab&quot;</code> 的数据类型是 <code>const char [3]</code> 。</li><li>对于<code>char *p = &quot;ab&quot;;</code> 就有 <code>sizeof(p) == 4</code>，因为 p 的数据类型是 <code>char*</code> 。</li><li>对于空字符串 <code>sizeof(&quot;&quot;) == 1</code>，<code>sizeof(&quot;\0&quot;) == 2</code> 。只要是字符串，默认结尾加 <code>\0</code></li></ul><h4 id="（2）数组名和指针的辨析">（2）数组名和指针的辨析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p1 = <span class="hljs-string">&quot;ab&quot;</span>;   <span class="hljs-comment">// &quot;ab&quot; 储存在字符常量区，“ab” 表示一个指针，指向 “ab” 的首地址</span><br><span class="hljs-type">char</span> *p2;<br><span class="hljs-type">char</span> s[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;ab&quot;</span>;<br>p2 = s;          <span class="hljs-comment">// 数组名是指针，指向首元素的首地址</span><br><br><span class="hljs-keyword">sizeof</span>(s);  <span class="hljs-comment">// 2   // 返回字符数组的内存大小【传入的是首元素首地址】数组做sizeof的参数不退化成指针。</span><br><span class="hljs-keyword">sizeof</span>(&amp;s);  <span class="hljs-comment">// 8   // 返回地址的内存大小。&amp;s 表示整个字符数组的首地址。</span><br><span class="hljs-keyword">sizeof</span>(p1);  <span class="hljs-comment">// 8   // 返回指针的大小。64位系统下，指针占八个字节。存的是 “ab” 的地址。</span><br><span class="hljs-keyword">sizeof</span>(p2);  <span class="hljs-comment">// 8   // 返回指针的大小。</span><br><span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;ab&quot;</span>);  <span class="hljs-comment">//2  // 返回&quot;ab&quot;的内存大小。</span><br></code></pre></td></tr></table></figure><h4 id="（3）内存大小和字符串长度的辨析">（3）内存大小和字符串长度的辨析</h4><p>sizeof 计算内存大小，测量字符串长度，使用 <code>strlen()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;     <span class="hljs-comment">// sizeof(a) == 100;</span><br><span class="hljs-type">char</span> b[] = “abc”;                 <span class="hljs-comment">// sizeof(b) == 4; (附加结束符 \0)</span><br></code></pre></td></tr></table></figure><h3 id="6-数据类型取值范围">6.数据类型取值范围</h3><blockquote><p>计算机储存数据，都是按照补码来储存的，所以取值范围即<strong>若干位补码的取值范围。</strong></p></blockquote><h4 id="1-字节大小">(1)字节大小</h4><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>char</td><td>1字节</td><td>-128～127（-2<sup>7</sup> ~ 2<sup>7</sup> -1）</td></tr><tr><td>short</td><td>2字节</td><td>-32768～32767（-2<sup>15</sup> ~ 2<sup>15</sup> -1）</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648~2147473647（-2<sup>31</sup> ~ 2<sup>31</sup> -1）</td></tr><tr><td>long</td><td>4字节</td><td>-2147483648~2147473647（-2<sup>31</sup> ~ 2<sup>31</sup> -1）</td></tr><tr><td>unsigned short</td><td>2字节</td><td>0～65535（0 ~ 2<sup>16</sup> -1）</td></tr><tr><td>unsigned int</td><td>4字节</td><td>0～4294967295（0 ~ 2<sup>32</sup> -1）</td></tr><tr><td>unsigned long</td><td>4字节</td><td>0～4294967295（0 ~ 2<sup>32</sup> -1）</td></tr><tr><td>long long</td><td>8字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td>精度：7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>精度：16位有效数字</td></tr></tbody></table><h4 id="2-为何正数范围比负数范围少一个？">(2)为何正数范围比负数范围少一个？</h4><blockquote><p>以有符号的char为例。</p></blockquote><table><thead><tr><th></th><th>原码范围</th><th></th></tr></thead><tbody><tr><td>正数</td><td>0000 0000 ～ 0111 111</td><td>+0 ～ +127</td></tr><tr><td>负数</td><td>1000 0000 ～ 1111111</td><td>-0 ～ -127</td></tr><tr><td><mark>特殊</mark></td><td><mark>1000 0000 不等于-0，等于-128</mark></td><td><mark>-128</mark></td></tr></tbody></table><p><strong>原因</strong>：因为-127 + -1 = <code>1 1000 0000</code> 即-128，舍去符号位1，将 <code>1000 0000</code> 当作 -128。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">1000</span> <span class="hljs-number">0001</span>（-<span class="hljs-number">127</span>的补码）<br>  <span class="hljs-attribute">1111</span> <span class="hljs-number">1111</span>（-<span class="hljs-number">1</span>的补码）<br><span class="hljs-attribute">1</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span>（-<span class="hljs-number">127</span> + -<span class="hljs-number">1</span>  = -<span class="hljs-number">128</span>的补码）<br></code></pre></td></tr></table></figure><h4 id="3-数值越界">(3)数值越界</h4><p>化为补码运算后，舍弃高位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a = <span class="hljs-number">255</span> + <span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>, a);  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>PS：以下不是数值越界情况，<code>a + 2</code> 是另外一块存储单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a = <span class="hljs-number">255</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>, a + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 257</span><br></code></pre></td></tr></table></figure><h3 id="7-关键字：signed、unsigned">7.关键字：signed、unsigned</h3><ul><li>signed 表示 有符号，数据类型默认有符号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">signed</span> <span class="hljs-type">int</span> a = <span class="hljs-number">-1</span>;    <span class="hljs-comment">/*等价于*/</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><ul><li>unsigned 表示 无符号。</li><li>无符号打印用 <code>%u</code>，打印的是补码，所以不能打印负数！。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>print(<span class="hljs-string">&quot;%u&quot;</span>, a);<br></code></pre></td></tr></table></figure><h2 id="005-输出">005.输出</h2><h3 id="1-格式">1.格式</h3><table><thead><tr><th>类型</th><th>格式</th></tr></thead><tbody><tr><td>short</td><td>%hd</td></tr><tr><td>long</td><td>%ld</td></tr><tr><td>unsigned int</td><td>%u</td></tr><tr><td>long</td><td>%ld</td></tr><tr><td>long long</td><td>%lld</td></tr><tr><td>unsigned long long</td><td>%ull</td></tr><tr><td>以16进制打印指针</td><td>%p</td></tr><tr><td>打印%</td><td>%%</td></tr></tbody></table><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>光标切换到句首，【删除本行】<br>用处：进度条，倒计时</td></tr><tr><td>\b</td><td>退格，【删除一个字符】</td></tr><tr><td>\123</td><td>八进制转义字符</td></tr><tr><td>\x23</td><td>十六进制转义字符</td></tr><tr><td>“\0123”</td><td>字符串中 “\0123” 表示 \n，</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-string">&#x27;\123&#x27;</span>);   <span class="hljs-comment">//0123 = 10</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-string">&#x27;\0x23&#x27;</span>);  <span class="hljs-comment">//0x23 = 35</span><br></code></pre></td></tr></table></figure><ul><li>double 和 float 输出默认六位小数，<strong>格式化输出除外。</strong></li></ul><h3 id="2-调试">2.调试</h3><blockquote><p>用于打印调试日志。</p></blockquote><p><code>__FILE__</code> 、<code>__LINE__</code> 是系统设置好的。⚠️注意：<code>__FILE__</code> 、<code>__LINE__</code> 是左右各两个下划线连在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file = %s\n&quot;</span>, __FILE__);   <span class="hljs-comment">// 文件目录打印</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line = %d\n&quot;</span>, __LINE__);   <span class="hljs-comment">// 该行代码所在行</span><br></code></pre></td></tr></table></figure><h3 id="3-补充：取余和取模的区别">3.补充：取余和取模的区别</h3><ul><li>同号取余取模结果一致。</li><li>异号结果不一致</li></ul><p><strong>举例</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 取余</span><br><span class="hljs-number">-7</span> % <span class="hljs-number">4</span> = <span class="hljs-number">-3</span><br><span class="hljs-number">7</span> % <span class="hljs-number">-4</span> = <span class="hljs-number">3</span><br>  <br><span class="hljs-comment">// 取模</span><br><span class="hljs-number">-7</span> mod <span class="hljs-number">4</span> = <span class="hljs-number">1</span><br><span class="hljs-number">7</span> mod <span class="hljs-number">-4</span> = <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>本质</strong>：取余和取模都是以下两步</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">商 = a / b;<br>取余或取模 = a - (商 * b);<br></code></pre></td></tr></table></figure><p>取余和取模的区别就在于第一步求商这步：</p><ul><li>取余：-7 / 4 = -1.75，取余会靠近 <strong>0</strong> 舍入，商 = -1。</li><li>取模：-7 / 4 = -1.75，取模会靠近 <strong>负无穷大</strong> 舍入，商 = -2。</li></ul><p>第二步相同。</p><h2 id="006-各进制的储存方式">006.各进制的储存方式</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>十进制DEC</td><td>直接写</td><td>%d</td></tr><tr><td>八进制OCT</td><td>以0开头：<strong>int a =0123</strong></td><td>%o【默认以四个字节输出】</td></tr><tr><td>十六进制HEX</td><td>以0x开头：<strong>int a = 0x123</strong></td><td>%x【默认以四个字节输出】<br>%X（即大写字母十六进制输出）</td></tr><tr><td>二进制BIN</td><td><mark>C语言不能直接表示</mark></td><td></td></tr></tbody></table><p><strong>注意事项</strong>：</p><ul><li><p><mark>输入输出十进制，计算机默认输入输出的是 原码。</mark></p></li><li><p><mark>输入输出八进制 / 十六进制，计算机默认输入输出的是 补码。</mark></p></li><li><p>正数原码补码一致，所以无影响。</p></li></ul><p><strong>举例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 输入为十六进制（补码），输出为十进制（原码）</span><br><span class="hljs-type">char</span> a = <span class="hljs-number">0x81</span>;      <span class="hljs-comment">//补码：1000 0001</span><br>pritnf(<span class="hljs-string">&quot;%d&quot;</span>, a);    <span class="hljs-comment">//原码：1111 1111 = -127</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 输入为十进制（原码），输出为十六进制（补码）</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">-1</span>;        <span class="hljs-comment">//原码：1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0x&quot;</span>, a)      <span class="hljs-comment">//补码：1111 1111 1111 1111 1111 1111 1111 1111 = ffff ffff</span><br></code></pre></td></tr></table></figure><p>PS：<code>%0x</code> 以四个字节输出，（32位）。</p><h2 id="007-关键字：define、类型限定符">007.关键字：define、类型限定符</h2><blockquote><p><strong>类型限定符</strong>：extern、const、volatile、register。</p></blockquote><h3 id="1-define">1.define</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000   <span class="hljs-comment">//结尾没有分号</span></span><br></code></pre></td></tr></table></figure><ul><li>作用：定义一个宏定义标示符MAX，它代表1000。</li><li>#号开头的语句是预处理语句，（预处理时，MAX将自动替换为1000），<em><strong>无需分号结束。</strong></em></li></ul><h3 id="2-extern">2.extern</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b；  <span class="hljs-comment">//未建立储存空间</span><br></code></pre></td></tr></table></figure><ul><li>int a 是既声明，又定义。</li><li>extern int a 是声明，未定义（即未建立储存空间）。</li></ul><h3 id="3-const">3.const</h3><blockquote><p>constant 的缩写。</p></blockquote><h4 id="（1）修饰只读变量">（1）修饰只读变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>；<br></code></pre></td></tr></table></figure><h4 id="（2）易错">（2）易错</h4><ul><li>必须初始化。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a;      <span class="hljs-comment">// 非法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><ul><li>如何在另一.c源文件中引用const常量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">//合法</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> j=<span class="hljs-number">10</span>; <span class="hljs-comment">//非法，常量不可以被再次赋值</span><br></code></pre></td></tr></table></figure><h4 id="（3）好处">（3）好处</h4><ul><li>可以避免不必要的内存分配。（define 有若干个拷贝，const 只有一份拷贝，不会浪费内存。）</li><li>指针做函数参数，可以有效的提高代码可读性，减少bug。</li></ul><h3 id="4-volatile">4.volatile</h3><p>防止编译器优化代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a = i;<br><span class="hljs-type">int</span> b = i;<br></code></pre></td></tr></table></figure><ul><li>编译器优化代码：当编译器发现，第2行 和 第3行之间没有代码对 <strong>i</strong> 的值进行改变，自动把上次读的 <strong>i</strong>值 放在 b 中。</li><li><code>volatile</code> 关键字声明 变量<strong>i</strong> 之后，告诉编译器 <strong>i</strong> 易变（受操作系统、硬件或者其它线程的影响）， 编译器每次都需要在 <strong>i</strong> 的地址处读取 <strong>i</strong> 值。</li></ul><h3 id="5-register">5.register</h3><blockquote><p>register：寄存器</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>；<br></code></pre></td></tr></table></figure><ul><li>定义寄存器变量，如果CPU有空闲寄存器，将a存入寄存器，提高效率。</li></ul><h2 id="008-switch语句">008.switch语句</h2><p>case 数字或者字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (a) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> :  <br>    pass;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> : <br>    pass;<br>  <span class="hljs-keyword">default</span> : <br>    pass;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>括号内的a只能是 <strong>整型</strong> 或者 <strong>字符型。</strong></li></ul><h2 id="009-随机数">009.随机数</h2><ol><li><code>void srand(unsigned int seed);</code> 设置rand()产生随机数时的随机种子seed。</li><li><code>int rand(void)</code> rand()返回一个随机数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span>     <span class="hljs-comment">//time()函数的头文件，用 time() 的返回值做seed</span></span><br>srand((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)time(<span class="hljs-literal">NULL</span>));   <span class="hljs-comment">//设置随机数种子</span><br>random_num = rand();   <span class="hljs-comment">//产生随机数</span><br></code></pre></td></tr></table></figure><h2 id="010-getchar-吞掉回车">010.getchar() 吞掉回车</h2><blockquote><p>读入字符的时候，一定要注意！利用getchar() 清空 stdin 的缓冲区。</p></blockquote><p>【<strong>两种场景</strong>】</p><ol><li>先读入一个字符串，再读入一个字符</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>...<br>    <span class="hljs-comment">// 中间有上万行代码，只要没有处理 stdin 的缓冲区。</span><br>...<br>sacnf(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br></code></pre></td></tr></table></figure><ol start="2"><li>先读入一个字符，再读入一个字符</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch1);<br>...<br>    <span class="hljs-comment">// 中间有上万行代码，只要没有处理 stdin 的缓冲区。</span><br>...<br>sacnf(<span class="hljs-string">&quot;%c&quot;</span>, ch2);<br></code></pre></td></tr></table></figure><p>【<strong>原因</strong>】</p><p>键盘输入的字符，会放到缓冲区，<code>scanf</code> 函数从缓冲区中读取。读取字符的时候，可以读 <code>‘\n’</code> 。读字符串时，不会读入<code>\n</code>，所以不需要 <code>getchar()</code>。</p><p>以两个c为例，键盘上敲出，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">c<br>c<br></code></pre></td></tr></table></figure><p>缓冲区中显示如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">c\nc<br></code></pre></td></tr></table></figure><p><code>scanf(“%c”, ch)</code> 会读取一个 <code>\n</code>。</p><h2 id="011-字符数组和字符串">011.字符数组和字符串</h2><h3 id="1-区别">1.区别</h3><p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//字符数组</span><br><span class="hljs-type">char</span> a[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;   <span class="hljs-comment">//sizeof(a) = 3</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;abc&quot;</span>;           <span class="hljs-comment">//zizeof(a) = 3   【如果没有内存空间补0，就是字符数组】</span><br><span class="hljs-comment">//注意 char a[3] = &quot;abc&quot;; c++ b允许这么使用，用 const char[4] 来初始化 char[3]</span><br><br><span class="hljs-comment">//字符串， %s输出到0停止，sizeof(a) = 4</span><br><span class="hljs-type">char</span> a[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> a[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;  <span class="hljs-comment">//&#x27;\0&#x27; 和 0 一样</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;      <span class="hljs-comment">//限定长度，后7位自动补0，（结束符）</span><br><br><span class="hljs-comment">//字符串，结尾自动加&#x27;\0&#x27;，会隐藏，但是占大小</span><br><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;abc&quot;</span>;            <span class="hljs-comment">//sizeof(a) = 4</span><br></code></pre></td></tr></table></figure><h3 id="2-字符串越界">2.字符串越界</h3><p>定义字符串时，初始化内容的长度大于定义的字符串，就会越界。</p><h3 id="3-字符串初始化原理">3.字符串初始化原理</h3><p><code>&quot;abcdef&quot;</code> 储存在文字常量区，<code>a[]</code> 内存空间在栈区，初始化时，将文字常量区的内容 <code>&quot;abcdef&quot;</code> ，拷贝到栈区 的 <code>a[]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="012-字符串处理函数">012.字符串处理函数</h2><h3 id="1-gets">1.gets()</h3><p>可以读取空格，<strong>不推荐使用。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 可以读取空格</span><br><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>];<br>gets(a);<br><span class="hljs-comment">//返回值：成功：读入的字符串。失败：NULL</span><br></code></pre></td></tr></table></figure><h3 id="2-fgets-a-name-fgets-a">2.fgets() <a name="fgets()"></a></h3><blockquote><p>三个要点：</p><p>1.写入会覆盖字符串。</p><p>2.stdin 内容 &lt; size，写入时自动增加一个换行符。</p><p>3.当 stdin 什么都没有时，由于stdin 内容 &lt; size，写入时自动增加一个换行符。</p></blockquote><p>读取回车、空格，推荐使用。</p><p>读取遇到换行符，结束本次读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-comment">//stream：文件指针，如果读键盘输入的字符串，固定写为 stdin</span><br><br><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-string">&quot;原来的文字将会被覆盖掉&quot;</span>&#125;;<br><span class="hljs-comment">// 1.如果输入内容 &gt; sizeof(a)-1，只读取 sizeof(a)-1 个字符</span><br><span class="hljs-comment">// 2.如果输入内容 &lt; sizeof(a)-1，会读取换行符【重要！会增加一个换行符】</span><br></code></pre></td></tr></table></figure><h3 id="3-fputs-a-name-fputs-a">3.fputs()<a name="fputs()"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-built_in">fputs</span>(a, <span class="hljs-built_in">stdout</span>);  <span class="hljs-comment">//stdout是设备文件指针，往屏幕上输出，固定写 stdout</span><br><br>FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;abc&quot;</span>, fp);   <span class="hljs-comment">// 将“abc”的指针，输出到 文件指针 fp 所关联的文件1.txt</span><br></code></pre></td></tr></table></figure><h3 id="4-strlen">4.strlen()</h3><p>计算字符串长度（不算结束符 “\0”）（“\n” 算一个字符）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);  <span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><p><code>strlen()</code>：从首元素开始，到结束符为止的长度（不计算结束符）。</p><p><code>sizeof()</code>：计算数据类型的长度，不会因为结束符停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">strlen</span>(a);  <span class="hljs-comment">//3</span><br><span class="hljs-keyword">sizeof</span>(a);  <span class="hljs-comment">//100</span><br></code></pre></td></tr></table></figure><h3 id="5-strcpy">5.strcpy</h3><p>拷贝字符串，自动加’\0’。</p><p><strong>重要</strong>：遇到 ‘\0’ 停止拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> old[] = <span class="hljs-string">&quot;abcdef\0gjk&quot;</span>;<br><span class="hljs-type">char</span> new[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">strcpy</span>(new, old);  <span class="hljs-comment">//拷贝到 结束符&#x27;\0&#x27;，并自动加&#x27;\0&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="6-strncpy">6.strncpy</h3><p>拷贝指定n个字符，不自动加’\0’。</p><p><strong>重要</strong>：遇到 ‘\0’ 停止拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> old[] = <span class="hljs-string">&quot;abcdef\0gjk&quot;</span>;<br><span class="hljs-type">char</span> new01[<span class="hljs-number">100</span>];<br><span class="hljs-type">char</span> new02[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// old 是指针（首地址）</span><br><span class="hljs-built_in">strncpy</span>(new01, old, n);  <span class="hljs-comment">//指定拷贝3个字符(不自动加&#x27;\0&#x27;)</span><br><br><span class="hljs-comment">//1. 若 n&gt;strlen(old)，拷贝到‘\0’（包含）</span><br><span class="hljs-comment">//2. 若 n&lt;strlen(old)，拷贝n个字符，不自动加&#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7-strcmp">7.strcmp</h3><blockquote><p>判断字符串是否相同。</p></blockquote><p>比较字符串大小（一个字母字母比较）。<br>注意：strcmp 传入参数时需保证参数不为 NULL/nullptr，因为 strcmp 实现中会直接取*，若是 NULL/nullptr，会报段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> str2 = <span class="hljs-string">&quot;bac&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(str1, str2) &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 &gt; str2&quot;</span>);<br><br><span class="hljs-comment">//返回值：</span><br><span class="hljs-comment">//1.相等 =0</span><br><span class="hljs-comment">//2.大于 &gt;0</span><br><span class="hljs-comment">//3.小于 &lt;0</span><br></code></pre></td></tr></table></figure><p>附：<strong>字符串比较问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// char * 类型 [不可以使用 == 比较]</span><br><span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">printf</span>(str1 == str2)   <span class="hljs-comment">// 打印 1，表示 str1 和 str2 指向的地址相同。</span><br><span class="hljs-comment">// 这里 == 比较的是 str1 和 str2 存的数据，也就是 “abc” 的地址。“abc” 是在文字常量区。</span><br><br><br><span class="hljs-comment">// char 数组类型 [不可以使用 == 比较]</span><br><span class="hljs-type">char</span> str3[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> str4[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">printf</span>(str1 == str2)   <span class="hljs-comment">// 打印 0, 表示 str3 和 str4 指向的地址不同。</span><br><span class="hljs-comment">// char 数组内存空间在栈区，str3 和 str4 分别指向两块内存空间。</span><br><br><br><span class="hljs-comment">// c++ 中的 string 类型 [可以使用 == 比较]</span><br><span class="hljs-built_in">string</span> str5 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">string</span> str6 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">printf</span>(str1 == str2) <span class="hljs-comment">// 打印 1, string 类重载了 == 操作符</span><br><br></code></pre></td></tr></table></figure><h3 id="8-strncmp">8.strncmp</h3><p>判断指定n个字母的大小。<br>注意：与 strcmp 一样，传入参数时需保证参数不为 NULL/nullptr，因为 strncmp 实现中会直接取*，若是 NULL/nullptr，会报段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> str2 = <span class="hljs-string">&quot;bac&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(str1, str2，<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 和 str2的前两个字母 相同&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="9-strcat">9.strcat</h3><p>将 str2 追加在 str1 后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> str2 = <span class="hljs-string">&quot;def&quot;</span>;<br><span class="hljs-built_in">strcat</span>(str1, str2);  <span class="hljs-comment">//str1 = &quot;abcdef&quot;</span><br></code></pre></td></tr></table></figure><p><strong>存疑</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;abcaaaaa11111111111111121sdfhaljashdflhfsdajlshdlfjsdhfljhldfjashfldajsdfhljksdfhljksfdhljksfdahljkfdhljkdfhljkfdhjklshfjklsfhlkjfsadhjklafdhjklfadhjkldfaljhkfadjklfsadjlsfahdjlhfjldahdfjlsaldhfsjalhjkdlfhdsaahlfsjdahsldjsfldhjalhfjdhljfdaahsjfdhljdsdflhklsdfkajhjfsdlahfjsdhfsdjkalhdfksljfdhjkasfhjklhfsajlfsahjkfdhskjafdskhjlfdshkldfhsklhlsfhfsdlshdflkshdfhskdhfhfdkjshsafhdlklasfdhk323342egwyrgyasdhljsdfhlkashfklsdhfkjsdfklhasadlhsdjlfhalshjdsljahkdfaljkdflhjkasfhkjlsafdkljlfsahjkfsahlkfsahlkdafldhjshfladhslfjkadhjfdshjflsfhajldhjlfhfjlhlflhkjlhksaklhsfhdklsdhfjklsaldfhasdjhlfsjldhkfjhkdljkhdfaljkhadjkfdhalkfadshlsdafjklsfdkjlsfkjlsjhkflddfjkhlhjfdklfdajkhlfjkhlhjklsfdhjsfklajksfldajkhlfkhsfhkfshjkfslhfjsdlewgfy83hfuehfjkashfjhsdfhgwieuhfuishflsdf&quot;</span>;<br>    <span class="hljs-type">char</span> b[] = <span class="hljs-string">&quot;1234567890&quot;</span>;<br>    <span class="hljs-built_in">strcat</span>(a, b);<br>    cout &lt;&lt; a;<br>&#125;<br><br><span class="hljs-comment">// 当 a 字符串过长，追加会报错。【待解决】</span><br></code></pre></td></tr></table></figure><p>但是若是定义a 的空间大一些，就不会错。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;abcaaaaa11111111111111121sdfhaljashdflhfsdajlshdlfjsdhfljhldfjashfldajsdfhljksdfhljksfdhljksfdahljkfdhljkdfhljkfdhjklshfjklsfhlkjfsadhjklafdhjklfadhjkldfaljhkfadjklfsadjlsfahdjlhfjldahdfjlsaldhfsjalhjkdlfhdsaahlfsjdahsldjsfldhjalhfjdhljfdaahsjfdhljdsdflhklsdfkajhjfsdlahfjsdhfsdjkalhdfksljfdhjkasfhjklhfsajlfsahjkfdhskjafdskhjlfdshkldfhsklhlsfhfsdlshdflkshdfhskdhfhfdkjshsafhdlklasfdhk323342egwyrgyasdhljsdfhlkashfklsdhfkjsdfklhasadlhsdjlfhalshjdsljahkdfaljkdflhjkasfhkjlsafdkljlfsahjkfsahlkfsahlkdafldhjshfladhslfjkadhjfdshjflsfhajldhjlfhfjlhlflhkjlhksaklhsfhdklsdhfjklsaldfhasdjhlfsjldhkfjhkdljkhdfaljkhadjkfdhalkfadshlsdafjklsfdkjlsfkjlsjhkflddfjkhlhjfdklfdajkhlfjkhlhjklsfdhjsfklajksfldajkhlfkhsfhkfshjkfslhfjsdlewgfy83hfuehfjkashfjhsdfhgwieuhfuishflsdf&quot;</span>;<br>    <span class="hljs-type">char</span> b[] = <span class="hljs-string">&quot;1234567890&quot;</span>;<br>    <span class="hljs-built_in">strcat</span>(a, b);<br>    cout &lt;&lt; a;<br>&#125;<br><span class="hljs-comment">// 正确执行</span><br></code></pre></td></tr></table></figure><h3 id="10-strncat">10.strncat</h3><p>将 指定长度的 str2 追加在 str1 后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> str2 = <span class="hljs-string">&quot;def&quot;</span>;<br><span class="hljs-built_in">strcat</span>(str1, str2, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;cd&quot;</span>));  <span class="hljs-comment">//str1 = &quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><h3 id="11-sprintf">11.sprintf</h3><p>格式化一个字符串，并输出到指定数组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>；<br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> dst[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sprintf</span>(dst, <span class="hljs-string">&quot;a = %d, str = %s&quot;</span>, a, str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, dst);   <span class="hljs-comment">//a = 10, str = abc</span><br></code></pre></td></tr></table></figure><h3 id="12-sscanf">12.sscanf</h3><p>从字符串数组中按指定格提取内容（便于提取数字）。</p><h4 id="（1）提取数字">（1）提取数字</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;a = 1, b = 2, c = 3&quot;</span>;<br><span class="hljs-type">int</span> a, b, c;<br><span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;a = %d, b = %d, c = %d&quot;</span>, &amp;a, &amp;b, &amp;c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, a, b, c);    <span class="hljs-comment">//1 2 3   </span><br></code></pre></td></tr></table></figure><h4 id="（2）提取字符">（2）提取字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello world my friend&quot;</span>  <span class="hljs-comment">//提取字符串，默认以空格分割</span><br><span class="hljs-type">char</span> m[<span class="hljs-number">10</span>], n[<span class="hljs-number">10</span>], k[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%s %s %s&quot;</span>, m, n, k);  <span class="hljs-comment">//不用取地址&amp;，数组名就是首元素地址</span><br>pritnf(<span class="hljs-string">&quot;%s %s %s&quot;</span>, m, n, k);<br></code></pre></td></tr></table></figure><h3 id="13-strchr">13.strchr</h3><p>查询字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;d&#x27;</span>);   <br><span class="hljs-comment">// 在 buf 中查询字符&#x27;d&#x27;</span><br><span class="hljs-comment">// 若找到，返回d所在位置地址，若失败，返回NULL</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);    <span class="hljs-comment">//打印 d 开始的字符串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//只打印 d</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-strstr">14.strstr</h3><h4 id="（1）查询字符串">（1）查询字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">strstr</span>(buf, <span class="hljs-string">&quot;abc&quot;</span>);   <br><span class="hljs-comment">// 在 buf 中查询字符串 &quot;abc&quot;</span><br><span class="hljs-comment">// 若找到，返回 a 所在位置地址，若失败，返回NULL</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询失败&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）模型｜查找字符串个数">（2）模型｜查找字符串个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 查找匹配字符串的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;12abc23dasdabcrweqabc&quot;</span>;<br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//tmp 标记当前查找到的位置，若为NULL，表示没查到</span><br>        tmp = <span class="hljs-built_in">strstr</span>(p, <span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            n ++;<br>            p = tmp + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-strtok">15.strtok</h3><p>字符串分割，会更改原字符串，记得备份。</p><ol><li>第一次调用，参数写原字符串地址。</li><li>第二次起调用，参数写NULL。</li><li>每次调用，返回值为切割的字符串地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;abc,edf,mnk,110&quot;</span>;<br><span class="hljs-comment">// 第一次调用，第一个参数写原字符串地址，第二个参数写分割符</span><br><span class="hljs-type">char</span> *P = strtok(buf, <span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-comment">//若分割成功，p = 字符串地址。若失败（即无内容可分），则 p = NULL</span><br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p);<br>    <span class="hljs-comment">// 第二次起调用，第一个参数写NULL，第二个参数写分割符</span><br>     p = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>具体样例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;abc，edf&quot;</span>;<br><span class="hljs-type">char</span> *p = strtok(buf, <span class="hljs-string">&quot;,&quot;</span>);  <span class="hljs-comment">// 此时 buf[] = &quot;abc&quot;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);             <span class="hljs-comment">//abc</span><br>p = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;,&quot;</span>);      <span class="hljs-comment">// 第二次参数使用NULL</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);             <span class="hljs-comment">//edf</span><br></code></pre></td></tr></table></figure><h3 id="16-atoi">16.atoi</h3><p>将字符串转化为整型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abc123&quot;</span>;<br><span class="hljs-type">int</span> num = atoi(str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num);    <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><h3 id="17-atof">17.atof</h3><p>将字符串转化为浮点型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;0.123&quot;</span>;<br><span class="hljs-type">double</span> num = atof(str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, num);    <span class="hljs-comment">//0.123</span><br></code></pre></td></tr></table></figure><h3 id="18-atol">18.atol</h3><p>将字符串转化为长整型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abc123&quot;</span>;<br><span class="hljs-type">long</span> num = atoi(str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, num);    <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><h2 id="013-字符串常用模型">013.字符串常用模型</h2><h3 id="1-两头堵模型">1.两头堵模型</h3><p>有一个字符串，开头或结尾含有n个空格， (&quot; abcdefgdddd &quot;)，欲去掉前后空格，返回一个新字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">trimSpace</span><span class="hljs-params">(<span class="hljs-type">char</span> *inbuf, <span class="hljs-type">char</span> *outbuf)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inbuf == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> *begin = inbuf, *end = inbuf + <span class="hljs-built_in">strlen</span>(inbuf) - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; end) &#123;<br>        <span class="hljs-keyword">if</span> (*begin == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            begin++;<br>            end--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    outbuf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(end - begin + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">strncpy</span>(outbuf, begin, end - begin + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> outbuf;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *inbuf = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">char</span> *outbuf = <span class="hljs-literal">NULL</span>;<br>    outbuf = trimSpace(inbuf, outbuf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, outbuf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-字符串反转模型">2.字符串反转模型</h3><blockquote><p>例如：“abcd” 变为 “dcba”。</p></blockquote><h4 id="（1）传统解法">（1）传统解法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">inverse</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> lens = (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-type">char</span> *head = <span class="hljs-literal">NULL</span>, *end = <span class="hljs-literal">NULL</span>;<br>    head = str;<br>    end = str + lens - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (head &lt; end) &#123;<br>        <span class="hljs-type">char</span> tmp = *head;<br>        *head = *end;<br>        *end = tmp;<br>        head ++;<br>        end --;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）递归解法">（2）递归解法</h4><blockquote><p>非常巧妙，<code>strncat(buf, str, 1);</code> 一定要放在 <code>inverse(str+1);</code> 后面，这样才能先写入后面的数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">char</span> g_buf[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">inverse</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    inverse(str+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">strncat</span>(g_buf, str, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="014-分文件编程-a-name-分文件编程-a">014.分文件编程 <a name="分文件编程"></a></h2><h3 id="1-文件功能">1.文件功能</h3><ol><li>main.c</li></ol><blockquote><p>调用自己的头文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>my.h</li></ol><blockquote><p>放置函数声明，避免每调用一次，都要写无数条函数声明。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_fun01</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">my_fun02</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>my_fun.c</li></ol><blockquote><p>写函数的具体实现。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_fun01</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">my_fun02</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-防止头文件重复包含">2.防止头文件重复包含</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><h2 id="015-指针">015.指针</h2><h3 id="1-野指针">1.野指针</h3><p>野指针：保存非法地址的指针。</p><p>非法地址：只有定义后的变量的地址才是合法地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p;<br>p = <span class="hljs-number">0x1234</span>;    <br>*p = <span class="hljs-number">1</span>;     <span class="hljs-comment">//操作野指针所指向的内存 将导致段错误</span><br></code></pre></td></tr></table></figure><h3 id="2-空指针">2.空指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// p1, p2都是空指针</span><br><span class="hljs-type">int</span> *p1;<br><span class="hljs-type">int</span> *p2 = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="3-指针大小">3.指针大小</h3><p>32位编辑器 用32位（4字节）存指针。</p><p>64位编辑器 用64位（8字节）存指针。</p><h3 id="4-多级指针">4.多级指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1 = &amp;a;<br><span class="hljs-type">int</span> **p2 = &amp;p1;<br><span class="hljs-type">int</span> ***p3 = &amp;p2;<br></code></pre></td></tr></table></figure><h3 id="5-p-等价于-p-0">5.*p 等价于 p[0]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p = &amp;a;<br></code></pre></td></tr></table></figure><p>变量a 大小为4个字节，由四个地址储存。p 是指向 a 的首地址，等价于 p[0]。</p><p><strong>PS</strong>：p[1] 等价于 *(p + 1)，即p加上4字节，野指针不能用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br><span class="hljs-comment">// 如果是数组的话，p[1] 等价于 *(p + 1)，数值刚好是 a[1];</span><br></code></pre></td></tr></table></figure><h3 id="6-指针步长">6.指针步长</h3><p>p+1，不是 <code>p中所指向的地址</code> + 1，而是 <code>p中所指向的地址</code> + <code>sizeof(数据类型)</code>。</p><h3 id="7-万能指针-a-name-万能指针-a">7.万能指针 <a name="万能指针"></a></h3><p>void * 定义的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// void a;  不能定义变量，因为不知道分配多大空间</span><br><span class="hljs-type">void</span> *p;   <span class="hljs-comment">//可以定义指针，因为64位编译器用 8字节 储存指针</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>p = &amp;a; <br>*(<span class="hljs-type">int</span> *)p = <span class="hljs-number">11</span>;  <span class="hljs-comment">// 为什么要类型转换？ 因为*p 不知道要操作多大内存（p指向的是首地址）</span><br></code></pre></td></tr></table></figure><h3 id="8-const修饰指针">8.const修饰指针</h3><p>（1）const * 表示指针所指向的变量只读。</p><blockquote><p>const 修饰 *</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p1 = &amp;a;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p2 = &amp;a;  <span class="hljs-comment">// 两种写法都可以</span><br>p = <span class="hljs-literal">NULL</span>;            <span class="hljs-comment">//不能通过 *p 修改 a的值，但可以修改 p 的值</span><br></code></pre></td></tr></table></figure><p>（2）* const p 表示指针变量只读。</p><blockquote><p>const 修饰 p</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br>*p = <span class="hljs-number">100</span>; <span class="hljs-comment">// 可以通过 *p 修改a的值，但是不能修改 p 的值</span><br>p = <span class="hljs-literal">NULL</span> <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><p>（3）双const</p><blockquote><p>指针和指针所指变量的值都不能修改。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure><h3 id="9-形参中的数组退化为指针">9.形参中的数组退化为指针</h3><p>形参中的 <code>a[]</code> 是指针，写 <code>int *a</code> <code>int a[100]</code> <code>int a[]</code>是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) <span class="hljs-comment">//无法求出数组长度，sizeof(a) = 64位/32位</span><br>    <span class="hljs-comment">//a[1] 表示 *(a + 1)</span><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    fun(a);            <span class="hljs-comment">//传入的是指针（数组首地址）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>PS：补充见 015.13.(2) <a href="#形参中不能用 char **a 代替 char a[][10]">形参中不能用 <code>char **a</code> 代替 <code>char a[][10]</code></a></p><h3 id="10-字符串常量地址相同">10.字符串常量地址相同</h3><ol><li>字符串常量 放在 data 区，相同的常量，地址相同。</li><li>【<strong>每个字符串都是一个地址</strong>】，这个地址是字符串首地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//0x123</span><br>    fun();                  <span class="hljs-comment">//0x123</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, *(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">//h   //&quot;hello&quot; 表示 字符串的首地址【重要】</span><br>&#125;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// 表示 指针p 指向 &quot;hello&quot; 表示的地址</span><br></code></pre></td></tr></table></figure><h3 id="11-数组名">11.数组名</h3><h4 id="（1）数组名是常量">（1）数组名是常量</h4><p>数组只有定义的时候可以初始化！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//1. 数组名 始终储存着 数组首元素地址，即 a == &amp;a[0]</span><br>a = &#123;<span class="hljs-number">10</span>&#125;;  <span class="hljs-comment">//error  //2. 数组名是常量，不允许修改</span><br><br>---------------------------------------------------<br><br><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];<br>a = <span class="hljs-string">&quot;abc&quot;</span>;    <span class="hljs-comment">//error   //见 2</span><br><span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;abc&quot;</span>);   <span class="hljs-comment">//【解决方案】</span><br></code></pre></td></tr></table></figure><h4 id="（2）数组名b、-b-的数据类型不一样">（2）数组名<code>b</code>、<code>&amp;b</code> 的数据类型不一样</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p><code>b</code> 表示首元素的地址。<code>b + 1</code> 表示 首元素的地址加 4。</p><p><code>&amp;b</code> 表示整个数组的首地址。<code>&amp;b + 1</code> 表示 整个数组的首地址加 4 * 10。</p><h4 id="（3）二维数组数组名">（3）二维数组数组名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p><code>a</code> 、<code>&amp;a[0]</code> 表示 第 0 行首地址。步长：<code>sizeof(int [4])</code></p><p><code>a + i</code> 、<code>&amp;a[i]</code> 表示 第 i 行首地址。 步长：<code>sizeof(int [4])</code></p><p><code>*(a + i)</code> 、 <code>a[i]</code> 表示 第 i 行首元素地址。步长：<code>sizeof(int)</code></p><p><code>*(a + i) + j</code> 、 <code>&amp;a[i][j]</code> 表示 第 i 行第 j 列元素的地址。步长：<code>sizeof(int)</code></p><p><code>*(*(a + i) + j)</code> 、 <code>a[i][j]</code> 表示 第 i 行第 j 列元素的值。</p><p><code>&amp;a</code> 表示 整个数组的首地址，<code>&amp;a + 1</code> 表示 整个数组的首地址加 整个数组的大小。步长：<code>sizeof(int [4] * 3)</code></p><p>【<strong>辨析</strong>】:</p><p><code>&amp;a</code>：整个数组的首地址</p><p><code>a</code>、<code>a + 0</code>：第 0 行首地址，<code>&amp;a[0]</code>、<code>&amp;(*a)</code></p><p><code>*a</code>、<code>*(a + 0)</code>：第 0 行 第 0 个元素首地址，<code>a[0]</code></p><p><code>**a</code>、<code>*(*(a + 0) + 0)</code> ：第 0 行 第 0 个元素的值，<code>*a[0]</code>、<code>a[0][0]</code></p><h4 id="（4）二维数组的本质">（4）二维数组的本质</h4><p>二维数组的本质：一维数组；也可以看成若干个一维数组的组合。</p><p>将二维数组的每一行看作一个数组，有助于理解 数组指针。</p><p>另外，由于二维数组其实也是线性存储的，所以二维数组可以当一维数组输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> a_size = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    fun((<span class="hljs-type">int</span> *)a, a_size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）二维数组名的本质">（5）二维数组名的本质</h4><p>二维数组名的本质：数组指针。</p><p>通过 <code>+ i</code> 来指向若干个数组的首地址，<code>a</code> 表示第 0 行的首地址，<code>a + 1</code> 表示第 1 行的首地址。</p><h4 id="（6）二维数组求行数、列数">（6）二维数组求行数、列数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//第一个元素为0，初始化变量时，未提及的元素自动为0</span><br>line = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);        <span class="hljs-comment">//求行数</span><br>row = <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);   <span class="hljs-comment">// 求列数</span><br></code></pre></td></tr></table></figure><h3 id="12-指针数组">12.指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p[] = &#123;<span class="hljs-string">&quot;11111&quot;</span>, <span class="hljs-string">&quot;22222&quot;</span>, <span class="hljs-string">&quot;22333&quot;</span>&#125;;<br><span class="hljs-comment">// p[0] 指向 文字常量区的 “11111”，sizeof(p[0]) = 8 </span><br></code></pre></td></tr></table></figure><h3 id="13-数组指针">13.数组指针</h3><h4 id="（1）储存整个数组首地址">（1）储存整个数组首地址</h4><p>【<strong>一维数组</strong>】数组指针指向 一维数组 整个数组的首地址，<code>&amp;a</code> ，步长为整个数组的大小。</p><p>【<strong>二维数组</strong>】每一行是一个数组，数组指针指向 一维数组 整个数组的首地址（即每一行的首地址），<code>a</code>，表示第 0 行数组的首地址，步长为整个第 0 行数组的大小。</p><p>【<strong>注意</strong>】数组指针 p 的步长，是数据类型的大小，也就是整个数组的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义------------------------------------------------ */</span><br><span class="hljs-comment">// 第一种格式，【先定义数组类型，再定义数组指针】</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> A[<span class="hljs-number">10</span>];<br>A *p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 第二种格式，【先定义数组指针类型，再定义数组指针】</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*P)</span>[10];<br>P p = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 定义数组指针p</span><br><br><span class="hljs-comment">// 第三种，直接定义</span><br><span class="hljs-type">int</span>(*p)[<span class="hljs-number">10</span>];<br><br><span class="hljs-comment">/* --------------------------------------------------- */</span><br><span class="hljs-comment">// 1. 赋值，一维数组</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>p = &amp;a;<br><br><span class="hljs-comment">// 遍历一维数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0</span>; i++) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (*p)[i]);        <span class="hljs-comment">// *p 表示 *(&amp;a)，即 a，</span><br>&#125;<br><br><span class="hljs-comment">/* --------------------------------------------------- */</span><br><span class="hljs-comment">// 2. 赋值，二维数组</span><br><span class="hljs-type">int</span> b[<span class="hljs-number">2</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>p = b;<br><br><span class="hljs-comment">// 遍历二维数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p[i][j]);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）形参中不能用-char-a-代替-char-a-10-a-name-形参中不能用-char-a-代替-char-a-10-a">（2）形参中不能用 <code>char **a</code> 代替 <code>char a[][10]</code> <a name="形参中不能用 char **a 代替 char a[][10]"></a></h4><p>对于一维数组，函数形参中，写 <code>char a[]</code> 、<code>char a[100]</code> 、<code>char *a</code> 是一样的，均为 <code>char *</code> 类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 下面代码完全正确 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> n)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 指针步长为 sizeof(char) == 1</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>);<br>    fun(a, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是对于，二维数组，函数形参中不能用 <code>char **a</code> 代替 <code>char a[][10]</code>。</p><p>因为 <code>a[1]</code> 表示 <code>*(a + 1)</code> ，而 a 的步长是 <code>sizeof(char *) == 8</code> 。我们想要的步长是 10</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 下面代码错误：不能用 char **a 代替 char a[][10] */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> **a, <span class="hljs-type">int</span> n)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a + <span class="hljs-number">1</span>);    <span class="hljs-comment">//步长是 sizeof(char *) == 8</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    fun(a, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）改进办法1：形参中规定指针步长">（3）改进办法1：形参中规定指针步长</h4><p><code>void fun(char **a, int n);</code> 改为 <code>void fun(char a[3][10], int n);</code>、<code>fun(char a[][10], int n);</code>。</p><p>数组做形参都会退化成指针，即 a 是一个指针，所以<code>cahr a[3]</code> 、 <code>char a[]</code> 都是 <code>char *a</code> 的意思，指针 a 指向 数组的首地址，（每一行就是一个数组），<code>a + i</code> 表示 第 i 行的首地址，即第 i 行数组的首地址。</p><h4 id="（4）改进本法2：形参中用数组指针">（4）改进本法2：形参中用数组指针</h4><p><code>void fun(char **a, int n);</code> 改为 <code>void fun(char (*a)[10], int n);</code></p><p>传入的是数组的首地址，（每一行就是一个数组），即传入的是 每一行的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> (*a)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> n)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, a + <span class="hljs-number">1</span>);    <span class="hljs-comment">//步长是 sizeof(char *) == 10</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br>    fun(a, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-指针函数">14.指针函数</h3><p>返回指针类型的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="15-函数指针">15.函数指针</h3><blockquote><p>指向函数的指针。</p></blockquote><p>（1）先定义函数类型，再定义指针（不常用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun_01</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>  <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-comment">// 【定义】</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FUN</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;  <span class="hljs-comment">// FUN 是函数类型</span><br>FUN *p = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 函数指针变量，函数返回值和形参 必须和和 FUN 函数类型相同</span><br><br><span class="hljs-comment">// 【赋值】</span><br><span class="hljs-comment">// 下面两种赋值方式完全等价</span><br>p = &amp;fun_01;   <span class="hljs-comment">// 函数指针 p 指向 fun_01 函数</span><br>p = fun_01;<br><br><span class="hljs-comment">// 【使用】</span><br>fun(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 传统调用</span><br>p(<span class="hljs-number">6</span>);    <span class="hljs-comment">// 函数指针调用</span><br>(*p)(<span class="hljs-number">6</span>); <span class="hljs-comment">// 函数指针调用</span><br></code></pre></td></tr></table></figure><p>（2）先定义函数指针类型，根据类型定义指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义函数指针类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PFUN)</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;  <span class="hljs-comment">// a 可省略。typedef int (*PFUN)(int); </span><br><br><span class="hljs-comment">// 定义函数指针</span><br>PFUN p = fun_01  <span class="hljs-comment">// 函数指针 p 指向 fun_01 函数</span><br><br><span class="hljs-comment">// 使用</span><br>p(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p>（3）直接定义函数指针（常用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 第一种</span><br><span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> a) = fun_01;  <span class="hljs-comment">// a 可省略。int (*p)(int) = fun_01;</span><br>p(<span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// 第二种</span><br><span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span> a);<br>p = fun_01;<br>p(<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><h3 id="16-函数指针数组">16.函数指针数组</h3><blockquote><p>函数指针组成的数组。</p><p><code>int (*p_fun[5])() = &#123;add, subtract, multiply, divide, exit&#125;;</code> 大括号内写函数名。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">divide</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><p>没使用函数指针数组之前，制作菜单，根据命令调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> command[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;inputs your command please:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, command);<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;add&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            add();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;subtract&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            subtract();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;multiply&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            multiply();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;divide&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            divide();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;exit&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">exit</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用函数指针之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> command[<span class="hljs-number">100</span>]; <br>    <span class="hljs-type">int</span> (*p_fun[<span class="hljs-number">5</span>])() = &#123;add, subtract, multiply, divide, <span class="hljs-built_in">exit</span>&#125;; <span class="hljs-comment">/*【函数指针数组的定义】*/</span><br>    <span class="hljs-type">char</span> *command_str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;subtract&quot;</span>, <span class="hljs-string">&quot;multiply&quot;</span>, <span class="hljs-string">&quot;divide&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>&#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, command);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, *command_str[i]) == <span class="hljs-number">0</span>) &#123;<br>                p_fun[i]();     <span class="hljs-comment">// ⚠️注意：函数调用需要有个括号。</span><br>                <span class="hljs-keyword">break</span>；<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-回调函数">17.回调函数</h3><p>在函数中调用函数，通过传递不同的函数指针，实现同一个函数框架，调用不同的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-comment">// 框架</span><br><span class="hljs-comment">// a、b 可以省略。</span><br><span class="hljs-comment">// int fun(int x, int y, int (*p_fun)(int, int) /*回调函数*/ ) &#123;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> (*p_fun)(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-comment">/*回调函数*/</span> )</span> &#123;<br>    <span class="hljs-keyword">return</span> p_fun(x, y);<br>&#125;<br><br><span class="hljs-comment">// 主函数使用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = fun(a, b, add);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-指针易错">18.指针易错</h3><h4 id="（1）指针值传递">（1）指针值传递</h4><p>调用函数修改指针的值，需要传递的参数是 指针的地址，并用二级指针的来做形参，接收指针的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//【错误】：</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;   <span class="hljs-comment">//定义两个全局变量</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span> &#123;<br>    p = &amp;b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = &amp;a;<br>    fun(p);         <span class="hljs-comment">// 虽然传的参数是指针，但是是值传递。// 调用fun函数，无法改变 p 的值。 </span><br>&#125;<br><br><span class="hljs-comment">// 【改正】：</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> **p)</span> &#123;   <span class="hljs-comment">// 由于 p 是指针，所以要用二级指针来存 p 的地址。</span><br>    *p = &amp;b;            <span class="hljs-comment">// 用 *p 改变 p 所指向地址 所储存的值。 </span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = &amp;a;<br>    fun(&amp;p);         <span class="hljs-comment">// 要改变 p 的值，需要传递的参数是 p 的地址。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）二级指针没有空间">（2）二级指针没有空间</h4><p>一级指针没有指向内存空间，通过操作二级指针给一级指针所指内存拷贝内容。【内存污染】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pp 指向一个堆区空间，存放三个指针 pp[0], pp[1], pp[2] 的地址。</span><br><span class="hljs-type">char</span> **pp = (<span class="hljs-type">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *)); <br><span class="hljs-type">char</span> ch[] = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-built_in">strcpy</span>(pp[<span class="hljs-number">0</span>], ch);   <span class="hljs-comment">// error.  //pp[0] 没有指向任何空间，所以没有空间 存储字符串。</span><br></code></pre></td></tr></table></figure><h2 id="016-main-函数参数">016.main()函数参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br><span class="hljs-comment">// argv[] 是一个指针数组，但形参中用二级指针保存指针数组 argv[] 的首地址</span><br></code></pre></td></tr></table></figure><p><code>argc</code> 储存的是 <code>argv[]</code> 的 数组大小</p><p><code>argv[]</code> 存储的是命令 + 参数，举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[0] = %s\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[1] = %s\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 将此文件编译成二进制可执行文件，名叫 my_main</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. 在终端中执行该二进制文件，并添加参数：</span><br><span class="hljs-comment">./my_main abc</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3. 打印结果显示为</span><br><span class="hljs-comment">argv[0] = ./my_main</span><br><span class="hljs-comment">argv[1] = abc</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="017-内存管理">017.内存管理</h2><h3 id="1-普通局部变量">1.普通局部变量</h3><p>（1）作用域：括号</p><p>（2）离开{}，内存自动释放</p><p>（3）就近原则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">11</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);   <span class="hljs-comment">// a = 11</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-static局部变量">2.static局部变量</h3><p>（1）作用域：括号</p><p>（2）离开{}，不会释放；程序结束，static局部变量才自动释放【<strong>存储在data区</strong>，程序不结束，data区数据不释放】。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>    a ++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);    <span class="hljs-comment">//函数结束，a不释放</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    fun();   <span class="hljs-comment">//1</span><br>    fun();   <span class="hljs-comment">//2</span><br>    fun();   <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）data区数据，在编译阶段已分配空间，程序还没执行，static 局部变量就存在。</p><p>（4）static 局部变量不初始，值默认 = 0。多次调用初始化语句，只会执行一次。</p><p>（5）static 局部变量只能用常量初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> b = a; <span class="hljs-comment">//error //程序还没执行（a变量还没定义），static变量已存在</span><br></code></pre></td></tr></table></figure><h3 id="3-普通和static局部变量的区别">3.普通和static局部变量的区别</h3><p>（1）普通局部变量只有<strong>执行到定义变量的语句</strong>才分配空间；static局部变量<strong>编译时就分配空间。</strong></p><p>（2）普通局部变量<strong>离开{}</strong>，自动释放；static局部变量程序结束，自动释放。</p><p>（3）普通局部变量不初始化，值为随机数，static局部变量不初始化，值为0【初始化语句只执行一次】。</p><h3 id="4-全局变量">4.全局变量</h3><p>（1）使用变量时，前面没有变量定义，需声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(a);  <span class="hljs-comment">//使用变量时，前面未定义变量  //在第2行前面，extern int a;</span><br>&#125;<br><br><span class="hljs-type">int</span> a;     <span class="hljs-comment">//&#123;&#125;外定义全局变量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    fun();    <br>&#125;<br></code></pre></td></tr></table></figure><p>（2）分文件写，在main.c中定义，在头文件中声明。</p><ul><li><strong>为什么在头文件中声明？</strong> 避免函数需要进行多次声明。【见 <a href="#分文件编程">014.分文件编程 </a>】</li><li>**为什么在main.c中定义？**不能在头文件中定义，否则多次调用头文件时，会出现多次定义全局变量的问题。</li></ul><h3 id="5-static全局变量">5.static全局变量</h3><ul><li>static全局变量，只能在本文件中使用，不能在其他文件使用。</li><li>普通全局变量可以在所有文件中使用。</li></ul><h3 id="6-内存分区">6.内存分区</h3><h4 id="（1）内存四区">（1）内存四区</h4><ol><li><p>堆区 heap</p></li><li><p>栈区 stack</p><ul><li>局部变量</li></ul></li><li><p>全局区</p><ul><li>未初始化 bss<ul><li>静态变量</li><li>全局变量</li></ul></li><li>初始化 data<ul><li>静态变量</li><li>全局变量</li></ul></li><li>文字常量区</li></ul></li><li><p>代码区 code</p></li></ol><h4 id="（2）内存加载顺序">（2）内存加载顺序</h4><ul><li><p>当程序运行时，首先将以下几个确定的内存分区（code，data，bass）先加载：</p><ul><li>code（代码区）：只读，函数。</li><li>data：初始化的数据，全局变量，static 变量。</li><li>文字常量区（只读）。</li><li>bss：没有初始化的数据，全局变量，static变量。</li></ul></li><li><p>然后额外加载两个区：</p><ul><li>stack（栈区）：普通局部变量，自动管理内存，先进后出。</li><li>heap（堆区）：手动申请空间（malloc），手动释放（free），整个程序结束，系统自动回收。</li></ul></li></ul><h4 id="（3）栈区堆区扩展方向">（3）栈区堆区扩展方向</h4><p>栈区：从高地址向低地址扩展。</p><p>堆区：从低地址向高地址扩展</p><p><img src="https://hutu.aimtao.net/mark/2020-04-16-4hX36M.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="7-内存操作函数｜memset">7.内存操作函数｜memset</h3><blockquote><p>void 是万能指针，可以接收任何类型指针【见<a href="#万能指针">015.7.万能指针</a>】，size_t 是无符号整型。</p></blockquote><p>【<strong>特别注意</strong>】</p><p><code>memset(b, 0, sizeof(b))</code> 是对 <strong>每个字节</strong> 都赋值为 0；以64位 int 为例，四个字节分别赋值为 0（最后该数字还是等于0）。</p><p>【<strong>进一步探究</strong>】</p><p><strong>对于 char 而言</strong>，可以赋值任何字符，因为其只有一个字节。</p><p><strong>对于 int 而言</strong>，除了 0 之外，还可赋值为 -1、0x3f3f3f。</p><ol><li>当赋值为 -1，-1 的反码是 <code>1111 1111 1111 1111 1111 1111 1111 1111</code>，存入 1 字节就是 <code>1111 1111</code>，每个字节都是 <code>1111 1111</code> ，那四个字节就是 <code>1111 1111 1111 1111 1111 1111 1111 1111</code>，所以该 int 数字还是 -1。</li><li>当赋值为 0x3f3f3f，其反码是 0x3f3f3f，存入 1 字节就是 0x3f，每个字节都是 0x3f，那四个字节就是 0x3f3f3f，所以该 int 数字还是 0x3f3f3f。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">//将s的内存区域的前n个字符，以参数c填入【参数c，是以字符来处理，即ascii码】</span><br><br><span class="hljs-type">int</span> a；<br><span class="hljs-built_in">memset</span>(&amp;a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);    <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">memset</span>(&amp;a, <span class="hljs-number">97</span>, <span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, a)     <span class="hljs-comment">// c</span><br>  <br><span class="hljs-comment">//用处：清空数组</span><br><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(b));<br></code></pre></td></tr></table></figure><h3 id="8-内存操作函数｜memcpy">8.内存操作函数｜memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">//拷贝src所指内存的前n个字节，到dest所值的内存地址上</span><br><br><span class="hljs-type">char</span> p[] = <span class="hljs-string">&quot;hello\0world&quot;</span>;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><br><span class="hljs-built_in">memcpy</span>(buf, p, <span class="hljs-keyword">sizeof</span>(p));    <span class="hljs-comment">// buf[100] = &quot;hello\0world&quot;</span><br><span class="hljs-comment">//memcpy 可以拷所有字符，不会因为”\0“结束【与strcpy的区别】</span><br></code></pre></td></tr></table></figure><h3 id="9-内存操作函数｜memmove">9.内存操作函数｜memmove</h3><p><strong>用途</strong>：将 a[0], a[1], a[2] 所存内容移动到 a[2], a[3], a[4].（如果用 memcpy 拷贝，会发生内存重叠）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;                    <span class="hljs-comment">// a[5] = &#123;1, 2, 3, 0, 0&#125;</span><br>memmove(&amp;a[<span class="hljs-number">2</span>], a, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));      <span class="hljs-comment">// bfore_a[5] = &#123;1, 2, 1, 2, 3&#125;</span><br><span class="hljs-comment">// 以上表示的是，将 地址a的数组的 前3个元素，移动到 地址是&amp;a[2]数组的 前3个元素</span><br><span class="hljs-comment">// 如使用 memcpy，a[5] = &#123;1, 2, 1, 2, 1&#125;，内存冲突，会覆盖</span><br></code></pre></td></tr></table></figure><h3 id="10-内存操作函数｜memcmp">10.内存操作函数｜memcmp</h3><p>与 strncmp 相似，<strong>用途</strong>：判断是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-type">int</span> flag = <span class="hljs-built_in">memcmp</span>(a, b, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));   <span class="hljs-comment">//flag &lt; 0   // 比较的是ascii码，一个个比较</span><br><span class="hljs-comment">// 相等：flag == 0</span><br><span class="hljs-comment">// a&gt;b：flag &gt; 0</span><br><span class="hljs-comment">// a&lt;b：flag &lt; 0</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>补充</strong>：不能使用 memcmp 来判断 strcut 结构体是否相等。</p><p>因为结构体存在内存对齐，内存对齐的那几个字节的值是随机的。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span><br>&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br>MyStruct A, B;    <span class="hljs-comment">// A 和 B 均有内存对齐，但是内存对齐的三个字节，内容是随机的。</span><br><span class="hljs-built_in">memcmp</span>(&amp;A, &amp;B, <span class="hljs-built_in">sizeof</span>(MyStruct));<br></code></pre></td></tr></table></figure><ul><li><p><strong>再补充</strong>：如果一定要用 memcmp 比较，需要先用 memset 将 A、B 置 0，再赋值，才能比较。因为 memset 将字节对齐的那部分也置于 0 了。</p></li><li><p><strong>再再补充</strong>：结构体比较是否相等，用重载 ==。</p></li></ul><h3 id="11-内存释放">11.内存释放</h3><p>内存释放只能释放一次，释放多次会发生段错误。</p><p><strong>内存泄漏</strong>： 动态分配空间，不释放空间。</p><p><strong>内存污染</strong>： 非法使用内存（操作野指针所指向的内存、堆区越界）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br>p = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));   <span class="hljs-comment">// 从堆中申请空间，申请成功返回地址，失败返回NULL</span><br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">NULL</span>；   <span class="hljs-comment">// 【很重要】释放完，赋值为NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><ul><li>第五行，null 代表着，该指针被释放；未被赋值为 null，代表着指针所指空间未被释放。</li><li>未被赋值为 null 的指针，容易造成二次释放。已释放的空间，二次释放，将出现错误。</li></ul><h3 id="12-堆区空间越界">12.堆区空间越界</h3><p><code>malloc</code> 分配的空间 &lt; 操作的空间，会发生内存污染。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;123abc&quot;</span>);    <span class="hljs-comment">// 堆区空间越界</span><br></code></pre></td></tr></table></figure><h3 id="13-堆区数组">13.堆区数组</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br>p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));    <span class="hljs-comment">// 连续申请10个 int 大小空间，p指向首地址</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 等价于 *(p + 0)</span><br>p[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 等价于 *(p + 1)</span><br></code></pre></td></tr></table></figure><h3 id="14-内存污染｜返回栈区地址">14.内存污染｜返回栈区地址</h3><h4 id="（1）问题">（1）问题</h4><p>函数执行完，自动释放栈区内存空间，（<strong>可以返回结果，不能返回空间地址</strong>）。</p><p><strong>错误案例01</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = fun();    <span class="hljs-comment">// 程序执行完，自动释放内存空间，此时p为野指针</span><br>    *p = <span class="hljs-number">20</span>;           <span class="hljs-comment">//error   // 操作野指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误案例02</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">get_char</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abcdef&quot;</span>;   <span class="hljs-comment">// 从文字常量区，将 &quot;abcdef&quot; 拷贝到栈区</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strcpy</span>(buf, get_str()); <span class="hljs-comment">// error   //程序执行完，返回的 str 内存空间被自动释放</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);      <span class="hljs-comment">// 打印出来的将是乱码</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）改进">（2）改进</h4><p>将函数体内局部变量定义为 static ，储存在 data 区，程序结束前，不会释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = fun();<br>    *p = <span class="hljs-number">20</span>;           <span class="hljs-comment">// 合法！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-内存泄漏｜值传递">15.内存泄漏｜值传递</h3><h4 id="（1）问题-2">（1）问题</h4><p>传递的是指针的值（NULL），函数中申请堆区空间，tmp 指向堆区，但是 p 并没有指向堆区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *tmp)</span> &#123;<br>    tmp = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));    <span class="hljs-comment">// 堆区空间，函数结束没释放，【内存泄漏】</span><br>    *tmp = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>:<br>    fun(p);          <span class="hljs-comment">// 传递的是指针p所储存的内容（NULL）</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *p);    <span class="hljs-comment">// 此时p，还是空指针，会发生段错误，【内存污染】</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）改进｜返回堆区空间">（2）改进｜返回堆区空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *tmp)</span> &#123;<br>    tmp = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    * tmp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> tmp;      <span class="hljs-comment">// 把堆区空间地址传回来，赋值给p</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br>    p = fun(p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *p);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-非法使用内存导致错误">16.非法使用内存导致错误</h3><p>非法使用指针，造成内存污染。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p;<br>*p = <span class="hljs-string">&quot;abc&quot;</span>;    <span class="hljs-comment">// 可能编译通过，随着代码量的增加，会出现断错误</span><br></code></pre></td></tr></table></figure><h3 id="17-如何避免非法使用内存">17.如何避免非法使用内存</h3><p>定义一个指针后，先指向一块内存再使用！</p><ol><li>指向栈区内存（即指向普通变量）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p;<br><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;ab&quot;</span>;<br>p = s;<br></code></pre></td></tr></table></figure><ol start="2"><li>指向堆区（malloc申请空间）</li></ol><p>【堆区空间 记得 free()】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p;<br>p = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>3.指向文字常量区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p;<br>p = <span class="hljs-string">&quot;ab&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="018-结构体">018.结构体</h2><blockquote><p>复合类型</p></blockquote><h3 id="1-格式-2">1.格式</h3><ul><li>结构体类型定义，右括号有分号！</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;;       <span class="hljs-comment">// 【重要】有分号！</span><br><br><span class="hljs-comment">// 结构体、联合体、枚举、do-while、typedef都有分号！</span><br></code></pre></td></tr></table></figure><ul><li>和数组一样：<ul><li>结构体变量只有定义的时候可以初始化。</li><li>初始化使用大括号，而且有分号。<code>struct student s1 = &#123;18, &quot;Tom&quot;&#125;;</code></li></ul></li><li>【<strong>易错</strong>】没初始化，不能操作 字符数组名（line 4）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">s1</span>;</span><br>    s1.age = <span class="hljs-number">18</span>;<br>    s1.name = <span class="hljs-string">&quot;tom&quot;</span>;    <span class="hljs-comment">// error【重要】name是数组名（首地址），数组名是常量，不允许修改</span><br>    <span class="hljs-built_in">strcpy</span>(s1.name, <span class="hljs-string">&quot;tom&quot;</span>);   <span class="hljs-comment">// 解决方案1   // 解决方案2：使用指针定义 name</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-不常用定义方法">2.不常用定义方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;s1, s2;    <span class="hljs-comment">// 定义两个结构体变量</span><br><br>-------------------------------------<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;s1 = &#123;<span class="hljs-number">18</span>, <span class="hljs-string">&quot;Tom&quot;</span>&#125;;  <span class="hljs-comment">// 定义时初始化</span><br><br>-------------------------------------<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;s3, s4;   <span class="hljs-comment">// 定义两个结构体变量，但此时结构体类型是一次性的，不能用它定义其他结构体变量  </span><br></code></pre></td></tr></table></figure><h3 id="3-结构体数组初始化">3.结构体数组初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;;       <span class="hljs-comment">// 【重要】有分号！</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">s</span>[5] &#123;</span><br>    &#123;<span class="hljs-number">18</span>, <span class="hljs-string">&quot;student_01&quot;</span>&#125;,<br>    &#123;<span class="hljs-number">19</span>, <span class="hljs-string">&quot;student_02&quot;</span>&#125;,<br>    &#123;<span class="hljs-number">20</span>, <span class="hljs-string">&quot;student_03&quot;</span>&#125;  <span class="hljs-comment">// 最后没有逗号</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">double_s</span>[5] &#123;</span><br>    <span class="hljs-number">18</span>, <span class="hljs-string">&quot;student_01&quot;</span>,<br>    <span class="hljs-number">19</span>, <span class="hljs-string">&quot;student_02&quot;</span>,<br>    <span class="hljs-number">20</span>, <span class="hljs-string">&quot;student_03&quot;</span>  <span class="hljs-comment">// 最后没有逗号</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-结构体嵌套">4.结构体嵌套</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 结构体类型定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Score</span> &#123;</span><br>    <span class="hljs-type">int</span> chinese;<br>    <span class="hljs-type">int</span> math;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Score</span> <span class="hljs-title">score</span>;</span>  <span class="hljs-comment">// 结构体嵌套。</span><br>&#125;<br><br><span class="hljs-comment">// 初始化嵌套结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">s</span> =</span> &#123;<span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;tom&quot;</span>&#125;  <span class="hljs-comment">// 也就是chinese=90， math=100， age=18。</span><br><span class="hljs-comment">// 修改嵌套结构体数据</span><br>s.score.math = <span class="hljs-number">110</span>;   <span class="hljs-comment">// 点到嵌套结构体的最后一层。</span><br></code></pre></td></tr></table></figure><h3 id="5-结构体的值传递和地址传递">5.结构体的值传递和地址传递</h3><p>值传递，是直接内存拷贝，效率不高；地址传递效率更高。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;;       <span class="hljs-comment">// 【重要】有分号！</span><br><br><span class="hljs-comment">// 利用指针进行地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Student *p <span class="hljs-comment">/*p指向s1所在内存*/</span>)</span> </span>&#123;<br>  p-&gt;age = <span class="hljs-number">10</span>; <br>  <span class="hljs-built_in">memcpy</span>(p-&gt;name, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Tom&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> s1;<br>    <span class="hljs-built_in">fun</span>(&amp;s1);   <span class="hljs-comment">// 地址传递</span><br>&#125;<br><br>---------------------------------------------------<br><br><span class="hljs-comment">// 如果限制只读，可以用 const</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Student *p)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="6-结构体指针套一级指针">6.结构体指针套一级指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> *name;<br>&#125;; <span class="hljs-comment">//有分号！</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">s1</span>;</span><br>    s1.age = <span class="hljs-number">18</span>;<br>    s1.name = <span class="hljs-string">&quot;Tom&quot;</span>;  <span class="hljs-comment">// 可以这样赋值，“Tom” 在文字常量区，将 ”Tom“ 的首地址，赋值给指针 name</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s1.name);  <span class="hljs-comment">// 用指针直接打印字符串</span><br>    <br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">p</span>;</span><br>    p = (<span class="hljs-keyword">struct</span> Student *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Student));   <span class="hljs-comment">// 记得free()</span><br>    p-&gt;age = <span class="hljs-number">18</span>;<br>    <span class="hljs-built_in">strcpy</span>(p-&gt;name, <span class="hljs-string">&quot;tom&quot;</span>); <span class="hljs-comment">// error // 只分配了 age大小（int，4字节） + name大小（指针），没有让name 指向内存空间，所以无法将“tom” 拷贝到此空间</span><br>    p-&gt;name = <span class="hljs-string">&quot;Tom&quot;</span>;   <span class="hljs-comment">// 解决方案，让name指向常量区</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2020-04-16-GDeDyp.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="7-结构体指针数组套二级指针">7.结构体指针数组套二级指针</h3><p>用一个指针指向 导师结构体数组，表示有 teacher_num 个导师，一个导师有 student_num 个学生。用二级指针指向学生数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> &#123;</span><br>        <span class="hljs-type">char</span> **student;<br>    &#125;Teacher;<br><br>Teacher *<span class="hljs-title function_">creatTeacher</span><span class="hljs-params">(<span class="hljs-type">int</span> teacher_num)</span> &#123;<br>    Teacher *p = (Teacher *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Teacher) * teacher_num);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">creatStudent</span><span class="hljs-params">(Teacher **p, <span class="hljs-type">int</span> teacher_num, <span class="hljs-type">int</span> student_num)</span> &#123;<br><br>    <span class="hljs-comment">// 1. 对于每个结构体，申请空间，用来存储一级指针，一级指针指向 学生姓名字符数组。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; teacher_num; i++) &#123;<br>        (*p)[i].student = (<span class="hljs-type">char</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *) * student_num);<br>        <br>        <span class="hljs-comment">// 2. 对于每个一级指针，申请空间，用来存储 学生姓名字符数组。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; student_num; j++) &#123;<br>            (*p)[i].student[j] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span>);<br><br>            <span class="hljs-comment">// 3. 为每个 学生姓名字符数组 赋值。</span><br>            <span class="hljs-type">char</span> tmp_name[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">sprintf</span>(tmp_name, <span class="hljs-string">&quot;s_name_%d_%d&quot;</span>, i, j);<br>            <span class="hljs-built_in">strcpy</span>((*p)[i].student[j], tmp_name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printAllStudent</span><span class="hljs-params">(Teacher **p, <span class="hljs-type">int</span> teacher_num, <span class="hljs-type">int</span> student_num)</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; teacher_num; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; student_num; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d名，%s\n&quot;</span>, n++ ,(*p)[i].student[j]);   <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeAllSpace</span><span class="hljs-params">(Teacher **p, <span class="hljs-type">int</span> teacher_num, <span class="hljs-type">int</span> student_num)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; teacher_num; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; student_num; j++) &#123;<br>            <span class="hljs-keyword">if</span> ((*p)[i].student[j] != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">free</span>((*p)[i].student[j]);<br>                (*p)[i].student[j] = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((*p)[i].student != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">free</span>((*p)[i].student);<br>            (*p)[i].student = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(*p != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">free</span>(*p);<br>        *p = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Teacher *p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 创建导师结构体数组</span><br>    <span class="hljs-type">int</span> teacher_num = <span class="hljs-number">3</span>;<br>    p = creatTeacher(teacher_num);<br><br>    <span class="hljs-comment">// 为每个导师结构体中的 二级指针所指向的空间 申请空间并赋值</span><br>    <span class="hljs-type">int</span> student_num = <span class="hljs-number">2</span>;<br>    creatStudent(&amp;p, teacher_num, student_num);<br><br>    <span class="hljs-comment">// 遍历不同导师的不同学生</span><br>    printAllStudent(&amp;p, teacher_num, student_num);<br><br>    <span class="hljs-comment">// 释放空间</span><br>    freeAllSpace(&amp;p, teacher_num, student_num);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-结构体的深拷贝与浅拷贝">8.结构体的深拷贝与浅拷贝</h3><ul><li><strong>浅拷贝</strong>（Shallow Copy）：结构体中嵌套指针，而且动态分配空间，同类型结构体变量赋值，不同结构体成员指针变量指向同一块内存。</li><li><strong>深拷贝</strong>（Deep Copy）：人为申请空间，重新拷贝堆区内容。</li></ul><p><img src="https://hutu.aimtao.net/mark/2020-04-29-0nhUrS.webp-s" srcset="/img/loading.gif" lazyload alt="浅拷贝"></p><p><img src="https://hutu.aimtao.net/mark/2020-04-29-oQeizK.webp-s" srcset="/img/loading.gif" lazyload alt="深拷贝"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> &#123;</span><br>        <span class="hljs-type">char</span> *course;<br>        <span class="hljs-type">int</span> score;<br>    &#125;Teacher;<br><br>    Teacher t1;<br>    t1.course = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>    t1.score = <span class="hljs-number">90</span>;<br>    <span class="hljs-built_in">strcpy</span>(t1.course, <span class="hljs-string">&quot;math&quot;</span>);<br>    <br>    <span class="hljs-comment">// 浅拷贝，对于指针所指向的内存空间不拷贝</span><br>    Teacher t2 = t1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-结构体内存">9.结构体内存</h3><blockquote><p>由于结构体存在字节对齐，所以结构体变量的内存大小，大于其成员变量的内存大小之和。</p><p><strong>注意</strong>：当结构体变量更改顺序时，所占内存大小不一样。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp1</span> &#123;   <span class="hljs-comment">// sizeof(tmp1) = 4+4</span><br>   <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">short</span> b;<br>   <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp2</span> &#123;   <span class="hljs-comment">// sizeof(tmp2) = 4+4+4</span><br>   <span class="hljs-type">short</span> b;<br>   <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">char</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（1）结构体偏移量">（1）结构体偏移量</h4><p>结构体类型定义下来，内部的成员变量的内存布局已经确定下来。</p><p><img src="https://hutu.aimtao.net/mark/2020-04-29-n27YYZ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="（2）结构体对齐规则">（2）结构体对齐规则</h4><ul><li><p><strong>为什么要对齐？</strong></p><p>便于查找，提高存取数据的速度，利用空间换时间。</p><p>比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需1个读取周期（以32位系统为例，CPU读取内存时，一次读取32位，4个字节）即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。</p></li><li><p><strong>结构体的对齐参数</strong></p><p>以结构体中最长字节的变量对齐。利用偏移量来对齐，偏移量按照类型大小成倍增加。</p></li><li><p><strong>举个例子</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-type">char</span>    c;     <span class="hljs-comment">//1byte</span><br>    <span class="hljs-type">double</span>  d;     <span class="hljs-comment">//8byte</span><br>    <span class="hljs-type">short</span>   s;     <span class="hljs-comment">//2byte</span><br>    <span class="hljs-type">int</span>     i;     <span class="hljs-comment">//4byte</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>系统默认以最长字节的类型的大小来对齐：<strong>8 个字节</strong>。</li></ol><table><thead><tr><th>变量</th><th>偏移量 sizeof(类型) * 倍数</th><th>所占位置</th><th>首地址</th></tr></thead><tbody><tr><td>char c</td><td>1 * 0 = 0</td><td>1</td><td>1</td></tr><tr><td>double d</td><td>8 * 1 = 8</td><td>9 - 16</td><td>9</td></tr><tr><td>short s</td><td>2 * 8 = 16</td><td>17 - 18</td><td>17</td></tr><tr><td>int i</td><td>4 * 5 = 20</td><td>21 - 24</td><td>21</td></tr></tbody></table><img src="https://hutu.aimtao.net/mark/2020-04-30-sgPDSj.webp-s" srcset="/img/loading.gif" lazyload style="zoom:50%"><ol start="2"><li><strong>字节对齐可以程序控制，采用指令</strong>。但对齐参数不能大于最长字节的类型大小。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(xx)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)             <span class="hljs-comment">//1字节对⻬齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2)             <span class="hljs-comment">//2字节对⻬齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)            <span class="hljs-comment">//4字节对⻬齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)            <span class="hljs-comment">//8字节对⻬齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(16)        <span class="hljs-comment">//16字节对⻬齐</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>当系统以 4 个字节对齐</strong>。</li></ol><p>当最长类型大小 &gt; 对齐参数，按照对齐参数计算偏移量。</p><table><thead><tr><th>变量</th><th>偏移量 sizeof(类型) * 倍数</th><th>所占位置</th><th>首地址</th></tr></thead><tbody><tr><td>char c</td><td>1 * 0 = 0</td><td>1</td><td>1</td></tr><tr><td>double d</td><td>4 * 1 = 4【最长类型大小 &gt; 对齐参数】</td><td>5 - 12</td><td>5</td></tr><tr><td>short s</td><td>2 * 7 = 14</td><td>15 - 16</td><td>15</td></tr><tr><td>int i</td><td>4 * 4 = 16</td><td>17 - 20</td><td>17</td></tr></tbody></table><img src="https://hutu.aimtao.net/mark/2020-04-30-Efqt1j.webp-s" srcset="/img/loading.gif" lazyload style="zoom:50%"><ol start="4"><li><strong>当系统以 1 个字节对齐</strong>。</li></ol><p><img src="https://hutu.aimtao.net/mark/2020-04-30-1qwOTY.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="（3）特殊情况｜当结构体成员为数组时">（3）特殊情况｜当结构体成员为数组时</h4><p>当结构体成员为数组时，并不是将整个数组当成一个成员来对待，而是 将数组的每个元素当一个成员来分配，其他分配规则不变。比如 <code>int a[5]</code> ，当作 5 个 <code>int</code> 类型来处理。</p><h4 id="（4）特殊情况｜当有不完整类型时">（4）特殊情况｜当有不完整类型时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-type">int</span>   a1:<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span>   a2:<span class="hljs-number">9</span>;<br>    <span class="hljs-type">char</span>  c;<br>    <span class="hljs-type">int</span>   b:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">short</span> s;<br>&#125;;<br></code></pre></td></tr></table></figure><p>【要点】：</p><ul><li>对于位段成员，依旧按类型分配空间。</li><li>同类型的、相邻的位段成员，可当作一个类型变量来处理。比如 <code>a1:5</code> <code>a2:9</code> 可以当作一个 <code>int</code> 变量处理。</li></ul><p><strong>系统默认以 4 个字节来对齐</strong>：</p><p><code>a1:5</code> 表示 占 5bit，<code>a2:9</code> 表示 占 9bit，加起来一共 16bit，未超过 <code>int</code> 的 4 个字节。所以将 <code>a1:5</code> <code>a2:9</code> 放在一个 <code>int</code> 空间。由于 <code>b:4</code> 和 <code>s</code> 的类型不一样，所以不能放在一起，<code>b:4</code> 依旧占 4 个字节。</p><p><img src="https://hutu.aimtao.net/mark/2020-04-30-Up8TGh.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="10-typedef">10.typedef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1.给 类型struct Stdent 取个别名 Student</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>  <span class="hljs-type">int</span> age;<br>  <span class="hljs-type">char</span> *name;<br>&#125;Student;<br><br><span class="hljs-comment">// 2.给int取别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> int64;<br><br><span class="hljs-comment">// 3.定义数组类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> A[<span class="hljs-number">8</span>];   <span class="hljs-comment">// A 代表一个类型，不是变量</span><br>A a;   <span class="hljs-comment">// 等价于 int a[8]</span><br><br><span class="hljs-comment">// 4.定义函数类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(MY_FUNC)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="11-比较结构体是否相等">11.比较结构体是否相等</h3><p>不可使用 memcmp 判断，因为用于内存对齐的几个字节是垃圾值。</p><p>使用重载 == 操作符。</p><h2 id="019-共用体（联合体）、枚举">019.共用体（联合体）、枚举</h2><h3 id="1-共用体">1.共用体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a(1字节)、b（2字节）、c（4字节）共用一块内存（最大成员的内存）。</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> b;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Test</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//obj 内存大小为 4，因为成员中 int 最大，4字节。</span><br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2020-04-16-dwqnyR.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="2-枚举">2.枚举</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    red, write, blue   <span class="hljs-comment">// 最后没逗号</span><br>&#125;;  <span class="hljs-comment">// 有分号！</span><br></code></pre></td></tr></table></figure><h2 id="020-文件操作">020.文件操作</h2><h3 id="1-缓冲区">1.缓冲区</h3><blockquote><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p></blockquote><h4 id="（1）为什么要有缓冲区？">（1）为什么要有缓冲区？</h4><p>提高交互效率</p><p><code>fputs()</code> 把内存的值写入文件：内存 -&gt; 缓冲区 -&gt; 缓冲区（缓冲区满了，或者程序结束） -&gt; 屏幕（标准输出文件）。</p><p><code>fgets()</code> 从文件读取数据：键盘（标准输入文件） -&gt; 缓冲区 -&gt; 缓冲区（缓冲区满了，或者程序结束）-&gt; 内存。</p><img src="https://hutu.aimtao.net/mark/2020-05-01-DB98mK.webp-s" srcset="/img/loading.gif" lazyload style="zoom:80%"><h4 id="（2）缓冲区写入文件的条件">（2）缓冲区写入文件的条件</h4><ul><li><p>【标准设备文件】<code>stdin</code> <code>stdout</code> <code>stderr</code> 可以实时读写。</p></li><li><p>【缓冲区满了】但是缓冲区不同系统大小不一样，缓冲区相当于一个固定大小的字符串。</p></li><li><p>【程序结束】程序正常关闭，缓冲区的内容，自动写入文件。</p></li><li><p>【关闭文件】<code>fclose(fp)</code> 文件正常关闭，缓冲区的内容，自动写入文件。</p></li><li><p>【手动刷新缓冲区】<code>fflush(fp)</code> 仅限 Linux。文件不关闭，程序没结束，实时刷新缓冲区。</p></li></ul><h4 id="（3）刷新缓冲区｜fflush">（3）刷新缓冲区｜fflush()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure><p>【linux系统下，刷新缓冲区】：当缓冲区积累的内容没有足够多，或者程序未结束，缓冲区的内容还未写入文件，需要手动刷新一下缓区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;this is test&quot;</span>;<br>FILE *fp = fopen(<span class="hljs-string">&quot;./test.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br><span class="hljs-built_in">fputs</span>(buf, fp);  <span class="hljs-comment">// 此时写入了缓冲区，但是没有写入文件</span><br><span class="hljs-comment">//----------此时文件中并没有内容--------------</span><br>fflush(fp);  <span class="hljs-comment">//刷新缓冲区，只有在linux系统可以。</span><br><br>getchar();   <span class="hljs-comment">// 程序未结束</span><br>fclose(fp); <span class="hljs-comment">// 不要忘记关闭文件</span><br></code></pre></td></tr></table></figure><h3 id="2-文件指针">2.文件指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp;<br></code></pre></td></tr></table></figure><ul><li>fp指针 是结构体指针，结构体内部是，若干个数据成员，保存文件状态等各种信息（不必关心内部）。</li><li>fp指针，调用 <code>fopen()</code> 时 ，在堆区分配空间，地址返回给 fp，【故 fp指针 不指向文件，而是指向堆区的结构体，该结构体用来储存文件状态等信息】。</li><li>通过文件库函数操作 fp指针，来修改该结构体内部数据成员。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 【文件句柄】了解就可以</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">short</span>          level; <span class="hljs-comment">/* 缓冲区&quot;满&quot;或者&quot;空&quot;的程度 */</span> <br>    <span class="hljs-type">unsigned</span>       flags; <span class="hljs-comment">/* ⽂文件状态标志 */</span><br>    <span class="hljs-type">char</span>           fd;   <span class="hljs-comment">/* ⽂文件描述符 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  hold;  <span class="hljs-comment">/* 如⽆无缓冲区不读取字符 */</span><br>    <span class="hljs-type">short</span>          bsize; <span class="hljs-comment">/* 缓冲区的⼤小 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  *buffer;<span class="hljs-comment">/* 数据缓冲区的位置 */</span><br>    <span class="hljs-type">unsigned</span>       ar;   <span class="hljs-comment">/* 指针，当前的指向 */</span><br>    <span class="hljs-type">unsigned</span>       istemp; <span class="hljs-comment">/* 临时⽂文件，指⽰示器 */</span><br>    <span class="hljs-type">short</span>          token; <span class="hljs-comment">/* ⽤用于有效性的检查 */</span><br>&#125;FILE;<br></code></pre></td></tr></table></figure><h3 id="3-文件分类">3.文件分类</h3><h4 id="（1）分类">（1）分类</h4><ul><li>磁盘文件：硬盘中的文件<ul><li>文本文件（遇到 -1或特殊字符会结束）</li><li>二进制文件</li></ul></li><li>设备文件<ul><li>键盘</li><li>屏幕</li></ul></li></ul><h4 id="（2）win-和-linux-文本文件的区别">（2）win 和 linux 文本文件的区别</h4><ul><li>win 文本文件的换行符是 “\r\n”</li><li>linux 文本文件的换行符是 “\n”</li></ul><p>ps：所以记事本打开会不换行。</p><p>win 下读写 会自动转换换行符。</p><ul><li>在 win 下，读取文本文件时，系统将 “\r\n” 转化为 “\n”</li><li>写入文件时，系统将 “\n” 转化为 “\r\n”</li></ul><h3 id="4-文件操作流程">4.文件操作流程</h3><ol><li>打开文件fopen()</li><li>读写文件<ul><li>按 字符 读写 fgetc()、fputc()</li><li>按 字符串（行）读取文件 fgets()、fputs()</li><li>文件结尾判断 feof() 【end of file】</li></ul></li><li>关闭文件 fclose()</li></ol><h3 id="5-标准设备文件指针">5.标准设备文件指针</h3><ul><li>stdin：标准输入</li><li>stdout：标准输出</li><li>stderr：标准出错，<code>perror</code> 函数输出错误信息</li></ul><p><strong>补充</strong>：</p><ul><li>fclose() 关闭文件</li><li>perror() 打印库函数调用失败原因<ul><li>失败：Bad file descriptor</li><li>成功：Sucess 或者 不显示信息</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <br>    <span class="hljs-comment">// 1.关闭 标准输出  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;aa\n&quot;</span>);      <span class="hljs-comment">// 可以正常打印 aa</span><br>    fclose(<span class="hljs-built_in">stdout</span>);    <span class="hljs-comment">// 关闭标准输出文件</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bb\n&quot;</span>);      <span class="hljs-comment">// 无法打印出来</span><br><br>    <span class="hljs-comment">// 2.打印 库函数 调用失败原因</span><br>    perror(<span class="hljs-string">&quot;my error&quot;</span><span class="hljs-comment">/*括号内为自定义的字符串*/</span>);   <span class="hljs-comment">//my error: Bad file descriptor</span><br><br>    <span class="hljs-comment">// 3.关闭 标准输入</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    fclose(<span class="hljs-built_in">stdin</span>);   <span class="hljs-comment">// 关闭标准输出文件</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);  <span class="hljs-comment">// 无法从键盘读取数据, 此时 a 还是等于0</span><br><br>    perror(<span class="hljs-string">&quot;my new error&quot;</span>);      <span class="hljs-comment">// my new error: Bad file descriptor</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-文件打开和关闭">6.文件打开和关闭</h3><h4 id="（1）fopen">（1）fopen()</h4><p>fp指针，调用 <code>fopen()</code> 时 ，在堆区分配空间，地址返回给 fp。失败返回 NULL。</p><h5 id="1-路径">&lt;1&gt; 路径</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 仅 windows 可使用的路径</span><br><span class="hljs-comment">// 直接复制过来，是反斜杠，需要多加一个斜杠进行转义</span><br>fp = fopen(<span class="hljs-string">&quot;my_code\\hello\\hell.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-comment">// 推荐的路径格式</span><br>fp = fopen(<span class="hljs-string">&quot;my_code/hello/hell.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-comment">//用指针代替路径</span><br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;1.txt&quot;</span>;<br>fp = fopen(p, <span class="hljs-string">&quot;w&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>Tip</strong>：如果路径字符串过长，可以用续行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;1234567&quot;</span>\               <span class="hljs-comment">// 表示是一个完整的字符串。</span><br>            <span class="hljs-string">&quot;asdasfsdgasfdgs&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);<br></code></pre></td></tr></table></figure><h5 id="2-权限">&lt;2&gt; 权限</h5><p><code>w</code>：【写入】如果文件不存在，新建；如果文件存在，清空内容再打开。</p><p><code>r</code>：【只读】如果文件不存在，打开失败。</p><p><code>a</code>：【追加】如果文件不存在，新建；如果文件存在，光标自动放在文件最后末尾。</p><p><code>r+</code>：【读写】允许读写，文件必须存在</p><p><code>w+</code>：【读写】允许读写，文件不存在，则创建，文件存在，则清空</p><p>rb：window 平台下，r或者rt 读文本文件，rb 表示二进制文件【linux 写 rb 不影响】。</p><p>wb：window 平台下，w或者wt 写文本文件，wb 表示二进制文件【linux 写 wb 不影响】。</p><h5 id="3-注意">&lt;3&gt; 注意</h5><ul><li>编译的同时运行程序，相对路径不一定相对于源代码路径。</li><li>直接运行程序，相对路径是相对于可执行程序。</li></ul><h4 id="（2）fclose">（2）fclose()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fclose(FILE *stream);<br></code></pre></td></tr></table></figure><h3 id="7-写文件｜fputc-、fputs">7.写文件｜fputc()、fputs()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><p>将 ch 转换为 unsigned char 后，写入 stream 指定文件中。</p><ul><li>ch：需要写入文件的字符</li><li>stream：文件指针</li></ul><p><strong>返回值</strong>：</p><ul><li>成功：返回读到的字符</li><li>失败：-1</li></ul><p><strong>流程</strong>：写入缓冲区 -&gt; 写入硬盘中的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//1.打开文件</span><br>fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><br><span class="hljs-keyword">if</span>(fp == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">// 判断是否打开失败</span><br>    perror(fopen);   <span class="hljs-comment">// 打印出错原因</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//2.写文件</span><br>fputc(<span class="hljs-string">&#x27;a&#x27;</span>, fp);<br><br><span class="hljs-comment">//3.关闭文件</span><br>fclose(fp);<br></code></pre></td></tr></table></figure><p>PS：写文件｜fputs() 见 <a href="#fputs()">012.3 fputs()</a></p><h3 id="8-读文件｜fgetc-、fgets">8.读文件｜fgetc()、fgets()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure><p>从 stream 指定的文件中读取一个字符。</p><p><strong>返回值</strong>：</p><ul><li>成功：返回读到的字符</li><li>失败：-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从键盘上读数据</span><br>fgetc(<span class="hljs-built_in">stdin</span>);<br><br>FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);  <span class="hljs-comment">// 读文件，以只读的方式打开文件。</span><br><br><span class="hljs-comment">// 读取一个字符</span><br><span class="hljs-type">char</span> ch;<br>ch = fget(fp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>ch = fget(fp);      <span class="hljs-comment">// 多次读取字符，光标自动向后移动。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br></code></pre></td></tr></table></figure><p>PS：读文件｜fgets() 见 <a href="#fgets()">012.2 fgets()</a></p><p>当 fgets() 读到文件结尾，读取失败，保存上一次读取的值（按行读取，也就是上一行的值）。</p><h3 id="9-判断文件结尾｜feof">9.判断文件结尾｜feof()</h3><blockquote><p>feof() 任何文件都能判断。</p></blockquote><p>文本文件，结尾有一个隐藏的 -1，因为ascii码中没有 -1 ，EOF（end of）的宏定义为 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">// 读取文件所有字符</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">char</span> ch;<br>    ch = fget(fp);<br>    <span class="hljs-keyword">if</span> (ch != <span class="hljs-number">-1</span>) &#123;   <span class="hljs-comment">// 当读到隐藏的 -1，就是 文件结尾。</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>&#125;<br></code></pre></td></tr></table></figure><p>二进制文件不能用 -1 判断结尾。</p><p>任何文件都能判断是否结尾，如果到文件结尾，feof() 返回真。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">// 读取文件所有字符</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">char</span> ch;<br>    ch = fget(fp);<br>    <span class="hljs-keyword">if</span> (feof(fp)) &#123;   <span class="hljs-comment">// 如果到文件结尾，feof() 返回真。</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原理</strong>： 判断的是，光标前一个字符是否是最后一个字符。</p><ul><li>对于空文件，应该先读取，让光标后移，才能判断是否结尾。</li><li>对于文本文件，读取到 隐藏字符 -1，feof() 才能判断结尾。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);   <span class="hljs-comment">// 1.txt 为空文件</span><br><br>feof(fp);   <span class="hljs-comment">// 此时永远返回假</span><br></code></pre></td></tr></table></figure><h3 id="10-格式化｜fprintf">10.格式化｜fprintf()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);     <span class="hljs-comment">// 1.txt为空。</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;num = %d\n&quot;</span>, &amp;num);     <span class="hljs-comment">// 将 num 内容格式化写入文件。</span><br></code></pre></td></tr></table></figure><h3 id="11-格式化｜fscanf">11.格式化｜fscanf()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);   <span class="hljs-comment">// 1.txt 中内容为 num = 10。</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;num = %d\n&quot;</span>, &amp;num);     <span class="hljs-comment">// 按照格式，读出数据 到num。</span><br></code></pre></td></tr></table></figure><ul><li>读取失败时（读到末尾，边界值），自动保存上一次读取的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  1.txt内容如下</span><br><span class="hljs-comment">num = 99</span><br><span class="hljs-comment">num = 98</span><br><span class="hljs-comment">*/</span><br>FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>); <br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;num = %d\n&quot;</span>, &amp;num);     <span class="hljs-comment">// num = 99</span><br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;num = %d\n&quot;</span>, &amp;num);     <span class="hljs-comment">// num = 98</span><br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;num = %d\n&quot;</span>, &amp;num);     <span class="hljs-comment">// num = 98   // 还是98，读取失败时，保存上一次读取的数据。</span><br></code></pre></td></tr></table></figure><h3 id="12-按块读写文件">12.按块读写文件</h3><h4 id="（1）fwrite">（1）fwrite()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> *ptr, <span class="hljs-type">size_t</span> size， <span class="hljs-type">size_t</span> number, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><p><strong>返回值</strong>：</p><ul><li>成功：返回写入内容的块数目 number，（不是文件总大小）。</li><li>失败：返回 0。</li></ul><p><strong>参数</strong>：</p><ul><li><p>ptr：准备写入文件数据的地址</p></li><li><p>size：往文件写入内容的块大小，数据类型的大小</p></li><li><p>number：往文件写入内容的块数目</p></li><li><p>stream：操作的文件指针</p></li></ul><p><strong>总大小</strong>：</p><p><code>size * number</code> 是总大小，所以 size 和 number 的参数位置调换，没有影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p  = <span class="hljs-string">&quot;Tom&quot;</span>;<br>FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-type">int</span> ret = fwrite(p, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-built_in">strlen</span>(p), fp);  <span class="hljs-comment">// 写入成功，ret 返回的是 strlen(p) 的大小。</span><br>fclose(fp);<br></code></pre></td></tr></table></figure><h4 id="（2）fread">（2）fread()</h4><p><strong>返回值</strong>：同 fwrite()</p><p><strong>参数</strong>：同 fwrite()</p><p><strong>注意</strong>：</p><ul><li>文件内容 &gt; 用户指定总大小 <code>size * number</code> ，返回值为用户指定大小的块数目。</li><li>文件内容 &lt; 用户指定总大小 <code>size * number</code> ，返回值为实际读取的块数目，或者为 0（比如，number = 0.2时，返回为 0 ）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>FILE *fp = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-type">int</span> ret = fread(s, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">50</span> <span class="hljs-comment">/* 假如文件中有50个字符 */</span>, fp);<br>fclose(fp);<br></code></pre></td></tr></table></figure><h4 id="（3）返回值与边界问题">（3）返回值与边界问题</h4><blockquote><p>对于二进制文件，所读取的字符串，不要用 <code>strlen()</code> 判断长度。</p></blockquote><ol><li>读文件时，应该用 <code>ret == 0</code> 做是否读到的判断，不应该用 <code>strlen() == 0</code> 做是否读到的判断，因为有些特殊字符会导致出现 <code>‘/0’</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ret = fread(a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), sizof(a), r_fp);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>对读到的字符串进行处理，应该用 <code>i &lt; ret</code> 做循环，不应该用 <code>i &lt; strlen()</code> 做循环，因为有些特殊字符会导致出现 <code>‘/0’</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; ret; i++) &#123;<br>    a[i] = a[i] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>写文件时，应该读多少写多少，避免越界。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> ret = fread(a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), sizof(a), r_fp);<br>fwrite(a, <span class="hljs-number">1</span>, ret, w_fp);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fwrite(a, 1, sizeof(a), w_fp); // 错误：sizeof(a) 有可能大于 ret，产生越界</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="13-光标移动｜fseek">13.光标移动｜fseek()</h3><p><strong>功能</strong>：移动文件光标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>offset：偏移量</li><li>whence：<ul><li>SEEK_SET：从文件开头移动 offset 个字节。</li><li>SEEK_CUR：从当前位置移动 offset 个字节。</li><li>SEEK_END：从文件末尾移动 offset 个字节。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">fseek(fp, <span class="hljs-number">0</span>, SEEK_SET);    <span class="hljs-comment">// 光标回到 开头偏移 0个字节的位置【光标回到开头】</span><br>fseek(fp, <span class="hljs-number">100</span>, SEEK_SET);  <span class="hljs-comment">// 光标回到 开头偏移 100个字节的位置</span><br>fseek(fp, <span class="hljs-number">0</span>, SEEK_END);    <span class="hljs-comment">// 光标回到 末尾偏移 0个字节的位置【回到末尾】</span><br>fseek(fp, <span class="hljs-number">-1</span>, SEEK_END);    <span class="hljs-comment">// 光标回到 倒数第二个位置。</span><br></code></pre></td></tr></table></figure><h3 id="14-获取光标位置｜ftell">14.获取光标位置｜ftell()</h3><p>返回的长整型为，光标距离开头的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure><h3 id="15-光标回到开头｜rewind">15.光标回到开头｜rewind()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure><h3 id="16-应用：获取文件大小">16.应用：获取文件大小</h3><ol><li>读方式打开文件。</li><li>光标移到文件结尾。</li><li>返回文件位置。</li><li>关闭文件 或者 恢复光标</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1. 读方式打开文件。</span><br>fp = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;rb+&quot;</span>);<br><br><span class="hljs-comment">// 2. 光标移到文件结尾。</span><br>fseek(fp, <span class="hljs-number">0</span>, SEEK_END);<br><br><span class="hljs-comment">// 3. 返回文件位置。</span><br><span class="hljs-type">long</span> size = ftell(fp);<br><br><span class="hljs-comment">// 4. 关闭文件 或者 恢复光标</span><br>rewind(fp);<br>fclose(fp);<br></code></pre></td></tr></table></figure><h2 id="021-链表">021.链表</h2><h3 id="1-链表和数组的区别">1.链表和数组的区别</h3><p><strong>链表</strong>：</p><ul><li>不需要一块连续的储存区域</li><li>删除和插入元素高效</li></ul><p><strong>数组</strong>：</p><ul><li>随机访问元素效率高</li></ul><h3 id="2-分类">2.分类</h3><h4 id="（1）动态链表和静态链表">（1）动态链表和静态链表</h4><p>类似于，动态数组和静态数组，储存结构的两种不同表示方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 动态数组</span><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-comment">// 静态数组</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p><strong>静态链表</strong>：所有结点程序定义，不是临时申请的，无需释放。</p><p><strong>动态链表</strong>：一个个临时申请的结点和输出的数据。建立的前后相连的关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 静态</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">structure</span> &#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">structure</span> *<span class="hljs-title">p</span>;</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">structure</span> <span class="hljs-title">s1</span>, <span class="hljs-title">s2</span>, *<span class="hljs-title">head</span>;</span><br>    head = &amp;s1;<br>    s1.num = <span class="hljs-number">1</span>;<br>    s1.p = &amp;s2;<br>    s2.num = <span class="hljs-number">2</span>;<br>    s2.p = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）带头链表和不带头链表">（2）带头链表和不带头链表</h4><p><strong>带头链表</strong>：头结点固定，储存的并不是有效数据，可能结点的个数。有效结点从第二个开始，若需在头部插入新结点，插在头结点和第二个结点之间即可。</p><p><strong>不带头结点</strong>：头结点不固定，若需在头部插入新结点，新结点指针指向头结点即可。</p><h4 id="（3）单向链表和双向链表">（3）单向链表和双向链表</h4><h4 id="（4）循环链表">（4）循环链表</h4><h3 id="3-增删改查">3.增删改查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node;<br><br><span class="hljs-comment">// 创建一个带头结点的链表</span><br>Node *<span class="hljs-title function_">ListCreat</span><span class="hljs-params">()</span> &#123;<br>    Node *head = <span class="hljs-literal">NULL</span>;<br>    head = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    head-&gt;data = <span class="hljs-number">-1</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    Node *current = head;<br>    Node *new_ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;input your data please:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        new_ptr = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        <span class="hljs-keyword">if</span> (new_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        current-&gt;next = new_ptr;<br>        new_ptr-&gt;data = data;<br>        new_ptr-&gt;next = <span class="hljs-literal">NULL</span>;<br>        current = new_ptr;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">// 打印链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ListShow</span><span class="hljs-params">(Node *head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *current = head-&gt;next;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,current-&gt;data);<br>        current = current-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入数据</span><br><span class="hljs-comment">// 在第一个 place_data 的前面插入 new_data</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListInset</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> place_data, <span class="hljs-type">int</span> new_data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    Node *aim_ptr = <span class="hljs-literal">NULL</span>;<br>    Node *current = head;<br>    <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current-&gt;next-&gt;data == place_data) &#123;<br>            aim_ptr = current;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        current = current-&gt;next;<br>    &#125;<br>    Node *new_ptr = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    new_ptr-&gt;data = new_data;<br>    <span class="hljs-keyword">if</span> (aim_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>        new_ptr-&gt;next = <span class="hljs-literal">NULL</span>;<br>        current-&gt;next = new_ptr;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        new_ptr-&gt;next = aim_ptr-&gt;next;<br>        aim_ptr-&gt;next = new_ptr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除结点</span><br><span class="hljs-comment">// 删除第一个 delete_data</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(Node *head, <span class="hljs-type">int</span> delete_data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    Node *current = head;<br>    <span class="hljs-keyword">while</span>(current-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span>(current-&gt;next-&gt;data == delete_data) &#123;<br>            Node *tmp = current-&gt;next;<br>            current-&gt;next = tmp-&gt;next;<br>            tmp-&gt;next = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">free</span>(tmp);<br>            tmp = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        current = current-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 清空链表</span><br>Node *<span class="hljs-title function_">ListClean</span><span class="hljs-params">(Node *head)</span> &#123;<br>    Node *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>) &#123;<br>        tmp = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(head);<br>        head = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Node *head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 创建</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ListCreat:&quot;</span>);<br>    head = ListCreat();<br>    ListShow(head);<br>    <span class="hljs-comment">// 插入</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ListInset:&quot;</span>);<br>    ListInset(head, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br>    ListShow(head);<br>    <span class="hljs-comment">// 删除</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ListDelete:&quot;</span>);<br>    ListDelete(head, <span class="hljs-number">6</span>);<br>    ListShow(head);<br>    <span class="hljs-comment">// 清空</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ListClean:&quot;</span>);<br>    head = ListClean(head);<br>    ListShow(head);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-交换节点">4.交换节点</h3><p>交换节点 = 交换结构体储存内容 + 交换指针指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1.交换整个结构体内容：数据域和指针域</span><br>tmp = *pCur;<br>*pCur = *pPre;<br>*pPre = tmp;<br><br><span class="hljs-comment">// 2.交换指针指向</span><br>tmp.next = pCur-&gt;next;<br>pCur-&gt;next = pPre-&gt;next;<br>pPre-&gt;next = tmp.next;<br></code></pre></td></tr></table></figure><p>PS：如果数据域只有一个，直接交换数据域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">tmp = p1-&gt;data;<br>p1-&gt;data = p2-&gt;data;<br>p2-&gt;data = tmp;<br></code></pre></td></tr></table></figure><p>PSS：如果数据域有多个，可以封装成一个结构体 data，在交换 data。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span>&#123;</span><br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>        <span class="hljs-type">int</span> num;<br>    &#125; data;<br>  <br>    Node *next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> <span class="hljs-title">tmp</span>;</span><br><br>tmp = p1-&gt;data;<br>p1-&gt;data = p2-&gt;data;<br>p2-&gt;data = tmp;<br></code></pre></td></tr></table></figure><h3 id="5-链表反转">5.链表反转</h3><ul><li>先用 p_next 保存第 3 个节点地址。</li><li>在将第 2 个节点（p_cur）的指针域指向第 1 个节点（p_pre）。</li><li>p_pre、p_cur 整体后移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ListNodeReverse</span><span class="hljs-params">(Node *head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span> || head-&gt;next-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    Node *p_pre = head-&gt;next;<br>    Node *p_cur = p_pre-&gt;next;<br>    Node *p_next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">while</span> (p_cur != <span class="hljs-literal">NULL</span>) &#123;<br>        p_next = p_cur-&gt;next;<br>        p_cur-&gt;next = p_pre;<br>        <span class="hljs-comment">// p_pre、p_cur 整体后移</span><br>        p_pre = p_cur;<br>        p_cur = p_next;<br>    &#125;<br>    <span class="hljs-comment">// 更改 head 指向。</span><br>    head-&gt;next-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = p_pre;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="022-常见错误">022.常见错误</h2><h3 id="1-Segmentation-Fault">1. Segmentation Fault</h3><p>段错误，主要原因是 <strong>操纵了非法内存</strong>。</p><p>常见情景有：</p><ul><li>数组越界</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br>a[<span class="hljs-number">10</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><ul><li>链表越界</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">head = <span class="hljs-literal">NULL</span>;<br>head-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li>指针操纵非法内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *p);<br></code></pre></td></tr></table></figure><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C-C/">#C/C++</a></div></div><div class="license-box my-3"><div class="license-title"><div>查漏补缺｜C 语言</div><div>https://www.aimtao.net/c/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2020-02-22</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/git/" title="学习笔记｜Git"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">学习笔记｜Git</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/c-plus-plus/" title="学习笔记｜C++"><span class="hidden-mobile">学习笔记｜C++</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>