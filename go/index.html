<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="不要通过共享内存来通信；通过通信来共享内存。"><title>学习笔记｜Go - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2020-12-07-go.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="学习笔记｜Go"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-07 21:59" pubdate>2020-12-07 PM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 89k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 67 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">学习笔记｜Go</h1><p class="note note-info">本文最后更新于：5 years ago</p><div class="markdown-body"><h2 id="1-准备工作">1.准备工作</h2><h3 id="1-1-GOROOT-和-GOPATH">1.1 GOROOT 和 GOPATH</h3><ul><li>GOROOT：Go SDK的位置。</li><li>GOPATH：在 goland 中分为全局 GOPATH、项目 GOPATH、模块 GOPATH。</li></ul><blockquote><p>使用原生的 go mod 的方式，不用管这些乱七八糟的 GOPATH，<strong>将它当作一个普通且普通的放代码的目录即可。</strong></p></blockquote><p><strong>一个 go 项目的目录是什么样的？</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">go    <span class="hljs-comment"># GOPATH</span><br>├── bin  <span class="hljs-comment"># Go 构建的编译可执行程序的位置</span><br>└── pkg  <span class="hljs-comment"># 编译后包文件会生成.a文件，放置在 $GOPATH/pkg/$GOOS_$GOARCH中。</span><br>│   └── mod <span class="hljs-comment"># 程序寻找第三方库，就在该目录下寻找</span><br>│       ├── go.uber.org <span class="hljs-comment"># 依赖的第三方库的版本信息</span><br>│       └── cache <span class="hljs-comment"># 依赖的第三方库代码实际缓存的位置</span><br>├── project1  <span class="hljs-comment"># 项目一</span><br>│   ├── go.mod  <span class="hljs-comment"># 用于依赖管理的 mod 文件：记录了所依赖的第三方库名称及其版本。</span><br>│   ├── go.sum  <span class="hljs-comment"># 对于 mod 文件更详细的描述：包含 现在 和 曾经 依赖的第三方库名称、版本、hash 值。</span><br>│   └── zaptest <span class="hljs-comment"># 包</span><br>│   │   ├── func.go    <span class="hljs-comment"># 封装的功能一</span><br>│   │   └── zaptest.go <span class="hljs-comment"># 封装的功能二 </span><br>│   └── entry   <span class="hljs-comment"># 包</span><br>│       └── entry.go   <span class="hljs-comment"># 启动程序，调用第三方库和封装的功能</span><br>│<br>└── project2  <span class="hljs-comment"># 项目二</span><br></code></pre></td></tr></table></figure><h3 id="1-2-hello-world">1.2 hello world</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-goimports">1.3 goimports</h3><p>在保存代码后，goimports 可自动导入需要的包，格式化代码（<strong>甚至将空格转化为 tab</strong>）</p><h3 id="1-4-goland-快捷键">1.4 goland 快捷键</h3><p><strong>（1）代码编辑</strong></p><ul><li>command + alt + V，自动生成变量名。</li><li>command + B，转到声明。</li><li>command + N，快速生成代码。</li><li>command + X，剪切、删除当前光标所在行。</li><li>command + D，复制当前光标所在行。</li><li>command + shift + Up/Down， 代码向上/下移动。</li><li>alt + Delete，按单词进行删除。</li><li>command + Delete，按整行删除</li><li>shift + enter，向下插入新行，即使光标在当前行的中间。</li><li>command + shift + U，将选中内容进行大小写转化。</li></ul><p><strong>（2）代码格式化</strong></p><ul><li>command + alt + T，把代码包在一个块内，例如if{…}else{…}。</li><li>command + alt + L，格式化代码。</li><li>command + /，单行注释。</li><li>command + shift + /，进行多行注释。</li><li>command + “+/-”，可以将当前方法进行展开或折叠。</li></ul><p><strong>（3）查找和定位</strong></p><ul><li>command + F，查找文本。</li><li>command + R，替换文本。</li><li>command + shift + F，进行全局查找。</li></ul><p><strong>（4）文件相关快捷键</strong></p><ul><li>command + E，打开最近浏览过的文件。</li><li>command + shift + E，打开最近更改的文件。</li><li>command + shift + N，快速生成文件。</li></ul><h3 id="1-5-编译命令">1.5 编译命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">go run helloworld.go  <span class="hljs-comment"># 编译运行单个文件。</span><br>go build    <span class="hljs-comment"># 编译整个项目，但不保存可执行文件。</span><br>go install  <span class="hljs-comment"># 编译后，将可执行文件保存在 $GOPATH/bin/ 目录下。</span><br></code></pre></td></tr></table></figure><h2 id="2-基础语法">2.基础语法</h2><h3 id="2-1-变量定义">2.1 变量定义</h3><p><strong>（1）var 声明变量类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span>    <span class="hljs-comment">// 定义一个变量</span><br><span class="hljs-keyword">var</span> b, c <span class="hljs-type">int</span> <span class="hljs-comment">// 定义两个变量</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><br><span class="hljs-comment">// 赋初值</span><br><span class="hljs-keyword">var</span> aa <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> bb, cc <span class="hljs-type">int</span> = <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> ss <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br><br><span class="hljs-comment">// 用括号集中定义</span><br><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">int</span><br>    s <span class="hljs-type">string</span><br>)<br></code></pre></td></tr></table></figure><p><strong>（2）当赋初值时，不声明变量类型</strong></p><blockquote><p>当不声明类型时，可以不同类型可以一起定义。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b, c, s = <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（3）不使用 var 关键字【推荐】</strong></p><p><code>:=</code> 表示定义<br><code>=</code> 表示赋值。<br>注：只能在函数内使用这种定义方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">1</span><br>b, s := <span class="hljs-number">2</span>, <span class="hljs-string">&quot;abc&quot;</span><br><br><span class="hljs-comment">// 【注意】</span><br>a, b := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>   <span class="hljs-comment">// 定义 a, b</span><br>b, c := <span class="hljs-number">3</span>, <span class="hljs-number">4</span>   <span class="hljs-comment">// 虽然 b 定义过，因为 c 没定义过，所以 b, c 可以使用 := 定义。</span><br>fmt.Println(a, b, c)<br></code></pre></td></tr></table></figure><p><strong>（4）包内定义和函数内定义</strong></p><ul><li>go 没有真正的全局变量，包内定义只能在包内使用。</li><li>包内定义推荐使用 <code>var ()</code> 集中定义。</li></ul><h3 id="2-2-变量类型-占位符">2.2 变量类型/占位符</h3><p><strong>变量类型</strong>：</p><ul><li><p>bool、string</p></li><li><p>无符号整型：int（长度跟随操作系统位数）、int8、int16、int32、int64</p></li><li><p>指针（长度跟随操作系统位数）：unitptr</p></li><li><p>字符类型（8位，1字节，同 int8）：byte</p></li><li><p>字符类型（32位，4字节，同 int32）：rune</p><blockquote><p>utf-8 中，有的字符需要三个字节表示。</p><p>使用 char 有很多问题，所以 go 没有 char 类型，使用 4 个字节来作为字符类型。</p></blockquote></li><li><p>浮点型：float32、float64</p></li><li><p>复数：complex64、complex128</p></li></ul><p><strong>占位符</strong>：</p><p>通用占位符</p><ul><li><code>%v</code>：默认格式</li><li><code>%+v</code>：在打印结构体时，包含字段名和字段值 <code>&#123;Name:Alice Age:30&#125;</code></li><li><code>%#v</code>：输出 Go 语言的语法格式 <code>main.Person&#123;Name:&quot;Alice&quot;, Age:30&#125;</code></li><li><code>%T</code>：打印值的类型</li><li><code>%%</code>：打印百分号</li></ul><p>布尔类型</p><ul><li><code>%t</code>：true 或 false</li></ul><p>整数类型</p><ul><li><code>%b</code>：二进制表示</li><li><code>%c</code>：相应 Unicode 码点表示的字符</li><li><code>%d</code>：十进制表示</li><li><code>%o</code>：八进制表示</li><li><code>%O</code>：带 0o 前缀的八进制表示</li><li><code>%q</code>：单引号围绕的字符字面值，由 Go 语法安全地转义</li><li><code>%x</code>：十六进制表示，使用 a-f</li><li><code>%X</code>：十六进制表示，使用 A-F</li><li><code>%U</code>：Unicode 格式：U+1234</li></ul><p>浮点数及复数类型</p><ul><li><code>%b</code>：无小数部分的科学计数法，如 -123456p-78</li><li><code>%e</code>：科学计数法，如 -1.234456e+78</li><li><code>%E</code>：科学计数法，如 -1.234456E+78</li><li><code>%f</code>：有小数点而无指数，如 123.456</li><li><code>%F</code>：同 <code>%f</code></li><li><code>%g</code>：根据情况采用 <code>%e</code> 或 <code>%f</code> 格式（以获得更紧凑的表示）</li><li><code>%G</code>：根据情况采用 <code>%E</code> 或 <code>%F</code> 格式（以获得更紧凑的表示）</li></ul><p>字符串和字节切片</p><ul><li><code>%s</code>：字符串或字节切片，不进行格式化</li><li><code>%q</code>：双引号围绕的字符串字面值，由 Go 语法安全地转义</li><li><code>%x</code>：每个字节用两字符十六进制表示，使用 a-f</li><li><code>%X</code>：每个字节用两字符十六进制表示，使用 A-F</li></ul><p>指针</p><ul><li><code>%p</code>：十六进制表示，前缀 0x</li></ul><h3 id="2-3-类型转化">2.3 类型转化</h3><p>只有强制类型转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 参数、返回值均为 float64：func Sqrt(x float64) float64 &#123;&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">triangle</span><span class="hljs-params">()</span></span> &#123;<br>    a, b := <span class="hljs-number">3</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br>    c = <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(a*a + b*b)))   <span class="hljs-comment">// 所以此处必须强制转换</span><br>    fmt.Println(c)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-常量定义">2.4 常量定义</h3><p>不声明类型时，常量的数值可以作为各种类型使用，就相当于文本替换（C++中的宏定义）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> filename <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc.txt&quot;</span>     <span class="hljs-comment">// 申明类型</span><br><br><span class="hljs-keyword">const</span> a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>      <span class="hljs-comment">// 不声明类型，a、b 既可以做 int 也可以做 float</span><br><br><span class="hljs-comment">// 集中定义</span><br><span class="hljs-keyword">const</span> (<br>    a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span><br>    filename = <span class="hljs-string">&quot;abc.txt&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>特殊的常量：枚举类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> (   <span class="hljs-comment">// 定义枚举类型</span><br>        cpp    = <span class="hljs-number">0</span><br>        java   = <span class="hljs-number">1</span><br>        python = <span class="hljs-number">3</span><br>        golang = <span class="hljs-number">4</span><br>    )<br>    fmt.Println(cpp, java, python, golang) <span class="hljs-comment">// 0 1 3 4</span><br>&#125;<br><br><br>---------------------<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> (<br>        cpp = <span class="hljs-literal">iota</span>   <span class="hljs-comment">// 创建自增的枚举，这样后面变量可不赋值，自动 +1</span><br>        java<br>        python<br>        golang<br>    )<br>    fmt.Println(cpp, java, python, golang) <span class="hljs-comment">// 0 1 3 4</span><br>&#125;<br><br><br>---------------------<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> (<br>        b = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)    <span class="hljs-comment">// 利用自增作为种子，构建表达式</span><br>        kb<br>        mb<br>        gb<br>        tb<br>    )<br>    fmt.Println(b, kb, mb, gb, tb)      <span class="hljs-comment">// 1 1024 1048576 1073741824 1099511627776</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-条件语句">2.5 条件语句</h3><p><strong>（1）if</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> fileame = <span class="hljs-string">&quot;./abc.txt&quot;</span><br>    contents, err := ioutil.ReadFile(filename)   <span class="hljs-comment">// 读取文件，返回两个参数，内容和错误信息。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;   <span class="hljs-comment">// 判断是否有错误信息</span><br>        fmt.Println(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, contents)<br>    &#125;<br>&#125;<br><br><br>---------------------<br><span class="hljs-comment">// 定义变量和 if 判断写到一起, 用分号做分割</span><br><span class="hljs-comment">// 注意：此时 contents 只能在 if 中使用。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> filename = <span class="hljs-string">&quot;./abc.txt&quot;</span><br>    <span class="hljs-keyword">if</span> contents, err := ioutil.ReadFile(filename); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, contents)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）switch</strong></p><ul><li>默认每个 case 后自动有 break，否则需要使用 fallthrough。</li><li>panic 函数会终止程序，打印错误信息。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">grade</span><span class="hljs-params">(score <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    yourGrade := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">0</span> &amp;&amp; score &lt; <span class="hljs-number">60</span>:<br>        yourGrade = <span class="hljs-string">&quot;fail&quot;</span><br>    <span class="hljs-keyword">case</span> score &lt; <span class="hljs-number">90</span>:<br>        yourGrade = <span class="hljs-string">&quot;pass&quot;</span><br>    <span class="hljs-keyword">case</span> score &lt;= <span class="hljs-number">100</span>:<br>        yourGrade = <span class="hljs-string">&quot;super&quot;</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;Wrong score: %d&quot;</span>, score))   <span class="hljs-comment">// 同 c++ 的 sprintf，将字符串格式化，当作 panic 的参数。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> yourGrade<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-Loop-及常见易错">2.6 Loop 及常见易错</h3><ul><li>条件没有括号。</li><li>初始条件、结束条件、递增表达式都可以省掉。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>        sum += i<br>    &#125;<br>    fmt.Println(sum)<br>&#125;<br><br>---------------------<br><span class="hljs-comment">// 省略初始条件</span><br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> ; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>    sum += i<br>&#125;<br><br><br>---------------------<br><span class="hljs-comment">// 省略初始条件、递增表达式，同其他语言的 while（go 没有 while）</span><br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">100</span> &#123;<br>    sum += i<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><br>---------------------<br><span class="hljs-comment">// 省略初始条件、结束条件、递增表达式（死循环）</span><br><span class="hljs-keyword">for</span> &#123;<br>    sum += i<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>【<strong>重点注意</strong>】遍历中，循环变量的易错点。</p><p><strong>易错点一：使用循环变量的地址</strong></p><p>循环变量是局部变量，只会被初始化一次，之后的每次循环时，重新赋值覆盖前面的值。</p><p>解决方案：</p><ul><li>在使用循环变量的地址时，需用临时变量保留循环变量。</li><li>传递原始的指针。</li><li>利用函数闭包功能。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr []*<span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;  <span class="hljs-comment">// i 是局部变量，只会被初始化一次，之后的每次循环时，对 i 的重新赋值覆盖前面的储存 &amp;i 的值。</span><br>        arr = <span class="hljs-built_in">append</span>(arr, &amp;i)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;值:&quot;</span>, *arr[<span class="hljs-number">0</span>], *arr[<span class="hljs-number">1</span>], *arr[<span class="hljs-number">2</span>])<br>    fmt.Println(<span class="hljs-string">&quot;地址:&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>])<br>&#125;<br><br><span class="hljs-comment">// 值: 3 3 3</span><br><span class="hljs-comment">// 地址: 0xc000134008 0xc000134008 0xc000134008</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    arr2 := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(arr1))<br><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr1 &#123;<br>        arr2[i] = &amp;v<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;值:&quot;</span>, *arr2[<span class="hljs-number">0</span>], *arr2[<span class="hljs-number">1</span>], *arr2[<span class="hljs-number">2</span>])<br>    fmt.Println(<span class="hljs-string">&quot;地址:&quot;</span>, arr2[<span class="hljs-number">0</span>], arr2[<span class="hljs-number">1</span>], arr2[<span class="hljs-number">2</span>])<br>&#125;<br><br><span class="hljs-comment">// 值: 3 3 3</span><br><span class="hljs-comment">// 地址: 0xc0000b4008 0xc0000b4008 0xc0000b4008</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arrays [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, arr := <span class="hljs-keyword">range</span> [][<span class="hljs-number">1</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;&#125; &#123;<br>        arrays = <span class="hljs-built_in">append</span>(arrays, arr[:])<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Values:&quot;</span>, arrays)<br>&#125;<br><br><span class="hljs-comment">// Values: [[3] [3] [3]]</span><br></code></pre></td></tr></table></figure><p><strong>易错点二：在循环体内使用 goroutine</strong></p><p>循环可能很快跑完，val 已经遍历到 values 的最后一个值了，go func 可能才开始运行，此时的 val 就是 values 的最后一个值。</p><p>解决方案：</p><ul><li><p>保存临时变量。</p></li><li><p>闭包：将循环变量当作 goroutine 的参数传入。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(val)<br>        &#125;()<br>    &#125;<br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-comment">// 使用闭包的代码：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(val)<br>        &#125;(val)<br>    &#125;<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-Function">2.7 Function</h3><p><strong>（1）函数定义</strong></p><p>函数名写在前面，返回类型在后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;+&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）返回值可以返回两个</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b, a - b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    max, min := function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 接收两个返回值。</span><br>    tmp, _ := function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)   <span class="hljs-comment">// 只接收一个返回值，_ 用作占位符。</span><br>    fmt.Println(max, min, tmp)<br>&#125;<br><br><br>---------------------<br><span class="hljs-comment">// 函数体比较长，不推荐的写法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (max, min <span class="hljs-type">int</span>) &#123;   <span class="hljs-comment">// 返回值中声明变量名</span><br>    max = a + b<br>    min = a - b<br>    <span class="hljs-keyword">return</span>    <span class="hljs-comment">// 返回时可不写变量名。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况，两个返回值，一个返回结果一个返回错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;+&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b, <span class="hljs-literal">nil</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;unsuported operation: %s&quot;</span>, s)   <span class="hljs-comment">// 返回错误</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> res, err := function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;*&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;   <span class="hljs-comment">// 判断是否有错</span><br>        fmt.Println(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(res)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）函数作为参数</strong></p><p>同 C++ 中的回调函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注意函数做参数的定义方式（函数名称，函数参数，函数返回值）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(opt <span class="hljs-keyword">func</span>(<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>, a, b <span class="hljs-type">float64</span>) <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> opt(a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(function(math.Pow, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 2 的 3 次方 = 8</span><br>    fmt.Println(function(math.Max, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 2 和 3 中最大 = 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）匿名函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(opt <span class="hljs-keyword">func</span>(<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>, a, b <span class="hljs-type">float64</span>) <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> opt(a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(function(<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f1 <span class="hljs-type">float64</span>, f2 <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;   <span class="hljs-comment">// 使用匿名函数作为 function 的参数，完成减法</span><br>            <span class="hljs-keyword">return</span> f1 - f2<br>        &#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>),<br>    )    <span class="hljs-comment">// 2 - 3 = -1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）可变参数列表</strong></p><ul><li>go 没有默认参数、可选参数、函数重载、操作符号重载等花里胡哨的东西。</li><li>只有 <strong>可变参数列表</strong>，相当于一个数组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumArgs</span><span class="hljs-params">(values ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;   <span class="hljs-comment">// values ...int 就是可变参数列表</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> values &#123;<br>        sum += values[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(sumArgs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-Pointer">2.8 Pointer</h3><ul><li>因为类型在后面，定义指针和使用指针是很好区分。</li><li>指针不能运算（C 语言中指针的复杂来源于指针 + 1）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = &amp;a   <span class="hljs-comment">// 定义指针</span><br>*p = <span class="hljs-number">3</span>    <span class="hljs-comment">// 使用指针</span><br>fmt.Println(a)   <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="2-9-参数传递">2.9 参数传递</h3><ul><li>C/C++ 可以值传递，也可以引用传递。</li><li>java/python 大部分类型是引用传递。</li><li>go 只有值传递，通过指针可以实现引用传递的效果。</li></ul><h3 id="2-10-Array">2.10 Array</h3><p><strong>（1）定义</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>    arr2 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;  <span class="hljs-comment">// 使用 := 就应该赋初值  类型：[3]int</span><br>    arr3 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;  <span class="hljs-comment">// 省略数组个数，但是需要加 ...  类型：[4]int</span><br>    arr4 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;  <span class="hljs-comment">// 【注意】不加...，类型为 []int，表示切片</span><br>  <br>    <span class="hljs-keyword">var</span> arr5 = [<span class="hljs-number">4</span>][<span class="hljs-number">5</span>]<span class="hljs-type">bool</span>   <span class="hljs-comment">// 定义二维数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）求长度</strong></p><p>数组、slice、string（特殊的 slice） 求长度均使用 len 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-built_in">len</span>(arr)<br></code></pre></td></tr></table></figure><p><strong>（3）遍历数组</strong></p><p>推荐使用 range 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr2 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>    <span class="hljs-comment">// 遍历数组</span><br>      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr2); i++ &#123;<br>        fmt.Println(arr2[i])<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历数组【推荐写法】</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr2 &#123;   <span class="hljs-comment">// range 函数只获取数组下标</span><br>        fmt.Println(arr2[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr2 &#123;   <span class="hljs-comment">// range 函数获取数组下标和值，r 表示下标，v 表示元素值</span><br>        fmt.Println(i, v)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr2 &#123;   <span class="hljs-comment">// range 函数只获取数组的值</span><br>        fmt.Println(v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）数组是值类型</strong></p><ul><li><code>[3]int</code> 和 <code>[4]int</code> 是不同类型，类型不同不能直接调用。</li><li>调用 <code>func function(arr [3]int)</code> ，传参会拷贝数组，值传递。（大部分语言的数组传递都是引用传递）</li><li>在 go 中，一般不直接使用数组，使用切片。</li><li>注意：【传递切片也是值传递，但是可以实现引用传递效果，因为切片只是相当于视图】</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// [3]int 和 [4]int 是不同类型，类型不同不能直接调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(arr [3]<span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-comment">// 传参会拷贝数组，值传递 </span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Println(i, v)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    function(arr)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>指向数组的指针作为函数参数【一般不用这种方式，推荐使用切片】</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(arrPtr *[3]<span class="hljs-type">int</span>)</span></span> &#123;   <span class="hljs-comment">// 用 指针传递 作为 引用传递</span><br>    arrPtr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>   <span class="hljs-comment">// 使用 指针 直接取值</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arrPtr &#123;   <span class="hljs-comment">// range 可直接遍历 arrPtr 指向的数组</span><br>        fmt.Println(i, v)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    function(&amp;arr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-11-Slice">2.11 Slice</h3><blockquote><p>slice：切片</p><p>既是切片，也是动态数组。</p></blockquote><p><strong>（1）基本用法</strong></p><ul><li><code>arr[2:6]</code> 表示第 2 位到第 5 位，左闭右开。</li><li>前后下标可以缺省。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;   <span class="hljs-comment">// 定义的是 array</span><br>    fmt.Println(arr[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>]) <span class="hljs-comment">// [2 3 4 5]  // 传入的是 slice</span><br>    fmt.Println(arr[<span class="hljs-number">2</span>:])  <span class="hljs-comment">// [2 3 4 5 6]</span><br>    fmt.Println(arr[:<span class="hljs-number">6</span>])  <span class="hljs-comment">// [0 1 2 3 4 5]</span><br>    fmt.Println(arr[:])   <span class="hljs-comment">// [0 1 2 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）底层原理</strong></p><ul><li>slice 底层结构是一个结构体，里面包含了指针、元素数量、容量。</li><li>对于切片 s，<code>len(s)</code> 可以取出 slice 中的元素数量，<code>cap(s)</code> 可以取出 slice 的容量。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-09-21-Lfakp4.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer <span class="hljs-comment">// 指向数组的指针</span><br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// slice 中元素的数量</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量：从 slice 起始位置到 array 尾部的长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）切片做参数</strong></p><ul><li>go 所有类型都是值类型。slice 传递的也是值，<strong>不过这个值是指向数组的指针，可以对数组进行操作。</strong></li><li>slice 本身是没有数据的，是对底层 array 的一个 view（视图）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;   <span class="hljs-comment">// 形参里，[] 表示传递的是 slice，[数字] 表示传递的是数组</span><br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br>    fmt.Println(arr) <span class="hljs-comment">// [100 3 4 5]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;   <span class="hljs-comment">// 定义的是 array</span><br>    function(arr[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>])  <span class="hljs-comment">// 传入的是 slice</span><br>    fmt.Println(arr) <span class="hljs-comment">// [0 1 100 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）slice 的拷贝</strong></p><ul><li>s1、s2 都是 arr 的 view。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;   <span class="hljs-comment">// 定义的是 array</span><br>    s1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]  <span class="hljs-comment">// s is slice</span><br>    fmt.Println(s1)   <span class="hljs-comment">// [1 2 3 4 5]</span><br>    s2 := s1[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(s2)   <span class="hljs-comment">// [2 3 4]</span><br>    s2 = s2[<span class="hljs-number">1</span>:]<br>    fmt.Println(s2)  <span class="hljs-comment">// [3 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）slice 的扩展</strong></p><ul><li>slice 可以向后扩展，不能向前扩展。</li><li>s[i] 不能超过 <code>len(s)</code>，向后扩展不能超过 <code>cap(s)</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>    s1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(s1) <span class="hljs-comment">// [1 2 3]</span><br>    s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(s2) <span class="hljs-comment">// [3 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2021-09-21-xT4KFy.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（6）slice 的添加元素</strong></p><blockquote><ul><li><p><code>append(slice, elems)</code> 由于值传递的关系，必须接受 <code>append()</code> 的返回值。</p><p>一般 <code>s2 = append(s1, elems)</code> 或 <code>s1 = append(s1, elems)</code></p></li><li><p>elems 是可变参数，可以加多个。<code>append(slice, elem1, elem2, elem3)</code></p></li></ul></blockquote><ul><li>slice 的容量足够时，<ul><li>会通过指针更改原数组的值。</li></ul></li><li>当 slice 的容量不够时，<ul><li>slice 的指针会指向一个新建的数组，并将原数组中的数据拷贝到新数组中。</li><li>扩容原则（类似 STL 中的 vector）：新数组是原数组容量的两倍，当原数组长度大于 1024 时，将每次按照不小于 25% 的涨幅扩容。</li></ul></li><li>扩容后的 slice 不再指向原数组，无法更改原数组的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    s1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]      <span class="hljs-comment">// [1]</span><br> <br>  <br>    <span class="hljs-comment">// ======slice 的容量够用======  </span><br>    s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">20</span>) <span class="hljs-comment">// [1 20]</span><br>    fmt.Printf(<span class="hljs-string">&quot;s1 = %d, len(s1) = %d, cap(s1) = %d\n&quot;</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br>    <span class="hljs-comment">// s1 = [1 20], len(s1) = 2, cap(s1) = 2</span><br>  <br>  <br>    <span class="hljs-comment">// ======slice 的容量不够用======</span><br>    s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>    <span class="hljs-comment">// 此时，s1 = [1 20 3 4], len(s1) = 4, cap(s1) = 4</span><br>  <br>    s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">5</span>)<br>    <span class="hljs-comment">// 此时，s1 = [1 20 3 4 5], len(s1) = 5, cap(s1) = 8</span><br>  <br>  <br>    <span class="hljs-comment">// ======扩容后的 s1 不再指向原数组，无法更改原数组的值======</span><br>      s1[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span><br>    fmt.Println(arr) <span class="hljs-comment">// [0 1 20]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（7）slice 的合并</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// array</span><br>s1 := arr[:<span class="hljs-number">1</span>] <span class="hljs-comment">// slice</span><br>s2 := arr[<span class="hljs-number">2</span>:]  <span class="hljs-comment">// slice</span><br>s := <span class="hljs-built_in">append</span>(s1, s2...)  <span class="hljs-comment">// s -&gt; &#123;0, 2&#125;   // ... 表示对 slice s2 解构</span><br></code></pre></td></tr></table></figure><p><strong>（8）slice 作动态数组（定义）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 定义空 slice</span><br>    <span class="hljs-comment">//  此时 s == nil, len(s) == 0，cap(s) == 0</span><br>    <span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// 初始化 slice 的值</span><br>    <span class="hljs-comment">// 此时 s1 == [1 2 3]，len(s) == 3，cap(s) == 3</span><br>    s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>    <span class="hljs-comment">// 定义空 slice 并设置元素输量</span><br>    <span class="hljs-comment">// 此时 s1 == [0 0 0]，len(s) == 3，cap(s) == 3</span><br>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment">// 定义空 slice 并设置容量</span><br>    <span class="hljs-comment">// 此时 s1 == [0 0 0]，len(s) == 3，cap(s) == 16</span><br>    s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">16</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（9）slice 作动态数组（拷贝）</strong></p><ul><li>利用 <code>copy()</code> 拷贝时，是拷贝元素值，不是指向数组的指针。（类似于 C++ 的深拷贝）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">copy</span>(s2, s1)<br>    fmt.Println(s1)  <span class="hljs-comment">// [0 1 2 3]</span><br>    fmt.Println(s2)  <span class="hljs-comment">// [0 1 2 3 0 0 0 0]</span><br>  <br>  <span class="hljs-comment">// ======= 当 len(s2) 小于 len(s1) 时，只能拷贝前一部分 =======</span><br>    s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">copy</span>(s2, s1)<br>    fmt.Println(s1)  <span class="hljs-comment">// [0 1 2 3]</span><br>    fmt.Println(s2)  <span class="hljs-comment">// [0 1]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（10）slice 作动态数组（删除某元素）</strong></p><ul><li>使用 <code>append(slice, elems)</code> 函数。<ul><li><code>s1 = append(s1[:2], s1[3:]...)</code> 向 <code>s1[:2]</code> 中添加 <code>s1[3:]</code> 的所有元素。</li><li><code>elems</code> 是可变参数，使用 <code>s1[3:]...</code> 可以省去将 <code>s1[3:]</code> 的所有元素都列举出来。</li></ul></li><li>删除头尾极其方便。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除中间 2 这元素</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    s1 = <span class="hljs-built_in">append</span>(s1[:<span class="hljs-number">2</span>], s1[<span class="hljs-number">3</span>:]...)<br>    fmt.Println(s1)  <span class="hljs-comment">// [0 1 3]</span><br>&#125;<br><br><span class="hljs-comment">// 删除头尾元素比较方便</span><br>s1 = s1[<span class="hljs-number">1</span>:]<br>s1 = s1[:<span class="hljs-built_in">len</span>(s1) - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="2-12-Map">2.12 Map</h3><p><strong>（1）创建</strong></p><ul><li><p>使用 make 建立的是空的 map（empty map），使用 var 定义的是 nil，但是二者可以互相运算，无影响。</p><blockquote><p>But：nil map 不能直接增加元素，需要用 make 函数创建一个非 nil map。</p></blockquote></li><li><p>上述二者打印出来就是 <code>map[]</code>。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;cpp&quot;</span>:    <span class="hljs-number">85</span>,<br>        <span class="hljs-string">&quot;java&quot;</span>:   <span class="hljs-number">40</span>,<br>        <span class="hljs-string">&quot;python&quot;</span>: <span class="hljs-number">60</span>,<br>        <span class="hljs-string">&quot;golang&quot;</span>: <span class="hljs-number">100</span>,<br>    &#125;<br><br><br>    <span class="hljs-comment">// 创建 empty map</span><br>    m0 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;  <span class="hljs-comment">// m0 == empty map</span><br>    m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)   <span class="hljs-comment">// m1 == empty map</span><br><br>    <span class="hljs-keyword">var</span> m2 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>   <span class="hljs-comment">// m2 == nil    // nil map 不能直接赋值</span><br><br>    fmt.Println(m, m1, m2) <span class="hljs-comment">// map[cpp:85 golang:100 java:40 python:60] map[] map[]</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充：</p><ul><li>声明的是 nil map。</li><li>nil map 不能直接赋值。</li><li>但是 nil map 可以取值，返回类型的默认值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个 nil map</span><br><span class="hljs-keyword">var</span> m2 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br><br><span class="hljs-comment">// m2[&quot;app&quot;] = &quot;APP&quot;   // error：nil map 不能直接赋值</span><br>value, ok := m2[<span class="hljs-string">&quot;http&quot;</span>]  <span class="hljs-comment">// 正确：nil map 可以返回默认值。value = “”, ok = false</span><br><br>m2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)   <span class="hljs-comment">// 创建一个非 nil map，可以直接赋值</span><br>m2[<span class="hljs-string">&quot;app&quot;</span>] = <span class="hljs-string">&quot;APP&quot;</span>   <span class="hljs-comment">// 正确。</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>（2）遍历元素</strong></p><ul><li>使用 range 遍历 key 或 value 或 key-value 对。</li><li>hash map，没有顺序（每次打印的顺序不一样）。</li><li>空 map 也可以直接遍历，不会报错，不需要提前判断是否为空。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;cpp&quot;</span>:    <span class="hljs-number">85</span>,<br>        <span class="hljs-string">&quot;java&quot;</span>:   <span class="hljs-number">40</span>,<br>        <span class="hljs-string">&quot;python&quot;</span>: <span class="hljs-number">60</span>,<br>        <span class="hljs-string">&quot;golang&quot;</span>: <span class="hljs-number">100</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;   <span class="hljs-comment">// 只遍历 key</span><br>        fmt.Println(k)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;  <span class="hljs-comment">// 只遍历 value</span><br>        fmt.Println(v)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> k, v = <span class="hljs-keyword">range</span> m &#123;   <span class="hljs-comment">// 遍历 key-value 对</span><br>        fmt.Println(k, v)<br>    &#125;<br>    <br>    emptyMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> k, v = <span class="hljs-keyword">range</span> emptyMap &#123;<br>        fmt.Println(<span class="hljs-string">&quot;遍历空 map，不会报错，也不会进入循环体。&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）增加元素</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>m1[<span class="hljs-string">&quot;add&quot;</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>（4）获取元素</strong></p><ul><li>当 key 不存在时，获得 value 类型的初始值。<ul><li>int 初始值是 0，string 初始值是空串 <code>&quot;&quot;</code>，bool 初始值是 false。</li></ul></li><li>获取元素时，可两个返回值：value、ok。<ul><li>存在 ok == true</li><li>不存在 ok == false</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;cpp&quot;</span>:    <span class="hljs-number">85</span>,<br>        <span class="hljs-string">&quot;java&quot;</span>:   <span class="hljs-number">40</span>,<br>        <span class="hljs-string">&quot;python&quot;</span>: <span class="hljs-number">60</span>,<br>        <span class="hljs-string">&quot;golang&quot;</span>: <span class="hljs-number">100</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// 获取存在的元素</span><br>    value1 := m[<span class="hljs-string">&quot;cpp&quot;</span>]<br>    fmt.Println(value1) <span class="hljs-comment">// 85</span><br><br>    <span class="hljs-comment">// 获取不存在的元素</span><br>    value2, ok := m[<span class="hljs-string">&quot;app&quot;</span>]<br>    fmt.Println(value2, ok) <span class="hljs-comment">// 0, false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）删除元素</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;cpp&quot;</span>:    <span class="hljs-number">85</span>,<br>        <span class="hljs-string">&quot;java&quot;</span>:   <span class="hljs-number">40</span>,<br>        <span class="hljs-string">&quot;python&quot;</span>: <span class="hljs-number">60</span>,<br>        <span class="hljs-string">&quot;golang&quot;</span>: <span class="hljs-number">100</span>,<br>    &#125;<br><br>    <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;java&quot;</span>)<br>    fmt.Println(m) <span class="hljs-comment">// map[cpp:85 golang:100 python:60]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）map 中的 key 的类型</strong></p><ul><li>map 使用哈希表，必须可以比较相等。</li><li>除了 slice、map、function 的内建类型都可以作为 key。</li><li>当 struct 不包括上述类型，也可以作为 key。</li></ul><p><strong>（7）复合 map</strong></p><ul><li>map 的 value 是个 map。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <br>      <span class="hljs-comment">// m 的 key 是 string 类型，value 是 map[string]int 类型。</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;China&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;cpp&quot;</span>:  <span class="hljs-number">80</span>,<br>            <span class="hljs-string">&quot;java&quot;</span>: <span class="hljs-number">20</span>,<br>        &#125;,<br>        <span class="hljs-string">&quot;USA&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;cpp&quot;</span>:  <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;java&quot;</span>: <span class="hljs-number">0</span>,<br>        &#125;,<br>        <span class="hljs-string">&quot;England&quot;</span>: &#123;&#125;,<br>    &#125;<br>    fmt.Println(m)  <span class="hljs-comment">// map[China:map[cpp:80 java:20] England:map[] USA:map[cpp:0 java:0]]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-13-Rune">2.13 Rune</h3><p><strong>（1）字符串存在的问题</strong>：索引和汉字数量无法对上，意味着无法通过索引取到中文汉字。</p><ul><li>s 有 5 个汉字。</li><li><code>len(s) = 15</code>，len 只能获得字节长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;民族有希望&quot;</span><br>    <br>    <span class="hljs-comment">// 存在问题：索引和汉字数量无法对上</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;(%d, %c)  &quot;</span>, i, ch)  <span class="hljs-comment">// (0, 民)  (3, 族)  (6, 有)  (9, 希)  (12, 望) </span><br>        <span class="hljs-comment">// fmt.Printf(&quot;%c&quot;, s[2])  // 无法取到想要的汉字</span><br>    &#125;<br>    fmt.Println()<br><br>    <span class="hljs-comment">// 解决问题：使用 rune 对字符串进行类型转换</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-type">rune</span>(s) &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;(%d, %c)  &quot;</span>, i, ch)  <span class="hljs-comment">// (0, 民)  (1, 族)  (2, 有)  (3, 希)  (4, 望) </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）出现问题的原因</strong></p><ul><li>string 本质上是字节数组，索引的长度大小是字节，而 utf-8 编码是 3 个字节储存一个汉字，所以汉字数量和索引自然对不上。</li><li>之所以转 rune 数组可以解决问题，是因为 rune 是 4 字节储存一个字符/汉字，索引的长度大小是 rune。</li></ul><p><strong>（3）十六进制打印验证一下</strong></p><blockquote><p>前置知识点：</p><ul><li><p>rune 是 4 个字节储存 1 个字符，不使用 UTF-8 编码方式，使用 unicode 字符集一一对照即可。</p></li><li><p>string 使用的是 UTF-8 编码方式。</p></li><li><p>unicode 只是字符集，UTF-8 是 unicode 的实现方式之一，详见<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰：字符编码笔记</a></p></li></ul><p>如果明白了UTF-8、unicode，应该可以很轻松理解以下两个事实：</p><ul><li>在 UTF-8 编码模式下，一个汉字需要 3 个字节表示。</li><li>使用 4 个字节储存 1 个汉字，使用 unicode 字符集一一对照时，其实只有后两个字节有数据，前两个字节数据均为 0。</li></ul><p>再深入一点，都是使用 unicode 字符集，UTF-8 为什么需要更长的字节？</p><ul><li>UTF-8 编码是变长的编码方式，所以需要用额外的字符标记，这是 3 个字节表示 1 个字符，而不是 3 个字节表示是 3 个字符。</li><li>当规定编码方式为 4 个字节表示 1 个字符，就不需要使用额外的字符来标记多少字节储存一个字符。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;民族有希望&quot;</span><br><br>    <span class="hljs-comment">// s 本质上就是字节数组，为了将其按 Byte 为单位打印出来，需要将 s 转化为字节数组。</span><br>    <span class="hljs-comment">// 每个 ch 是 byte，一共循环 15 次，取出 15 个 byte。</span><br>    <span class="hljs-comment">// UTF—8 编码中，3 个字节表示 1 个汉字，所以一共表示 5 个汉字。</span><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> []<span class="hljs-type">byte</span>(s) &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%X &quot;</span>, ch) <span class="hljs-comment">// E6 B0 91 E6 97 8F E6 9C 89 E5 B8 8C E6 9C 9B</span><br>    &#125;<br>    fmt.Println()<br><br>    <span class="hljs-comment">// 对于 string，索引 i 还是按照 byte 为单位，但是打印是会按照字符来打印。</span><br>    <span class="hljs-comment">// 每个 ch 是 rune，一共循环 5 次，取出 5 个 rune，表示 5 个汉字。</span><br>    <span class="hljs-comment">// rune 使用 unicode 符号集，只需 2 个字节可表示一个汉字，所以 rune 的 4 字节，只有后面 2 个字节有数据，故只打印出后面两个字节</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;(%d, %X)  &quot;</span>, i, ch) <span class="hljs-comment">// (0, 6C11)  (3, 65CF)  (6, 6709)  (9, 5E0C)  (12, 671B)</span><br>    &#125;<br>    fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）获取 string 中的字符数量。</strong></p><ul><li>问题：<code>len(s)</code> 只能获得字节长度，无法获取字符数量。</li><li>理解：将 string 转化为 rune，取 rune 的数量。</li><li>函数：<code>utf8.RuneCount(string)</code></li></ul><p><strong>（5）在 byte 数组中，获取 rune 字符</strong></p><ul><li>理解：将 Byte 数组中的二进制，用 UTF-8 编码，转化为字符，以 rune 类型返回字符，size 表示字符含有几个字节。</li><li>函数：<code>ch, size := utf8.DecodeRune(bytes)</code></li></ul><h3 id="2-14-String">2.14 String</h3><blockquote><p>PS：反引号可以多行字符串，还能写入引号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">`frist line</span><br><span class="hljs-string">second line</span><br><span class="hljs-string">&quot;33&quot;`</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>（1）string 和 rune 数组、byte 数组的关系。</strong></p><ul><li>string 本质上是 []byte，但是 string 的类型是 string，[]byte 的类型是 []uint8。</li><li>string 和 []byte 可以互相转化。</li><li>string 和 []rune 可以互相转化，但 rune 使用 4 个字节储存 string 的一个字符/汉字。</li><li><strong>[]rune 不可以和 []byte 互相转化。</strong></li></ul><p><strong>（2）string 拼接：直接 + 字符串（双引号）即可。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// string 与 string 拼接</span><br>s := <span class="hljs-string">&quot;abc&quot;</span><br>s += <span class="hljs-string">&quot;123&quot;</span><br><br><span class="hljs-comment">// string 与 []rune 拼接</span><br>r := []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br>s += <span class="hljs-type">string</span>(r)<br><br><span class="hljs-comment">// string 与 []byte 拼接</span><br>b := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br>s += <span class="hljs-type">string</span>(b)<br><br><span class="hljs-comment">// string 与 字符 拼接</span><br>c := <span class="hljs-string">&#x27;d&#x27;</span><br>s += <span class="hljs-type">string</span>(c)<br><span class="hljs-comment">// fmt.Printf(&quot;%s&quot;, s)  // abc123abcabcd</span><br></code></pre></td></tr></table></figure><p><strong>（3）[]byte、[]rune 拼接不能使用 <code>+</code>，使用 append</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">r1, r2 := []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;abc&quot;</span>), []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;def&quot;</span>)<br>r1 = <span class="hljs-built_in">append</span>(r1, r2...)<br><span class="hljs-comment">// fmt.Printf(&quot;%c&quot;, r1)   // [a b c d e f]</span><br><br><br>r1, r2 := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;abc&quot;</span>), []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;def&quot;</span>)<br>r1 = <span class="hljs-built_in">append</span>(r1, r2...)<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, r1)   <span class="hljs-comment">// [a b c d e f]</span><br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, r1)   <span class="hljs-comment">// [a b c d e f]</span><br></code></pre></td></tr></table></figure><p><strong>（4）string 和 rune 数组遍历</strong></p><p>string 和数组遍历一样。</p><p><code>for i, value := range s</code> 或者 <code>for i := 0; i &lt; len(s); i++</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 二维数组的使用方式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">destCity</span><span class="hljs-params">(paths [][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, path := <span class="hljs-keyword">range</span> paths &#123;<br>        path[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span><br>        fmt.Println(path)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）string[i] 是 “c” or ‘c’？</strong></p><p>如何判断 s[i] 是不是 ‘-’</p><ul><li><p>string[0] 是 uint8 类型。</p></li><li><p>判断方式： <code>s[i] == 'c'</code></p><p>注意：上述判断方式只能与 uint8（byte）类型比较，与 uint32（rune）类型比较时，需要强制转换为 uint8（byte）类型。</p></li><li><p><code>ch := 'a'</code> ch 是 uint32，也就是 rune 类型。</p></li></ul><p><strong>（6）string 切片</strong></p><p>string 可以切片；切片可用 <code>+</code> 拼接。</p><p><strong>（7）字符串打印</strong></p><p>rune 、[]rune、byte、[]byte 均为整型，必需先将其转换为string才能用 Println 打印出来，否则打印出来的是一个整数。</p><h3 id="2-15-strings-Builder">2.15 strings.Builder</h3><p>string 类型也是只读且不可变的。因此，这种拼接字符串的方式会导致大量的string创建、销毁和内存分配。Golang 1.10 之后，推出了 <code>strings.Builder</code> 用于拼接字符串。</p><p><strong>（1）实现文件：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgolang.org%2Fsrc%2Fstrings%2Fbuilder.go%3Fs%3D1379%3A1412%23L15">strings/builder.go</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> Write(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> WriteByte(c <span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> WriteRune(r <span class="hljs-type">rune</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> WriteString(s <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><strong>（2）原理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Builder <span class="hljs-keyword">struct</span> &#123;<br>    addr *Builder <span class="hljs-comment">// of receiver, to detect copies by value</span><br>    buf  []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>既然 string 在构建过程中会不断的被销毁重建，为了尽量避免这个问题，底层使用一个 <code>buf []byte</code> 来存放字符串的内容。</li><li>对于写操作，将新内容 append 到 buf 中即可。</li><li>buf 容量不够就自动扩容。</li></ul><p><strong>（3）Grow()</strong></p><ul><li>扩容的原理：分配新的更大的 slice。</li><li><code>strings.Builder</code> 的 <code>Grow()</code> 方法是通过 <code>current_capacity * 2 + n</code> （<code>n</code> 就是你想要扩充的容量）的方式来对内部的 slice 进行扩容的。</li><li>当 n &lt; current_capacity 是不会发生扩容的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> Grow(n <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p><strong>（4）String()</strong></p><ul><li><code>strings.Builder</code> 支持使用 <code>String()</code> 来获取最终的字符串结果。</li><li>unsafe.Pointer，该类型可以表示任意类型且可寻址的指针值，可以在不同的指针类型之间进行转换。</li><li>这里直接将<code>buf []byte</code>转换为 string 类型，无需拷贝 buf，节省内存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> *(*<span class="hljs-type">string</span>)(unsafe.Pointer(&amp;b.buf))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）不要拷贝</strong></p><ul><li><p><code>strings.Builder</code> 不推荐被拷贝。当你试图拷贝 <code>strings.Builder</code> 并写入的时候，你的程序就会崩溃。</p></li><li><p>原因：<code>strings.Builder</code> 拷贝是浅拷贝，拷贝前后两个 builder 指向同一个 <code>buf []byte</code> 。</p></li><li><p>拷贝后只支持 len()、string()，不支持更改数据的。除非调用 <code>builder.Reset()</code> 方法重置了 builder，才能写入。</p></li></ul><h3 id="2-16-strings-package">2.16 strings package</h3><blockquote><p>不必过分深究 API，现用现学。参考：<a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter02/02.1.html">字符串操作</a></p></blockquote><p>strings 包内有诸多字符串操作，常用的有：</p><ul><li>分割拼接：Fields，Split，Join</li><li>查子串：Contains，Index，Count</li><li>转换大小写：ToLower，ToUpper</li><li>修建：Trim，TrimRight，TrimLeft</li><li>字符串比较：Compare</li></ul><p>字符串和基本数据类型之间转换：</p><ul><li>strconv.Itoa：string 转换为十进制有符号整型，实际上内部调用的 <code>ParseInt(s, 10, 0)</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>, base <span class="hljs-type">int</span>, bitSize <span class="hljs-type">int</span>)</span></span> (i <span class="hljs-type">int64</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 例：int 转 string</span><br>a := <span class="hljs-number">0</span><br>s := strconv.Itoa(a)<br></code></pre></td></tr></table></figure><h2 id="3-面对对象">3.面对对象</h2><ul><li>go 仅支持封装，不支持继承和多态。（面向接口编程）</li><li>go 没有 class，只有 struct。</li></ul><h3 id="3-1-结构体">3.1 结构体</h3><p><strong>（1）定义结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> treeNode <span class="hljs-keyword">struct</span> &#123;<br>    value       <span class="hljs-type">int</span><br>    left, right *treeNode<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）创建结构体</strong></p><ul><li>无论结构体指针还是结构体，都用 <code>.</code> 来访问成员。<ul><li>C++ 中使用的方式： <code>root.left-&gt;right</code>。</li><li>go 中为：<code>root.left.right</code>。</li></ul></li><li>new 一个变量返回变量地址。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-keyword">var</span> root treeNode<br>    root = treeNode&#123;value: <span class="hljs-number">3</span>&#125;<br>    <br>    root.right = &amp;treeNode&#123;&#125;   <span class="hljs-comment">// right 是指针，需赋值为地址</span><br>    <br>    root.left = &amp;treeNode&#123;<span class="hljs-number">5</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    <br>    root.left.right = <span class="hljs-built_in">new</span>(treeNode)<br>    <br>    fmt.Println(root)   <span class="hljs-comment">// &#123;3 0xc0000ac030 0xc0000ac018&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）创建结构体数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span> &#123;<br>    nodes := []treeNode&#123;<br>        &#123;value: <span class="hljs-number">3</span>&#125;,<br>        &#123;&#125;,<br>        &#123;<span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;,<br>    &#125;<br>    fmt.Println(nodes) <span class="hljs-comment">// [&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; &lt;nil&gt;&#125;]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）go 没有构造函数</strong></p><ul><li>如果需要控制结构体构造，可以写工厂函数。</li><li>在 go 中，可以返回局部变量的地址。<ul><li>（C++ 中局部变量分配在栈上，离开函数立即销毁，局部变量的地址不可返回，需要在堆上 new 出变量，并手动释放。）</li><li>（java 中所有变量都是分配在堆上的，有垃圾回收机制）</li><li>go 的变量分配在堆上还是栈上，<strong>无需使用者关心</strong>，由编译器根据代码来决定。</li></ul></li><li>那么，编译器根据代码如何决定，go 的局部变量分配在堆上还是栈上？<ul><li>如果局部变量没有取地址，并返回出去，将分配在栈上。</li><li>如果需要取地址并返回，将分配在堆上。</li><li>当该变量不再被使用，就会被垃圾回收机制回收。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span> &#123;<br>    ptr := createNode(<span class="hljs-number">10</span>)<br>    fmt.Println(*ptr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createNode</span><span class="hljs-params">(value <span class="hljs-type">int</span>)</span></span> *treeNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;treeNode&#123;value: value&#125;    <span class="hljs-comment">// 此处返回局部变量的地址，go 中不会有问题。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-结构体方法">3.2 结构体方法</h3><p><strong>（1）定义与使用</strong></p><ul><li><code>(node treeNode)</code> ：go 中叫接受者，相当于 this 指针，标记了哪个结构体在调用结构体方法。</li><li>结构体方法其实就是普通函数，使用接收者是为了便于 <code>root.print()</code> 的写法。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> treeNode <span class="hljs-keyword">struct</span> &#123;<br>    value       <span class="hljs-type">int</span><br>    left, right *treeNode<br>&#125;<br><br><span class="hljs-comment">// 结构体方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node treeNode)</span></span> <span class="hljs-built_in">print</span>() &#123;<br>    fmt.Println(node.value)<br>&#125;<br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print2</span><span class="hljs-params">(node treeNode)</span></span> &#123;<br>    fmt.Println(node.value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    root := treeNode&#123;<span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.<span class="hljs-built_in">print</span>()   <span class="hljs-comment">// 使用结构体方法</span><br>    print2(root)   <span class="hljs-comment">// 使用普通方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）接收者类型</strong></p><ul><li>接收者类型是结构体，该方法无法对结构体变量进行更改。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    root := treeNode&#123;<span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    root.setValue(<span class="hljs-number">600</span>)<br>    fmt.Println(root)   <span class="hljs-comment">// &#123;6 &lt;nil&gt; &lt;nil&gt;&#125;，root 没有被更改。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node treeNode)</span></span> setValue(value <span class="hljs-type">int</span>) &#123;  <span class="hljs-comment">// 接收者是结构体类型</span><br>    node.value = value<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接收者类型是结构体指针，该方法可以对结构体变量进行更改。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    root := treeNode&#123;<span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    root.setValue(<span class="hljs-number">600</span>)<br>    fmt.Println(root)   <span class="hljs-comment">// &#123;600 &lt;nil&gt; &lt;nil&gt;&#125;，root 被更改。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *treeNode)</span></span> setValue(value <span class="hljs-type">int</span>) &#123;   <span class="hljs-comment">// 接收者是结构体指针类型</span><br>    node.value = value<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>使用值接收者还是指针接收者呢？</strong></p><blockquote><p>值接收者是 go 特有的，C++ 和 java 都是 this 指针。</p></blockquote><ul><li>建议：最好使用指针接收者。</li><li>结构体过大，值传递需要拷贝，推荐使用指针接收者。</li><li>要改变结构体内容，必须使用指针接收者。</li></ul></li><li><p>无论接收者类型是指针还是结构体，都可以接收指针、结构体两种类型。</p><ul><li>在 C++ 中，<code>root.get()</code> 或 <code>root_ptr-&gt;get()</code>。</li><li>但在 go 中，<code>root.print()</code> 或 <code>rootPtr.print()</code> 都是用 <code>.</code> 。</li><li>所以 go 中接收者需要同时可以接收这两种类型。<strong>本质上都是传递的地址，再根据接收者的需要，取地址还是取结构体。</strong></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    root := treeNode&#123;<span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    rootPtr := &amp;root<br><br>    root.<span class="hljs-built_in">print</span>()<br>    rootPtr.<span class="hljs-built_in">print</span>()<br><br>    root.ptrPrint()<br>    rootPtr.ptrPrint()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node treeNode)</span></span> <span class="hljs-built_in">print</span>() &#123;<br>    fmt.Println(node.value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *treeNode)</span></span> ptrPrint() &#123;<br>    fmt.Println(node.value)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）结构体指针是nil，也可以调用结构体方法</strong></p><ul><li>首先，需要是结构体类型的指针，不可以 <code>nil.happy()</code> 。</li><li>其次，接收者应该是指针类型，否则会报错。（空指针有点特殊）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ptr *treeNode<br>    ptr.happy()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *treeNode)</span></span> happy() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;happy&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：空指针可以调用方法，<strong>这能有啥用呢？</strong></p><p>可以省去在递归时对空指针的判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 二叉树的中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *treeNode)</span></span> traverse() &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    node.left.traverse()    <span class="hljs-comment">// 正是因为空指针可以调用方法，所以此处不用判断 node.left 是否为空。</span><br>    node.<span class="hljs-built_in">print</span>()<br>    node.right.traverse()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node treeNode)</span></span> <span class="hljs-built_in">print</span>() &#123;<br>    fmt.Println(node.value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-封装">3.3 封装</h3><p>go 语言，通过函数的命名来进行封装。</p><ul><li>函数命名方式：大驼峰、小驼峰。</li><li>首字母大写表示 public。</li><li>首字母小写表示 private。</li></ul><h3 id="3-4-包">3.4 包</h3><ul><li>每个目录有且只能有一个包。</li><li>包名 main 代表它是一个可独立运行的包，它在编译后会产生可执行文件。所以执行入口 go 文件的包名必须是 main。</li><li>为一个 struct 定义的方法必须放在同一个包内，但可以是包内的不同的文件。</li></ul><p>权限问题：</p><ul><li>同一个包内的文件的全局变量、定义的 struct、定义的函数可以互相使用，不区分大小写（变量、类型、函数命令小写表示 prtivate）。</li><li>不同的包之间，需要 import 才能互相使用，且只能使用大写命名的变量、类型、函数。</li></ul><p>例如：反转二叉树项目的目录结构。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">tree  <span class="hljs-comment"># 项目目录</span><br>├── node.go         <span class="hljs-comment"># 定义 struct 类型 Node   package tree</span><br>├── build_tree.go   <span class="hljs-comment"># 生成二叉树  package tree</span><br>├── traversal.go    <span class="hljs-comment"># 反转二叉树  package tree</span><br>├── print_tree.go   <span class="hljs-comment"># 打印二叉树  package tree</span><br>├── entry_traversal <span class="hljs-comment"># 启动目录 </span><br>│   └── entry.go        <span class="hljs-comment"># 启动入口 -- 反转二叉树  package main</span><br>└── entry_check     <span class="hljs-comment"># 启动目录</span><br>    └── entry.go    <span class="hljs-comment"># 启动入口 -- 检查是否反转正确  package main</span><br></code></pre></td></tr></table></figure><h3 id="3-5-扩展已有类型">3.5 扩展已有类型</h3><p>golang 并没有继承、没有重载，<strong>扩展已有类型</strong> 或 <strong>使用别人的函数</strong>，有三种方式：</p><p><strong>（1）使用别名</strong></p><p>利用已有的切片，来扩展成队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-type">int</span>   <span class="hljs-comment">// 使用别名，将 切片 扩展成 队列</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Push(value <span class="hljs-type">int</span>) &#123;<br>    *q = <span class="hljs-built_in">append</span>(*q, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    head := (*q)[<span class="hljs-number">0</span>]<br>    *q = (*q)[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）使用组合</strong></p><p>比如，扩展 tree 项目中的 Node 类型，使用别人的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myTreeNode <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// 使用组合的方式实现类型扩展</span><br>    node *Tree.Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(myNode *myTreeNode)</span></span> myNewFunction() &#123;   <span class="hljs-comment">// 用别人的代码实现自己的功能</span><br>    myNode.node.Traversal()<br>    myNode.node.Print()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> root myTreeNode<br>    <span class="hljs-comment">// ...</span><br>    root.myNewFunction()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）使用内嵌（embedding）</strong></p><ul><li>使用内嵌定义的新类型，是可以直接使用 内嵌类型的变量、函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myTreeNode <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// myTreeNode 内嵌 *Tree.Node 类型</span><br>    *Tree.Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(myNode *myTreeNode)</span></span> myNewFunction() &#123;   <span class="hljs-comment">// 用别人的代码实现自己的功能</span><br>    myNode.Traversal()   <span class="hljs-comment">// 新的类型，可以直接使用 *Tree.Node 类型的功能</span><br>    myNode.Print()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> root myTreeNode<br>    <span class="hljs-comment">// ...</span><br>    root.myNewFunction()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）“重载” 了内嵌类型的函数</strong></p><p>IDE 会标记 shadowed method，其实并不是重载。</p><ul><li>这两个 Traversal 并没有任何关系，只是语法糖导致 node 的方法可以直接被 myNode 调用。</li><li>父类指针无法指向子类对象。（<strong>go 语言通过接口来实现这样的能力。</strong>）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myTreeNode <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// myTreeNode 内嵌 *Tree.Node 类型</span><br>    *Tree.Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(myNode *myTreeNode)</span></span> Traversal() &#123;   <span class="hljs-comment">// 和内嵌类型的函数名一样。</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> root myTreeNode<br>    <span class="hljs-comment">// ...</span><br>    root.node.Traversal()   <span class="hljs-comment">// 使用内嵌类型的 Traversal 函数。</span><br>    root.Traversal()        <span class="hljs-comment">// 使用新类型的 Traversal 函数。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）两种 Type 用法</strong></p><p>看到过这种写法 <code>type FuncMap = template.FuncMap</code>，在此说明：</p><ul><li>有 = 表示两个类型没区别，可以互相替换</li><li>无 = 表示创建新类型，继承旧类型的方法和属性</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> myInt = <span class="hljs-type">int</span>  <span class="hljs-comment">// int 和 myInt 可以互相替换</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a myInt<br>    a = <span class="hljs-number">2</span><br>    function(a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> myInt  <span class="hljs-type">int</span>   <span class="hljs-comment">// 表示定义了新类型 myInt，它的底层类型是 int，继承了 int 的所有方法和属性</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a myInt<br>    a = <span class="hljs-number">2</span><br>    function(a)   <span class="hljs-comment">// 报错类型不匹配，此处传入的是 MyInt，应该传入 int 类型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-依赖管理">4.依赖管理</h2><p>go 的依赖管理有三个发展阶段：GOPATH、GOVENDOR、go mod。</p><p>推荐使用 <strong>go mod</strong>。</p><h3 id="4-1-GOPATH">4.1 GOPATH</h3><p>默认在 ～/go，使用第三方库依赖时，GOPATH 下的 src 目录下开始寻找。</p><p><strong>缺点</strong>：</p><ul><li>所有的项目、依赖的第三方库都放在 GOPATH 下。</li><li>不同项目所依赖的第三方库版本可能不一样。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">GOPATH<br>├── bin<br>└── src<br>    ├── go.uber.org   <span class="hljs-comment"># 依赖的第三方库</span><br>    │   └── zap<br>    ├── golang.org    <span class="hljs-comment"># 依赖的第三方库</span><br>    │   └── x<br>    ├── project1   <span class="hljs-comment"># 项目一</span><br>    │   └── hellogo<br>    │       └── hello.go<br>    └── project2   <span class="hljs-comment"># 项目二</span><br>        ├── entry<br>        │   └── main.go<br>        └── zaptest<br>            └── zaptest.go<br><br></code></pre></td></tr></table></figure><h3 id="4-2-GOVENDOR">4.2 GOVENDOR</h3><ul><li>第三方依赖管理库：glide、dep、go dep…</li><li><strong>理念</strong>：<ul><li>项目所依赖的第三方库放在自己的 vendor 的目录下。</li><li>使用第三方库依赖时，从项目中的 vendor 目录下寻找。</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── bin<br>│   └── goimports<br>└── src<br>    ├── project1     <span class="hljs-comment"># 项目一</span><br>    │   ├── hellogo<br>    │   │   └── hello.go<br>    │   └── vendor      <span class="hljs-comment"># project1 依赖的第三方库</span><br>    │       └── golang.org<br>    └── project2     <span class="hljs-comment"># 项目二</span><br>        ├── entry<br>        │   └── main.go<br>        ├── zaptest<br>        │   └── zaptest.go<br>        └── vendor      <span class="hljs-comment"># project2 依赖的第三方库</span><br>            ├── golang.org<br>            └── go.uber.org <br></code></pre></td></tr></table></figure><ul><li><strong>缺点</strong>：<ul><li>需要手动管理第三方库。</li><li>即使使用第三方依赖管理库，依然会有种打补丁的感觉。</li></ul></li></ul><h3 id="4-3-go-mod">4.3 go mod</h3><blockquote><p>go module</p></blockquote><ul><li>原生的依赖管理。</li><li>理念：用户只需关心自己写的源代码即可，无需管理第三方依赖库。</li><li><strong>优点</strong>：<ul><li>使用 go.mod 对工程进行管理，只记录依赖的第三方库的名称和版本。</li><li>第三方库的实际代码放在 pkg 目录下进行缓存。</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">go    <span class="hljs-comment"># GOPATH</span><br>├── bin  <span class="hljs-comment"># Go 构建的编译可执行程序的位置</span><br>└── pkg  <span class="hljs-comment"># 编译后包文件会生成.a文件，放置在 $GOPATH/pkg/$GOOS_$GOARCH中。</span><br>│   └── mod <span class="hljs-comment"># 程序寻找第三方库，就在该目录下寻找</span><br>│       ├── go.uber.org <span class="hljs-comment"># 依赖的第三方库的版本信息</span><br>│       └── cache <span class="hljs-comment"># 依赖的第三方库代码实际缓存的位置</span><br>├── project1  <span class="hljs-comment"># 项目一</span><br>│   ├── go.mod  <span class="hljs-comment"># 用于依赖管理的 mod 文件：记录了所依赖的第三方库名称及其版本。</span><br>│   ├── go.sum  <span class="hljs-comment"># 对于 mod 文件更详细的描述：包含 现在 和 曾经 依赖的第三方库名称、版本、hash 值。</span><br>│   └── zaptest <span class="hljs-comment"># 包</span><br>│   │   ├── func.go    <span class="hljs-comment"># 封装的功能一</span><br>│   │   └── zaptest.go <span class="hljs-comment"># 封装的功能二 </span><br>│   └── entry   <span class="hljs-comment"># 包</span><br>│       └── entry.go   <span class="hljs-comment"># 启动程序，调用第三方库和封装的功能</span><br>│<br>└── project2  <span class="hljs-comment"># 项目二</span><br></code></pre></td></tr></table></figure><h3 id="4-4-相关命令">4.4 相关命令</h3><ul><li><p>如果项目中无 go.mod 文件，需要初始化：<code>go mod init</code></p></li><li><p>查看当前项目的配置：<code>go env</code></p></li><li><p>临时关闭 go mod：<code>export GO111MODULE=off</code></p></li><li><p>增加第三方依赖库：<code>go get</code></p></li><li><p>更新第三方库版本：添加版本号，例如 <code>go get -u go.uber.org/zap@v1.18.0</code></p></li><li><p>去除多余的第三方库：<code>go mod tidy</code></p></li></ul><h2 id="5-接口">5.接口</h2><h3 id="5-1-概念">5.1 概念</h3><p><strong>（1）在其他强类型语言中</strong></p><ul><li>接口本质上是定义接口规范，保证所有子类都有相同的接口实现。</li><li>接口就是一个抽象类，多个派生类，可以继承该抽象类，并实现抽象类的方法。</li><li>目的：从而实现多态，降低代码的耦合度，提高可扩充性和可维护性。（派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容。）</li></ul><p><strong>（2）在 go 中</strong></p><ul><li>go 没有继承和多态，使用接口来实现相关的功能。</li><li>只要实现了接口的所有方法，就隐式地实现了接口，就可以使用接口。</li></ul><p><strong>（3）go 的接口的语法样例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">interface</span> &#123;   <span class="hljs-comment">// 定义接口类型 Retriever</span><br>    Get(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRetriever</span><span class="hljs-params">()</span></span> Retriever &#123;   <span class="hljs-comment">// 返回接口类型 Retriever</span><br>    <span class="hljs-keyword">return</span> infra.Retriever&#123;&#125;   <span class="hljs-comment">// 实际上返回的是 infra 的 Retriever</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    retriever := getRetriever()   <span class="hljs-comment">// 使用者，使用 Retriever 接口类型</span><br>    retriever.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-为什么需要接口">5.2 为什么需要接口</h3><blockquote><p>为什么强类型语言需要有接口，而弱类型语言不需要接口呢？</p></blockquote><p>在下面代码中，没有使用接口，会有哪些问题呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRetriever</span><span class="hljs-params">()</span></span> infra.Retriever &#123;<br>    <span class="hljs-keyword">return</span> infra.Retriever&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> retriever infra.Retriever = getRetriever()<br>    retriever.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>main 函数中，<code>getRetriever()</code> 返回的类型是 <code>infra.Retriever</code> ，也就是说 retriever 的类型就是 <code>infra.Retriever</code>。</p></li><li><p>其他人也实现了一个不同功能的 Retriever 类型，当 main 函数需要使用这个人的 Retriever 时，要做哪些修改呢？</p><ul><li>更改 <code>getRetriever</code> 函数定义中的返回值类型、返回值。</li><li>main 函数中 变量类型。</li></ul></li></ul><p>有了接口后，只需更改 <code>getRetriever</code> 函数定义的返回值即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">interface</span> &#123;  <span class="hljs-comment">// 接口定义</span><br>    Get(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRetriever</span><span class="hljs-params">()</span></span> Retriever &#123;<br>    <span class="hljs-keyword">return</span> infra.Retriever&#123;&#125;   <span class="hljs-comment">// 只需要更改此处的返回值即可。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    retriever := getRetriever()<br>    retriever.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过使用接口，就减少了 main 函数和 infra.Retriever 的耦合性。</li><li>main 函数就可以在不更改代码的前提下，使用各种各样的 Retriever 类型，从而实现了向后兼容。</li></ul><h3 id="5-3-duck-typing">5.3 duck typing</h3><ul><li>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</li><li><strong>描述事物的外部行为，而非内部结构。</strong></li><li>进一步具体来讲：方法 A 可以接收不同类型的对象，只要该对象实现了方法 A 所用到的方法 B。</li></ul><p><strong>（1）go 是不是 duck typing ？</strong></p><ul><li>go 属于结构化类型系统，类似 duck typing，但不是 duck typing。<ul><li>为什么类似？go 符合 “描述事物的外部行为，而非内部结构。”</li><li>为什么不是？duck typing 要求使用多态，动态绑定，而 go 语言在编译时就绑定了。</li></ul></li></ul><p><strong>（2）python 的 duck typing</strong>：</p><ul><li>download 函数在接收、使用 retriever 时，并不知道 retriever 有没有实现 get 方法。</li><li>只有<strong>运行</strong>时，才知道 retriever 有没有实现 get 方法。</li><li>需要使用注释来说明接口。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义 download 函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">retriever</span>):<br>    <span class="hljs-keyword">return</span> retriever.get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>（3）C++ 的 duck typing</strong>：</p><ul><li>C++ 使用模板函数来实现 duck typing。</li><li>只有<strong>编译</strong>时，才知道传入的 retriever 有没有实现 get 方法。</li><li>需要使用注释来说明接口。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&gt;<br><span class="hljs-function">string <span class="hljs-title">download</span><span class="hljs-params">(<span class="hljs-type">const</span> R&amp; retriever)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> retriever.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）Java 中的类似代码</strong>：</p><blockquote><p>Java 没有 duck typing，只有类似代码。</p></blockquote><ul><li>因为有 <code>&lt;R extends Retriever&gt;</code> 类型限定，所以传入的参数，必须实现 Retriever 的所有接口。</li><li>优点：不需要用注释来说明接口，通过类型来限定。r 没有 get 方法，写代码时就会报错。</li><li>缺点：<ul><li>不是 duck typing，r 只有 get 方法还不行，需要完整地实现 Retriever 接口。</li><li>Java 不可以多继承，所以如果 r 需要同时使用两个不同类型的 duck typing 接口，Java 是做不到的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Retriever</span>&gt;<br>String <span class="hljs-title function_">download</span><span class="hljs-params">(R r)</span> &#123;<br>    <span class="hljs-keyword">return</span> r.get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）go 的 duck typing</strong>：</p><blockquote><p>结合了各语言的优点。</p></blockquote><ul><li>有 python、C++ 的 duck typing 的灵活性。</li><li>有 Java 的类型检查。</li></ul><blockquote><p>只要有结构体实现了 retriever 的 Get 方法，实例化的结构体就可以传入 download 函数中，被 download 函数使用。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">interface</span> &#123;  <span class="hljs-comment">// 接口定义</span><br>    Get(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(Retriever retriever)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> retriever.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-接口的定义与实现">5.4 接口的定义与实现</h3><p>在上面的 go 的 duck typing 样例中，Retriever 是一个接口，现在我们定义一个结构体 MyRetriever 实现了 Retriever 的所有方法。</p><ul><li>MyRetriever 是实现者。</li><li>download 是使用者。</li></ul><p>在传统的面向对象中，接口是由实现者决定的，MyRetriever 只有实现了这个接口，download 才可以使用这个接口。</p><p>在 go 中，<strong>接口由使用者决定的</strong>，download 要使用有 Get 方法的接口，只要实现了 Get 方法的结构体，都是接口的实现者。</p><p><strong>实例</strong>：</p><ul><li>downlod 要使用有 Get 方法的接口。</li><li>实现两个有 Get 方法的接口，一个 real、一个 mock，共 download 函数使用。</li></ul><p>[1] mock/retriever.go</p><blockquote><p>让 mock.Retriever 实现 Get 方法。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mock<br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">struct</span> &#123;<br>    Contents <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(receiver Retriever)</span></span> Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;  <span class="hljs-comment">// 返回一个固定的假值。</span><br>    <span class="hljs-keyword">return</span> receiver.Contents<br>&#125;<br></code></pre></td></tr></table></figure><p>[2] real/retriever.go</p><blockquote><p>让 real.Retriever 实现 Get 方法。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> <span class="hljs-built_in">real</span><br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">struct</span> &#123;<br>    UserAgent <span class="hljs-type">string</span><br>    TimeOut   time.Duration<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Retriever)</span></span> Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123; <span class="hljs-comment">// 返回利用 http 库获取到的真值</span><br>    response, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    result, err := httputil.DumpResponse(response, <span class="hljs-literal">true</span>)<br>    response.Body.Close()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>[3] main.go</p><blockquote><p>分别使用 mock.Retriever 和 real.Retriever。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;learngo/retriever/mock&quot;</span><br>    <span class="hljs-string">&quot;learngo/retriever/real&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">interface</span> &#123;   <span class="hljs-comment">// 定义接口。</span><br>    Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(r Retriever)</span></span> <span class="hljs-type">string</span> &#123;   <span class="hljs-comment">// 使用接口。</span><br>    <span class="hljs-keyword">return</span> r.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> r Retriever   <span class="hljs-comment">// 定义接口变量的 r </span><br><br>    r = mock.Retriever&#123;Contents: <span class="hljs-string">&quot;This is mock message&quot;</span>&#125;  <span class="hljs-comment">// 使用 mock 的 Get</span><br>    fmt.Println(download(r))<br><br>    r = <span class="hljs-built_in">real</span>.Retriever&#123;&#125;   <span class="hljs-comment">// 使用 real 的 Get</span><br>    fmt.Println(download(r))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-接口变量的值类型">5.5 接口变量的值类型</h3><blockquote><p><code>fmt.Printf(&quot;%T, %v\n&quot;, r, r)</code></p><ul><li><p><code>%T</code> 打印变量类型</p></li><li><p><code>%v</code> 打印变量的值</p></li></ul></blockquote><ul><li><p>接口变量 r 储存两个内容：实现者的类型、实现者的指针或实现者的值。</p><p>使用指针的好处：避免使用者的多次值拷贝，节省内存。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-11-14-MzZSvR.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">real/retriever.go 使用指针接收者。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">struct</span> &#123;<br>    UserAgent <span class="hljs-type">string</span><br>    TimeOut   time.Duration<br>&#125;<br><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Retriever)</span></span> Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    response, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    result, err := httputil.DumpResponse(response, <span class="hljs-literal">true</span>)<br>    response.Body.Close()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">main.go</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> r Retriever<br>    fmt.Printf(<span class="hljs-string">&quot;%T, %v\n&quot;</span>, r, r)   <span class="hljs-comment">// &lt;nil&gt;, &lt;nil&gt;</span><br>    <br>    <span class="hljs-comment">// 1.既可以赋值为指针</span><br>    r = &amp;mock.Retriever&#123;Contents: <span class="hljs-string">&quot;Pointer receiver&quot;</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%T, %v\n&quot;</span>, r, r)  <span class="hljs-comment">// *mock.Retriever, &amp;&#123;Pointer receiver&#125;  // 前面是实现者类型，后面是实现者变量的指针</span><br>    <br>    <span class="hljs-comment">// 2.也可以赋值为值</span><br>    r = mock.Retriever&#123;Contents: <span class="hljs-string">&quot;Value receiver&quot;</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%T, %v\n&quot;</span>, r, r)  <span class="hljs-comment">// mock.Retriever, &#123;Value receiver&#125;</span><br><br>    <span class="hljs-comment">// 只能赋值为指针，因为是结构体指针实现了接口。</span><br>    r = &amp;<span class="hljs-built_in">real</span>.Retriever&#123;<br>        UserAgent: <span class="hljs-string">&quot;Mozilla/5.0&quot;</span>,<br>        TimeOut:   time.Minute,<br>    &#125; <br>    fmt.Printf(<span class="hljs-string">&quot;%T, %v\n&quot;</span>, r, r)   <span class="hljs-comment">// *real.Retriever, &amp;&#123;Mozilla/5.0 1m0s&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现方法是指针接收者的，（表示<strong>结构体指针实现了接口</strong>），接口变量使用时该实现时，只可以赋值为指针；</li><li>实现方法是值接受者的，（表示<strong>结构体实现了接口</strong>），接口变量使用时该实现时，既可以赋值为指针，也可以赋值为值。</li></ul><p>对于上面两句话理解不深刻的，可以看看优先这两个连接：</p><ul><li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3">指针与接口</a></li><li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44370277/type-is-pointer-to-interface-not-interface-confusion">&quot; is pointer to interface, not interface&quot; confusion</a></li></ul><p>给接口变量传递参数时，不要传递接口变量的指针，go 中不推荐这么写。因为当<strong>结构体指针实现了接口</strong>，我是要拿着结构体指针去调用实现的方法的，而这个结构体指针就储存在接口变量中。如果传递接口变量的指针，反而拿不到结构体指针。</p><h3 id="5-6-查看接口变量">5.6 查看接口变量</h3><h4 id="5-6-1-Type-Assertion">5.6.1 Type Assertion</h4><blockquote><p>Assertion：断言。</p><p><code>r.(mock.Retriever)</code> 用于判断 r 是否是 mock.Retriever 类型变量，如果是，则 ok 为 true，反之为 false。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inspect</span><span class="hljs-params">(r Retriever)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> mockRetriever, ok := r.(mock.Retriever); ok &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Contents: &quot;</span>, mockRetriever.Contents)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;UserAgent: &quot;</span>, r.(*<span class="hljs-built_in">real</span>.Retriever).UserAgent)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-6-2-Type-Switch">5.6.2 Type Switch</h4><blockquote><p><code>r.(type)</code> 可以获取到接口变量内的具体 Retriever 变量。（只能在 switch 中使用。）</p><ul><li><code>r.(type).Contents</code> ：正确。</li><li><code>r.Contents</code>：错误。r 是接口变量，虽然可以被复制为 mock.Retriever，但并可以直接取 Contents。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inspect</span><span class="hljs-params">(r Retriever)</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> value := r.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> mock.Retriever:<br>        fmt.Println(<span class="hljs-string">&quot;Contents: &quot;</span>, value.Contents)<br>    <span class="hljs-keyword">case</span> *<span class="hljs-built_in">real</span>.Retriever:<br>        fmt.Println(<span class="hljs-string">&quot;UserAgent: &quot;</span>, value.UserAgent)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-6-3-任何类型表示法">5.6.3 任何类型表示法</h4><p><code>interface&#123;&#125;</code> 表示任何类型。</p><blockquote><p>注：仔细想想这样也合理，任何类型的变量，只要实现了某个接口，就可以称为该接口类型的变量。<code>interface&#123;&#125;</code> 没有任何需要实现的方法，自然可以储存任何类型的变量。</p></blockquote><p>以 Queue 文件为例，使用 <code>interface&#123;&#125;</code> 表示 Queue 中可以储存任何类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> queue<br><br><span class="hljs-comment">// type Queue []int  // 定义 Queue 表示 int 数组类型。</span><br><span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">interface</span>&#123;&#125;  <span class="hljs-comment">// 定义 Queue 表示 任何类型数组 的类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Push(value <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *q = <span class="hljs-built_in">append</span>(*q, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Pop() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(*q)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> != <span class="hljs-number">0</span> &#123;<br>        *q = (*q)[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">// 删除之前，队列为空，返回 false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Front() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">return</span> (*q)[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Back() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(*q)<br>    <span class="hljs-keyword">return</span> (*q)[<span class="hljs-built_in">len</span><span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Size() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(*q)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义 <code>interface&#123;&#125;</code> 后，如果需要进行类型约束怎么办？</p><ul><li><p>实际上与 <code>r.(type)</code> 一致。</p></li><li><p>但此类约束，只有运行时，才会报错。比如以下代码：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>    a = <span class="hljs-string">&quot;0&quot;</span><br>    fmt.Println(a.(<span class="hljs-type">int32</span>))   <span class="hljs-comment">// a 的实际类型是 string，不能打印出 int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>interface{} 转为其他类型。（以 int 为例）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interfaceToInt</span><span class="hljs-params">(inter <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">switch</span> inter.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        fmt.Println(inter)<br>        <span class="hljs-keyword">return</span> inter.(<span class="hljs-type">int</span>)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;inter is not int&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interfaceToInt(<span class="hljs-number">1</span>)<br>    interfaceToInt(<span class="hljs-number">1.1</span>)<br>    interfaceToInt(<span class="hljs-string">&quot;golang&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-7-接口的组合">5.7 接口的组合</h3><p>mock.Retriever 实现了 Get / Post 方法，也就表示分别实现了 Retriever 和 Poster 接口。（类似于 C++ 多继承了两个抽象类）。</p><p>接口最本质的目的就是：<strong>将实现了接口的类的对象，赋值给接口变量，由接口变量调用对象的所实现的接口方法。</strong></p><p>那如果接口变量既要调用 Get 方法，又要调用 Post 方法，请问这个接口变量应该是什么类型呢？</p><p>答：就是接口组合类型。</p><p>s 是一个 mock.Retriever 类型，但既要使用 Get 方法，也要使用 Post 方法，在执行 <code>session(s RetrieverPoster)</code> 函数时，只能用一个组合接口类型变量来接受 s。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">mock/retriever.go</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">package</span> mock<br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">struct</span> &#123;<br>    Contents <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(receiver *Retriever)</span></span> Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> receiver.Contents <span class="hljs-comment">// 返回一个固定的假值。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(receiver *Retriever)</span></span> Post(url <span class="hljs-type">string</span>, form <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    receiver.Contents = form[<span class="hljs-string">&quot;Contents&quot;</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">main.go</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">type</span> Retriever <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// Retriever 接口</span><br>    Get(url <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Poster <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// Poster 接口</span><br>    Post(url <span class="hljs-type">string</span>, form <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> RetrieverPoster <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// 组合接口：Retriever &amp; Poster</span><br>    Retriever<br>    Poster<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(r Retriever)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> r.Get(url)<br>&#125;<br><br><span class="hljs-comment">// s 既可以调用 Post，也可以调用 Get，只需要 mock.Retriever 同时实现了 Get、Post 方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">session</span><span class="hljs-params">(s RetrieverPoster)</span></span> <span class="hljs-type">string</span> &#123;<br>    s.Post(url, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;Contents&quot;</span>: <span class="hljs-string">&quot;I will change contents&quot;</span>,<br>    &#125;)<br>    <span class="hljs-keyword">return</span> s.Get(url)<br>&#125;<br><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://www.aimtao.net&quot;</span><br><span class="hljs-keyword">const</span> mockContents = <span class="hljs-string">&quot;This is mock message&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := &amp;mock.Retriever&#123;Contents: mockContents&#125;<br>    fmt.Println(download(s))<br>    fmt.Println(session(s))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-8-常用的系统接口">5.8 常用的系统接口</h3><h4 id="5-8-1-Stringer">5.8.1 Stringer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-8-2-Reader-Writer">5.8.2 Reader/Writer</h4><p>希望把底层一些的 IO 操作封装在 Writer/Reader 里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>  Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-9-函数式编程">5.9 函数式编程</h3><p>函数是一等公民：参数、变量、返回值都可以是函数。</p><h3 id="5-10-闭包">5.10 闭包</h3><blockquote><p>python、C++、Java 也支持闭包。</p></blockquote><p><img src="https://hutu.aimtao.net/mark/2021-11-27-2QLJ4n.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>以下面代码为例，sum 是 自由变量，v 是局部变量。</p><p>在将 adder() 赋值给 a 后，a 不光拥有一个你们函数，还拥有一个自由变量 sum。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += v<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := adder()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        fmt.Println(a(i))<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="5-10-1-实例：fibonacci">5.10.1 实例：fibonacci</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>    a, b := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>        a, b = b, a+b<br>        <span class="hljs-keyword">return</span> a, b<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := fibonacci()<br>    fmt.Println(f())   <span class="hljs-comment">// 1 2</span><br>    fmt.Println(f())   <span class="hljs-comment">// 2 3</span><br>    fmt.Println(f())   <span class="hljs-comment">// 3 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-10-2-实例：函数实现接口">5.10.2 实例：函数实现接口</h4><p>fibonacci 返回的匿名函数，实现了 Read 接口的方法。该方法的作用就是返回 io.Reader 变量。</p><p>既然实现了接口，printFileContents 就可以用接口变量 io.Reader 来接收匿名函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">()</span></span> intGen &#123;<br>    a, b := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>        a, b = b, a+b<br>        <span class="hljs-keyword">return</span> a, b<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> intGen <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// intGen 匿名函数实现接口的 Read 方法：将值格式化为字符串。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g intGen)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <br>    nextA, nextB := g()<br>    <span class="hljs-keyword">if</span> nextA &gt; <span class="hljs-number">1000</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, io.EOF<br>    &#125;<br>    s := fmt.Sprintf(<span class="hljs-string">&quot;%d, %d\n&quot;</span>, nextA, nextB)<br>    <span class="hljs-keyword">return</span> strings.NewReader(s).Read(p)<br>&#125;<br><br><span class="hljs-comment">// 接收一个 reader，代替我们完成打印动作。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printFileContents</span><span class="hljs-params">(reader io.Reader)</span></span> &#123;<br>    scanner := bufio.NewScanner(reader)<br>    <span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>        fmt.Println(scanner.Text())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := fibonacci()<br>    printFileContents(f)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-资源管理与出错处理">6.资源管理与出错处理</h2><h3 id="6-1-defer-调用">6.1 defer 调用</h3><ul><li><p>确保调用在函数结束时发生。</p><p>函数结束时才会自动调用，即使发生 panic 程序中断也会执行 defer 调用。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tryDefer</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mock error&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/* 输出如下：</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">panic: mock error</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><p>defer 列表为先进后出（栈）。</p></li><li><p><strong>参数在 defer 语句时计算</strong>。</p><p>defer 调用时的变量值，与正常顺序调用的变量值一致。虽然 <code>fmt.Println(i)</code> 在 <code>fmt.Println(&quot;defer start.&quot;)</code> 之后调用， 运行 <code>fmt.Println(&quot;defer start.&quot;)</code> 时 i 值为 5，但 defer 调用时，i 仍然是之前计算好的值。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tryDefer</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(i)<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;defer start.&quot;</span>)<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;printed too many.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 输出如下：</span><br><span class="hljs-comment">defer start.</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">panic: printed too many.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="6-2-实例：defer-与文件读写">6.2 实例：defer 与文件读写</h3><p>写文件的过程中，有成对的操作（打开/关闭 文件、写入/刷新缓冲区），使用 defer 调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回一个生成 fibonacci 数列的函数。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    a, b := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        a, b = a+b, a<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 写文件</span><br><span class="hljs-comment">1.open file</span><br><span class="hljs-comment">2.write buffer</span><br><span class="hljs-comment">3.flush buffer</span><br><span class="hljs-comment">4.close file</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 1. open file</span><br>    file, err := os.Create(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()  <span class="hljs-comment">// 程序结束需要 close file</span><br><br>    <span class="hljs-comment">// 2. write file</span><br>    writer := bufio.NewWriter(file)<br>    <span class="hljs-keyword">defer</span> writer.Flush()   <span class="hljs-comment">// 程序结束需要 flush buffer</span><br><br>    f := fib.Fibonacci()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        fmt.Fprintf(writer, <span class="hljs-string">&quot;%d\t&quot;</span>, f())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    writeFile(<span class="hljs-string">&quot;fib.txt&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fib.txt</span><br><span class="hljs-comment">2    3	5	8	13	</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="6-3-错误处理">6.3 错误处理</h3><p>在 <code>6.2 实例：defer 与文件读写</code> 中，以打开文件为例，探究 error 的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, <span class="hljs-number">0666</span>) <span class="hljs-comment">// 如果文件存在，os.OpenFile 就会出错。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <br>    <span class="hljs-keyword">defer</span> file.Close()<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>转到声明，可以看到 error 是 interface，里面有 Error() 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>os.OpenFile</code> 上面有一行注释，error 的类型是 *PathError。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// If there is an error, it will be of type *PathError.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenFile</span><span class="hljs-params">(name <span class="hljs-type">string</span>, flag <span class="hljs-type">int</span>, perm FileMode)</span></span> (*File, <span class="hljs-type">error</span>) &#123;...<br></code></pre></td></tr></table></figure><p>转到 PathError 声明，可以看到 error 里有三个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>      Op   <span class="hljs-type">string</span><br>      Path <span class="hljs-type">string</span><br>      Err  <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时，也可以看到 PathError 实现了 Error 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;<br></code></pre></td></tr></table></figure><p>所以我们可以多种方式打印 error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(err) <span class="hljs-comment">// open fib.txt: file exists</span><br>  <br>    fmt.Println(err.Error())  <span class="hljs-comment">// open fib.txt: file exists</span><br>  <br>    <span class="hljs-keyword">if</span> pathError, ok := err.(*os.PathError); !ok &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s, %s, %s&quot;</span>, pathError.Op, pathError.Path, pathError.Err) <span class="hljs-comment">// open, fib.txt, file exists</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-实例：服务器统一出错处理">6.4 实例：服务器统一出错处理</h3><h4 id="6-4-1-构建资源管理服务器">6.4.1 构建资源管理服务器</h4><p>在统一出错处理之前，先构建一个资源管理服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/file/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br><br>        <span class="hljs-comment">// 1. 获取文件路径</span><br>        path := request.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/file/&quot;</span>):]<br><br>        <span class="hljs-comment">// 2. 打开文件</span><br>        file, err := os.Open(path)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>        <span class="hljs-keyword">defer</span> file.Close()<br><br>        <span class="hljs-comment">// 3. 读取文件</span><br>        all, err := ioutil.ReadAll(file)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 将读到的数据写入 response</span><br>        writer.Write(all)<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 5. 启动监听</span><br>    err := http.ListenAndServe(<span class="hljs-string">&quot;:8888&quot;</span>, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于出现的 error，直接 panic。访问错误路径的错误，要分两种情况讨论：</p><ul><li><p>localhost:8888/myfile/</p><p>客户端报 404 not found，服务端不会处理 /myfile/，只会处理 /file/，所以不会进入 HandleFunc 函数。</p></li><li><p>localhost:8888/file/not_exit_file</p><p>此时进入 HandleFunc 函数，但 not_exit_file 并不存在，os.Open 报 error。</p><ul><li><p>服务端：程序会 panic 报错，但信息不明显。（对于 http 服务，panic 之后 recover）。</p></li><li><p>客户端：因为程序 panic，<strong>客户端会显示服务器中断连接，对于用户不友好</strong>。</p></li></ul></li></ul><h4 id="6-4-2-处理-panic-错误">6.4.2 处理 panic 错误</h4><p>使用 http 的报错替换 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.Open(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">/* 使用 http 的报错：</span><br><span class="hljs-comment">        1. 第一个参数：向谁汇报这个错误</span><br><span class="hljs-comment">        2. 第二个参数：汇报的字符串</span><br><span class="hljs-comment">        3. 第三个参数：状态码</span><br><span class="hljs-comment">    */</span><br>    http.Error(writer, err.Error(), http.StatusInternalServerError)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>处理该错误后，当 os.Open 报错时，客户端不会因为 panic 而显示服务器中断连接，会直接显示 err.Error() 的错误信息。例如：open 1: no such file or directory。</p><h4 id="6-4-3-统一处理错误">6.4.3 统一处理错误</h4><p><strong>（1）HandleFile</strong>：处理实际的请求，一旦出现 error 就返回出去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> filehandle<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFile</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> <span class="hljs-type">error</span> &#123;<br><br>    <span class="hljs-comment">// 1. 获取文件路径</span><br>    path := request.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/file/&quot;</span>):]<br><br>    <span class="hljs-comment">// 2. 打开文件</span><br>    file, err := os.Open(path)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    <span class="hljs-comment">// 3. 读取文件</span><br>    all, err := ioutil.ReadAll(file)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 将读到的数据写入 response</span><br>    writer.Write(all)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）errwrapper</strong>：包装作用，将 HandleFile 包装成没有返回值的 handle 函数。</p><ul><li>errwrapper 其实什么也没干，接收一个函数，返回一个函数：接收 HandleFile 作为参数，返回没有返回值的 handle 函数。</li><li>在这个没有返回值的 handle 函数里，调用真正的 handler 函数，并实现 error 的统一处理。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> appHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 函数功能：包装 filehandle.HandleFile，并处理报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errwrapper</span><span class="hljs-params">(handler appHandler)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>        err := handler(writer, request)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            http.Error(writer, err.Error(), http.StatusInternalServerError)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）main</strong>：<code>errwrapper(filehandle.HandleFile)</code> 中 <code>filehandle.HandleFile</code> 是真正的处理请求的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/file/&quot;</span>, errwrapper(filehandle.HandleFile))<br><br>    err := http.ListenAndServe(<span class="hljs-string">&quot;:8899&quot;</span>, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-4-4-将内部的-error-包装成外部的-error">6.4.4 将内部的 error 包装成外部的 error</h4><ul><li><p><strong>问题</strong>：将内部的出错信息 <code>err.Error()</code> 暴露给了用户。</p></li><li><p><strong>解决</strong>：利用 switch，根据具体的错误，返回更友好的报错信息给客户端。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数功能：包装 filehandle.HandleFile，并处理报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errwrapper</span><span class="hljs-params">(handler appHandler)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>        err := handler(writer, request)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 【在服务器端打印内部错误】</span><br>            log.Println(<span class="hljs-string">&quot;Error handling request: &quot;</span>, err.Error())<br><br>            <span class="hljs-comment">// 【生成外部错误】</span><br>            code := http.StatusOK<br>            <span class="hljs-keyword">switch</span> &#123;<br>            <span class="hljs-keyword">case</span> os.IsNotExist(err): <span class="hljs-comment">// 不存在该文件</span><br>                code = http.StatusNotFound<br>            <span class="hljs-keyword">case</span> os.IsPermission(err): <span class="hljs-comment">// 访问无权限</span><br>                code = http.StatusForbidden<br>            <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 其他错误</span><br>                code = http.StatusInternalServerError<br>            &#125;<br>            <span class="hljs-comment">/* 使用 http 的报错：</span><br><span class="hljs-comment">            1. 第一个参数：向谁汇报这个错误</span><br><span class="hljs-comment">            2. 第二个参数：汇报的字符串</span><br><span class="hljs-comment">            3. 第三个参数：状态码</span><br><span class="hljs-comment">            */</span><br>            http.Error(writer, http.StatusText(code), code)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-4-5-recover：保护-panic">6.4.5 recover：保护 panic</h4><blockquote><p>虽然上面判断了一些错误，但仍然可能有其他错误导致服务发生 panic。</p><p>例如：</p><ul><li>main 函数中，如果处理的是 <code>/</code> 路径：<code>http.HandleFunc(&quot;/&quot;, errwrapper(filehandle.HandleFile))</code>。</li><li>而 handle 函数中处理的是 <code>/file/</code> 路径。此时 handle 函数中，<code>path := request.URL.Path[len(&quot;/file/&quot;):]</code> 就可能因为索引越界而 panic。</li><li>以 <code>http://localhost:8899/abc</code> 为例，参数长度为 3，根本取不到 <code>[len(&quot;/file/&quot;):]</code> 这个切片。</li></ul></blockquote><p>当客户端 A 访问服务器，发生错误。因为服务器将程序保护起来，报错 panic 后，会自动 recover，以便来响应下一次访问。</p><ul><li><p><strong>问题</strong>：此时客户端 A 看到的是无法连接服务器，并不友好。</p></li><li><p><strong>解决</strong>：在程序 panic 之前，手动 recover。（另外在 handler 函数中也要进行判断处理）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数功能：包装 filehandle.HandleFile，并处理报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errwrapper</span><span class="hljs-params">(handler appHandler)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>        <br>        <span class="hljs-comment">// 【在程序挂掉之前手动 recover】</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>                log.Printf(<span class="hljs-string">&quot;Panic: %v&quot;</span>, r)<br>                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)  <span class="hljs-comment">// 给客户端看的</span><br>            &#125;<br>        &#125;()<br>        <br>        err := handler(writer, request)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 在服务器端打印内部错误</span><br>            log.Println(<span class="hljs-string">&quot;Error handling request: &quot;</span>, err.Error())<br><br>            <span class="hljs-comment">// 生成外部错误</span><br>            code := http.StatusOK<br>            <span class="hljs-keyword">switch</span> &#123;<br>            <span class="hljs-keyword">case</span> os.IsNotExist(err): <span class="hljs-comment">// 不存在该文件</span><br>                code = http.StatusNotFound<br>            <span class="hljs-keyword">case</span> os.IsPermission(err): <span class="hljs-comment">// 访问无权限</span><br>                code = http.StatusForbidden<br>            <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 其他错误</span><br>                code = http.StatusInternalServerError<br>            &#125;<br>            <span class="hljs-comment">/* 使用 http 的报错：</span><br><span class="hljs-comment">               1. 第一个参数：向谁汇报这个错误</span><br><span class="hljs-comment">               2. 第二个参数：汇报的字符串</span><br><span class="hljs-comment">               3. 第三个参数：状态码</span><br><span class="hljs-comment">            */</span><br>            http.Error(writer, http.StatusText(code), code)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 handler 函数中也提前进行判断处理，并给服务器打出更友好的 err log。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> filehandle<br><br><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&quot;/file/&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFile</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 1. 获取文件路径</span><br>    <span class="hljs-keyword">if</span> strings.Index(request.URL.Path, prefix) != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 【先判断一下，路径中是否含有 &quot;/file/&quot; 这个子串】</span><br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;path must start with &quot;</span> + prefix)   <span class="hljs-comment">// 返回的 err log。</span><br>    &#125;<br>    path := request.URL.Path[<span class="hljs-built_in">len</span>(prefix):]<br><br>    <span class="hljs-comment">// 2. 打开文件</span><br>    file, err := os.Open(path)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    <span class="hljs-comment">// 3. 读取文件</span><br>    all, err := ioutil.ReadAll(file)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 将读到的数据写入 response</span><br>    writer.Write(all)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-4-6-处理特殊错误">6.4.6 处理特殊错误</h4><blockquote><p>error = 给服务端看的 error log + 给客户端看的 error log。</p></blockquote><p>比如上面的 <code>errors.New(&quot;path must start with &quot; + prefix)</code> 这个 error 是可以给用户看的。</p><ul><li>声明一个 userError 的接口，有 Error() 和 Message() 方法，分别返回给服务器的 error log 和返回给客户端的 error log。</li><li>handler 中 fileUserError 结构体有两个变量，分别是 error 和 message；并实现了 Error() 和 Message() 这两个方法，分别返回 error 和 message。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> filehandle<br><br><span class="hljs-keyword">type</span> fileUserError <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">error</span>   <span class="hljs-type">string</span><br>    message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e fileUserError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.<span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e fileUserError)</span></span> Message() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.message<br>&#125;<br><br><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">&quot;/file/&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFile</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 1. 获取文件路径</span><br>    <span class="hljs-keyword">if</span> strings.Index(request.URL.Path, prefix) != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 先判断一下，路径中是否含有 &quot;/file/&quot; 这个子串。</span><br>        <span class="hljs-keyword">return</span> fileUserError&#123;  <span class="hljs-comment">// 【返回 fileUserError，保存着 error 和 message】</span><br>            <span class="hljs-type">error</span>:   <span class="hljs-string">&quot;path must start with &quot;</span> + prefix,<br>            message: <span class="hljs-string">&quot;path must start with &quot;</span> + prefix,<br>        &#125;<br>    &#125;<br>    path := request.URL.Path[<span class="hljs-built_in">len</span>(prefix):]<br><br>    <span class="hljs-comment">// 2. 打开文件</span><br>    file, err := os.Open(path)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    <span class="hljs-comment">// 3. 读取文件</span><br>    all, err := ioutil.ReadAll(file)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 将读到的数据写入 response</span><br>    writer.Write(all)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> userError <span class="hljs-keyword">interface</span> &#123;  <span class="hljs-comment">// 【特殊处理的 error 接口】</span><br>    Error() <span class="hljs-type">string</span><br>    Message() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> appHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 函数功能：包装 filehandle.HandleFile，并处理报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errwrapper</span><span class="hljs-params">(handler appHandler)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br><br>        <span class="hljs-comment">// 在程序挂掉之前手动 recover</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>                log.Printf(<span class="hljs-string">&quot;Panic: %v&quot;</span>, r)<br>                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)<br>            &#125;<br>        &#125;()<br><br>        err := handler(writer, request)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 在服务器端打印内部错误</span><br>            log.Println(<span class="hljs-string">&quot;Error handling request: &quot;</span>, err.Error())<br><br>            <span class="hljs-comment">// 【对于处理特殊的 error，给客户端看 message，message 就是可以给客户端看的 error log】</span><br>            <span class="hljs-keyword">if</span> userErr, ok := err.(userError); ok &#123;<br>                http.Error(writer, userErr.Message(), http.StatusBadRequest)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            <span class="hljs-comment">// 生成外部错误</span><br>            code := http.StatusOK<br>            <span class="hljs-keyword">switch</span> &#123;<br>            <span class="hljs-keyword">case</span> os.IsNotExist(err): <span class="hljs-comment">// 不存在该文件</span><br>                code = http.StatusNotFound<br>            <span class="hljs-keyword">case</span> os.IsPermission(err): <span class="hljs-comment">// 访问无权限</span><br>                code = http.StatusForbidden<br>            <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 其他错误</span><br>                code = http.StatusInternalServerError<br>            &#125;<br>            <span class="hljs-comment">/* 使用 http 的报错：</span><br><span class="hljs-comment">               1. 第一个参数：向谁汇报这个错误</span><br><span class="hljs-comment">               2. 第二个参数：汇报的字符串</span><br><span class="hljs-comment">               3. 第三个参数：状态码</span><br><span class="hljs-comment">            */</span><br>            http.Error(writer, http.StatusText(code), code)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-总结">6.5 总结</h3><ul><li>能用 error 的场景，不要用 panic。</li><li>对于意料之内的错误，使用 error 处理，如：文件无法打开。</li><li>对于意料之外的错误，使用 panic，如：数组越界。</li></ul><h2 id="7-测试">7.测试</h2><blockquote><p>Debugging Sucks! Testing Rocks!</p></blockquote><h3 id="7-1-传统测试与表格驱动测试">7.1 传统测试与表格驱动测试</h3><p><strong>（1）传统测试</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以 java 为例</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> &#123;<br>    assertEquals(<span class="hljs-number">3</span>, add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    assertEquals(<span class="hljs-number">2</span>, add(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    assertEquals(<span class="hljs-number">0</span>, add(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    assertEquals(<span class="hljs-number">0</span>, add(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    assertEquals(Integer.MIN_VALUE, add(<span class="hljs-number">1</span>, Integer.MAX_VALUE));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试数据和测试逻辑混在一起。</li><li>出错信息不明确，只会打印正确结果和错误结果，不会打印是如何计算的结果。</li><li>一旦一个数据输错，测试全部结束。</li></ul><p><strong>（2）表格驱动测试</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">tests := []<span class="hljs-keyword">struct</span> &#123;<br>    a, b, c <span class="hljs-type">int32</span><br>&#125;&#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;math.MaxInt32, <span class="hljs-number">1</span>, math.MinInt32&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br>    <span class="hljs-keyword">if</span> actual := add(test.a, test.b); actual != test.c &#123;<br></code></pre></td></tr></table></figure><ul><li>测试数据和测试逻辑分离。</li><li>明确的出错信息：可以自定义。</li><li>测试数据可以部分失败。</li><li>golang 的语法使得我们更容易时间表格驱动测试。</li></ul><h3 id="7-2-testing-T">7.2 testing.T</h3><p><strong>（1）文件结构</strong>：待测文件和测试文件写在同一目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">triangle<br>├── triangle.go<br>└── triangle_test.go<br></code></pre></td></tr></table></figure><p><strong>（2）待测文件</strong>：利用勾股定理计算斜边长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> triangle<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Triangle</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(a*a + b*b)))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）测试文件</strong>：triangle_test.go</p><ul><li>测试文件命名以待测内容 + test 组成。</li><li>参数使用 *testing.T。</li><li>不符合预期的结果，用 <code>t.Errorf</code> 打印出来。</li><li>TestTriangle 函数可以直接运行，IED 会自动识别为测试程序。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> triangle<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestTriangle</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    tests := []<span class="hljs-keyword">struct</span>&#123; a, b, c <span class="hljs-type">int</span> &#125;&#123;<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>&#125;,<br>        &#123;<span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>&#125;,<br>        &#123;<span class="hljs-number">12</span>, <span class="hljs-number">35</span>, <span class="hljs-number">37</span>&#125;,<br>        &#123;<span class="hljs-number">30000</span>, <span class="hljs-number">40000</span>, <span class="hljs-number">50000</span>&#125;,<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br>        <span class="hljs-keyword">if</span> actual := Triangle(test.a, test.b); actual != test.c &#123;<br>            t.Errorf(<span class="hljs-string">&quot;calcTrangle(%d, %d); got %d; expected %d&quot;</span>, test.a, test.b, actual, test.c)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）命令行方式测试</strong></p><p>在测试文所在目录下，执行 <code>go test .</code> 即可执行测试程序。</p><h3 id="7-3-代码覆盖率">7.3 代码覆盖率</h3><p><strong>使用</strong>：以代码覆盖率的方式运行 test.go 文件，</p><h2 id="8-goroutine">8.goroutine</h2><h3 id="8-1-协程-coroutine">8.1 协程 coroutine</h3><ul><li>轻量级线程（创建 1000 个也没关系）</li><li>非抢占式多任务处理，由协程主动交出控制权（线程是抢占式任务处理，由 CPU 调度）</li><li>（线程切换需要保存上下文，协程只需要处理集中切换的节点即可，所以协程对资源消耗较少）</li><li>编译器/解释器/虚拟机层面的多任务（线程是操作系统层面的多任务）</li><li>多个协程可能在一个或多个线程上运行</li></ul><p><strong>（1）例子A</strong>：在函数前，加 go 即可开启 goroutine，并发执行该函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;  <span class="hljs-comment">// 开多个 goroutine 来打印。</span><br>            <span class="hljs-keyword">for</span> &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;Hello from goroutine %d\n&quot;</span>, i)<br>            &#125;<br>        &#125;(i)<br>    &#125;<br>    time.Sleep(time.Millisecond)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个程序看起来是抢占式的，是因为由 IO 操作，IO 操作需要等待，所以来看例子B。</p><p><strong>（2）例子B</strong>：因为不是抢占式的，所以数组中并不是所有值都有机会执行 <code>a[i]++</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">for</span> &#123;<br>                a[i]++<br>            &#125;<br>        &#125;(i)<br>    &#125;<br>    time.Sleep(time.Millisecond)<br>    fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-子程序是协程的一个特例">8.2 子程序是协程的一个特例</h3><blockquote><p>所有的函数调用都是子程序。</p></blockquote><p><strong>（1）线程</strong></p><ul><li>main 调用 doWork ，控制权交给 doWork（压栈），当 doWork 执行完，控制权交给 main（弹栈）。</li><li>main 和 doWork 在一个线程里。</li></ul><p><strong>（2）协程</strong></p><ul><li>main 和 doWork 之间由双向的通道，数据、控制权可以双向的流通。</li><li>main 和 doWork 不一定在一个线程里，程序员不需要关心，由调度器来决定。</li></ul><p><img src="https://hutu.aimtao.net/mark/2022-02-24-jJHIg0.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="8-3-goroutine">8.3 goroutine</h3><p><strong>（1）特点</strong></p><ul><li>任何函数只需加上 go，就能送给调度器运行。</li><li>不需要在定义时，区分是否是异步函数。</li><li>调度器在合适的点进行切换。（传统的协程 coroutine，协程切换的点需要显式的写出来，但 goroutine 不需要写出来，它是由调度器在切换，切换的点并不能完全由开发者控制）</li><li>使用 <code>go run -race</code> 来检测数据访问冲突（比如同一块内存，被不同的 goroutine 边读边写）。</li></ul><p><strong>（2）可能切换的点</strong></p><p>只是参考，不能保证切换，也不能保证在其他地方不切换。</p><ul><li>I/O，select</li><li>channel</li><li>等待锁</li><li>函数调用（函数调用式切换的一个机会，但会不会切换，由调度器决定）</li><li>runtime.Gosche()</li></ul><p><strong>例子</strong>：如果开了 1000 个 goroutine，会映射到具体的物理核心上。</p><ul><li>比如 4 核机器，1000 个 goroutine 可能会在 4 个线程上运行。</li><li>为什么不超过 4 个呢？因为不需要系统来调度，goroutine 的调器度去可以调度。</li></ul><h2 id="9-channel">9.channel</h2><blockquote><p>channle 是 goroutine 之间的双向通道。</p></blockquote><h3 id="9-1-基本语法">9.1 基本语法</h3><p><strong>（1）创建</strong></p><ul><li><code>var c chan int</code> 此时 c 是 nil，并不能直接用来收发数据；需要 make 出来，才可以使用。</li><li><code>chan int</code> 表示 channle 只能传输 int 类型数据。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>   <span class="hljs-comment">// c is nil</span><br>c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <span class="hljs-comment">// c is chan int</span><br></code></pre></td></tr></table></figure><p><strong>（2）阻塞</strong></p><p>channle 收发数据都是阻塞的，发出数据没人收，就会阻塞在当前语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    c &lt;- <span class="hljs-number">1</span>   <span class="hljs-comment">// 阻塞在这里，deadlock</span><br>    n := &lt;-c<br>    fmt.Println(n)<br>    time.Sleep(time.Millisecond)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）简单的例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 channle</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 使用一个 goroutine 并发的从 channle 中收数据</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            n := &lt;-c <span class="hljs-comment">// 收数据</span><br>            fmt.Println(n)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 向 channle 中发数据</span><br>    c &lt;- <span class="hljs-number">1</span><br>    c &lt;- <span class="hljs-number">2</span><br><br>    time.Sleep(time.Millisecond) <span class="hljs-comment">// 防止发完数据，main 函数直接退出，goroutine 来不及接收并处理数据。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-2-channel-作为一等公民">9.2 channel 作为一等公民</h3><blockquote><p>channel 可以作为参数、作为返回值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    channelDemo()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelDemo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化  channel</span><br>    <span class="hljs-keyword">var</span> channels [<span class="hljs-number">10</span>]<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// channel 作为数组</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> channels &#123;<br>        channels[i] = createChannel(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 发数据</span><br>    <span class="hljs-keyword">for</span> i, channel := <span class="hljs-keyword">range</span> channels &#123;<br>        channel &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i<br>        channel &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + i<br>    &#125;<br>    <span class="hljs-comment">// 保证数据接收处理完之前，main 函数不退出</span><br>    time.Sleep(time.Millisecond)<br>&#125;<br><br><span class="hljs-comment">// 创建 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createChannel</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// channel 作为返回值</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWork(id, c)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 接收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(id <span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// channel 作为参数</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;channel %d received %c\n&quot;</span>, id, &lt;-c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3-channel-的方向">9.3 channel 的方向</h3><ul><li>channel 作为参数、返回值时，为了明确是接收数据还是发送数据，用 <code>&lt;-</code> 作为标识。</li><li><code>chan&lt;- int</code> 只能发数据；<code>&lt;-chan int</code> 只能收数据。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    channelDemo()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelDemo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> channel <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span><br>    channel = createChannel() <span class="hljs-comment">// createChannel 返回值是发数据的 channel，所以 channel 必须是发数据的 channel</span><br><br>    channel &lt;- <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// 发数据</span><br>    time.Sleep(time.Millisecond)<br>&#125;<br><br><span class="hljs-comment">// 创建 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createChannel</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// 返回的 channel 只能发数据</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWork(c)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 接收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(c &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// 接收的 channel 只能收数据</span><br>    fmt.Printf(<span class="hljs-string">&quot;received %c&quot;</span>, &lt;-c)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-4-channel-buffer">9.4 channel buffer</h3><p>在 meke channel 的时候，可以设置一个 buffer。以下面代码为例，连续发送到第 4 个数据，才会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bufChannel</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 设置 channel 的 buffer</span><br>    c &lt;- <span class="hljs-string">&#x27;a&#x27;</span><br>    c &lt;- <span class="hljs-string">&#x27;b&#x27;</span><br>    c &lt;- <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-comment">// 连续发三次数据，依然不会阻塞。</span><br><br>    <span class="hljs-comment">// c &lt;- &#x27;d&#x27; // 第四次发数据会阻塞。</span><br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Println(&lt;-c)<br>        &#125;<br>    &#125;()<br>    time.Sleep(time.Millisecond)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-5-close-channel">9.5 close channel</h3><p>配套使用，发送方 close，接收方判断 channel 是否 close。</p><ul><li>数据发送方可以 close channel，来通知接收方，数据发送完毕。</li><li>接收方可以收到两个值，第二个 bool 值表示 channel 是否 close。第二个值若为 false，则表示 channel 已 close，此时第一个值为默认值（比如 chan int 的默认值 为 0，chan string 的默认值为空串 “”）。</li><li>注：如果发送方 close channel，接收方没有进行判断，channel 中会一直为默认值。（此时发送方已 close，channel 中为默认值，接收方不会阻塞）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWorker(c)<br>    c &lt;- <span class="hljs-number">1</span><br>    c &lt;- <span class="hljs-number">2</span><br>    c &lt;- <span class="hljs-number">3</span><br>    <span class="hljs-built_in">close</span>(c) <span class="hljs-comment">// 表示数据发送完毕</span><br>    time.Sleep(time.Millisecond)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWorker</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> n, ok := &lt;-c; ok &#123; <span class="hljs-comment">// 接收方需要对 channel 是否 close 进行判断</span><br>            fmt.Println(n)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;End.&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：for range 代替 if 判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWorker(c)<br>    c &lt;- <span class="hljs-number">1</span><br>    c &lt;- <span class="hljs-number">2</span><br>    c &lt;- <span class="hljs-number">3</span><br>    <span class="hljs-built_in">close</span>(c) <span class="hljs-comment">// 表示数据发送完毕</span><br>    time.Sleep(time.Millisecond)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWorker</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c &#123; <span class="hljs-comment">// 利用 for range 判断是否 close</span><br>        fmt.Println(n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-6-CSP">9.6 CSP</h3><p>channel 的理论基础：通信顺序进程（CSP：Communication Sequential Process），go 语言就是基于 CSP 模型来实现并发的。</p><p>Don’t communicate by sharing memory; share memory by communicating.（不要通过共享内存来通信；通过通信来共享内存。）</p><p>官方解释：<a href="https://go.dev/blog/codelab-share" rel="nofollow noopener" target="_blank">The Go Blog：Share Memory By Communicating</a></p><p>《Go 语言设计与实现》作者的解释比较易懂：<a href="https://draveness.me/whys-the-design-communication-shared-memory/" rel="nofollow noopener" target="_blank">为什么使用通信来共享内存？</a></p><blockquote><p>无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是『为什么我们使用发送消息的方式来同步信息，而不是多个线程或者协程直接共享内存？』</p><ol><li>首先，使用发送消息来同步信息相比于直接使用共享内存和互斥锁是一种更高级的抽象，使用更高级的抽象能够为我们在程序设计上提供更好的封装，让程序的逻辑更加清晰；</li><li>其次，消息发送在解耦方面与共享内存相比也有一定优势，我们可以将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存；</li><li>最后，Go 语言选择消息发送的方式，通过保证同一时间只有一个活跃的线程能够访问数据，能够从设计上天然地避免线程竞争和数据冲突的问题；</li></ol></blockquote><p><a name="9.7 channel 等待多任务结束"></a></p><h3 id="9-7-channel-等待多任务结束">9.7 channel 等待多任务结束</h3><p>在前面的例子中，我们会使用 <code>time.Sleep(time.Millisecond)</code> 来防止 goroutine 还没执行完时，主线程退出。</p><p>那么如何让主程序知道 goroutine 执行完毕呢？用 channel 来通信，告诉主程序运行结束。</p><p>在下面的例子中，</p><ul><li>接收方：当接收并处理完数据后，通过 channel done 发送数据。</li><li>发送方：主程序会阻塞在 done 接收数据这一行，当收到数据，则可结束主程序。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    channelDemo()<br>&#125;<br><br><span class="hljs-keyword">type</span> worker <span class="hljs-keyword">struct</span> &#123;<br>    in   <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>  <span class="hljs-comment">// 用来传输数据</span><br>    done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span> <span class="hljs-comment">// 告知发送方数据是否发完</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelDemo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化  channel</span><br>    <span class="hljs-keyword">var</span> channels [<span class="hljs-number">10</span>]worker<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> channels &#123;<br>        channels[i] = createChannel(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 发数据</span><br>    <span class="hljs-keyword">for</span> i, channel := <span class="hljs-keyword">range</span> channels &#123;<br>        channel.in &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + i<br>    &#125;<br><br>    <span class="hljs-comment">// 等待数据接收处理后，channelDemo 函数退出</span><br>    <span class="hljs-keyword">for</span> _, channel := <span class="hljs-keyword">range</span> channels &#123;<br>        &lt;-channel.done<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createChannel</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> worker &#123;<br>    w := worker&#123;<br>        in:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>),<br>        done: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>    &#125;<br>    <span class="hljs-keyword">go</span> doWork(id, w.in, w.done)<br>    <span class="hljs-keyword">return</span> w<br>&#125;<br><br><span class="hljs-comment">// 接收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(id <span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;channel %d received %c\n&quot;</span>, id, n)<br>        done &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 数据接收处理结束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-8-wait-group">9.8 wait group</h3><blockquote><p>对于等待多任务结束，go 语言已经封装好了工具：sync.WaitGroup，多任务共用一个 wait group。</p></blockquote><ol><li>定义 wait group，<code>var wgsync.WaitGroup</code></li><li>添加任务数量，<code>wg.Add(20)</code></li><li>接收方结束任务，<code>wg.Done()</code>，（下面代码中，使用 woker.done 对 WaitGroup.Done 进行了抽象，不影响 wait Group 的使用流程。题外话：对 WaitGroup.Done 进行抽象的好处是 woker.done 具体做什么事情，由初始化时决定。）</li><li>发送方等待任务结束，<code>wg.Wait()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    channelDemo()<br>&#125;<br><br><span class="hljs-keyword">type</span> worker <span class="hljs-keyword">struct</span> &#123;<br>    in   <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 用来传输数据</span><br>    done <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>   <span class="hljs-comment">// 调用 WaitGroup.Done()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelDemo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// 1.定义 wait group</span><br><br>    <span class="hljs-comment">// 初始化  channel</span><br>    <span class="hljs-keyword">var</span> channels [<span class="hljs-number">10</span>]worker<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> channels &#123;<br>        channels[i] = createChannel(i, &amp;wg)<br>    &#125;<br><br>    wg.Add(<span class="hljs-number">20</span>) <span class="hljs-comment">// 2.添加 20 个任务</span><br><br>    <span class="hljs-comment">// 发数据</span><br>    <span class="hljs-keyword">for</span> i, channel := <span class="hljs-keyword">range</span> channels &#123;<br>        channel.in &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, channel := <span class="hljs-keyword">range</span> channels &#123;<br>        channel.in &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i<br>    &#125;<br><br>    <span class="hljs-comment">// 等待所有数据接收处理后，channelDemo 函数退出</span><br>    wg.Wait() <span class="hljs-comment">// 4.等待任务结束</span><br>&#125;<br><br><span class="hljs-comment">// 创建 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createChannel</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> worker &#123;<br>    w := worker&#123;<br>        in: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>),<br>        done: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            wg.Done()<br>        &#125;,<br>    &#125;<br>    <span class="hljs-keyword">go</span> doWork(id, w)<br>    <span class="hljs-keyword">return</span> w<br>&#125;<br><br><span class="hljs-comment">// 接收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(id <span class="hljs-type">int</span>, w worker)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> w.in &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;channel %d received %c\n&quot;</span>, id, n)<br>        w.done() <span class="hljs-comment">// 3.接收处理数据完成，任务结束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-9-实例：使用-channel-来实现树的遍历">9.9 实例：使用 channel 来实现树的遍历</h3><blockquote><p>只是一个练习，使用 channel 遍历二叉树，这个过程会显得更加的线性，channel 中会源源不断的传出节点。</p></blockquote><ol><li>利用层序遍历的数组，构造二叉树。（不是重点）</li><li>先序遍历这颗二叉树，并将遍历到的节点，通过 channel 发送给 main 函数。</li><li>main 函数循环从 channel 中接收数据，并找出最大值。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    val   <span class="hljs-keyword">interface</span>&#123;&#125;<br>    left  *Node<br>    right *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.利用层序遍历构造一个二叉树</span><br>    <span class="hljs-keyword">var</span> root *Node<br>    treeList := []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">nil</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>    root = buildTree(treeList, <span class="hljs-number">0</span>)<br><br>    maxNum := math.MinInt<br>    channel := root.TraverseWithChannel()<br>    <span class="hljs-keyword">for</span> node := <span class="hljs-keyword">range</span> channel &#123; <span class="hljs-comment">// 2.main 函数通过 channel 收到节点。</span><br>        <span class="hljs-keyword">if</span> maxNum &lt; node.val.(<span class="hljs-type">int</span>) &#123;<br>            maxNum = node.val.(<span class="hljs-type">int</span>)<br>        &#125;<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;max number = &quot;</span>, maxNum)<br>&#125;<br><br><span class="hljs-comment">// 先序遍历中，使用 channel 传输 node 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *Node)</span></span> TraverseWithChannel() <span class="hljs-keyword">chan</span> *Node &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Node)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        root.TraverseFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *Node)</span></span> &#123;<br>            out &lt;- node <span class="hljs-comment">// 向 main 函数传出节点</span><br>        &#125;)<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *Node)</span></span> TraverseFunc(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *Node)</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        f(root)<br>        root.left.TraverseFunc(f)<br>        root.right.TraverseFunc(f)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 利用层序遍历的数组，构建二叉树</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(list []<span class="hljs-keyword">interface</span>&#123;&#125;, i <span class="hljs-type">int</span>)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(list) || list[i] == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    node := Node&#123;<br>        val:   list[i],<br>        left:  buildTree(list, <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>),<br>        right: buildTree(list, <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>),<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;node<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-10-select-channel-调度">9.10 select &amp; channel 调度</h3><p><strong>（1）什么是 select</strong></p><p>在 linux 系统编程中，学习过 select、poll、epoll 模型，来实现 io 多路复用：select 模型可以同时监听多个文件描述符的可读可写状态。</p><p>在 go 中 select 有类型的功能，select 可以让 Goroutine 同时等待多个 channel，在 channel 状态改变前，select 会一直阻塞当前线程或者 goroutine。</p><p><strong>（2）select 与 channel 的简单应用</strong></p><p>注：select 和 switch 结构类似，但 select 的 case 必须是 channel 的收发操作。</p><p>例子：c1、c2 谁接收数据接收的快，就打印谁的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = generator(), generator()<br><br>    <span class="hljs-comment">// 谁数据接收得快，打印谁的数据</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c1:<br>            fmt.Println(<span class="hljs-string">&quot;Received from c1: &quot;</span>, n)<br>        <span class="hljs-keyword">case</span> n := &lt;-c2:<br>            fmt.Println(<span class="hljs-string">&quot;Received from c2: &quot;</span>, n)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 channel，并且并发地往这个 channel 中发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）特性：nil channel 不会被匹配到</strong></p><p>由于 c1、c2 是 nil，所有任何 case 都无法匹配到，只能走 default 分支，如果没有 default 分支，程序就会出现 deadlock。【nil channel 是一个可以利用的特性。】</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// nil channel</span><br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> n := &lt;-c1:<br>        fmt.Println(<span class="hljs-string">&quot;Received from c1: &quot;</span>, n)<br>    <span class="hljs-keyword">case</span> n := &lt;-c2:<br>        fmt.Println(<span class="hljs-string">&quot;Received from c2: &quot;</span>, n)<br>    <span class="hljs-keyword">default</span>:   <span class="hljs-comment">// 如果没有 default，就会出现 deadlock</span><br>        fmt.Println(<span class="hljs-string">&quot;No data received.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）利用 nil channel 的例子</strong></p><p>当有数据需要处理的时候，才将 activeWorker 赋值为 woker（处理数据的打工人）；否则 activeWorker 就是 nil channel，永远不会匹配到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = generator(), generator()<br>    <span class="hljs-keyword">var</span> worker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = createWorker()<br><br>    n := <span class="hljs-number">0</span><br>    hasValue := <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">var</span> activeWorker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> hasValue &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               当有数据要处理的时候，activeWorker &lt;- n 这个 case 才可以被匹配到。</span><br><span class="hljs-comment">               当没有数据的时候，activeWorker 为 nil channel，永远不会被匹配到，该 case 会阻塞住。</span><br><span class="hljs-comment">            */</span><br>            activeWorker = worker<br>        &#125;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n = &lt;-c1:<br>            hasValue = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">case</span> n = &lt;-c2:<br>            hasValue = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">case</span> activeWorker &lt;- n:<br>            hasValue = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 channel，并且并发地往这个 channel 中发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 创建一个接收并处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWork(c)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 真正并发地处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）用队列储存待处理的数据</strong></p><p><strong>上面代码的问题</strong>：可是这样还是有问题，worker 处理数据的速度和 c1、c2 生成数据的速度不一致。如果 worker 处理数据慢，会导致未来及处理的数据丢失。</p><p><strong>解决方案</strong>：用队列储存从 c1、c2 读到的数据；worker 处理一个数据，出队一个数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = generator(), generator()<br>    <span class="hljs-keyword">var</span> worker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = createWorker()<br><br>    <span class="hljs-keyword">var</span> values []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> activeValue <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">var</span> activeWorker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) &gt; <span class="hljs-number">0</span> &#123;<br>            activeWorker = worker<br>            activeValue = values[<span class="hljs-number">0</span>] <span class="hljs-comment">// 需要拷贝 values[0]，不能直接在case 中写 activeWorker&lt;-values[0]，因为 values[0] 不一定存在。</span><br>        &#125;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c1:<br>            values = <span class="hljs-built_in">append</span>(values, n) <span class="hljs-comment">// 收到的数据 入队</span><br>        <span class="hljs-keyword">case</span> n := &lt;-c2:<br>            values = <span class="hljs-built_in">append</span>(values, n) <span class="hljs-comment">// 收到的数据 入队</span><br>        <span class="hljs-keyword">case</span> activeWorker &lt;- activeValue:<br>            values = values[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 处理的数据出队</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 channel，并且并发地往这个 channel 中发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 创建一个接收并处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWork(c)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 真正并发地处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-c)<br>        time.Sleep(time.Second) <span class="hljs-comment">// worker 处理数据特别慢</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-11-计时器">9.11 计时器</h3><p>利用 select 和 channel 进行调度的过程中，一般是在 for 循环中，如何自动退出 for 循环？可以使用计时器。</p><p><strong>（1）一个简单的例子</strong></p><ul><li><code>time.After</code> 函数会返回一个 <code>&lt;-chan time</code> 类型的 channel，如果计时结束，这个 channel 就会收到数据。</li><li>利用这个特性，在 select 中，添加一个 time channel 的 case，计时结束，即可匹配到。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := generator()<br>    w := worker()<br>    myTime := time.After(<span class="hljs-number">5</span> * time.Second) <span class="hljs-comment">// time.After 返回值是一个 &lt;-chan time，时间到了，channel 中会收到数据</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c: <span class="hljs-comment">// 有数据就走这个 case</span><br>            w &lt;- n<br>        <span class="hljs-keyword">case</span> &lt;-myTime: <span class="hljs-comment">// 时间到了，会收到 time channel 会收到数据，就会走这个 case</span><br>            fmt.Println(<span class="hljs-string">&quot;Time is over.&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    worker := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-worker)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> worker<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）结合 9.10 中 select &amp; channel 的调度案例</strong></p><p>10s 后结束程序，可以写成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = generator(), generator()<br>    <span class="hljs-keyword">var</span> worker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> = createWorker()<br><br>    myTime := time.After(<span class="hljs-number">5</span> * time.Second) <span class="hljs-comment">// time.After 返回值是一个 &lt;-chan time</span><br>    <span class="hljs-keyword">var</span> values []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> activeValue <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">var</span> activeWorker <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) &gt; <span class="hljs-number">0</span> &#123;<br>            activeWorker = worker<br>            activeValue = values[<span class="hljs-number">0</span>]<br>        &#125;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c1:<br>            values = <span class="hljs-built_in">append</span>(values, n)<br>        <span class="hljs-keyword">case</span> n := &lt;-c2:<br>            values = <span class="hljs-built_in">append</span>(values, n)<br>        <span class="hljs-keyword">case</span> activeWorker &lt;- activeValue:<br>            values = values[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">case</span> &lt;-myTime:<br>            fmt.Println(<span class="hljs-string">&quot;Bye&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 channel，并且并发地往这个 channel 中发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 创建一个接收并处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> doWork(c)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 真正并发地处理数据的 channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-c)<br>        time.Sleep(time.Second) <span class="hljs-comment">// worker 处理数据特别慢</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="9.12 超时计时器"></a></p><h3 id="9-12-超时计时器">9.12 超时计时器</h3><p>计时器是计算从函数开始到当前的时间。同理，我们可以使用 <code>case &lt;-time.After(800 * time.Millisecond)</code> 来计算 select 开始到现在的时间（即 select 等待 channel 中数据的时间，也可以说成相邻两个 channel 请求之间的时间）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := generator()<br>    w := worker()<br>    myTime := time.After(<span class="hljs-number">5</span> * time.Second)<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c:<br>            w &lt;- n<br>        <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">800</span> * time.Millisecond): <span class="hljs-comment">// select 等待 channel 的数据时间超过 800ms，即匹配这个 case</span><br>            fmt.Println(<span class="hljs-string">&quot;timeout.&quot;</span>)<br>        <span class="hljs-keyword">case</span> &lt;-myTime:<br>            fmt.Println(<span class="hljs-string">&quot;Time is over.&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    worker := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-worker)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> worker<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-13-定时器">9.13 定时器</h3><p>在 select 中，可能需要定时的来做一些事情，<code>time.Tick(time.Second)</code> 返回 &lt;-chan time，每隔 1s，会发送一个数据，从而达到定时作用。</p><p>例如：在上面的例子中，每 2 秒打印一个下划线。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := generator()<br>    w := worker()<br>    myTime := time.After(<span class="hljs-number">10</span> * time.Second)<br>    tick := time.Tick(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">// time.Tick 返回 &lt;-chan time，每隔 2s，会发送一个数据。</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> n := &lt;-c:<br>            w &lt;- n<br>        <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">800</span> * time.Millisecond):<br>            fmt.Println(<span class="hljs-string">&quot;timeout.&quot;</span>)<br>        <span class="hljs-keyword">case</span> &lt;-myTime:<br>            fmt.Println(<span class="hljs-string">&quot;Time is over.&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">case</span> &lt;-tick: <span class="hljs-comment">// 每隔 2s，tick 会收到数据，即匹配这个case，达到定时作用。</span><br>            fmt.Println(<span class="hljs-string">&quot;-------------------&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generator</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>            out &lt;- i<br>            i++<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// 收数据、处理数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    worker := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, &lt;-worker)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> worker<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-14-传统同步机制">9.14 传统同步机制</h3><blockquote><p>传统同步机制指：通过共享内存来通信。</p></blockquote><ul><li>WaitGroup：使用 channel 实现，但是看起来像传统的同步机制。</li><li>Mutex：sync.Mutex，互斥量。</li><li>Cond：sync.Cond，条件变量。</li></ul><p>例：使用 Mutex 实现一个 atomicInt 类型。</p><p>atomicInt 是原子性的 int 类型，表示该 int 类型是线程安全的。【其实 go 中 <code>atomic.AddInt64()</code> 这类线程安全的函数。】</p><p>在对 atomicInt 类型数据读写时，利用 <code>sync.Mutex</code> 来保护。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> atomicInt <span class="hljs-keyword">struct</span> &#123;<br>    value <span class="hljs-type">int</span><br>    lock  sync.Mutex <span class="hljs-comment">// Mutex 锁保护</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *atomicInt)</span></span> increment() &#123; <span class="hljs-comment">// 【一定注意是指针传递】</span><br>    i.lock.Lock() <span class="hljs-comment">//读写前进行保护</span><br>    <span class="hljs-keyword">defer</span> i.lock.Unlock()<br><br>    i.value++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *atomicInt)</span></span> Get() <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// 【一定注意是指针传递】</span><br>    i.lock.Lock() <span class="hljs-comment">//读写前进行保护</span><br>    <span class="hljs-keyword">defer</span> i.lock.Unlock()<br><br>    <span class="hljs-keyword">return</span> i.value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a atomicInt<br>    a.increment()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        a.increment()<br>    &#125;()<br>    time.Sleep(time.Millisecond)<br>    fmt.Println(a.Get())<br>&#125;<br></code></pre></td></tr></table></figure><p>补充：如何只在一块代码区（一段代码中）进行 Mutex 保护。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *atomicInt)</span></span> increment() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;safe increment.&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 写一个 匿名函数，这个 mutex 只保护这个代码块。</span><br>        i.lock.Lock()<br>        <span class="hljs-keyword">defer</span> i.lock.Unlock()<br><br>        i.value++<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-15-并发编程模式">9.15 并发编程模式</h3><p>从应用的角度来看，这些并发的工具，如何解决实际的问题。（挖坑：等有时间看看 <a target="_blank" rel="noopener" href="https://www.imooc.com/learn/927">搭建并行处理管道</a>）</p><p>这里的模式只是总结的经验，总结起来就是两条：</p><ul><li>每个 channel 可以表示一个服务。</li><li>如何处理这些并发的服务（channel）？利用 goroutine 或 select 实现 fan-in。</li></ul><p><strong>（1）首先，channel 可以做成一个生成器。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">()</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;  <span class="hljs-comment">// 不断生成消息，供 main 函数处理。</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;message %d&quot;</span>, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen()<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c1)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）其次，生成器可以抽象地理解成服务/任务。</strong></p><p>channel 相当于服务/任务的句柄（handle），拿到这个 handle 就可以与这个服务交互。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;service1&quot;</span>) <span class="hljs-comment">// channel 相当于服务/任务的句柄（handle），拿到这个 handle 就可以与这个服务交互</span><br>    c2 := msgGen(<span class="hljs-string">&quot;service2&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c1)<br>        fmt.Println(&lt;-c2)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）最后，如何同时等待多个任务（使用 fan-in 的方式）</strong></p><blockquote><p>fan-in，扇入，一个逻辑门输入的数量。</p><p>在这里的意思是，将多个 channel，封装成一个 channel：哪个 channel 有数据，就先处理哪个 channel。</p></blockquote><ul><li><strong>实现 fan-in 的方法一</strong>：利用 goroutine 来处理。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanIn</span><span class="hljs-params">(c1, c2 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>        <span class="hljs-keyword">for</span> &#123;  <span class="hljs-comment">// 需要不停地判断 service 是否有数据</span><br>            c &lt;- &lt;-c1  <span class="hljs-comment">// 将 service1 的数据收到后，发送给 c</span><br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>        <span class="hljs-keyword">for</span> &#123;  <span class="hljs-comment">// 需要不停地判断 service 是否有数据</span><br>            c &lt;- &lt;-c2  <span class="hljs-comment">// 将 service2 的数据收到后，发送给 c</span><br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;service1&quot;</span>)<br>    c2 := msgGen(<span class="hljs-string">&quot;service2&quot;</span>)<br>    c := fanIn(c1, c2)  <span class="hljs-comment">// 将多个 channel 封装成一个 channel 并行处理。</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>实现 fan-in 的方法二</strong>：利用 select 来处理。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInBySelect</span><span class="hljs-params">(c1, c2 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 需要不停的处理来选择 channel 提供数据</span><br>            <span class="hljs-keyword">select</span> &#123; <span class="hljs-comment">// 通过 select 来实现 fan-in</span><br>            <span class="hljs-keyword">case</span> c &lt;- &lt;-c1:<br>            <span class="hljs-keyword">case</span> c &lt;- &lt;-c2:<br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;service1&quot;</span>)<br>    c2 := msgGen(<span class="hljs-string">&quot;service2&quot;</span>)<br>    c := fanInBySelect(c1, c2)<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）补充</strong>：对于同时等待多个服务（channel）的情况，是选择 goroutine 还是选择 select？</p><p>当不确定有多少服务的时候，选择 goroutine。（使用可变参数列表）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanInBySelect</span><span class="hljs-params">(channels ...&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;   <span class="hljs-comment">// 可变参数列表</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> channels &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <span class="hljs-comment">// 【注意】此处需注意循环变量的坑，ch 在循环中会被覆盖，需要备份。</span><br>            <span class="hljs-keyword">for</span> &#123;<br>                c &lt;- &lt;-ch<br>            &#125;<br>        &#125;(ch)<br>    &#125;<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;service1&quot;</span>)<br>    c2 := msgGen(<span class="hljs-string">&quot;service2&quot;</span>)<br>    c3 := msgGen(<span class="hljs-string">&quot;service3&quot;</span>)<br>    c := fanInBySelect(c1, c2, c3)<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-16-并发任务的控制">9.16 并发任务的控制</h3><p>channel 可以看成是服务，对于服务可以有更复杂的交互方式：</p><ul><li>非阻塞等待</li><li>超时机制（超时等待）</li><li>任务中断/退出</li><li>优雅退出</li></ul><h4 id="9-16-1-非阻塞等待">9.16.1 非阻塞等待</h4><blockquote><p>select + default</p></blockquote><p>select 会阻塞等待接收 channel 的数据；为了避免阻塞，为 select 配上 default 分支。</p><p>当 channel 没有数据的时候，select 走 default 分支。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nonBlockingWait</span><span class="hljs-params">(channel <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">bool</span>) &#123; <span class="hljs-comment">// select + default 实现对 channel 的非阻塞处理</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg := &lt;-channel:<br>        <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// 当 channel 没有数据的时候，select 走 default 分支。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;Service1&quot;</span>)<br>    c2 := msgGen(<span class="hljs-string">&quot;Service2&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c1)<br>        <span class="hljs-keyword">if</span> msg, ok := nonBlockingWait(c2); ok &#123;<br>            fmt.Println(msg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;No message from service2&quot;</span>)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-16-2-超时机制">9.16.2 超时机制</h4><blockquote><p>select + time.After</p></blockquote><p><a href="#9.12 超时计时器">9.12 超时计时器</a> 的应用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timeoutWait</span><span class="hljs-params">(channel <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, timeout time.Duration)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg := &lt;-channel:<br>        <span class="hljs-keyword">return</span> msg, <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := msgGen(<span class="hljs-string">&quot;Service1&quot;</span>)<br>    c2 := msgGen(<span class="hljs-string">&quot;Service2&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Println(&lt;-c1)<br>        <span class="hljs-keyword">if</span> msg, ok := timeoutWait(c2, <span class="hljs-number">200</span>*time.Millisecond); ok &#123;<br>            fmt.Println(msg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Service2 timeout.&quot;</span>)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>            c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>            time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">1000</span>)))<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-16-3-服务中断-退出">9.16.3 服务中断/退出</h4><blockquote><p>select + done channel</p></blockquote><p><strong>需求</strong>：main 函数退出之前，需要通知服务退出。</p><p><strong>解决</strong>：通过 select 来接收 done channel 的消息，如果接收不到，继续提供服务，如果接收到了 done channel，中断服务。与 <a href="#9.7 channel 等待多任务结束">#9.7 channel 等待多任务结束</a> 解决方式类似，只不过这个是 main 函数通知 goroutine 要中断服务。</p><p>注：<strong><code>chan struct&#123;&#125;</code> 比 <code>chan bool</code> 更省空间。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>    c1 := msgGen(<span class="hljs-string">&quot;Service1&quot;</span>, done)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        fmt.Println(&lt;-c1)<br>    &#125;<br>    done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;      <span class="hljs-comment">// 退出前，发消息给 done</span><br>    time.Sleep(time.Second) <span class="hljs-comment">// 给 goroutine 时间来 clean up</span><br>    fmt.Println(<span class="hljs-string">&quot;Main function out.&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>, done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">200</span>))): <span class="hljs-comment">// 随机时间发送消息</span><br>                c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>                i++<br>            <span class="hljs-keyword">case</span> &lt;-done: <span class="hljs-comment">// 收到 done 后，清理并退出</span><br>                fmt.Printf(<span class="hljs-string">&quot;%s clean up.\n&quot;</span>, name)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-16-4-优雅退出">9.16.4 优雅退出</h4><p><strong>问题</strong>：在 main 函数通知 goroutine 要中断服务，但 main 函数不知道这个服务要清理多久。上面的案例中， main 函数 time sleep 1 秒钟，main 函数如何优雅的退出呢？</p><p><strong>解决</strong>：done 可以做成双向的，当 clean up 结束后，向 done 发送消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>    c1 := msgGen(<span class="hljs-string">&quot;Service1&quot;</span>, done)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        fmt.Println(&lt;-c1)<br>    &#125;<br>    done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &lt;-done <span class="hljs-comment">// 收到消息证明服务已清理完毕，可以优雅退出。</span><br>    fmt.Println(<span class="hljs-string">&quot;Main function out.&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">msgGen</span><span class="hljs-params">(name <span class="hljs-type">string</span>, done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">200</span>))): <span class="hljs-comment">// 随机时间发送消息</span><br>                c &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s: message %d&quot;</span>, name, i)<br>                i++<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                time.Sleep(time.Second * <span class="hljs-number">2</span>) <span class="hljs-comment">// 需要清理 2s。</span><br>                fmt.Printf(<span class="hljs-string">&quot;%s clean up.\n&quot;</span>, name)<br>                done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// 清理完后，通知 main 函数。</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-17-实例：广度优先搜索迷宫">9.17 实例：广度优先搜索迷宫</h3><blockquote><p>利用广度优先算法走迷宫。</p></blockquote><p><strong>（1）主要思路</strong></p><ul><li><p>如何广度优先？</p><p>遍历的时候先遍历周围的点，在遍历周围的点的周围的点。为了满足这个特性，使用队列。</p></li><li><p>如何遍历？</p><p>从当前点开始，上下左右遍历，符合要求的点（不是墙、没走过的、没越界）将会被入队。循环取队头来遍历。</p></li><li><p>如何判断是否走过？</p><p>维护一个和地图一样大的二维数组，记录状态，称为状态二维数组。</p><p>为了方便广度优先搜索后，从状态二维数组中找到路径，每个点可记录为从起点到达当前点所需的步数。</p></li><li><p>如何记录迷宫路径？</p><p>从终点开始遍历周围的点，有且仅有一个小于当前步数的点，这个点就是路径中的点之一。以这个点为终点，遍历周围的点，同样有且仅有一个小于当前步数的点。以此类推，直到找到起点。</p></li></ul><p><strong>（2）广度优先搜索模型</strong></p><ol><li>获取当前节点，当前节点出队</li><li>从当前节点开始，上下左右探索</li><li>对于新点进行判断<ol><li>是否越界/遇到墙</li><li>是否走过（在状态二维数组中，0 才是没走过的点）</li><li>是否走到原点（因为在状态二维数组中，原点也是 0，但不代表没走过）</li></ol></li><li>维护状态二维数组</li><li>周围的节点入队</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 对点进行抽象</span><br>    i, j <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 从文件中读取点，并存入二维数组中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readMaze</span><span class="hljs-params">(filePath <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    file, err := os.Open(filePath)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">var</span> row, col <span class="hljs-type">int</span><br>    fmt.Fscanf(file, <span class="hljs-string">&quot;%d %d&quot;</span>, &amp;row, &amp;col)<br><br>    maze := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, row)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> maze &#123;<br>        maze[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, col)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> maze[i] &#123;<br>            fmt.Fscanf(file, <span class="hljs-string">&quot;%d&quot;</span>, &amp;maze[i][j])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maze<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p point)</span></span> add(p2 point) point &#123;<br>    <span class="hljs-keyword">return</span> point&#123;p.i + p2.i, p.j + p2.j&#125;<br>&#125;<br><br><span class="hljs-comment">// 返回在 p 点在网格中的值，当越界时返回 false</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p point)</span></span> at(grid [][]<span class="hljs-type">int</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">if</span> p.i &lt; <span class="hljs-number">0</span> || p.j &lt; <span class="hljs-number">0</span> || p.i &gt;= <span class="hljs-built_in">len</span>(grid) || p.j &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[p.i][p.j], <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 探索迷宫</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walk</span><span class="hljs-params">(maze [][]<span class="hljs-type">int</span>, start, end point)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        广度优先遍历的主要思路：</span><br><span class="hljs-comment">            1.获取当前节点，当前节点出队</span><br><span class="hljs-comment">            2.从当前节点开始，上下左右探索</span><br><span class="hljs-comment">            3.对于新点进行判断</span><br><span class="hljs-comment">                3.1 是否越界/遇到墙</span><br><span class="hljs-comment">                3.2 是否走过（在步数的二维数组中，0 才是没走过的点）</span><br><span class="hljs-comment">                3.3 是否走到原点（因为在步数的二维数组中，原点也是 0，但不代表没走过）</span><br><span class="hljs-comment">            4.维护步数的二维数组（状态二维数组）</span><br><span class="hljs-comment">            5.周围的节点入队</span><br><span class="hljs-comment">    */</span><br>    pointQueue := []point&#123;start&#125;<br>    minStepMaze := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(maze))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> minStepMaze &#123;<br>        minStepMaze[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(maze[<span class="hljs-number">0</span>]))<br>    &#125;<br>    dirs := [<span class="hljs-number">4</span>]point&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125; <span class="hljs-comment">// 上下左右探索的长度，便于遍历相加</span><br><br>    <span class="hljs-comment">// 当队列中没有点可走，就退出</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(pointQueue) &gt; <span class="hljs-number">0</span> &#123;<br>        curPoint := pointQueue[<span class="hljs-number">0</span>] <span class="hljs-comment">// 1.获取当前节点，当前节点出队</span><br>        pointQueue = pointQueue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">if</span> curPoint == end &#123; <span class="hljs-comment">// 当前点是 end 点时，返回结果</span><br>            <span class="hljs-keyword">return</span> minStepMaze<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> dirs &#123; <span class="hljs-comment">// 2.从当前节点开始，上下左右探索</span><br>            newPoint := curPoint.add(dir)<br><br>            val, ok := newPoint.at(maze) <span class="hljs-comment">// 3.1 是否越界/遇到墙</span><br>            <span class="hljs-keyword">if</span> !ok || val == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            val, ok = newPoint.at(minStepMaze) <span class="hljs-comment">// 3.2 是否走过（在步数的二维数组中，0 才是没走过的点）</span><br>            <span class="hljs-keyword">if</span> !ok || val != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> newPoint == start &#123; <span class="hljs-comment">// 3.3 是否走到原点（因为在步数的二维数组中，原点也是 0，但不代表没走过）</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            step, _ := curPoint.at(minStepMaze)<br>            minStepMaze[newPoint.i][newPoint.j] = step + <span class="hljs-number">1</span> <span class="hljs-comment">// 4.维护步数的二维数组（状态二维数组）</span><br>            pointQueue = <span class="hljs-built_in">append</span>(pointQueue, newPoint)      <span class="hljs-comment">// 5.周围的节点入队</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minStepMaze<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    maze := readMaze(<span class="hljs-string">&quot;../maze/maze.in&quot;</span>)<br>    start := point&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    end := point&#123;<span class="hljs-built_in">len</span>(maze) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(maze[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>&#125;<br>    minStepMaze := walk(maze, start, end)<br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> minStepMaze &#123;<br>        <span class="hljs-keyword">for</span> _, step := <span class="hljs-keyword">range</span> row &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%-4d&quot;</span>, step)<br>        &#125;<br>        fmt.Println()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-go-网络编程">10.go 网络编程</h2><h3 id="10-1-http-标准库">10.1 http 标准库</h3><p>使用 http client 发送请求。使用 httputil 显示源文件。（ 软件包 httputil 提供 HTTP 实用程序功能，补充了 net/http 软件包中较常见的功能。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 获取网页</span><br>    resp, err := http.Get(<span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>    <span class="hljs-comment">// 解析 response</span><br>    bytes, err := httputil.DumpResponse(resp, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, bytes)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 http.client 控制 request 的 header。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 新建一个请求</span><br>    request, err := http.NewRequest(http.MethodGet, <span class="hljs-string">&quot;https://www.aimtao.net&quot;</span>, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 增加头部</span><br>    request.Header.Add(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot; Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15&quot;</span>)<br><br>    <span class="hljs-comment">// 获取网页</span><br>    response, err := http.DefaultClient.Do(request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 response</span><br>    bytes, err := httputil.DumpResponse(response, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, bytes)<br>&#125;<br></code></pre></td></tr></table></figure><p>http client 除了使用 DefaultClient，还可以自定义 client，可以设置很多内容，比如 CheckRedirect 会记录重定向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 新建一个请求</span><br>    request, err := http.NewRequest(http.MethodGet, <span class="hljs-string">&quot;http://aimtao.net&quot;</span>, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 增加头部</span><br>    request.Header.Add(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&quot;</span>)<br><br>    <span class="hljs-comment">// 自定义可以将重定向记录打印出来的 client。</span><br>    client := http.Client&#123;<br>        CheckRedirect: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(req *http.Request, via []*http.Request)</span></span> <span class="hljs-type">error</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Redirect: &quot;</span>, req)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 获取网页</span><br>    response, err := client.Do(request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 response</span><br>    bytes, err := httputil.DumpResponse(response, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, bytes)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-http-性能分析">10.2 http 性能分析</h3><p><strong>（1）<code>/net/http/pprof</code></strong></p><p>对于需要分析的程序，需要导入 <code>/net/http/pprof</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;/net/http/pprof&quot;</span><br></code></pre></td></tr></table></figure><p>对提供服务的端口，访问其 <code>/debug/pprof</code> 目录， 例如访问 <a target="_blank" rel="noopener" href="http://localhost:8899/debug/pprof/">http://localhost:8899/debug/pprof/</a> 。</p><p><strong>（2）使用 go tool pprof 分析性能</strong></p><blockquote><p>使用之前需要安装 graphviz。</p></blockquote><p>查看 CPU 使用情况。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 默认等待 30s，即可查看 30s CPU 使用情况。</span><br>go tool pprof http://localhost:8899/debug/pprof/profile<br><br><span class="hljs-comment"># 等待 60s。</span><br>go tool pprof http://localhost:8899/debug/pprof/profile?seconds=60<br></code></pre></td></tr></table></figure><p>查看内存使用情况。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">go tool pprof http://localhost:8899/debug/pprof/head<br></code></pre></td></tr></table></figure><p><strong>（3）使用 go tool pprof web 界面</strong></p><p>最后访问 <a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a> 即可查看 web 界面。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> tool pprof -http=:<span class="hljs-number">8080</span> http://localhos<span class="hljs-variable">t:8899</span>/<span class="hljs-keyword">debug</span>/pprof/head<br></code></pre></td></tr></table></figure><h3 id="10-3-JSON-处理">10.3 JSON 处理</h3><p><strong>（1）结构体打印</strong></p><p>使用 `%+v 打印，会附带上结构体成员名。</p><p>当定义变量时，有成员未被赋值，会自动赋值为默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>    ID         <span class="hljs-type">string</span><br>    Name       <span class="hljs-type">string</span><br>    Quantity   <span class="hljs-type">int</span><br>    TotalPrice <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printOrder</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID:         <span class="hljs-string">&quot;001&quot;</span>,<br>        Name:       <span class="hljs-string">&quot;cola&quot;</span>,<br>        Quantity:   <span class="hljs-number">3</span>,<br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, o)<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, o)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    &#123;001 cola 3 30&#125;</span><br><span class="hljs-comment">    &#123;ID:001 Name:cola Quantity:3 TotalPrice:30&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>（2）JSON 序列化</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printOrderByJson</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID:         <span class="hljs-string">&quot;001&quot;</span>,<br>        Name:       <span class="hljs-string">&quot;cola&quot;</span>,<br>        Quantity:   <span class="hljs-number">3</span>,<br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    bytes, err := json.Marshal(o)  <span class="hljs-comment">// 将结构体序列化成 []byte 类型。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, bytes)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   &#123;&quot;ID&quot;:&quot;001&quot;,&quot;Name&quot;:&quot;cola&quot;,&quot;Quantity&quot;:3,&quot;TotalPrice&quot;:30&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>（3）struct tag</strong></p><p>为了各模块方便协作，按照 JSON 中的要求，键的名称应该是<strong>下划线命名法</strong>。但是 go 中，变量名小写，意味着 private，将无法序列化出来。所以需要使用 tag 来进行规定。</p><p>用 <code>``</code> 符号进行标记。</p><p><code>json:&quot;id&quot;</code> 表示 json 序列化后，使用字段键名要使用 <code>id</code> 。<strong>注意：有严格的格式要求，不能随意加空格。</strong></p><p>在键名后面加上 <code>omitempty</code> 表示如果这个字段没有提供，序列化时就不会出现这个字段，否则会以默认值填充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>    ID         <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name       <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Quantity   <span class="hljs-type">int</span>     <span class="hljs-string">`json:&quot;quantity,omitempty&quot;`</span>   <span class="hljs-comment">// 表示序列化时</span><br>    TotalPrice <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;total_price&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：下面这种情况，Quantity 在定义时未赋值。当标记了 <code>omitempty</code>，序列化时会自动忽略 quantity 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID:         <span class="hljs-string">&quot;001&quot;</span>,<br>        Name:       <span class="hljs-string">&quot;cola&quot;</span>,<br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;  <span class="hljs-comment">// 未赋值 Quantity。</span><br><br>    bytes, err := json.Marshal(o)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, bytes)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;cola&quot;,&quot;total_price&quot;:30&#125;   // 标记了 omitempty</span><br><span class="hljs-comment">&#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;cola&quot;,&quot;quantity&quot;:0,&quot;total_price&quot;:30&#125;  // 未标记了 omitempty</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>（4）struct tag 的坑</strong></p><p>正如上面所描述的，当标记 <code>omitempty</code> 后，未被赋值的变量 quantity，在序列化时会被忽略。</p><p>但当 quantity 被赋值为变量字段的默认值时（quantity 是 int 类型，默认值是 0），序列化时也会被忽略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID:         <span class="hljs-string">&quot;001&quot;</span>,<br>        Name:       <span class="hljs-string">&quot;cola&quot;</span>,<br>        Quantity:   <span class="hljs-number">0</span>, <span class="hljs-comment">// 被赋值为该类型的默认值</span><br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    bytes, err := json.Marshal(o)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, bytes) <span class="hljs-comment">// &#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;cola&quot;,&quot;total_price&quot;:30&#125;   // quantity 被忽略。</span><br>    fmt.Printf(<span class="hljs-string">&quot;%+v&quot;</span>, o)      <span class="hljs-comment">// &#123;ID:001 Name:cola Quantity:0 TotalPrice:30&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）JSON 反序列化</strong></p><p>JSON 字符串中有引号，变量定义是要使用 <code>``</code>。</p><p><code>json.Unmarshal</code> 的第一个参数是 []byte 类型，直接将 string 强制转换即可（string 本质上就是 []byte）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">`&#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;cola&quot;,&quot;quantity&quot;:3,&quot;total_price&quot;:30&#125;`</span>  <span class="hljs-comment">// 使用 ``</span><br>    <span class="hljs-keyword">var</span> o Order<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(s), &amp;o)  <span class="hljs-comment">// string 要转为 []byte</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%+v&quot;</span>, o)  <span class="hljs-comment">// &#123;ID:001 Name:cola Quantity:3 TotalPrice:30&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）嵌套结构体和结构体指针</strong></p><p>结构体常常会出现嵌套。结构体变量作为值，或者结构体变量指针作为值（节省空间）。</p><p>两种嵌套方式均可以直接序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> OrderItem <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Price <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;price&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>    ID         <span class="hljs-type">string</span><br>    Item       OrderItem   <span class="hljs-comment">// 结构体变量作为值。</span><br>    Quantity   <span class="hljs-type">int</span><br>    TotalPrice <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID: <span class="hljs-string">&quot;001&quot;</span>,<br>        Item: OrderItem&#123;   <span class="hljs-comment">// 结构体变量作为值。</span><br>            ID:    <span class="hljs-string">&quot;001&quot;</span>,<br>            Name:  <span class="hljs-string">&quot;cola&quot;</span>,<br>            Price: <span class="hljs-number">3</span>,<br>        &#125;,<br>        Quantity:   <span class="hljs-number">10</span>,<br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    bytes, err := json.Marshal(o)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, bytes)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> OrderItem <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Price <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;price&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>    ID         <span class="hljs-type">string</span><br>    Item       *OrderItem   <span class="hljs-comment">// 结构体变量作为值。</span><br>    Quantity   <span class="hljs-type">int</span><br>    TotalPrice <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    o := Order&#123;<br>        ID: <span class="hljs-string">&quot;001&quot;</span>,<br>        Item: &amp;OrderItem&#123;   <span class="hljs-comment">// 结构体变量作为值。</span><br>            ID:    <span class="hljs-string">&quot;001&quot;</span>,<br>            Name:  <span class="hljs-string">&quot;cola&quot;</span>,<br>            Price: <span class="hljs-number">3</span>,<br>        &#125;,<br>        Quantity:   <span class="hljs-number">10</span>,<br>        TotalPrice: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    bytes, err := json.Marshal(o)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, bytes)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-4-实例：解析阿里云-NLP-API-结果">10.4 实例：解析阿里云 NLP API 结果</h3><p>对于 “三只松鼠无漂白原味健康坚果” 进行命名实体识别，得到 json 字符串。</p><p>利用 <code>json.Unmarshal</code> 解析成结构化数据。两种接收方式：map 和 struct。</p><p><strong>（1）方式一：用 map 接收</strong></p><p>不推荐使用，因为 map 中存储的是 <code>interface&#123;&#125;</code> 类型，取值的时候需要使用 Type Assertion 来表明具体的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNLP</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 得到的 json 数据结果</span><br>    res := <span class="hljs-string">`&#123;</span><br><span class="hljs-string">  &quot;data&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.800000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;品牌&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;三只松鼠&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.600000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;修饰&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;无漂白&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.600000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;修饰&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;原味&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;1.000000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;品类&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;坚果&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;`</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(res), &amp;m) <span class="hljs-comment">// 使用 map 接收</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 取第一个词的 tag，需要使用 Type Assertion 表明值类型。</span><br>    fmt.Println(m[<span class="hljs-string">&quot;data&quot;</span>].([]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-number">0</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;tag&quot;</span>])<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）方式二：用 struct 接收</strong></p><p>需要先定义一个嵌套的结构体，但取某个字段的值非常方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNLP</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 得到的 json 数据结果</span><br>    res := <span class="hljs-string">`&#123;</span><br><span class="hljs-string">  &quot;data&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.800000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;品牌&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;三只松鼠&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.600000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;修饰&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;无漂白&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;0.600000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;修饰&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;原味&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;synonym&quot;: &quot;&quot;,</span><br><span class="hljs-string">      &quot;weight&quot;: &quot;1.000000&quot;,</span><br><span class="hljs-string">      &quot;tag&quot;: &quot;品类&quot;,</span><br><span class="hljs-string">      &quot;word&quot;: &quot;坚果&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;`</span><br>    m := <span class="hljs-keyword">struct</span> &#123;   <span class="hljs-comment">// 定义一个匿名结构体</span><br>        Data []<span class="hljs-keyword">struct</span> &#123;<br>            Synonym <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;synonym&quot;`</span><br>            Weight  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;weight&quot;`</span><br>            Tag     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;tag&quot;`</span><br>            Word    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;word&quot;`</span><br>        &#125; <span class="hljs-string">`json:&quot;data&quot;`</span><br>    &#125;&#123;&#125;<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(res), &amp;m) <span class="hljs-comment">// 使用 struct 接收</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 取第一个词的 tag、word</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.Data) &gt; <span class="hljs-number">0</span> &#123;  <span class="hljs-comment">// 对 map、list 取值需要判断是否存在</span><br>        fmt.Println(m.Data[<span class="hljs-number">0</span>].Tag, m.Data[<span class="hljs-number">0</span>].Word)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-5-gin-框架">10.5 gin 框架</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br>            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>        &#125;)<br>    &#125;)<br>    r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-6-gin-的-middleware">10.6 gin 的 middleware</h3><p>对于任何请求，都先进过 middleware，在 middleware 中，可以统一地做一些工作，比如生成日志、生成随机 ID。</p><p>下面使用 zap 进行生成结构化数据的 log。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    r.Use(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 实现 middleware</span><br><br>        logger, err := zap.NewProduction()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br><br>        <span class="hljs-comment">// 记录当前时间</span><br>        now := time.Now()<br><br>        <span class="hljs-comment">// 执行真正的请求处理函数</span><br>        ctx.Next()<br><br>        <span class="hljs-comment">// 生成 log：path、time duration、code status</span><br>        logger.Info(<span class="hljs-string">&quot;log&quot;</span>, zap.String(<span class="hljs-string">&quot;path&quot;</span>, ctx.Request.URL.Path),<br>            zap.Duration(<span class="hljs-string">&quot;time&quot;</span>, time.Since(now)),  <span class="hljs-comment">// 记录消耗的时间</span><br>            zap.Int(<span class="hljs-string">&quot;codeStatus&quot;</span>, ctx.Writer.Status()))<br>    &#125;)<br><br>    <span class="hljs-comment">// 真正的请求处理函数</span><br>    r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>        ctx.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br>            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>        &#125;)<br>    &#125;)<br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-7-gin-的-context">10.7 gin 的 context</h3><p>context 是 go 标准库的接口，gin 对其进行了包装。下面要实现一个功能：为每个请求生成一个 ID，并写入 context 中。</p><p><code>context.Set</code> 、<code>context.Get</code> 可以写入和取出键值对。使用 Get 之前需要判断是否存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br>    r.Use(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 实现 middleware</span><br><br>        <span class="hljs-comment">// 生成随机的 ID，写入 context 中</span><br>        ctx.Set(<span class="hljs-string">&quot;requestID&quot;</span>, rand.Intn(<span class="hljs-number">999999999</span>))<br><br>        <span class="hljs-comment">// 执行真正的请求处理函数</span><br>        ctx.Next()<br>    &#125;)<br><br>    <span class="hljs-comment">// 真正的请求处理函数</span><br>    r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>        h := gin.H&#123;<br>            	<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>            &#125;<br>      <br>        <span class="hljs-comment">// 从 context 中取出 requestID</span><br>        <span class="hljs-keyword">if</span> requestID, exists := ctx.Get(<span class="hljs-string">&quot;requestID&quot;</span>); exists &#123;<br>            h[<span class="hljs-string">&quot;requestID&quot;</span>] = requestID<br>        &#125;<br>      <br>        ctx.JSON(<span class="hljs-number">200</span>, h)<br>    &#125;)<br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="11-reflect">11.reflect</h2><h3 id="11-1-是什么">11.1 是什么</h3><p>在计算机科学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。（来自wikipedia）</p><p>举个例子，通过变量值获取变量类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>v := reflect.ValueOf(x) <span class="hljs-comment">// 输入值可以是任意类型</span><br><br>fmt.Println(v.Kind())   <span class="hljs-comment">// 输出: int</span><br>fmt.Println(v.Int())    <span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h3 id="11-2-反射包">11.2 反射包</h3><p>Go 中的反射是用 reflect 包实现，<a target="_blank" rel="noopener" href="https://pkg.go.dev/reflect%E3%80%82">https://pkg.go.dev/reflect。</a></p><p>reflect 包中，最核心的两个类型是 <code>reflect.Type</code> 和 <code>reflect.Value</code> 类型。</p><ul><li><code>reflect.TypeOf()</code> 方法，返回 <code>reflect.Type</code> 类型，表示变量的类型。</li><li><code>reflect.ValueOf()</code> 方法，返回 <code>reflect.Value</code> 类型，表示变量的值。</li></ul><p>这两个方法的参数，都是 <code>interface&#123;&#125;</code> 类型，每个 <code>interface&#123;&#125;</code> 类型的变量都包含一对值 （type，value），type 表示变量的类型信息，value 表示变量的值信息。</p><blockquote><p>题外话，因为每个 <code>interface&#123;&#125;</code> 类型的变量都包含一对值 （type，value），所以 <code>interface&#123;&#125;</code> 类型的值，会存在 nil != nil 的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 动态类型和动态值都是 nil</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 动态类型和动态值都是 nil</span><br>fmt.Println(a == b) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = (*<span class="hljs-type">int</span>)(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// 动态类型是 *int，动态值是 nil</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span>         <span class="hljs-comment">// 动态类型和动态值都是 nil</span><br>fmt.Println(a == b)             <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></blockquote><p>所以，<strong>反射就是把 <code>interface&#123;&#125;</code> 类型变量转化为 reflect.Value 或 reflect.Type 类型变量，随后用 reflect 包中的方法对它们进行各种操作</strong>。（ <code>interface&#123;&#125;</code> 类型变量则是由 go 类型变量转化而来）</p><blockquote><p><code>interface&#123;&#125;</code> 也叫空接口类型</p></blockquote><pre><code class="mermaid">graph LR
A(Go 变量) --&gt; B(空接口类型变量)
B --&gt; C(反射包的反射类型对象)
</code></pre><p>可以有哪些操作？可以看这里 <a target="_blank" rel="noopener" href="https://pkg.go.dev/reflect">https://pkg.go.dev/reflect</a></p><h3 id="11-3-三大法则">11.3 三大法则</h3><p>在 Go 官方博客文章 <a target="_blank" rel="noopener" href="https://go.dev/blog/laws-of-reflection">laws-of-reflection</a> 中，描述了反射的三大发则，也就是三大用法。</p><ol><li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><p><strong>法则一：从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象</strong></p><p>反射的第一步是从通用的接口类型 <code>interface&#123;&#125;</code> 提取反射对象。在 Go 中，通过 <code>reflect</code> 包的 <code>reflect.ValueOf</code> 和 <code>reflect.TypeOf</code> 函数可以获取值的反射对象和类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br>v := reflect.ValueOf(x)<br>t := reflect.TypeOf(x)<br><br>fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, v)       <span class="hljs-comment">// Value: 3.14   // 输出反射对象的值</span><br>fmt.Println(<span class="hljs-string">&quot;Type:&quot;</span>, t)        <span class="hljs-comment">// Type: float64 // 输出反射对象的类型</span><br>fmt.Println(<span class="hljs-string">&quot;Kind:&quot;</span>, t.Kind()) <span class="hljs-comment">// Kind: float64 // 输出基础类型（Kind）</span><br></code></pre></td></tr></table></figure><p>通过这一步，我们将运行时的变量封装为一个可以进一步操作的反射对象。</p><p><strong>法则二：从反射对象可以获取 <code>interface&#123;&#125;</code> 变量</strong></p><p>反射允许将反射对象还原为原始值，通过 <code>reflect.Value</code> 的方法 <code>Interface()</code>，可以重新获得 <code>interface&#123;&#125;</code> 类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br>v := reflect.ValueOf(x)   <span class="hljs-comment">// 获取反射对象</span><br><br>y := v.Interface() <span class="hljs-comment">//反射对象转换为 interface&#123;&#125; 类型</span><br>fmt.Println(<span class="hljs-string">&quot;Original Value:&quot;</span>, y) <span class="hljs-comment">// Original Value: 3.14</span><br></code></pre></td></tr></table></figure><p>这一法则表明，反射操作是可逆的：可以从 <code>interface&#123;&#125;</code> 获取反射对象，也可以通过反射对象重新得到原值。</p><p><strong>法则三：要修改反射对象，其值必须可设置</strong></p><p>反射不仅可以读取值，还可以动态修改值。但前提是，反射对象必须是“可设置的”。这意味着在使用 <code>reflect.Value</code> 修改数据时：</p><ol><li>传入的值必须是指针，这样才能通过指针间接修改原始值。</li><li>反射对象必须调用 <code>Elem()</code> 方法获取实际值。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br>v := reflect.ValueOf(&amp;x).Elem() <span class="hljs-comment">// 获取指针指向的值</span><br><br><span class="hljs-keyword">if</span> v.CanSet() &#123; <span class="hljs-comment">// 检查值是否可修改，可以修改为 true</span><br>    v.SetFloat(<span class="hljs-number">6.28</span>) <span class="hljs-comment">// 修改原值</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Modified Value:&quot;</span>, x) <span class="hljs-comment">// Modified Value: 6.28</span><br><br><br><span class="hljs-comment">// 错误例子</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br>v := reflect.ValueOf(x)  <span class="hljs-comment">// 这是值拷贝，无法更改原值</span><br>fmt.Println(v.CanSet())  <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>如果尝试直接修改不可设置的值（例如通过 <code>reflect.ValueOf(x)</code> 而非 <code>reflect.ValueOf(&amp;x)</code>），将会导致运行时错误（编译运行不会错误，但结果非预期）。</p><h3 id="11-4-一些例子">11.4 一些例子</h3><ol><li><code>reflect.ValueOf</code></li></ol><p><strong>作用</strong>：</p><p>将任意值包装为 <code>reflect.Value</code> 类型，表示该值的动态表示。</p><p><strong>输入</strong>：</p><ul><li>任意类型的值（值类型、指针类型、结构体、基本类型等）。</li></ul><p><strong>输出</strong>：</p><ul><li>返回 <code>reflect.Value</code> 类型的对象，封装了输入值的动态表示。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>v := reflect.ValueOf(x) <span class="hljs-comment">// 输入值类型为 int</span><br><br>fmt.Println(v.Kind())   <span class="hljs-comment">// 输出: int</span><br>fmt.Println(v.Int())    <span class="hljs-comment">// 输出: 42</span><br></code></pre></td></tr></table></figure><ul><li><strong>指针类型示例</strong>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>v := reflect.ValueOf(&amp;x) <span class="hljs-comment">// 输入值类型为 *int</span><br><br>fmt.Println(v.Kind())    <span class="hljs-comment">// 输出: ptr</span><br></code></pre></td></tr></table></figure><p><strong>2. <code>reflect.Indirect</code></strong></p><p><strong>作用</strong>：</p><p>解引用指针类型，获取指针指向的值。如果输入值不是指针，则直接返回原值。</p><p><strong>输入</strong>：</p><ul><li><code>reflect.Value</code> 类型的对象。</li></ul><p><strong>输出</strong>：</p><ul><li>返回解引用后的 <code>reflect.Value</code> 对象（如果不是指针，返回原值）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = &amp;x<br>v := reflect.ValueOf(p)                <span class="hljs-comment">// 封装指针</span><br>fmt.Println(reflect.Indirect(v).Kind()) <span class="hljs-comment">// 输出: int</span><br></code></pre></td></tr></table></figure><ul><li>如果输入是非指针：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>v := reflect.ValueOf(x)<br>fmt.Println(reflect.Indirect(v).Kind()) <span class="hljs-comment">// 输出: int</span><br></code></pre></td></tr></table></figure><p><strong>3. <code>reflect.Indirect().Type()</code></strong></p><p><strong>作用</strong>：</p><p>获取解引用后的值的类型信息。</p><p><strong>输入</strong>：</p><ul><li><code>reflect.Value</code> 类型的对象。</li><li>通过 <code>reflect.Indirect</code> 解引用，获取指向的实际值。</li></ul><p><strong>输出</strong>：</p><ul><li>返回 <code>reflect.Type</code>，表示值的类型。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo *Foo = &amp;Foo&#123;&#125;<br>v := reflect.ValueOf(foo)                <span class="hljs-comment">// 输入值为指针 *Foo</span><br>t := reflect.Indirect(v).Type()          <span class="hljs-comment">// 解引用后获取类型</span><br><br>fmt.Println(t.Name())                    <span class="hljs-comment">// 输出: Foo</span><br>fmt.Println(t.Kind())                    <span class="hljs-comment">// 输出: struct</span><br></code></pre></td></tr></table></figure><ul><li>如果输入不是指针：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>v := reflect.ValueOf(x)<br>fmt.Println(reflect.Indirect(v).Type()) <span class="hljs-comment">// 输出: int</span><br></code></pre></td></tr></table></figure><p><strong>4. <code>reflect.Indirect().Type().Name()</code></strong></p><p><strong>作用</strong>：</p><p>获取解引用后的值的类型名称。</p><p><strong>输入</strong>：</p><ul><li><code>reflect.Value</code> 类型的对象，通常是结构体实例或指针。</li><li>通过 <code>reflect.Indirect</code> 解引用，获取值的实际类型。</li></ul><p><strong>输出</strong>：</p><ul><li>返回值类型的名称，字符串类型。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo *Foo = &amp;Foo&#123;&#125;<br>v := reflect.ValueOf(foo)<br>name := reflect.Indirect(v).Type().Name()<br><br>fmt.Println(name) <span class="hljs-comment">// 输出: Foo</span><br></code></pre></td></tr></table></figure><ul><li>如果输入是非指针：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo Foo<br>v := reflect.ValueOf(foo)<br>fmt.Println(reflect.Indirect(v).Type().Name()) <span class="hljs-comment">// 输出: Foo</span><br></code></pre></td></tr></table></figure><p><strong>5. <code>reflect.TypeOf</code></strong></p><p><strong>作用</strong>：</p><p>获取值的静态类型信息。</p><p><strong>输入</strong>：</p><ul><li>任意值（值类型、指针类型、结构体、基本类型等）。</li></ul><p><strong>输出</strong>：</p><ul><li>返回 <code>reflect.Type</code> 类型的对象，表示值的静态类型。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>fmt.Println(reflect.TypeOf(x))   <span class="hljs-comment">// 输出: int</span><br><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = &amp;x<br>fmt.Println(reflect.TypeOf(p))   <span class="hljs-comment">// 输出: *int</span><br></code></pre></td></tr></table></figure><ul><li>注意，与 <code>reflect.Indirect</code> 不同，它不会解引用：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo *Foo = &amp;Foo&#123;&#125;<br>fmt.Println(reflect.TypeOf(foo).Name()) <span class="hljs-comment">// 输出: 空字符串 (因为 *Foo 没有名称)</span><br>fmt.Println(reflect.TypeOf(foo).Elem()) <span class="hljs-comment">// 输出: Foo</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>作用</strong></th><th><strong>输入示例</strong></th><th><strong>输出示例</strong></th></tr></thead><tbody><tr><td><code>reflect.ValueOf</code></td><td>动态封装值</td><td><code>42</code></td><td><code>&lt;int Value&gt;</code></td></tr><tr><td><code>reflect.Indirect</code></td><td>解引用指针，获取指向的值</td><td><code>reflect.Value</code></td><td><code>&lt;int Value&gt;</code> (指针解引用后的值)</td></tr><tr><td><code>reflect.Indirect().Type()</code></td><td>获取解引用值的类型</td><td><code>reflect.Value</code></td><td><code>reflect.Type</code> (如 <code>int</code>)</td></tr><tr><td><code>reflect.Indirect().Type().Name()</code></td><td>获取解引用值的类型名称</td><td><code>reflect.Value</code></td><td><code>&quot;Foo&quot;</code></td></tr><tr><td><code>reflect.TypeOf</code></td><td>静态获取类型</td><td><code>*Foo</code></td><td><code>reflect.Type</code> (如 <code>*Foo</code>)</td></tr></tbody></table><h2 id="参考资料">参考资料</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang">Go 语言设计与实现</a></p><p><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design/">为什么这么设计</a></p><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Go/">#Go</a></div></div><div class="license-box my-3"><div class="license-title"><div>学习笔记｜Go</div><div>https://www.aimtao.net/go/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2020-12-07</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/linux-system/" title="学习笔记｜Linux 系统编程"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">学习笔记｜Linux 系统编程</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/insert-sort/" title="图解链表的插入排序"><span class="hidden-mobile">图解链表的插入排序</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>