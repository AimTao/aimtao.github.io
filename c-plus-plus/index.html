<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="本文基于 C 对 C++ 进行比较学习，系统描述了面向对象编程的语法知识。"><title>学习笔记｜C++ - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2020-02-22-c-plus-plus.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="学习笔记｜C++"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-02-22 10:34" pubdate>2020-02-22 AM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 42k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 32 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">学习笔记｜C++</h1><p class="note note-info">本文最后更新于：5 years ago</p><div class="markdown-body"><blockquote><p>本文基于 C 对 C++ 进行比较学习，系统描述了面向对象编程的语法知识。</p></blockquote><span id="more"></span><h2 id="零、Google-C-风格指南">零、Google C++ 风格指南</h2><h3 id="0-文件命名">0.文件命名</h3><p>全部小写 + 用下划线：<code>my_useful_class.cc</code></p><h3 id="1-变量命名">1.变量命名</h3><h4 id="（1）普通变量、结构体的数据成员">（1）普通变量、结构体的数据成员</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">string table_name;  <span class="hljs-comment">// 全部小写 + 用下划线.</span><br></code></pre></td></tr></table></figure><h4 id="（2）类的数据成员">（2）类的数据成员</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">string table_name_;  <span class="hljs-comment">// 全部小写 + 后加下划线.</span><br></code></pre></td></tr></table></figure><h3 id="2-常量和枚举值命名">2.常量和枚举值命名</h3><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kDaysInAWeek = <span class="hljs-number">7</span>;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UrlTableErrors</span> &#123;<br>  kOK = <span class="hljs-number">0</span>,<br>  kErrorOutOfMemory,<br>  kErrorMalformedInput,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-类型命名">3.类型命名</h3><p>类、结构体、类型定义 (<code>typedef</code>)、枚举名、类型模板参数：<strong>首字母大写 + 没有下划线 + 大小写混合</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 类和结构体</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlTable</span> &#123; ...<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UrlTableProperties</span> &#123; ...<br><br><span class="hljs-comment">// 类型定义</span><br><span class="hljs-keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;<br><br><span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UrlTableErrors</span> &#123; ...<br></code></pre></td></tr></table></figure><h3 id="4-函数命名">4.函数命名</h3><p>常规函数使用<strong>首字母大写+ 大小写混合 + 没有下划线</strong>, 取值和设值函数则要求与变量名匹配:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 常规函数</span><br><span class="hljs-built_in">MyExcitingFunction</span>();<br><span class="hljs-built_in">MyExcitingMethod</span>();<br><br><span class="hljs-comment">// 取值函数</span><br><span class="hljs-built_in">my_exciting_member_variable</span>();<br><br><span class="hljs-comment">// 设值函数</span><br><span class="hljs-built_in">set_my_exciting_member_variable</span>();<br></code></pre></td></tr></table></figure><h3 id="5-函数声明与定义">5.函数声明与定义</h3><ul><li>函数名和左圆括号间永远没有空格.</li><li>右圆括号和左大括号间总是有一个空格.</li></ul><p>函数看上去像这样:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">ReturnType <span class="hljs-title">ClassName::FunctionName</span><span class="hljs-params">(Type par_name1, Type par_name2)</span> </span>&#123;<br>  <span class="hljs-built_in">DoSomething</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果同一行文本太多, 放不下所有参数:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">ReturnType <span class="hljs-title">ClassName::ReallyLongFunctionName</span><span class="hljs-params">(Type par_name1, Type par_name2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             Type par_name3)</span> </span>&#123;<br>  <span class="hljs-built_in">DoSomething</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至连第一个参数都放不下:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">ReturnType <span class="hljs-title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    Type par_name1,  <span class="hljs-comment">// 4 space indent</span></span></span><br><span class="hljs-params"><span class="hljs-function">    Type par_name2,</span></span><br><span class="hljs-params"><span class="hljs-function">    Type par_name3)</span> </span>&#123;<br>  <span class="hljs-built_in">DoSomething</span>();  <span class="hljs-comment">// 2 space indent</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：对于单行函数的实现，在大括号内加上空格。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> b) : <span class="hljs-built_in">Bar</span>(), <span class="hljs-built_in">baz_</span>(b) &#123;&#125;  <span class="hljs-comment">// 大括号里面是空的话, 不加空格.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span> </span>&#123; baz_ = <span class="hljs-number">0</span>; &#125;  <span class="hljs-comment">// 用空格把大括号与实现分开.</span><br></code></pre></td></tr></table></figure><h3 id="6-循环、判断、开关">6.循环、判断、开关</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">if</span> (condition) &#123;  <span class="hljs-comment">// 左括号前面、右括号后面 有空格</span><br>  ...  <span class="hljs-comment">// 2 空格缩进.</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// else 与 if 的右括号同一行.</span><br>  ...<br>&#125;<br><br><span class="hljs-keyword">switch</span> (var) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;  <span class="hljs-comment">// 2 空格缩进   // 冒号后面有空格</span><br>    ...      <span class="hljs-comment">// 4 空格缩进</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">default</span>: &#123; <span class="hljs-comment">// 冒号后面有空格</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (condition) &#123;   <span class="hljs-comment">// 左括号前面、右括号后面 有空格</span><br>  ...<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 空格</span><br>  <span class="hljs-built_in">foo</span>();<br>&#125; <br><span class="hljs-built_in">catch</span> (NSException *ex) &#123;    <span class="hljs-comment">// 左括号前面、右括号后面 有空格，和 if 一样</span><br>  <span class="hljs-built_in">bar</span>(ex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-逻辑判断">7.逻辑判断</h3><p>逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;<br>    a_third_thing == a_fourth_thing &amp;&amp;<br>    yet_another &amp;&amp; last_one) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-函数返回值">8.函数返回值</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">return</span> result;         <span class="hljs-comment">// 返回值很简单, 没有圆括号.</span><br><span class="hljs-comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span><br><span class="hljs-keyword">return</span> (some_long_condition &amp;&amp;<br>        another_condition);<br></code></pre></td></tr></table></figure><h3 id="9-类格式">9.类格式</h3><ul><li>访问控制块的声明依次序是 <code>public:</code>， <code>protected:</code> ， <code>private:</code> ，每个都缩进 1 个空格，</li><li>除 <code>public</code> 外， <code>protected:</code> 、 <code>private:</code> 前要空一行。</li><li>继承与初始化列表中的冒号前后恒有空格。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> OtherClass &#123;    <span class="hljs-comment">// 继承冒号前后各一个空格。</span><br> <span class="hljs-keyword">public</span>:      <span class="hljs-comment">// 注意有一个空格的缩进</span><br>  <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 标准的两空格缩进</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunction</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunctionThatDoesNothing</span><span class="hljs-params">()</span> </span>&#123;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:     <span class="hljs-comment">// private: 上方要空一行</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SomeInternalFunction</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-type">int</span> some_var_;<br>  <span class="hljs-type">int</span> some_other_var_;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-初始化列表">10.初始化列表</h3><p>构造函数初始化列表放在同一行或按四格缩进并排多行。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 如果所有变量能放在同一行:</span><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var) : <span class="hljs-built_in">some_var_</span>(var) &#123;<br>  <span class="hljs-built_in">DoSomething</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果不能放在同一行,</span><br><span class="hljs-comment">// 必须置于冒号后, 并缩进 4 个空格</span><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var)<br>    : <span class="hljs-built_in">some_var_</span>(var), <span class="hljs-built_in">some_other_var_</span>(var + <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">DoSomething</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span><br><span class="hljs-comment">// 并逐行对齐</span><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var)<br>    : <span class="hljs-built_in">some_var_</span>(var),             <span class="hljs-comment">// 4 space indent</span><br>      <span class="hljs-built_in">some_other_var_</span>(var + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// lined up</span><br>  <span class="hljs-built_in">DoSomething</span>();<br>&#125;<br><br><span class="hljs-comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span><br><span class="hljs-comment">// 如果这样做合适的话</span><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var)<br>    : <span class="hljs-built_in">some_var_</span>(var) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="11-模版与转换">11.模版与转换</h3><p>&lt; 前没有空格，&gt; 和 ( 之间也没有。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">vector&lt;string&gt; x;<br>y = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(x);<br><br><span class="hljs-comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span><br>vector&lt;<span class="hljs-type">char</span> *&gt; x;<br></code></pre></td></tr></table></figure><h2 id="一、C-对-C-的增强">一、C++ 对 C 的增强</h2><h3 id="1-namespace-命名空间">1. namespace 命名空间</h3><h4 id="（1）定义">（1）定义</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">namespace</span> spaceA &#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">//使用（2种方式）</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> spaceA;<br><span class="hljs-keyword">using</span> spaceA::a;<br></code></pre></td></tr></table></figure><h4 id="（2）嵌套定义">（2）嵌套定义</h4><p>命名空间要引用到最后一层</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">namespace</span> spaceA &#123;<br>  <span class="hljs-keyword">namespace</span> spaceB &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用（2种方式）</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> spaceA::spaceB;<br><span class="hljs-keyword">using</span> spaceA::spaceB::a;<br></code></pre></td></tr></table></figure><h4 id="（3）命名空间的作用">（3）命名空间的作用</h4><p>可以由用户命名作用域，用来处理程序中常见的同名冲突。</p><h3 id="2-struct-结构体定义">2.struct 结构体定义</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>  string name;<br>  <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// C++的定义</span><br>student tom；   <span class="hljs-comment">//少了struct</span><br>tom.age = <span class="hljs-number">18</span>;<br>  <br><span class="hljs-comment">// C语言的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> tom;<br></code></pre></td></tr></table></figure><p>PS：C语言中的 sturct 不可以有成员函数，C++ 中 struct 可以有成员函数。</p><h3 id="3-bool-类型">3.bool 类型</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>；<br>cout &lt;&lt; flag;    <span class="hljs-comment">// 1;   // 只能 1 或 0</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(flag);  <span class="hljs-comment">// 1个字节，不是 int 的4个字节</span><br><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  pass;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三目运算符当左值">4.三目运算符当左值</h3><ul><li>在C中，三目运算符返回的是一个数值，运算器计算出的一个数值，不能当左值；</li><li>在C++中，三目运算符返回的是变量的引用，可以直接赋值。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// C语言中，需要返回地址，再改变地址储存的值</span><br>*(a &gt; b ? &amp;a : &amp;b) = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// C++中，返回的 a、b 是变量引用，可以直接赋值</span><br>(a &gt; b ? a : b) = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="5-const">5.const</h3><ul><li><code>const int a = 10;</code> C中，a 是一个变量；C++中，a 是一个常量，储存在常量区的符号表中。</li><li>C++中 <code>const</code> 类似于 <code>define</code>，但是 <code>define</code> 是在预处理时展开，<code>const</code> 在编译时处理。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// C语言中，通过以下方式可以更改 a 的值</span><br><span class="hljs-type">int</span> *p = &amp;a;<br>*p = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// C++中，不可以通过指针（以下方式）修改 a 的值</span><br><span class="hljs-comment">// int *p = (int*) &amp;a;</span><br><span class="hljs-comment">// *p = 20;</span><br></code></pre></td></tr></table></figure><p>⚠️<strong>辨析</strong>：</p><p><code>const *</code> 修饰变量只读，<code>* const</code> 修饰指针只读。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// const *  // 变量 a 的值不能改变</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p = &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;<br><br><span class="hljs-comment">// *const   // 指针 p 的值不能改变</span><br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br><br><span class="hljs-comment">// 对于其他的</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;  <span class="hljs-comment">// 引用 b 的值不能改变。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = a;   <span class="hljs-comment">// 变量 b 的值不能改变</span><br></code></pre></td></tr></table></figure><p>⚠️<strong>注意01</strong>：</p><p>安全性高的变量，不可以给安全性较低的变量赋值。（同样适用于函数参数传递。）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 变量赋值的情况</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = a;   <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 参数传递的情况</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>；<br><span class="hljs-built_in">fun</span>(a);   <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>⚠️<strong>注意02</strong>：</p><p>如果写以下代码，编译会报错：<code>conversion from string literal to 'char *' is deprecated</code></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;Tom&quot;</span>;   <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>加 <code>const</code> 修饰即可。【原因：“Tom” 为常量，安全性较高，不可以传递给 安全性较低的 <code>char *p</code>】</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> <span class="hljs-type">const</span> *p = <span class="hljs-string">&quot;Tom&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="6-枚举">6.枚举</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">season</span> &#123;<br>    spring = <span class="hljs-number">0</span>;<br>    summer;<br>    autumn;<br>    winter;<br>&#125;<br><br><span class="hljs-comment">// C语言中，可以用数字代替</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">season</span> s = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// C++中，不可以用数字代替</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">season</span> s = summer;<br></code></pre></td></tr></table></figure><h2 id="二、C-对-C-的扩展">二、C++ 对 C 的扩展</h2><h3 id="1-引用">1.引用</h3><h4 id="（1）引用初始化-与-const">（1）引用初始化 与 const</h4><ul><li><strong>定义引用时，必须初始化。</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-type">int</span> &amp;b = a;   <span class="hljs-comment">// 合法，初始化</span><br><span class="hljs-type">int</span> &amp;b;       <span class="hljs-comment">// 非法，没有初始化</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>non-const</code>引用 只能用 <code>non-const</code> 变量初始化。</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// non-const 变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;  <span class="hljs-comment">// const 变量</span><br><br><span class="hljs-type">int</span> &amp;aa = a;   <span class="hljs-comment">// 合法，用 non-const左值 初始化 non-const引用</span><br><span class="hljs-type">int</span> &amp;bb = b;   <span class="hljs-comment">// 非法，不能用 const 左值 初始化 const引用</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>const</code> 引用 可以用 常量、<code>non-const</code> 变量、<code>const</code> 变量初始化。</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// non-const 变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;  <span class="hljs-comment">// const 变量</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;aa = a;   <span class="hljs-comment">// 合法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;bb = b;   <span class="hljs-comment">// 合法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cc = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><h4 id="（2）引用的本质">（2）引用的本质</h4><ul><li>引用本质上是一个 常指针。</li><li>常指针被存在了常量区，即引用也存储在常量区，（不在栈中，但指向栈中的变量 a ）</li><li>同理的还有 <code>int arr[10];</code> ，a 存储在常量区中，指向栈中的10个int空间</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure><h4 id="（3）指针的引用">（3）指针的引用</h4><p><code>struct student* &amp;p</code> 表示 <code>struct student*</code> 类型的引用 <code>&amp;p</code></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>  <span class="hljs-type">int</span> id;<br>  string name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_student</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> student* &amp;p)</span> </span>&#123;  <span class="hljs-comment">// 指针的引用</span><br>  <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stduent</span> *p = <span class="hljs-literal">nullptr</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）const-修饰引用">（4）const 修饰引用</h4><p>对于常量的引用，应该用 const 修饰</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>  pass;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）引用作为函数返回值">（5）引用作为函数返回值</h4><blockquote><p>返回引用，就是返回 变量本身。</p></blockquote><ul><li>用于返回 函数中的静态变量 或者 类中的静态成员函数返回静态成员变量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp; <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; fun() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以当左值。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-built_in">fun</span>() = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 当左值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回类的对象</li></ul><p>见 <a href="#返回对象本身">this 的使用——返回对象本身</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>private:<br>  <span class="hljs-type">int</span> a;<br>public:<br>  Test &amp;<span class="hljs-title function_">Add</span><span class="hljs-params">(Test &amp;another)</span>&#123;   <span class="hljs-comment">// 使用引用 返回类的对象本身。</span><br>    this-&gt;a += another.a;<br>    <span class="hljs-keyword">return</span> *this;<br>  &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  Test <span class="hljs-title function_">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>, <span class="hljs-title function_">a2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span>;<br>  a1.Add().Add();      <span class="hljs-comment">// 计算 （a1 + a2）+ a1， a1.Add() 返回的是一个对象。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>禁止</strong>：禁止返回局部变量的引用。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-keyword">return</span> a;   <span class="hljs-comment">// error //局部变量 a，离开&#123;&#125;，被释放。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）引用做形参不发生隐式转换">（6）引用做形参不发生隐式转换</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;a)</span></span>&#123; <span class="hljs-comment">//... &#125;</span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">Fun</span>(a);   <span class="hljs-comment">// 报错！引用做形参不发生隐式转换。若去掉引用，可以隐式转换。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-inline-内联函数">2.inline 内联函数</h3><blockquote><p>宏函数的缺点：</p><ul><li>不对形参进行检查。</li><li>对于有表达式的形参，部分不执行，直接替换。</li><li>在预处理阶段处理。</li></ul><p>inline 函数的优点：</p><ul><li>是真正的函数，在编译阶段进行参数检查。</li></ul></blockquote><p>编译器直接将内联函数函数体，插入在函数调用的地方。内联函数，是由编译器在编译阶段处理的</p><p><strong>优势</strong>：内联函数没有函数调用的额外开销：压栈、跳转、返回</p><p><strong>限制</strong>：</p><ul><li>不能有任何形式的循环语句</li><li>不能对函数进行取值操作</li><li>不能有过多的条件判断语句</li><li>函数体不能过于庞大</li></ul><p><strong>本质</strong>： 用代码空间换时间</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>  cout &lt;&lt; a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-默认参数和占位参数">3.默认参数和占位参数</h3><p><strong>默认参数</strong>：只能放参数列表最后，没传参时，使用默认参数，传参即使用传递的参数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height = <span class="hljs-number">10</span>)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>占位参数</strong>： 没有意义，用途见 <a href="#参数占位符的使用"><code>++</code> 的重载 </a><a name="占位参数"></a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span>)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-函数重装">4.函数重装</h3><h4 id="（1）重载规则">（1）重载规则</h4><blockquote><p>注意⚠️：返回值不同不是函数重载的构成条件。</p></blockquote><ul><li>函数名相同，形参列表不同：<ul><li>形参个数</li><li>形参类型</li><li>形参顺序</li></ul></li></ul><h4 id="（2）调用准则">（2）调用准则</h4><ul><li>如果能严格匹配，调用完全匹配的函数</li><li>如果不能严格匹配，调用隐式转换</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// fun01</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-comment">// fun02</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-comment">// fun03</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span> </span>&#123;<br> pass; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fun</span>(<span class="hljs-number">1.2f</span>)  <span class="hljs-comment">// 调用 fun01，因为 float 隐式转换为 double。</span><br>  <span class="hljs-built_in">fun</span>(<span class="hljs-string">&quot;a&quot;</span>)   <span class="hljs-comment">// 调用 fun03，若没有 fun03，则 char 隐式转换为 int，调用 fun02。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）注意">（3）注意</h4><ul><li>函数重载，写默认参数，警惕函数冲突</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br>  pass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// 此时产生歧义</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）底层实现">（4）底层实现</h4><ul><li>C++ 利用 name mangling 来更改函数名，区分参数不同的同名函数</li><li>用 v c i f l d 表示 void char int float long double 及其引用</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// example</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;         <span class="hljs-comment">// fun_i (int a)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> a)</span>  <span class="hljs-comment">// fun_ci (char c, int a)</span></span><br></code></pre></td></tr></table></figure><h3 id="5-函数重载和函数指针">5.函数重载和函数指针</h3><p>函数指针一旦定了，就只会指向一个函数类型，不再会发生函数重载。</p><p>函数指针 p 指向的函数类型是 <code>int fun(int, int)</code>，<code>p(1, 2, 3);</code> 不会发生函数重载，会报错。</p><ul><li><p>函数指针<strong>赋值时</strong>，会发生函数重载：<code>p = fun;</code></p></li><li><p>函数指针<strong>调用时</strong>，不会发生函数重载，<strong>会严格匹配</strong>。因为赋值时，已决定 p 指向的函数类型。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>  pass;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>  pass;<br>&#125;<br><br><span class="hljs-type">int</span> (*p)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 赋值，发生函数重载</span><br>p = fun;<br><br><span class="hljs-comment">// 调用，不发生函数重载</span><br>p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// correct</span><br>p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// error，不能函数重载</span><br>p(a, b);    <span class="hljs-comment">// error, 不能隐式转换</span><br></code></pre></td></tr></table></figure><h2 id="三、类和对象">三、类和对象</h2><p>类：数据类型</p><p>对象：内存中的一块空间</p><p>数据类型：这块内存空间，赋予它的类型</p><p>变量：内存空间的名称</p><p>值：内存空间的内容</p><h3 id="1-类的基本概念">1.类的基本概念</h3><h4 id="（1）概念">（1）概念</h4><p>类就是一个结构体，区别在于：</p><ul><li>类可以设置访问控制权限（<strong>默认是 private</strong>），结构体默认访问控制权限是 public。</li><li>类中可以有成员函数，C++ 结构体也可以有成员函数，<strong>但 C 语言结构体只能有成员变量。</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-comment">// class &#123;&#125;内 叫类的内部，&#123;&#125;外 叫类的外部。</span><br><span class="hljs-keyword">public</span>:        <span class="hljs-comment">// public 下的成员变量的和成员函数，类内部和外部都可以访问。</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> fake_age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SayAge</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; fake_age &lt;&lt; endl;<br>    &#125;<br>  <br><span class="hljs-keyword">private</span>:      <span class="hljs-comment">// private 下的成员变量和成员函数，只能在类的内部访问。</span><br>    <span class="hljs-type">int</span> true_age;<br>&#125;;   <span class="hljs-comment">// 【重要】有分号！</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Animal dog;<br>    <span class="hljs-comment">// dog.name 是字符串数组，不能复制，不可以直接 dog.name = &quot;xiaohuang&quot;;</span><br>    <span class="hljs-built_in">memcpy</span>(dog.name, <span class="hljs-string">&quot;xiaohuang&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;xiaohuang&quot;</span>));<br>    dog.fake_age = <span class="hljs-number">2</span>;<br>    dog.<span class="hljs-built_in">SayAge</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）对象的大小-a-name-对象的大小-a">（2）对象的大小<a name="对象的大小"></a></h4><ul><li>对象的大小和结构体的大小一样，按照成员变量内存对齐计算大小。</li><li>函数储存在代码段中，不计算在对象的大小中。</li><li><a href="#静态成员变量">静态成员变量</a>，在 data 区，不计算在对象的大小中。</li></ul><p><strong>特殊</strong>：c++空类实例化出来的对象大小为1，原因如下：</p><ul><li>为了保证<strong>每个实例化在内存中都有独一无二的地址。</strong></li><li>编译器会给一个空类或者空的结构体中加入一个字节，这样空类或空结构体在实例化后在内存中就得到了独一无二的地址。</li></ul><p><strong>另</strong>：这1字节不会被子类继承。</p><h3 id="2-类的封装">2.类的封装</h3><blockquote><p>封装可以到达对内开放数据，对外屏蔽数据，只提供接口。</p></blockquote><h4 id="（1）封装的访问属性">（1）封装的访问属性</h4><table><thead><tr><th>访问属性</th><th>属性</th><th>访问权限</th></tr></thead><tbody><tr><td>pubilc</td><td>公有</td><td>类内外均可访问</td></tr><tr><td>protected</td><td>保护</td><td>类内访问</td></tr><tr><td>private（默认）</td><td>私有</td><td>类内访问</td></tr></tbody></table><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>  <span class="hljs-type">int</span> year;      <span class="hljs-comment">// 默认为 private  </span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）面对对象和面对过程">（2）面对对象和面对过程</h4><p>面向过程：吃(人, 饭)</p><p>面对对象：人.吃(饭)</p><h4 id="（3）以圆的面积为例">（3）以圆的面积为例</h4><p>面对过程：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleGrith</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">3.14</span> * r;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleArea</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * r * r;<br>&#125;<br></code></pre></td></tr></table></figure><p>面向对象：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetR</span><span class="hljs-params">(<span class="hljs-type">int</span> new_r)</span></span>&#123;<br>    m_r = new_r;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleGirth</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">3.14</span> * m_r;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleArea</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * m_r * m_r;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_r;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（4）初学者易犯错误模型">（4）初学者易犯错误模型</h4><p>对于成员的定义，一定不要使用表达式。因为在定义 area 时，r 是一个内存空间中的随机值。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">double</span> r;<br>  <span class="hljs-type">double</span> area = <span class="hljs-number">3.14</span> * r * r;   <span class="hljs-comment">// error，此时 r 是随机值。</span><br>&#125;; <br></code></pre></td></tr></table></figure><h4 id="（5）多文件编写">（5）多文件编写</h4><blockquote><p>如果文件链接失败，可以将 <a target="_blank" rel="noopener" href="http://circle.cc">circle.cc</a> 改为 circle.hpp ，并在 <a target="_blank" rel="noopener" href="http://main.cc">main.cc</a> 中调用 <code>#include &quot;circle.hpp&quot;</code>。</p></blockquote><p>circle.h</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_r</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleGrith</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CircleArea</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> m_r;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://circle.cc">circle.cc</a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circle::set_r</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span></span>&#123;<br>    m_r = r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Circle::CircleGrith</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">3.14</span> * m_r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Circle::CircleArea</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * m_r * m_r;<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Circle c;<br>    <span class="hljs-type">int</span> r;<br>    cin &gt;&gt; r;<br>    c.<span class="hljs-built_in">set_r</span>(r);<br>    cout &lt;&lt; c.<span class="hljs-built_in">CircleGrith</span>() &lt;&lt; endl;<br>    cout &lt;&lt; c.<span class="hljs-built_in">CircleArea</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）同类之间可直接访问私有变量">（6）同类之间可直接访问私有变量</h4><p>在类的定义中，成员函数需要调用 同类实例化的对象的 私有成员变量，可以直接访问，无需使用 set、get。</p><p><strong>原因</strong>：相同的类，私有成员变量都是一样的，无需隐藏。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetR</span><span class="hljs-params">(<span class="hljs-type">int</span> new_r)</span></span>&#123;<br>        m_r = new_r;<br>      &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(Circle &amp;another_circle)</span></span>&#123;<br>      <span class="hljs-keyword">if</span> (m_r == another_circle.m_r <span class="hljs-comment">/* 【同类之间，可以直接访问私有变量】 */</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;两个圆相同！&quot;</span> &lt;&lt; endl;<br>      &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> m_r;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-构造函数">3.构造函数</h3><p>实例化时，定义成员变量，却不赋值，不安全！所以需要在实例化对象时，对成员变量进行赋值。</p><h4 id="（1）格式">（1）格式</h4><p>构造函数没有返回值、函数类型，和类名同名，<strong>构造函数可以重载</strong>。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>()&#123; <span class="hljs-comment">// 无参构造函数 </span><br>    m_x = <span class="hljs-number">0</span>;<br>    m_y = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;  <span class="hljs-comment">// 全参构造函数</span><br>    m_x = x;<br>    m_y = y;<br>  &#125;<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x)&#123;<br>    m_x = x;<br>    m_y = <span class="hljs-number">0</span>;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> m_x;<br>  <span class="hljs-type">int</span> m_y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  Test t1;          <span class="hljs-comment">// 调用无参构造函数</span><br>  <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;   <br>  <span class="hljs-function">Test <span class="hljs-title">t3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;   <span class="hljs-comment">// 调用全参构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）默认构造函数">（2）默认构造函数</h4><blockquote><p>默认构造函数是空函数。</p></blockquote><ul><li>当没有任何构造函数时，会有默认构造函数。</li><li>一旦有任何显式构造函数（无参或有参），默认构造函数就会消失。</li></ul><h3 id="4-析构函数">4.析构函数</h3><p>析构函数在对象内存释放之前，自动调用。用来释放堆区空间（该对象开辟的）。</p><h4 id="（1）格式-2">（1）格式</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">Test</span>()&#123; <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">free</span>(p);<br>      p = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> *p;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2020-05-25-bjnOV8.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="（2）默认析构函数">（2）默认析构函数</h4><blockquote><p>默认构造函数是空函数。</p></blockquote><ul><li>当没有任何析构函数时，会有默认析构函数。</li><li>一旦有任何显式析构函数，默认析构函数就会消失。</li></ul><h4 id="（3）析构函数调用顺序">（3）析构函数调用顺序</h4><p>析构函数调用顺序，与构造函数相反，【<strong>先构造的对象，后析构</strong>】。</p><p>原因：压入栈的顺序，先构造的对象先压栈，后弹栈。</p><h3 id="5-拷贝构造函数">5.拷贝构造函数</h3><p>类 Test 实例化出 对象 t1、对象 t2。用 t1 给 t2 赋值。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">Test t1；<br><span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<br><br><span class="hljs-comment">// 或者写成</span><br>Test t2 = t1;<br></code></pre></td></tr></table></figure><h4 id="（1）显式的拷贝构造函数">（1）显式的拷贝构造函数</h4><p>显式的拷贝构造函数，用户自定义的。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test &amp;another_test)&#123;  <span class="hljs-comment">// 用 const 来修饰传入的对象。</span><br>  m_x = another_test.m_x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）默认拷贝构造函数">（2）默认拷贝构造函数</h4><ul><li><p>如果没显式拷贝构造函数，会有一个默认的拷贝构造函数。</p></li><li><p>将一个对象的成员变量的值，全部拷贝给另外一个对象的成员变量。</p></li></ul><h4 id="（3）拷贝构造函数与赋值操作符函数">（3）拷贝构造函数与赋值操作符函数</h4><p>此处调用的不是拷贝构造函数，因为 <strong>构造函数是对象初始化的时候调用</strong>。</p><p>PS：类中存在默认的赋值操作符函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc">Test t1;<br>Test t2;<br>t2 = t1;   <span class="hljs-comment">// 调用的不是拷贝构造函数，而是【赋值操作符函数】</span><br></code></pre></td></tr></table></figure><h4 id="（4）深拷贝与浅拷贝">（4）深拷贝与浅拷贝</h4><p><strong>浅拷贝的问题</strong>：用一个对象给另一个对象赋值，若存在指向堆区的指针，浅拷贝会只拷贝指针所储存的值（堆区地址），析构函数将对此堆区同一空间进行二次释放。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 浅拷贝：默认拷贝函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-built_in">Teacher</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *name)&#123;              <span class="hljs-comment">// 【⚠️重要】一定要加 const 修饰！见 一.5.注意02</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(name);<br>        m_name = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_name, name);<br>    &#125;<br>    ~<span class="hljs-built_in">Teacher</span>()&#123;<br>        <span class="hljs-keyword">if</span> (m_name != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">free</span>(m_name);<br>            m_name = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; m_name &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *m_name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(Teacher t2)</span></span>&#123;   <span class="hljs-comment">// 此处调用 t2 的默认拷贝函数，对值进行拷贝</span><br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Teacher <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-string">&quot;tom&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">Test</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>深拷贝</strong>：提供显式的拷贝构造函数，开辟空间，拷贝指针所指向的空间。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-built_in">Teacher</span>(<span class="hljs-type">const</span> Teacher &amp;another_teacher)&#123;  <span class="hljs-comment">// 【⚠️重要】一定要加 const 修饰！见 三.12.(2)</span><br>  <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(another_teacher.m_name);<br>  m_name = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">strcpy</span>(m_name, another_teacher.m_name);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）匿名对象的拷贝构造">（5）匿名对象的拷贝构造</h4><blockquote><p>匿名对象不能返回引用。匿名对象使用完，内存回收，返回引用没有意义。</p><p>返回对象—对象做拷贝</p><p>返回对象引用—对象本身</p></blockquote><p>当函数返回值是 <strong>对象</strong> 时，函数将 该对象拷贝给一个匿名对象。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">Test <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">Test <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>  <span class="hljs-keyword">return</span> temp;     <span class="hljs-comment">// 匿名对象 = tmp，此处调用了匿名对象的拷贝构造函数。</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>没有变量来接收</strong></li></ol><p>函数外部没有变量来接收函数返回值–匿名对象时，匿名对象将不会再被使用，将等待程序结束被回收。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-built_in">fun</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>新实例化一个对象来接收</strong></li></ol><p>此处将不再使用拷贝构造函数，匿名对象直接转正为 t，将匿名对象取名为 t；</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  Test t = <span class="hljs-built_in">fun</span>();      <span class="hljs-comment">// 不使用拷贝构造函数。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>已有对象来接收</strong></li></ol><p>t 已经分配空间，所以匿名对象不在转正。</p><ul><li>调用 t 的赋值操作符函数。</li><li>系统 【<strong>立刻回收</strong>】 匿名对象内存。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  Test t;<br>  t = <span class="hljs-built_in">fun</span>();    <span class="hljs-comment">// 调用 t 的赋值操作符函数。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-构造函数的初始化列表">6.构造函数的初始化列表</h3><p>当一个类 B 的成员变量是另一个类 A 时， 且类 A 的只有带参的构造函数。若要用类 B 实例化对象，必须在类 B 的构造函数调用的之前，调用类 A 的构造函数。</p><p><strong>原因</strong>：在初始化类 B 的对象 b 时，必须先初始化类 A 的对象 m_a1、m_a2，不然无法给类 B 的对象 b 分配空间。</p><h4 id="（1）格式-3">（1）格式</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)&#123;<br>        m_a = a;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(A &amp;a1, A &amp;a2, <span class="hljs-type">int</span> b):<span class="hljs-built_in">m_a1</span>(a1), <span class="hljs-built_in">m_a2</span>(a2)&#123;  <span class="hljs-comment">// 构造函数的初始化列表，使用【拷贝构造函数】</span><br>        m_b = b;<br>       <span class="hljs-comment">// m_a1= a1;  //【错误】这样调用的就不是构造函数，而是赋值操作符函数。</span><br>    &#125;<br>    <span class="hljs-comment">// 类 B 构造函数重载</span><br>      <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> b):<span class="hljs-built_in">m_a1</span>(al), <span class="hljs-built_in">m_a2</span>(a2)&#123;  <span class="hljs-comment">// 构造函数的初始化列表，使用【构造函数】</span><br>          m_b = b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    A m_a1;<br>    A m_a2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>, <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span>;<br>    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">(a1, a2, <span class="hljs-number">300</span>)</span></span>;<br>      <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）构造函数调用顺序">（2）构造函数调用顺序</h4><blockquote><p>调用 <strong>对象成员</strong> 的构造函数 的顺序，和初始化列表的顺序无关，和定义顺序有关。</p></blockquote><p>以对象 b1 的初始化为例：</p><ol><li><p><code>m_a1(a1)</code> ：因为 m_a1 先定义。<code>A m_a1;</code></p></li><li><p><code>m_a2(a2)</code> ：因为 m_a2 后定义。<code>A m_a2;</code></p></li><li><p><code>B()</code> ：因为要先调用 m_a1、m_a2 的拷贝构造函数，才能调用 b1 的构造函数。</p></li></ol><h4 id="（3）析构函数调用顺序-2">（3）析构函数调用顺序</h4><p>以对象 b1 为例：</p><ol><li><code>~B()</code> ：后构造，先析构。</li><li><code>~A()</code> ：m_a2 的析构函数。</li><li><code>~A()</code> ：m_a1 的析后函数。</li></ol><h4 id="（4）const-常量的初始化">（4）const 常量的初始化</h4><p>const 常量不允许在构造函数中赋值，应该定义时边初始化。故在参数列表中进行初始化。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">k_a</span>(k) <span class="hljs-comment">/* const 常量初始化。*/</span> &#123;  <br>        m_a1 = a1;<br>        m_a2 = a2;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_a1;<br>    <span class="hljs-type">int</span> m_a2;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> k_a;   <span class="hljs-comment">// 定义 const 常量</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> k_a) : <span class="hljs-built_in">m_a</span>(a1, a2, k_a), <span class="hljs-built_in">k_b</span>(k) <span class="hljs-comment">/* const 常量初始化。*/</span>&#123;<br>        m_b = b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    A m_a;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> k_b;   <span class="hljs-comment">// 定义 const 常量</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-new-和-delete">7.new 和 delete</h3><blockquote><p>new 和 delete 是<strong>操作符</strong>，不是函数，因此<strong>执行效率高</strong>。用来替代C语言的库函数 malloc 和 free。</p></blockquote><h4 id="（1）格式-4">（1）格式</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 申请一个 int 大小空间。</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;      <br><span class="hljs-comment">// int *p = new int(10);  // 表示申请一个 int 大小空间，并初始化为 10</span><br>*p = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-keyword">delete</span> p;<br>  p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 申请一个数组空间。</span><br><span class="hljs-type">int</span> *array_p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">// 注意：是中括号，不是小括号，小括号是初始化。</span><br><span class="hljs-keyword">if</span> (array_p != <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-keyword">delete</span>[] array_p;        <span class="hljs-comment">// 注意：有个[]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）异同">（2）异同</h4><p><strong>【相同的地方】</strong>：</p><p>new / detele 和 malloc / free 的 内存管理方式是互相兼容的。new 出的空间，可以用 free 释放。malloc 出的空间可以用 dlelte 释放。</p><p><strong>【不同的地方】</strong>：</p><ul><li><p><strong>执行效率</strong></p><p>new / delete 是操作符，malloc / free 是 C库函数。操作符效率更高，因为不需要压栈弹栈。</p></li><li><p><strong>调用类函数</strong></p><p>new 可以调用<strong>构造函数或拷贝构造函数</strong>；malloc 不能调用。</p><p>delete 可以在释放空间前调用<strong>析构函数</strong>；free 不能调用。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<br>        m_a = a;<br>        m_b = b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">// Test *p = (Test *)malloc(sizeof(Test));  // error, </span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）delete-和-delete-的区别">（3）delete 和 delete[] 的区别</h4><p><code>new</code> 先申请空间，再调用构造函数；<code>delete</code> 先调用析构函数，再释放空间。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">Test *p = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">10</span>];    <span class="hljs-comment">// 调用了 10 次构造函数</span><br><br><span class="hljs-keyword">delete</span>[] p;      <span class="hljs-comment">// 调用了 10 次析构函数</span><br><br><span class="hljs-keyword">delete</span> p;        <span class="hljs-comment">// 只调用一次析构函数，容易造成内存泄露。</span><br></code></pre></td></tr></table></figure><h3 id="8-static">8.static</h3><blockquote><p>静态局部变量：</p><ul><li>储存在 Data 区，默认初始化为 0。</li><li>程序结束才自动释放，只初始化一次。</li><li>编译阶段就已分配空间，所以不能用变量初始化。</li></ul><p>静态全局变量：</p><ul><li>只能在本文件中使用，不可多文件使用。</li></ul></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_a</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> m_a;<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_b;    <span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_a;    <span class="hljs-comment">// 声明</span><br>&#125;;<br><br><span class="hljs-type">int</span> Test::a = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> Test::b = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout &lt;&lt; Test::<span class="hljs-built_in">get_a</span>();   <span class="hljs-comment">// 调用，取值，函数的命名空间属于类。</span><br>  Test::<span class="hljs-built_in">get_a</span>() = <span class="hljs-number">20</span>;      <span class="hljs-comment">// 调用，赋值，</span><br>  <br>  <span class="hljs-comment">// 直接通过类的取值</span><br>  cout &lt;&lt; Test::a &lt;&lt; endl;   <span class="hljs-comment">// java 中是直接 类.静态变量 访问</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（1）静态成员变量-a-name-静态成员变量-a">（1）静态成员变量 <a name="静态成员变量"></a></h4><ul><li>储存在 Data 区，不在对象的内存当中，不占用类打大小。</li><li>程序结束才自动释放，只初始化一次，多个对象共享一个静态成员变量。</li><li>编译阶段就已分配空间。初始化在类外初始化。</li></ul><h4 id="（2）静态成员函数">（2）静态成员函数</h4><p>静态成员函数只能访问静态数据成员。</p><p>原因:非静态成员函数，在调用时 this 指针被当作参数传进。而静态成员函数属于类，而不属于对象，<strong>没有 this 指针。</strong></p><h3 id="9-this-指针">9.this 指针</h3><h4 id="（1）问题">（1）问题</h4><p><code>a1.get_a();</code> <code>a2.get_a();</code> 调用的是同一段代码，返回的值不一样？</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 类 Test 的成员函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Test::get_a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> m_a;<br>&#125;<br><br>a<span class="hljs-number">1.</span><span class="hljs-built_in">get_a</span>();<br>a<span class="hljs-number">2.</span><span class="hljs-built_in">get_a</span>();<br></code></pre></td></tr></table></figure><h4 id="（2）处理机制">（2）处理机制</h4><p>调用函数时，参数中 <strong>传递了对象的地址</strong>。</p><p>PS：成员变量以结构体类型储存，成员函数以及静态变量不在对象内存中。见<a href="#对象的大小"> 对象的大小</a></p><p><img src="https://hutu.aimtao.net/mark/2020-05-25-aM9eK7.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="（3）this-指针接收对象地址">（3）this 指针接收对象地址</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 实际代码是这样的：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Test::get_a</span><span class="hljs-params">(Test *<span class="hljs-keyword">this</span>)</span></span>&#123;   <span class="hljs-comment">// 用指针 this 来接收对象 a1 的地址。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_a;<br>&#125;<br><br>a<span class="hljs-number">1.</span><span class="hljs-built_in">get_a</span>(&amp;a1);   <span class="hljs-comment">// 传递对象 a1 的地址。</span><br></code></pre></td></tr></table></figure><h4 id="（4）this-指针特点">（4）this 指针特点</h4><p>This 是常指针，<code>Test *const this</code>，</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 正确！可以修改指针所指向内存的值。</span><br>  <span class="hljs-keyword">this</span>++；        <span class="hljs-comment">// 错误！ 不可以修改指针所储存的值。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_a;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）设置成员函数只读">（5）设置成员函数只读</h4><p>格式：在函数后加入 const。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;   <span class="hljs-comment">// 加 const 修饰 this 指针所指内容只读。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_a;<br>&#125;<br></code></pre></td></tr></table></figure><p>含义：加 const 修饰 this 指针所指内容只读（加的是第一个 const， 修饰 *，第二个 const 原本就有）。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Test * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="（6）返回对象本身-a-name-返回对象本身-a">（6）返回对象本身 <a name="返回对象本身"></a></h4><ul><li>返回值用 引用类型</li><li>用 <code>*this</code> 表示对象本身。</li></ul><p>用途：对于一个对象，连续调用其成员方法。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Test &amp;<span class="hljs-title">Add</span><span class="hljs-params">(Test &amp;another)</span></span>&#123;   <span class="hljs-comment">// 使用引用 返回类的对象本身。</span><br>    <span class="hljs-keyword">this</span>-&gt;a += another.a;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">Test <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>, <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>  a<span class="hljs-number">1.</span><span class="hljs-built_in">Add</span>(a2).<span class="hljs-built_in">Add</span>(a1);      <span class="hljs-comment">// 计算 （a1 + a2）+ a1 </span><br>                           <span class="hljs-comment">// a1.Add() 返回的是对象 a1。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-友元函数与友元类">10.友元函数与友元类</h3><h4 id="（1）友元函数">（1）友元函数</h4><p>类外的友元函数可以直接访问类的私有成员变量。</p><p><strong>弊端</strong>：破坏了类的封装性和隐蔽性。（类型 <code>goto</code> ，不推荐使用。）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Test &amp;t)</span></span>;  <span class="hljs-comment">// 友元函数的定义。</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Test &amp;t)</span></span>&#123;<br>  <span class="hljs-comment">// 频繁的压栈出栈影响效率。</span><br>  <span class="hljs-comment">// cout &lt;&lt; t.get_x() * t.get_x() + t.get_y() * t.get_y();</span><br>  <span class="hljs-comment">// 使用友元函数直接访问私有成员，提高效率。</span><br>  cout &lt;&lt; t.x * t.x + t.y * t.y &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>声明其他类中的成员方法为友元</strong>：（不推荐使用）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>;    <span class="hljs-comment">// 保证第5行中，形参定义不报错。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ReturnTest</span><span class="hljs-params">(Test &amp;t)</span></span>;   <span class="hljs-comment">// 保证第13行中，友元声明不报错。</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">A::ReturnTest</span><span class="hljs-params">(Test &amp;t)</span></span>;  <span class="hljs-comment">// 其他类中的成员方法为友元。</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A::ReturnTest</span><span class="hljs-params">(Test &amp;t)</span></span>&#123;    <span class="hljs-comment">// 先定义后实现，是因为，使用私有成员要在声明私有成员之后。</span><br>  <span class="hljs-keyword">return</span> t.x + t.y;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）友元类">（2）友元类</h4><p>在 A 类中声明 B 类为友元类，B 类中可以直接访问 A 类中的私有成员。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; obj_a.a &lt;&lt; endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  A obj_a;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（3）友元的特性">（3）友元的特性</h4><ol><li><p><strong>声明位置</strong></p><p>friend 友元声明写在类定义中，不受其所在类的声明区域 public、private 和 protected 的影响。</p></li><li><p><strong>友元关系不能被继承</strong></p></li><li><p><strong>友元关系是单向的，不具有交换性</strong></p><p>若类 B 是类 A 的友元,类 A 不一定是类 B 的友元,要看在类中是否有相应的声明。</p></li><li><p><strong>友元关系不具有传递性</strong></p><p>若类 B 是类 A 的友元,类 C 是 B 的友元,类 C 不一 定 是类 A 的友元,同样要看类中是否有相应的声明。</p></li></ol><h3 id="11-操作符重载">11.操作符重载</h3><blockquote><p>运算符重载的本质是函数重载。</p></blockquote><p>运算符重载的例子：<code>int + int</code>，<code>double + double</code>。计算机对整数、单精度数和双精度数的 加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就 能适用于int, float, doUble类型的运算。</p><h4 id="（1）类外重载">（1）类外重载</h4><blockquote><p>全局函数</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> num)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = num;<br>  &#125;<br>  <span class="hljs-keyword">friend</span> Test <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Test &amp;a, <span class="hljs-type">const</span> Test &amp;b);  <span class="hljs-comment">// 以便 operator+ 函数可以直接调用私有成员变量。</span><br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-comment">// 类外定义 + 号重载。</span><br>Test <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Test &amp;a, <span class="hljs-type">const</span> Test &amp;b)&#123; <span class="hljs-comment">// 返回值不能为引用，匿名对象返回引用，匿名对象会被回收内存。</span><br>  <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(a.num + b.num)</span></span>;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">Test <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>  Test c = a + b;                 <span class="hljs-comment">// 调用 + 号重载 的方式一</span><br>  Test d = <span class="hljs-keyword">operator</span>+(a, b);       <span class="hljs-comment">// 调用 + 号重载 的方式二，传递两个参数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）类内重载">（2）类内重载</h4><blockquote><p>成员函数</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> num)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;num = num;<br>  &#125;<br>  <span class="hljs-comment">// 类内定义 + 号重载。</span><br>  Test <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Test &amp;another)&#123;   <span class="hljs-comment">// 返回值不能为引用，匿名对象返回引用，匿名对象会被回收内存。</span><br>      <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;num + another.num)</span></span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">Test <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>  Test c = a + b;                 <span class="hljs-comment">// 调用 + 号重载 的方式一</span><br>  Test d = a.<span class="hljs-keyword">operator</span>+(b);       <span class="hljs-comment">// 调用 + 号重载 的方式二，传递一个参数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）操作符重载规则">（3）操作符重载规则</h4><ol><li><strong>只能对 C++ 允许重载的操作符进行重载。</strong></li></ol><p>&lt;img src=“<a target="_blank" rel="noopener" href="https://hutu.aimtao.net/mark/2020-05-26-higeP3.webp-s%22style=%22zoom:">https://hutu.aimtao.net/mark/2020-05-26-higeP3.webp-s&quot;style=&quot;zoom:</a> 67%;” /&gt;</p><ol start="2"><li><p><strong>重载不能改变运算符的运算对象(即操作数)的个数。</strong></p><p>关系运算符 <code>&gt;</code> 和 <code>&lt;</code> 等是双目运算符,重载后仍为双目运算符,需要两个参数。运算符 <code>+</code>，<code>-</code>，<code>*</code>，<code>&amp;</code> 等既可以作为单目运算符，也可以作为双目运算符，可以分别将它们重载为单目运算符或双目运算符。</p></li><li><p><strong>重载不能改变运算符的优先级别。</strong></p><p><code>*</code> 和 <code>/</code> 优先级高于 <code>+</code> 和 <code>-</code> ，不论怎样进行重载，各运算符之间 的优先级不会改变。</p></li><li><p><strong>重载不能改变运算符的结合性。</strong></p><p><code>=</code> 是从右向左结核性，重载后也是从右向左。</p></li><li><p><strong>重载运算符的函数不能有默认的参数。</strong></p></li><li><p><strong>重载的运算符必须和用户定义的自定义类型的对象一起使用。</strong></p></li><li><p><strong>用于类对象的运算符一般必须重载,但有两个例外,运算符”=“和运算 符”&amp;“不 必用户重载。</strong></p><p>赋值运算符 <code>=</code> 可以用于每一个类对象,可以用它在同类对象之间相互赋值。 因为系统已为每一个新声明的类重载了一个赋值运算符，它的作用是逐个复制类中的数据成员地址运算符 <code>&amp;</code> 也不必重载,它能返回类对象在内存中的起始地址。</p></li><li><p><strong>应当使重载运算符的功能类似于该运算符原含义。</strong></p></li></ol><h4 id="（4）实例：重载">（4）实例：重载<code>+=</code></h4><blockquote><p>重载双目运算符。</p></blockquote><ul><li><strong>类外重载</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Test &amp;<span class="hljs-keyword">operator</span>+=(Test &amp;t1, Test &amp;t2);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-comment">// += 类外重载</span><br>Test &amp;<span class="hljs-keyword">operator</span>+=(Test &amp;t1, Test &amp;t2)&#123;   <span class="hljs-comment">// 双目运算符，要返回对象t1本身，所以要用引用。</span><br>    t<span class="hljs-number">1.</span>x += t<span class="hljs-number">2.</span>x;<br>    <span class="hljs-keyword">return</span> t1;       <span class="hljs-comment">// 返回对象t1，实际上返回对象的引用。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    t1 += t2;    <span class="hljs-comment">// operator+=(t1, t2);</span><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">Print</span>();   <span class="hljs-comment">// 打印结果为 3</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>类内重载</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// += 类外重载</span><br>    Test &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Test &amp;another)&#123;  <span class="hljs-comment">// 双目运算符，要返回对象t1本身，所以要用引用。</span><br>        <span class="hljs-keyword">this</span>-&gt;x += another.x;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <span class="hljs-comment">// 返回对象t1，实际上返回对象的引用。</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    t1 += t2;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">Print</span>();   <span class="hljs-comment">// 打印结果为 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）实例：重载">（5）实例：重载 <code>++</code></h4><blockquote><p>重载单目运算符</p></blockquote><p>单目运算符 <code>++</code> 的重载要写两个，因为 <code>前置++</code> 和 <code>后置++</code> 不一样。</p><p>区别在于：</p><ul><li>前置++，<code>++a</code>，返回对象本身，可以连加。</li><li>后置++，<code>a++</code>，返回匿名对象，不可以连加。</li></ul><p>【 用参数占位符区分 前置++ 和 后置++】<a name="参数占位符的使用"></a> 见<a href="#占位参数"> 占位参数</a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Test &amp;<span class="hljs-keyword">operator</span>++(Test &amp;t);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Test <span class="hljs-keyword">operator</span>++(Test &amp;t, <span class="hljs-type">int</span>);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-comment">// 重载前置++，比如 t++</span><br>Test &amp;<span class="hljs-keyword">operator</span>++(Test &amp;t)&#123;   <span class="hljs-comment">// 返回对象t本身，使用引用</span><br>    t.x ++;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">// 重载后置++，比如 ++t</span><br><span class="hljs-comment">// 用参数占位符区分 前置++ 和 后置++</span><br><span class="hljs-type">const</span> Test <span class="hljs-keyword">operator</span>++(Test &amp;t, <span class="hljs-type">int</span>)&#123;    <span class="hljs-comment">// 返回一个匿名对象，const = 不可以修改、不可以连加</span><br>    <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(t)</span></span>;   <br>    t.x ++;<br>    <span class="hljs-keyword">return</span> tmp;    <span class="hljs-comment">// 返回 ++ 前的值。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    t1++;<br>    ++++t2;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">Print</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（6）实例：重载">（6）实例：重载 <code>&lt;&lt;</code> <code>&gt;&gt;</code></h4><blockquote><p>作用：直接打印出对象的成员变量。</p><p>注意：重载不能写在类的内部，因为会 <a href="#禁止类内重载">改变参数顺序 </a>。</p></blockquote><p>比如：类 Complex 有 x、y 两个坐标值。通过 <code>&lt;&lt;</code> <code>&gt;&gt;</code> 实现设值和打印。</p><ul><li><strong>类外重载</strong></li></ul><p>cout 的类型：ostream。</p><p>cin 的类型：istream。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>        <span class="hljs-keyword">this</span>-&gt;y = y;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Complex &amp;c);<br>    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Complex &amp;c);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-comment">// 左移重载</span><br><span class="hljs-comment">// ostream 是 cout 的类型</span><br><span class="hljs-comment">// 需要 连续使用左移运算符，如: cout &lt;&lt; x &lt;&lt; y;  // 所以返回 cout 对象本身</span><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Complex &amp;c)&#123;<br>        os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; c.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; c.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><br><span class="hljs-comment">// 右移重载</span><br><span class="hljs-comment">// istream 是 cin 的类型</span><br><span class="hljs-comment">// 需要 连续使用右移运算符，如: cin &gt;&gt; x &gt;&gt; y;  // 所以返回 cin 对象本身</span><br>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Complex &amp;c)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span>;<br>    is &gt;&gt; c.x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;y:&quot;</span>;<br>    is &gt;&gt; c.y;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    cin &gt;&gt; a;<br>    cout &lt;&lt; a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>类内重载</strong><a name="禁止类内重载"></a></li></ul><p><strong>不允许</strong>，改变了参数顺序。</p><p><code>ostream &amp;operator&lt;&lt;(ostream &amp;os)&#123;&#125;</code> 第一个参数是对象本身，第二参数是cout，所以调用时不能写成 <code>cout &lt;&lt; a;</code>，而是 <code>a &lt;&lt; cout;</code>。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>        <span class="hljs-keyword">this</span>-&gt;y = y;<br>    &#125;<br>    ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os)&#123;   <span class="hljs-comment">// 第一个参数是对象，第二个参数是cout</span><br>        os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>        a &lt;&lt; cout;             <span class="hljs-comment">// 调用的第一种方式，改变了操作符实际顺序，禁止！</span><br>        a.<span class="hljs-built_in">operator</span>(cout);      <span class="hljs-comment">// 调用的第二种方式</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（7）重写等号操作符">（7）重写等号操作符</h4><ul><li><p><strong>为什么要重写等号操作符？</strong></p><p>类中有默认等号操作符函数，函数内容和默认拷贝构造的函数类似，均是浅拷贝，若类中使用了堆区空间，就需要重写等号操作符函数。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无参构造函数</span><br>    <span class="hljs-built_in">Test</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-comment">// 全参构造函数</span><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = id;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, name);<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">Test</span>(Test &amp;another)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = another.id;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(another.name) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, another.name);<br>    &#125;<br>    <span class="hljs-comment">// 重写等号操作符函数</span><br>    Test &amp;<span class="hljs-keyword">operator</span>=(Test &amp;another)&#123;<br>        <span class="hljs-comment">// 防止自身辅助</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;another)&#123;    <span class="hljs-comment">// 【注意】判断地址是否相同！&amp; 是去地址。</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 先回收原本的空间</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;name != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;name;<br>        &#125;<br><br>        <span class="hljs-comment">// 申请堆区空间赋值</span><br>        <span class="hljs-keyword">this</span>-&gt;id = another.id;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(another.name) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, another.name);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Test</span>()&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;name != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;name;<br>            <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> *name;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（8）实例：重载">（8）实例：重载 <code>()</code></h4><p><strong>伪函数、仿函数、函数对象</strong>：将一个对象 当场普通函数来调用。STL 中较多。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;   <span class="hljs-comment">// 小括号重载，从而实现伪函数。</span><br>        <span class="hljs-keyword">return</span> value * value;<br>    &#125;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> value1, <span class="hljs-type">int</span> value2)</span></span>&#123;   <span class="hljs-comment">// 小括号重载，参数个数不同。</span><br>        <span class="hljs-keyword">return</span> value1 * value2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Test t;<br>      <span class="hljs-type">int</span> res = <span class="hljs-built_in">t</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 【伪函数、仿函数】将一个对象 当场普通函数来调用。</span><br>    <span class="hljs-comment">// int res = t.operator()(2);</span><br>      <span class="hljs-type">int</span> res = <span class="hljs-built_in">t</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（9）不建议重载 <code>||</code> 、<code>&amp;&amp;</code></p><ul><li><code>||</code> 、<code>&amp;&amp;</code> 有短路现象</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (a &amp;&amp; a = <span class="hljs-number">10</span>) &#123;<br>  pass;<br>&#125;<br>cout &lt;&lt; a;  <span class="hljs-comment">// 此时 a 为 0； // 因为 &amp;&amp; 有短路现象，第一个数为零，后面的参数直接忽略。</span><br><br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (b || b = <span class="hljs-number">10</span>) &#123;<br>  pass;<br>&#125;<br>cout &lt;&lt; b;  <span class="hljs-comment">// 此时 b 为 1；// 因为 || 有短路现象，第一个数为非零，后面的参数直接忽略。</span><br></code></pre></td></tr></table></figure><ul><li>重载后的 <code>||</code> 、<code>&amp;&amp;</code> 没有短路现象</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&amp;&amp;(Test &amp;another)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x &amp;&amp; another.x;<br>  &#125;<br>  Test <span class="hljs-keyword">operator</span>+(Tes &amp;another)&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;x + another.x)</span></span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-comment">// 相当于 t1.operator&amp;&amp;(t2.operator+(t3))</span><br>  <span class="hljs-comment">// 先执行 t2.operator+(t3)，再执行 t1.operator&amp;&amp;()，所以没有短路现象。</span><br>  <span class="hljs-keyword">if</span> (t1 &amp;&amp; (t2 + t3)) &#123;  <br>    <span class="hljs-comment">//</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（9）实例：自定义智能指针">（9）实例：自定义智能指针</h4><p>智能指针自动回收申请的堆区空间。</p><ul><li><strong>智能指针</strong></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;   <span class="hljs-comment">// 智能指针。</span><br>  *p = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>自定义智能指针</strong></li></ul><p><code>定义智能指针类 MyAutoPtr</code> + <code>重载 -&gt; 操作符函数</code> + <code>重载 * 操作符函数</code></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; endl;        <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAutoPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyAutoPtr</span>(A *p)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;p = p;<br>    &#125;<br>    ~<span class="hljs-built_in">MyAutoPtr</span>()&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> p;<br>            p = <span class="hljs-literal">nullptr</span>;<br>        &#125;       <br>    &#125;<br>    A *<span class="hljs-keyword">operator</span>-&gt;()&#123;      <span class="hljs-comment">// 重载 -&gt; </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;p;      <span class="hljs-comment">// 返回 ptr 私有成员 p 指针</span><br>    &#125;<br>    A &amp;<span class="hljs-keyword">operator</span>*()&#123;       <span class="hljs-comment">// 重载 *</span><br>        <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;p);    <span class="hljs-comment">// 返回 p 所指向的对象本身。</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    A *p;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyAutoPtr <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-comment">// 调用 -&gt; 操作符函数</span><br>    ptr-&gt;<span class="hljs-built_in">Print</span>();    <span class="hljs-comment">// ptr.operator-&gt;()-&gt;Print();</span><br>    <span class="hljs-comment">// 调用 * 操作符函数。</span><br>    (*ptr).<span class="hljs-built_in">Print</span>();  <span class="hljs-comment">// ptr.operator*().Print();</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">Fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⚠️注意</strong>：</p><p><code>重载 -&gt; 操作符函数</code> ：<code>ptr-&gt;Print()</code> 变成了 <code>(ptr.p)-&gt;Print()</code> ，返回值为 <code>p</code>，重载后 <code>-&gt;</code> 保留。</p><p><code>重载 * 操作符函数</code> ： <code>*ptr</code> 变成了 <code>*(ptr.p)</code> ，<strong>返回值却为 <code>*p</code></strong> ，重载后<code>*</code> 不保留。（如果 <code>*</code> 保留的话，应该返回值为 <code>p</code>）</p><h3 id="12-综合实战：自定义-string-类">12.综合实战：自定义 <code>string</code> 类</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无参构造</span><br>    <span class="hljs-built_in">MyString</span>()&#123;<br>        len = <span class="hljs-number">0</span>;<br>        str = <span class="hljs-literal">nullptr</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无参构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)&#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;str, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-built_in">strlen</span>(str);<br>            <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-keyword">this</span>-&gt;len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;str, str);<br>            cout &lt;&lt; <span class="hljs-string">&quot;有参构造&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> MyString &amp;another)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;len = another.len;<br>        <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-keyword">this</span>-&gt;len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;str, another.str);<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 重载 =</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyString &amp;another)&#123;<br>        <span class="hljs-comment">// 防止自身赋值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;another) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-comment">// 回收原空间</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;str != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;str;<br>            <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 赋值</span><br>        <span class="hljs-keyword">this</span>-&gt;len = another.len;<br>        <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-keyword">this</span>-&gt;len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;str, another.str);<br>        cout &lt;&lt; <span class="hljs-string">&quot;重载 = _对象&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重载 =</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)&#123;<br>          <span class="hljs-comment">// 回收原空间</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;str != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;str;<br>            <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 赋值</span><br>        <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-built_in">strlen</span>(p);<br>        <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-keyword">this</span>-&gt;len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;str, p);<br>        cout &lt;&lt; <span class="hljs-string">&quot;重载 = _字符 &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyString</span>()&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;str != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;str;<br>            <span class="hljs-keyword">this</span>-&gt;str = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">this</span>-&gt;len = <span class="hljs-number">0</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 重载 []</span><br>    <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;str[index];<br>    &#125;<br>    <span class="hljs-comment">// 重载 +</span><br>    MyString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyString &amp;another)&#123;<br>        MyString tmp;<br>        tmp.len = <span class="hljs-keyword">this</span>-&gt;len + another.len;<br>        tmp.str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[tmp.len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(tmp.str, <span class="hljs-keyword">this</span>-&gt;str);<br>        <span class="hljs-built_in">strcat</span>(tmp.str, another.str);<br>        cout &lt;&lt; <span class="hljs-string">&quot;重载 + &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-comment">// 重载 ==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyString &amp;another)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;重载 == &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-keyword">this</span>-&gt;str, another.str)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 重载 !=</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> MyString &amp;another)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;重载 != &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-keyword">this</span>-&gt;str, another.str)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重载 &lt;&lt;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, MyString &amp;s);<br>    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MyString &amp;s);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span> *str;<br>&#125;;<br><br><span class="hljs-comment">//重载 &lt;&lt;</span><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> MyString &amp;s)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.len; i++) &#123;<br>        os &lt;&lt; s[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;重载 &lt;&lt; &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-comment">//重载 &gt;&gt;</span><br>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MyString &amp;s)&#123;<br>    <span class="hljs-comment">// 回收原空间</span><br>        <span class="hljs-keyword">if</span> (s.str != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] s.str;<br>            s.str = <span class="hljs-literal">nullptr</span>;<br>            s.len = <span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-comment">// 写入</span><br>    <span class="hljs-type">char</span> tmp[<span class="hljs-number">4096</span>] = &#123;<span class="hljs-number">0</span>&#125;; <br>    is &gt;&gt; tmp;<br>    s.len = <span class="hljs-built_in">strlen</span>(tmp);<br>    s.str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(s.str, tmp);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyString <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;    <span class="hljs-comment">// 有参构造</span><br>    MyString s2 = <span class="hljs-string">&quot;123a&quot;</span>;  <span class="hljs-comment">// 有参构造</span><br>    <br>    MyString s3;  <span class="hljs-comment">// 无参构造</span><br>    s3 = <span class="hljs-string">&quot;abc&quot;</span>;   <span class="hljs-comment">// 赋值操作符函数 - const char *p</span><br>   <br>    MyString s4 = s3;   <span class="hljs-comment">// 拷贝构造</span><br>   <br>    MyString s5;<br>    s5 = s4;    <span class="hljs-comment">// 赋值操作符函数 - const MyString &amp;another</span><br>   <br>    MyString s6;  <br>    cin &gt;&gt; s6;    <span class="hljs-comment">// 重载 &gt;&gt;</span><br>    cout &lt;&lt; s6;   <span class="hljs-comment">// 重载 &lt;&lt;</span><br>   <br>    <span class="hljs-type">char</span> *p = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-function">MyString <span class="hljs-title">s7</span><span class="hljs-params">(p)</span></span>;  <span class="hljs-comment">// 有参构造</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>几点注意</strong>：</p><h4 id="（1）临时对象与拷贝省略">（1）临时对象与拷贝省略</h4><p><code>MyString s2 = &quot;123a&quot;;</code> 实际上是 <code>MyString s2 = MyString(&quot;123a&quot;);</code> ，<code>MyString(&quot;123a&quot;)</code> 定义一个临时对象，再拷贝给 <code>s2</code> 。</p><p>但实际上不发生拷贝构造，临时对象直接转正为 <code>s2</code> ，原因是编译器优化了，造成了拷贝省略（copy-elision）。 见 <a href="https://www.aimtao.net/copy-elision/" rel="nofollow noopener" target="_blank">Copy Elision 中的返回值优化和右值拷贝优化</a>。</p><h4 id="（2）const-的修饰必不可少。">（2）<code>const</code> 的修饰必不可少。</h4><p>有参构造 <code>MyString(const char *str)</code> 、 拷贝构造 <code>MyString(const MyString &amp;another)</code> 等函数的形参为只读，一定要用 const 修饰。</p><p>因为，如果实参是 const 修饰的，就无法完成传参数，const 类型不可以给非 const 类型传参。</p><h4 id="（3）记得回收原空间。">（3）记得回收原空间。</h4><p>除 <code>构造函数</code> 和 <code>拷贝构造函数</code> 外，利用 <code>赋值操作符</code> 、<code>重载 &gt;&gt; 函数</code> 更改对象值的函数，要先回收对象原来申请的空间。</p><h4 id="（4）判断参数是否特殊。">（4）判断参数是否特殊。</h4><p>传入字符串，可能是空字符串 或者 nullptr。</p><p>传入对象，可能是自身。常见于 <code>赋值操作符</code> 。</p><h2 id="四、继承">四、继承</h2><h3 id="1-类和类的关系">1.类和类的关系</h3><p>追求：高内聚，低耦合。</p><h4 id="（1）has-A">（1）has A</h4><p>类B has 类A，类B 依赖于 类A。耦合度教大。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  A a;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）use-A">（2）use A</h4><p>类B use 类A，类B 依赖于 类A。耦合度较小。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A &amp;a)</span></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（3）is-A">（3）is A</h4><p>类B 继承于 类A。耦合度非常高。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A &#123;<br>  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-继承的基本概念">2.继承的基本概念</h3><h4 id="（1）格式-5">（1）格式</h4><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id, string name)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;id = id;<br>    <span class="hljs-keyword">this</span>-&gt;name = name;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> id;<br>  string name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentPlus</span> : <span class="hljs-keyword">public</span> Student &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">StudentPlus</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">double</span> score) : <span class="hljs-built_in">Student</span>(id, name)&#123;  <span class="hljs-comment">// 利用父类构造</span><br>    <span class="hljs-keyword">this</span>-&gt;score = score;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> score;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于父类的变量，也可以用子类构造，比如：<a name="父类构造函数"></a></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">StudentPlus（<span class="hljs-type">int</span> id, string name, <span class="hljs-type">double</span> score)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;id = id;<br>    <span class="hljs-keyword">this</span>-&gt;name = name;<br>    <span class="hljs-keyword">this</span>-&gt;score = score;<br>&#125;<br></code></pre></td></tr></table></figure><p>但，实际上，子类构造依然调用了父类的<strong>无参构造</strong>！并且要求<strong>父类的变量是 public 修饰。</strong></p><h4 id="（2）定义">（2）定义</h4><p>从已有类产生新类 的过程就是类的派生。原类：基类、父类；新类：派生类、子类。</p><p>派生与继承，是同一种意义两种称谓。 is A 的关系。</p><h4 id="（3）子类的组成">（3）子类的组成</h4><p>子类内部部分空间和父类空间一样。</p><img src="https://hutu.aimtao.net/mark/2020-05-31-eX5LVm.webp-s" srcset="/img/loading.gif" lazyload style="zoom:67%"><h4 id="（4）继承方式">（4）继承方式</h4><table><thead><tr><th></th><th>父类的 public</th><th>父类的 protected</th><th>父类的 private</th></tr></thead><tbody><tr><td>公有继承 public</td><td>在子类中为 public</td><td>在子类中为 protected</td><td>子类不可见</td></tr><tr><td>保护继承 protected</td><td>在子类中为 protected</td><td>在子类中为 protected</td><td>子类不可见</td></tr><tr><td>私有继承 private</td><td>在子类中为 private</td><td>在子类中为 private</td><td>子类不可见</td></tr></tbody></table><ul><li><p>任何继承方式，子类都不能直接使用父类的私有成员 。</p></li><li><p>公有继承 public，在子类中访问控制权限保持不变。</p></li><li><p>保护继承，子类继承的成员变量全变保护（除父类的 private）。</p></li><li><p>私有继承，子类继承的成员变量全变私有（除父类的 private）。</p></li><li><p>公有继承 public 常用。</p></li></ul><h4 id="（5）访问控制权限的判断">（5）访问控制权限的判断</h4><blockquote><p>判断 <strong>子类成员变量</strong> 的访问控制权限，分三步。</p></blockquote><ol><li>类的内部还是外部？</li><li>子类的继承方式是什么？</li><li>该子类成员变量在父类的访问控制权限是什么？</li></ol><h3 id="3-继承中的构造和析构">3.继承中的构造和析构</h3><h4 id="（1）赋值兼容原则">（1）赋值兼容原则</h4><blockquote><ul><li>子类对象给父类赋值或初始化（反之不可）</li><li>子类对象可以当父类对象使用</li><li>父类指针可以指向子类对象（反之不可）</li><li>父类引用可以引用子类对象（反之不可）</li></ul></blockquote><ul><li><strong>子类对象给父类赋值或初始化</strong>（反之不可）</li></ul><p>子类内存空间大，可以用内存大的给内存小的赋值，因为子类变量齐全。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> f_num;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> s_num;<br>&#125;<br><br>Sun s;<br>Father f1 = s;    <span class="hljs-comment">// 用子类对象给父类对象初始化</span><br>Father f2;<br>f2 = s;       <span class="hljs-comment">// 用子类对象给父类对象赋值</span><br></code></pre></td></tr></table></figure><ul><li><strong>子类对象可以当父类对象使用</strong></li><li><strong>父类指针可以指向子类对象</strong> （反之不可）</li></ul><blockquote><p>多态发生的必要条件</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> f_num;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; f_num &lt;&lt; endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> s_num;<br>&#125;<br><br>Father *f_p = <span class="hljs-literal">nullptr</span>;<br>Sun *s_p = <span class="hljs-literal">nullptr</span>;<br><br>Sun s;<br><br>f_p = &amp;s;   <span class="hljs-comment">// 父类指针指向子类对象</span><br>f_p-&gt;<span class="hljs-built_in">Print</span>();     <span class="hljs-comment">// 但是父类指针只能操作子类继承的成员变量和成员方法</span><br></code></pre></td></tr></table></figure><ul><li><strong>父类引用可以引用子类对象</strong>（反之不可）</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc">Sun s;<br>Father &amp;pp = s;<br></code></pre></td></tr></table></figure><h4 id="（2）继承中构造析构调用原则">（2）继承中构造析构调用原则</h4><blockquote><p>先构造父类，再构造成员变量、最后构造自己。</p><p>先析构自己，在析构成员变量、最后析构父类。</p></blockquote><ul><li>调用子类构造之前，调用父类无参构造或者，显示调用父类有参构造。<a href="#父类构造函数">见：样例</a></li><li>析构与调用构造函数的顺序相反。</li></ul><h4 id="（3）子类父类重名变量和重名函数">（3）子类父类重名变量和重名函数</h4><ul><li>访问父类重名变量，用类作用域符。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; Father::a &lt;&lt; endl;    <span class="hljs-comment">// 访问父类变量，用类作用域符</span><br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>重名函数的解决方法，见 <a href="#重载、重写、重定义">重载、重写、重定义</a></li></ul><h4 id="（4）继承中的-static">（4）继承中的 static</h4><ul><li>子类共享父类的静态成员变量。（整个家族共享一个静态成员变量）</li><li>静态成员变量遵守继承的控制权限</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_i;<br>&#125;;<br><br><span class="hljs-type">int</span> Father::static_i = <span class="hljs-number">10</span>;       <span class="hljs-comment">// 静态成语变量的初始化，在类的外部初始化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>  cout &lt;&lt; Father::static_i;      <span class="hljs-comment">// 子类访问静态成员变量的方式：类作用域符。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-多继承">4.多继承</h3><p>子类拥有同时继承多个父类，同时拥有多个父类的成员变量和成员函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soft</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-built_in">Soft</span>(<span class="hljs-type">int</span> price)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;price = price;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sit</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sit&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bed</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-built_in">Bed</span>(<span class="hljs-type">int</span> price)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;price = price;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sleep</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sleep&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftBed</span> : <span class="hljs-keyword">public</span> Soft, <span class="hljs-keyword">public</span> Bed &#123;    <span class="hljs-comment">// 多继承的格式</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-comment">// 多继承的构造函数的格式</span><br>    <span class="hljs-built_in">SoftBed</span>(<span class="hljs-type">int</span> soft_price, <span class="hljs-type">int</span> bed_price) : <span class="hljs-built_in">Soft</span>(soft_price), <span class="hljs-built_in">Bed</span>(bed_price)&#123;  <br>        <span class="hljs-keyword">this</span>-&gt;price = soft_price + bed_price;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SitAndSleep</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">Sit</span>();<br>        <span class="hljs-built_in">Sleep</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-虚继承">5.虚继承</h3><h4 id="（1）多继承中二义性问题">（1）多继承中二义性问题</h4><p>如果一个派生类从多个基类派生，而这些基类又有一个共同 的基类，则在对该基类中声明的名字进行访问时，可能产生二义性。</p><p>C类多继承于 B1类、B2类，B1类、B2类均继承于 A类，因此，C类将构造两次A类对象，所以拥有两个同样的A类对象成员变量，C类访问该变量将产生错误。</p><p><img src="https://hutu.aimtao.net/mark/2020-06-04-QrhazV.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Furniture</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string texture;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soft</span> : <span class="hljs-keyword">public</span> Furniture &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Soft is &quot;</span> &lt;&lt; texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bed</span> : <span class="hljs-keyword">public</span> Furniture &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bed is &quot;</span> &lt;&lt; texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftBed</span> : <span class="hljs-keyword">public</span> Soft, <span class="hljs-keyword">public</span> Bed &#123;    <span class="hljs-comment">// 多继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Furniture is &quot;</span> &lt;&lt; Furniture::texture &lt;&lt; endl;   <span class="hljs-comment">// Error，无法确定哪一个Furniture类的成员（有两个）</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Soft is &quot;</span> &lt;&lt; Soft::texture &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bed is &quot;</span> &lt;&lt; Bed::texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）virtual">（2）virtual</h4><blockquote><p>在 <strong>父类</strong> 继承 <strong>父类的父类</strong> 的继承方式之前，加上 virtual。</p></blockquote><p><strong>目的</strong>：防止子类多继承父类的时候，出现父类的父类中的变量拷贝多份。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Furniture</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string texture;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soft</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Furniture &#123;  <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Soft is &quot;</span> &lt;&lt; texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bed</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Furniture &#123;   <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bed is &quot;</span> &lt;&lt; texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftBed</span> : <span class="hljs-keyword">public</span> Soft, <span class="hljs-keyword">public</span> Bed &#123;    <span class="hljs-comment">// 多继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Texture</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Furniture is &quot;</span> &lt;&lt; Furniture::texture &lt;&lt; endl;   <span class="hljs-comment">// 正确！不会出现二义性</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Soft is &quot;</span> &lt;&lt; Soft::texture &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bed is &quot;</span> &lt;&lt; Bed::texture &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="五、多态">五、多态</h2><h3 id="1-多态的意义">1.多态的意义</h3><p><strong>多态现象</strong>：几个似而不同的几个对象，收到同一个信号时，执行不同的操作。</p><p><strong>多态的优点</strong>： 增加系统灵活性，减轻系统升级维护调试的工作量和复杂度。（未来依旧可以使用以前的架构。）</p><h3 id="2-多态的三个必要条件">2.多态的三个必要条件</h3><ol><li><p>有继承</p></li><li><p>有虚函数重写</p></li><li><p><strong>父类指针或引用 指向子类对象</strong></p><p>子类指针指向子类对象时，无论子类的重定义还是虚函数重写，都会调用子类的函数。</p><p>父类指针指向子类对象时，默认调用父类函数。</p></li></ol><h3 id="3-虚函数">3.虚函数</h3><blockquote><p>virtual 关键字声明，分文件写类时，类外定义函数时，不用加 virtual 关键字，声明的时候需要加。</p></blockquote><p>父类指针指向子类对象时，为了父类指针能够调用子类重写父类的函数，将父类的该函数标记为虚函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Father</span>(<span class="hljs-type">int</span> id)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;               <span class="hljs-comment">// virtual 定义虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Father &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;id &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;    <span class="hljs-comment">//（第1点：有继承）</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-built_in">Sun</span>(<span class="hljs-type">int</span> id_sun, <span class="hljs-type">int</span> id_father) : <span class="hljs-built_in">Father</span>(id_father)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;id = id_sun;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-comment">// virtual 表示重写了父类的虚函数 //（第2点：有虚函数重写）</span><br>    <span class="hljs-comment">// 此处的 virtual 可以不写，但是为了表示，此函数是重写父类的虚函数，所以加上 virtual</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;Sun &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;id &lt;&lt; endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Funcation</span><span class="hljs-params">(Father *p)</span></span>&#123;    <span class="hljs-comment">// 多态：用父类指针指向子类对象  //（第3点：父类指针或引用 指向子类对象）</span><br>    p-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Sun <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-built_in">Funcation</span>(&amp;s);   <span class="hljs-comment">// 传递子类对象指针。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-静态联编和动态联编">4.静态联编和动态联编</h3><ul><li>联编是程序模块和代码之间相互关联的过程。</li><li><strong>静态联编（static binding）****：在编译阶段</strong> 实现程序的关联和连接。<strong>重载函数就是静态联编。</strong></li><li><strong>动态联编</strong>：在运行时，才进行程序的关联和连接。<strong>switch 语句和 if 语句</strong> 就是动态联编。</li></ul><p>补充：</p><ul><li>C++与C相同，是静态编译型语言。</li><li>编译时，编译器根据指针类型，判断指向什么样的对象。（所以父类指针默认指向父类对象）</li><li>在程序运行前，不知道父类指针是指向父类对象还是子类对象，为保证安全，编译器假设父类指针指向父类对象。这是静态联联编。</li><li>多态发生就是动态联编。在运行的时候，才知道指针指向的是子类对象还是父类对象。</li></ul><h3 id="5-虚析构函数">5.虚析构函数</h3><p><strong>问题</strong>： <code>delete</code> 只会调用父类的析构函数，不会调用子类的析构函数，造成内存泄漏。</p><p>因为 p 的类型是 Father，所以 delete p时，只能调用父类的析构函数 ~Father()。但实际上应该先析构 Sun， 再析构 Father。所以造成了子类未调用析构函数，造成了内存泄漏。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        char_p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">strcpy</span>(char_p, <span class="hljs-string">&quot;father&quot;</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; char_p &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>()&#123;<br>        <span class="hljs-keyword">if</span> (char_p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> char_p;<br>            char_p = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Father()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *char_p;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sun</span>() : <span class="hljs-built_in">Father</span>()&#123;<br>        char_p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">strcpy</span>(char_p, <span class="hljs-string">&quot;sun&quot;</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;         <span class="hljs-comment">// 重写父类的虚函数 Print</span><br>        cout &lt;&lt; char_p &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Sun</span>()&#123;<br>        <span class="hljs-keyword">if</span> (char_p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> char_p;<br>            char_p = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Sun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *char_p;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(Father *p)</span></span>&#123;    <span class="hljs-comment">// 多态条件之一：父类指针 指向子类对象。</span><br>    p-&gt;<span class="hljs-built_in">Print</span>();         <span class="hljs-comment">// 此处发生多态，Sun中重写了虚函数 Print</span><br>    <span class="hljs-keyword">delete</span> p;<br>      <span class="hljs-comment">// 因为 p 的类型是 Father，所以 delete p，只能调用 ~Father()。</span><br>    <span class="hljs-comment">// 应该先析构 Sun， 再析构 Father。</span><br>    <span class="hljs-comment">// 所以造成了内存泄漏</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sun *sun_p = <span class="hljs-keyword">new</span> Sun;<br>    <span class="hljs-built_in">Fun</span>(sun_p);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案</strong>： 使用虚析构函数。</p><p>在父类的析构函数前面加上 <code>virtual</code> 。</p><p>当父类指针指向子类对象时，并且该指针将要被 <code>delete</code> 时，先调用子类的析构，再调用父类的析构（因为执行子类的析构之后，默认会执行父类的析构）。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        char_p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">strcpy</span>(char_p, <span class="hljs-string">&quot;father&quot;</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; char_p &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Father</span>()&#123;                  <span class="hljs-comment">// 虚析构函数</span><br>        <span class="hljs-keyword">if</span> (char_p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> char_p;<br>            char_p = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Father()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *char_p;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sun</span>() : <span class="hljs-built_in">Father</span>()&#123;<br>        char_p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">strcpy</span>(char_p, <span class="hljs-string">&quot;sun&quot;</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; char_p &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Sun</span>()&#123;                     <span class="hljs-comment">// virtual 写不写都行，表示父类的析构函数为虚析构函数。</span><br>        <span class="hljs-keyword">if</span> (char_p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span> char_p;<br>            char_p = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Sun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *char_p;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(Father *p)</span></span>&#123;<br>    p-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">delete</span> p;            <span class="hljs-comment">// 先调用 子类的析构，再调用 父类的析构，最后 delete p所指向的内存。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sun *sun_p = <span class="hljs-keyword">new</span> Sun;<br>    <span class="hljs-built_in">Fun</span>(sun_p);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-重载、重写、重定义">6.重载、重写、重定义</h3><p><a name="重载、重写、重定义"></a></p><h4 id="（1）重载">（1）重载</h4><ul><li><p>重载一定是同一个作用域下。</p></li><li><p>函数名相同，参数列表不一样。</p></li></ul><h4 id="（2）重定义">（2）重定义</h4><ul><li>发生在不同的类中。</li></ul><p>有两种：</p><ol><li><strong>普通函数重定义</strong>（屏蔽基类函数）<ul><li>函数同名，参数列表相同，且父类该函数无 virtual ，父类该函数被隐藏。</li><li>函数同名，参数列表不同，无论父类该函数有无 virtual，父类该函数被隐藏。</li></ul></li><li><strong>虚函数重写</strong><ul><li>函数同名，参数列表相同，且父类该函数有 virtual</li><li>子类 <strong>覆盖重写了</strong> 父类的 虚函数。</li><li>此时发生多态。</li></ul></li></ol><p><strong>代码演示：重定义</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;             <span class="hljs-comment">// 函数同名，参数列表相同，且基类函数无 virtual ，父类该函数被隐藏。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun &quot;</span> &lt;&lt; endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sun s;<br>    s.<span class="hljs-built_in">Print</span>();   <span class="hljs-comment">// 打印结果：Sun </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-多态的原理">7.多态的原理</h3><h4 id="（1）虚函数表和-vptr-指针">（1）虚函数表和 vptr 指针</h4><ul><li>当类中声明虚函数时，编译器自动在类中生成一个虚函数表，虚函数表中存放虚函数的指针（函数的入口地址）。</li><li>存在虚函数表时，每个对象都有一个 vptr 指针，指向虚函数表。</li><li>虚函数表在常量区中。</li></ul><p><img src="https://hutu.aimtao.net/mark/2020-06-07-qqqqqq.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>当用父类指针指向子类对象，并调用 Fun(int, int) 函数时，可能会发生的情况</strong>：</p><ol><li><p><strong>父类中无 Fun(int, int) 函数</strong>：</p><p>报错！父类指针只能调用子类从父类继承的函数。</p></li><li><p><strong>父类中 Fun(int, int) 函数声明为虚函数【动态联编】</strong>：</p><ul><li>通过 VPTR 指针，在子类的虚函数表中查找 Fun(int, int) 函数。</li><li>若找到 Fun(int, int) 函数，执行虚函数表中的 Fun(int, int) 函数！</li><li>若没找到 Fun(int, int) 函数，执行父类中的 Fun(int, int) 函数。</li></ul></li><li><p><strong>父类中 Fun(int, int) 函数为普通函数【静态联编】</strong>：</p><p>直接执行父类中的 Fun(int, int) 函数。（不会查询虚函数表）</p></li></ol><h4 id="（2）验证-VPTR-指针的存在">（2）验证 VPTR 指针的存在</h4><ul><li><p>【<strong>存疑</strong>】当加入 虚函数 时，由 原来的 4 字节 变成了 16 字节。</p><p>按理说，应该增加 8 个字节，VPTR 指针的内存算入在类的内存中，函数 和 虚函数表的内存不算入类的内存。</p></li><li><p>【<strong>原因</strong>】由于字节对齐的原因。</p><ul><li>类中没有变量时，内存大小为 1 字节。</li><li>字节对齐以类型最长的变量为准。例如下方代码中，以 8 字节的指针为准对齐。变成了 2 * 8 = 16。</li></ul></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father:Fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun:Fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Father: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Father) &lt;&lt; endl;   <span class="hljs-comment">// Father: 16</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sun: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Sun) &lt;&lt; endl;         <span class="hljs-comment">// Sun: 4</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）VPTR-指针的分步初始化">（3）VPTR 指针的分步初始化</h4><ol><li><p>创建对象时，编译器对 VPTR 指针进行初始化。</p></li><li><p>当对象调用父类的构造函数时，VPTR 指针指向父类对象的虚函数表。</p></li><li><p>当执行完父类构造函数后，再执行子类的构造函数时，VPTR 指针指向 子类对象的虚函数表。</p></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>(<span class="hljs-type">int</span> a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        <span class="hljs-built_in">Fun</span>();       <span class="hljs-comment">// 父类的构造函数中，VPTR指针，指向父类的虚函数表。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father: virtual&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sun</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">Father</span>(a)&#123;<br>        <span class="hljs-built_in">Fun</span>();         <span class="hljs-comment">// 一旦父类构造函数构造完，VPTR指针指向子类的虚函数表</span><br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun: virtual&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（4）父类指针和子类指针步长">（4）父类指针和子类指针步长</h4><ul><li>父类指针的步长为父类的大小。</li><li>子类指针的步长为子类的大小。</li><li>指针不发生多态。</li></ul><p><strong>PS</strong>：如果用父类指针操作子类对象，并且自增，<strong>没发生错误，可能原因是</strong>：</p><ul><li>子类没有新的变量，所以子类父类大小相同。</li><li>由于字节对齐的原因：子类中有两个 int 变量，父类中只一个 int 变量，但两个类的内存大小相同。（比如下面代码中的两个类。）</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>(<span class="hljs-type">int</span> a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Father: virtual&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Father &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sun</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">Father</span>(a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun: virtual&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sun s[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">Sun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">Sun</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-built_in">Sun</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)&#125;;<br>    Father *p = &amp;s[<span class="hljs-number">0</span>];<br>    p++;                   <span class="hljs-comment">// 虽然父类指针指向子类对象，但是指针步长依然是父类的大小。【不能++】</span><br>    p-&gt;<span class="hljs-built_in">Fun</span>();              <span class="hljs-comment">// 发生段错误：segmentation fault</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）多态的总结">（5）多态的总结</h4><ul><li><p><strong>多态的实现效果</strong></p><p>同样的调用语句，有不同的表现形式。</p></li><li><p><strong>多态实现的三个条件</strong></p><p>继承，虚函数重写，父类指针指向子类对象。</p></li><li><p><strong>多态的 C++ 实现</strong></p><p>虚函数表和 VPRT 指针。</p><p>virtual 关键字告诉编译器，该函数支持多态。</p><p>不是根据指针类型来判断如何调用，而是根据指针所指的实际对象类型来判断如何调用。</p></li><li><p><strong>多态的理论依据</strong></p><p>动态联编，根据实际的对象类型来判断重写函数的调用。</p></li><li><p><strong>多态的重要意义</strong></p><p>设计模式的基础，框架的基石。</p></li></ul><h3 id="8-纯虚函数和抽象类">8.纯虚函数和抽象类</h3><p><strong>纯虚函数</strong>：</p><ul><li>基类中声明的虚函数，且没有定义，等待派生类重写此虚函数。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 拥有虚函数的抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstract</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;   <span class="hljs-comment">// 纯虚函数的声明。</span><br>&#125;;<br><br><span class="hljs-comment">// 继承抽象类且重写虚函数的子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sun</span> : <span class="hljs-keyword">public</span> Abstract&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;重写虚函数&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>抽象类</strong>：</p><ul><li>无论有没有变量，只要有纯虚函数的类就是抽象类。</li><li>一个类继承抽象类，如果没有重写纯虚函数，这个类还是抽象类。</li><li>抽象类不能实例化对象。</li></ul><h3 id="9-纯虚函数和多继承">9.纯虚函数和多继承</h3><p>继承多个接口（抽象类）。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Interface01</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun01</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Interface02</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun02</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Interface01, <span class="hljs-keyword">public</span> Interface02 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun01</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Interface01&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun02</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Interface02&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="六、常见错误">六、常见错误</h2><h3 id="1-pointer-being-freed-was-not-allocated">1. pointer being freed was not allocated</h3><p>错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">malloc: *** error <span class="hljs-keyword">for</span> object 0x7fd055c05820: pointer being freed was not allocated<br>malloc: *** <span class="hljs-built_in">set</span> a breakpoint <span class="hljs-keyword">in</span> malloc_error_break to debug<br></code></pre></td></tr></table></figure><p>指针指向堆区内存，该指针被释放了两次。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">char</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(‘a’)；<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C-C/">#C/C++</a></div></div><div class="license-box my-3"><div class="license-title"><div>学习笔记｜C++</div><div>https://www.aimtao.net/c-plus-plus/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2020-02-22</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/c/" title="查漏补缺｜C 语言"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">查漏补缺｜C 语言</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/computer-network/" title="学习笔记｜计算机网络"><span class="hidden-mobile">学习笔记｜计算机网络</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>