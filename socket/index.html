<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="本文主要描述 Linux 网络编程相关知识，由浅入深地搭建多路转接服务器来完成 socket 通信。"><title>学习笔记｜Socket 与并发服务器 - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2021-03-04-socket.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="学习笔记｜Socket 与并发服务器"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-04 10:46" pubdate>2021-03-04 AM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 32k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 24 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">学习笔记｜Socket 与并发服务器</h1><div class="markdown-body"><h2 id="1-网络应用程序设计模式">1.网络应用程序设计模式</h2><h3 id="1-1-C-S-模式">1.1 C/S 模式</h3><p>传统的网络应用设计模式，客户机（client）/ 服务器（server）模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><p><strong>优点</strong>：</p><ul><li>协议选用更加灵活，可以自定义。</li><li>可以提前缓存大量数据，提高数据传输的效率。</li></ul><p><strong>缺点</strong>：</p><ul><li>对用户主机构成威胁。</li><li>开发团队工作量大，客户端服务端联合调试困难。</li></ul><h3 id="1-2-B-S-模式">1.2 B/S 模式</h3><p>浏览器（browser）/ 服务器（server）模式。只需在一端部署服务器，而另外一端使用每台 PC 都默认配置的浏览器即可完成数据的传输。</p><p><strong>优点</strong>：</p><ul><li>不会安装软件，相对来说更安全。</li><li>不需要开发客户端，工作量相对较小。</li><li>跨平台。</li></ul><p><strong>缺点</strong>：</p><ul><li>协议选择不灵活，必须完整的支持协议。</li><li>不能数据缓存。</li></ul><h2 id="2-socket-概念">2.socket 概念</h2><blockquote><p>socket 不是网络协议，只是传输层协议 TCP/UDP 的实现。</p></blockquote><h3 id="2-1-socket-是伪文件">2.1 socket 是伪文件</h3><p>在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。（类比有名管道）</p><ul><li><p><strong>为什么要将套接字封装成伪文件？</strong></p><p>为了统一接口，使读写文件和读写套接字操作一致。</p></li><li><p><strong>套接字和管道的区别</strong></p><p>管道应用于 <strong>本地进程间</strong> 通信；套接字应用于 <strong>网络进程间</strong> 通信。</p></li></ul><p><strong>socket 在数据传输中的位置</strong>：</p><p><img src="https://hutu.aimtao.net/mark/2021-03-09-LA6yPg.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="2-2-socket-通信原理">2.2 socket 通信原理</h3><ul><li>IP：在网络环境中唯一标识一台主机。</li><li>port：在主机中唯一标识一个进程。</li><li>IP + port：在网络环境中唯一标识一个进程。</li></ul><p>所以 IP + port 就对应着一个 socket，想要连接的两个进程通过各自的 socket 来标识，这两个 socket 组成的 socket pair 就唯一标识一个连接。</p><h3 id="2-3-socket-的内核实现">2.3 socket 的内核实现</h3><ul><li><p>文件描述符对应着两个内核缓冲区，一个缓冲区接收数据，一个缓冲区发送数据。</p></li><li><p>为什么使用两个缓冲区？</p><p>参考管道，只能一个进程读，一个进程写，否则写的数据和读的数据互相覆盖。【<strong>半双工</strong>】</p><p>socket：既能读又能写。【<strong>全双工</strong>】</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-09-E3ODkk.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="3-预备知识">3.预备知识</h2><h3 id="3-1-网络字节序">3.1 网络字节序</h3><p>数据包在传输的过程中，需要拆包封包，读取 IP + port，本地字节序是小端方式，而网络字节需是大端方式。</p><p><strong>重要</strong>：因为 TCP/IP 协议规定，<mark>网络数据流应采用大端字节序</mark>；而 x86 机器都是小端字节序。</p><p>所以需要使用字节序转换函数。</p><p>h 表示 host，n 表示 network，l 表示 long 32 位长整型，s 表示 short 16位端整型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">unit32_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">unit32_t</span> hostlong)</span></span>;    <span class="hljs-comment">// IP   本地字节序 -&gt; 网络字节序</span><br><span class="hljs-function"><span class="hljs-type">unit16_t</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-type">unit16_t</span> hostshort)</span></span>;   <span class="hljs-comment">// port  本地字节序 -&gt; 网络字节序</span><br><span class="hljs-function"><span class="hljs-type">unit32_t</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-type">unit32_t</span> netlong)</span></span>;     <span class="hljs-comment">// IP    网络字节序 -&gt; 本地字节序</span><br><span class="hljs-function"><span class="hljs-type">unit16_t</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-type">unit16_t</span> netshort)</span></span>;    <span class="hljs-comment">// port  本地字节序 -&gt; 网络字节序</span><br></code></pre></td></tr></table></figure><p>PS：如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，<strong>将参数原封不动地返回</strong>。</p><h3 id="3-2-IP-地址转换">3.2 IP 地址转换</h3><p>常见的点分十进制 IP 地址是字符串类型，我们需要将 string 类型，先手动转化为 unsigned int 类型，才能使用 htonl 等函数。于是有了更便捷的函数，直接传入点分十进制 IP 地址的字符串作为参数。</p><blockquote><p>htonl：192.168.1.2 ==》 unsigned int ==》 网络字节序</p><p>inet_pton：192.168.1.2 ==》 网络字节序</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span></span>;   <span class="hljs-comment">// 本地字节序 ==》网络字节序</span><br></code></pre></td></tr></table></figure><ul><li><p>int af：用来表示 ipv4 还是 ipv6。</p><ul><li>ipv4：af = AF_INET</li><li>ipv6：af = AF_INT6</li></ul></li><li><p>char *src：本地字节序。点分十进制的 IP 地址。</p></li><li><p>void *dst：网络字节序，传出参数。比如 server_addr.sin_addr</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span></span>;  <span class="hljs-comment">// 网络字节序 ==》本地字节序</span><br></code></pre></td></tr></table></figure><ul><li><p>int af：同上。</p></li><li><p>void *dst：网络字节序。比如 client_addr.sin_addr</p></li><li><p>char *src：本地字节序。传出参数。</p></li><li><p>socklen_t size：src 字符串的大小。</p></li></ul><h3 id="3-3-sockaddr-数据结构">3.3 sockaddr 数据结构</h3><p><strong>关于 struct sockaddr</strong>：</p><ul><li><p>struct sockaddr 结构体诞生早于IPv4协议。</p></li><li><p>struct sockaddr 现在已经废弃，定义结构体时，应使用 sockaddr_in 或 sockaddr_in6。（分别表示 IPV4 和 IPV6）</p></li><li><p>【重要】但是 bind、accept、connect 等函数的参数，规定的还是 <code>struct sockaddr *</code>。</p><p>所以需要强制转换，例如：<code>bind( xxx, (struct sockaddr *) &amp;addr );</code></p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-10-mRyJ3M.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>关于 sockaddr_in</strong>：</p><p>在 <code>netinet/in.h</code> 文件中。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> &#123;<br>    <span class="hljs-type">__kernel_sa_family_t</span> sin_family;             <span class="hljs-comment">// Address family  地址结构类型（简称af）</span><br>    __be16 sin_port;                             <span class="hljs-comment">// Port number  端口号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> sin_addr;                     <span class="hljs-comment">// Internet address  IP地址</span><br><br>    <span class="hljs-comment">/* Pad to size of &#x27;struct sockaddr&#x27;. */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __pad[__SOCK_SIZE__ - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span> <span class="hljs-type">int</span>) -<br>    <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>) - <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> in_addr)];<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> &#123;    <span class="hljs-comment">/* Internet address. */</span><br>  __be32 s_addr;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>sin_family：填 AF_INET，表示 ipv4。</p></li><li><p>port：端口号</p></li><li><p>sin_addr：IP 地址</p><p>可以设置成 <code>htol(INADDR_ANY)</code>，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，</p></li><li><p>其他参数：填充空间的字符，pad：填充</p></li></ul><h2 id="4-网络套接字函数">4.网络套接字函数</h2><h3 id="4-1-socket-函数">4.1 socket 函数</h3><p>创建一个 socket，返回 socket 文件描述符。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>domain：</p><ul><li>AF_INET：IPV4 地址</li><li>AF_INET6：IPV6 地址</li><li>AF_UNIX：本地协议</li></ul></li><li><p>type：通信协议</p><ul><li><p>SOCK_STREAM：这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。典型代表协议 – TCP</p></li><li><p>SOCK_DGRAM：这个协议是无连接的、固定长度的传输调用。典型代表协议 – UDP</p></li><li><p><font color="#9a9a9a">不常用协议：</font></p><p><font color="#9A9A9A">SOCK_SEQPACKET：该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</font></p><p><font color="#9A9A9A">SOCK_RAW socket：类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</font></p><p><font color="#9A9A9A">SOCK_RDM：这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序。</font></p></li></ul></li><li><p>protocol：表示协议号。</p><ul><li>protocol = 0，表示 默认协议。</li><li>SOCK_STREAM 的默认协议是 TCP，SOCK_DGRAM 的默认协议是 UDP。</li></ul></li><li><p>返回值：成功，返回新创建的 socket 的文件描述符；失败，返回 -1，设置 errno。（errno 可以使用 perror 打印）</p></li></ul><h3 id="4-2-bind-函数">4.2 bind 函数</h3><p>绑定 IP + port 和 socket 文件描述符。使 sockfd 文件描述符监听 addr 所描述的地址和端口号。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span>   <span class="hljs-comment">// struct sockaddr_in 所在头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sockfd：</p></li><li><p>addr：sockaddr 结构体，存的是 IP + port。</p></li><li><p>addrlen：长度，sizeof(addr)，addr 可以有多种协议格式，所以需要指定结构体长度。</p></li></ul><h3 id="4-3-listen-函数">4.3 listen 函数</h3><p>用来声明sockfd处于监听状态，并指定 <strong>同时链接</strong> 的个数上限。【不是指定链接上限数】</p><p>例如：最多只能有 400 个客户端和我同时建立链接。也就是说，处于三次握手过程中的链接数最多是 400 个。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sockfd：socket 文件描述符。</p></li><li><p>backlog：处于三次握手过程中的链接数最。</p></li><li><p>返回值：成功返回 0，失败返回 -1。</p></li></ul><p><strong>查看系统默认 backlog</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/tcp_max_syn_backlog<br></code></pre></td></tr></table></figure><h3 id="4-4-accept-函数">4.4 accept 函数</h3><p>三方握手完成后，<strong>服务器</strong> 调用 accept() 接受连接。</p><p>如果服务器调用 accept() 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sockfd：socket 文件描述符。</p></li><li><p>addr：传出参数（value-result argumen），返回链接客户端的地址信息（IP + port）</p></li><li><p>addrlen：传入传出参数。【注意是指针 socklen_t*，bind 和 connect 函数的参数不是指针 socklen_t】</p><ul><li>传入：addr 还没发生改变时，传入 sizeof(addr)，表示传出参数容器的大小。</li><li>传出：函数执行后，addr 里面有了真正的数据，传出 sizeof(addr)，表示真正接收到的 addr 的大小。</li></ul></li><li><p>返回值：成功，返回一个<strong>新</strong>的 socket 文件描述符，用于和客户端通信。失败返回 -1，设置 errno。</p></li></ul><h3 id="4-5-connect-函数">4.5 connect 函数</h3><p><strong>客户端</strong> 调用 connect() 连接服务器。</p><p>connect 和 bind 的参数形式一致，区别在于 bind 的参数是自己的地址，而 connect 的参数是对方的地址。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sockfd：socke 文件描述符。</p></li><li><p>addr：传入参数，指定服务器端的信息，IP + port。</p></li><li><p>addrlen：传入参数，sizeof(addr)。</p></li><li><p>返回值：成功返回 0，失败返回 -1，设置 neero。</p></li></ul><h2 id="5-socket-实例">5.socket 实例</h2><h3 id="5-1-CS模型的流程">5.1 CS模型的流程</h3><p>客户端发送小写字母；服务端收到后，转换为大写字母，并回传给客户端。</p><p><img src="https://hutu.aimtao.net/mark/2021-03-18-1SuSNL.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="5-2-代码实现">5.2 代码实现</h3><p><strong><a target="_blank" rel="noopener" href="http://server.cc">server.cc</a></strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 6666</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;1.create...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <br>    sockaddr_in server_addr;    <br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;2.bind...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-built_in">bind</span>(lfd, (sockaddr *)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">32</span>);  <span class="hljs-comment">// 默认 128</span><br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;3.accept...&quot; &lt;&lt; std::endl;</span><br>    sockaddr_in client_addr;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>    <span class="hljs-built_in">bzero</span>(&amp;client_addr, len);<br><br>    <span class="hljs-type">int</span>  cfd = <span class="hljs-built_in">accept</span>(lfd, (sockaddr *)&amp;client_addr, &amp;len);<br>    <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;fail&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;4.put info...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-type">char</span> client_buf[BUFSIZ];<br>    <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, client_buf, <span class="hljs-built_in">sizeof</span>(client_buf));<br>    <span class="hljs-type">int</span> client_port = <span class="hljs-built_in">ntohs</span>(client_addr.sin_port);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client IP: &quot;</span> &lt;&lt; client_buf &lt;&lt; <span class="hljs-string">&quot;Client port: &quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;5.change...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[BUFSIZ];<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(cfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);     <span class="hljs-comment">// 转化为大写</span><br>        &#125;<br>        <span class="hljs-built_in">write</span>(cfd, buf, n);<br>    &#125;<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;6.end...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="client代码"></a></p><p><strong><a target="_blank" rel="noopener" href="http://client.cc">client.cc</a></strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_IP <span class="hljs-string">&quot;127.0.0.1&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 6666</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;1.create...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    sockaddr_in server_addr;<br>    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(server_addr));<br><br>    server_addr.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;server_addr.sin_addr);<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;2.connect...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">connect</span>(cfd, (sockaddr*)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;fail&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;3.change...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[BUFSIZ];<br>        <span class="hljs-built_in">fgets</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), stdin);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;buf = &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;<br>        <br>        <span class="hljs-built_in">write</span>(cfd, buf, <span class="hljs-built_in">strlen</span>(buf));<br><br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(cfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Response from server: &quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, n);<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;4.end...&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-遇到的问题">5.3 遇到的问题</h3><ul><li><p>inet_pton 函数传出参数不是 <code>&amp;server_addr.sin_addr.s_addr</code>，而是 <code>&amp;server_addr.sin_addr</code>。</p></li><li><p>server 的 IP 一定不能错。</p></li><li><p>如果不使用 toupper 函数，自己实现的话，注意输入非法字符容易报错（中文、数字、大写字母）</p></li><li><p>【<strong>重要问题</strong>】先关闭 server 后，四次挥手，server 进入 TIME_WAIT 状态，此时端口被占用，无法再次 connect。</p><p>检查端口 6666 是否占用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -apn | grep 6666<br></code></pre></td></tr></table></figure></li><li><p>connect error: No route to host. 链接失败，没有主机路由。需要关闭服务器防火墙测试。</p></li></ul><h3 id="5-4-错误处理函数">5.4 错误处理函数</h3><ul><li><p><strong>什么是错误处理函数？</strong></p><p>就是对 socket、bind、accept、connec 等函数进行二次封装，将返回值判断封装其中。</p></li><li><p><strong>为什么要写错误处理函数？</strong></p><p>对于 socket、bind、accept、connect 都应该判断返回值。但是为了保证主程序的逻辑清晰，将判断返回值的步骤放在错误处理函数中。</p></li><li><p><strong>为什么封装后的函数名要大写？</strong></p><p>socket 封装成 Socket，这样在 vim 中按 <code>shift + k</code> 依然可以打开 man 文档，因为打开 man 文档不区分函数名大小写。</p></li></ul><p><strong>wrap.hpp</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __WRAP_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __WRAP_H_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Accept</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> *salenptr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">my_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *ptr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readline</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> maxlen)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong><a target="_blank" rel="noopener" href="http://wrap.cc">wrap.cc</a></strong></p><p>【注意】<code>if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;</code> ，一定要将 <code>n = accept</code> 用括号括起来，因为 &lt; 的优先级高。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> </span>&#123;<br>    <span class="hljs-built_in">perror</span>(s);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Accept</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, sockaddr *sa, <span class="hljs-type">socklen_t</span> *salenptr)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 调用成功，需要返回一个新的文件描述符，用于与客户端通信。</span><br>    <span class="hljs-type">int</span> n;<br><br>again:<br>    <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">accept</span>(fd, sa, salenptr)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <br>        <span class="hljs-comment">// ECONNABORTED：异常断开</span><br>        <span class="hljs-comment">// EINTR：慢系统调用被信号中断</span><br>        <span class="hljs-keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR)) &#123;<br>            <span class="hljs-keyword">goto</span> again;    <span class="hljs-comment">// 要么重启，要么执行信号的默认动作。这里选择重启。</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;accept error&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(fd, sa, salen) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;bind error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(fd, sa, salen) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;connect error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> backlog)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(fd, backlog) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;listen error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 因为 socket 需要返回文件描述符，所以封装的 Socket 函数需要有返回值。</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">socket</span>(family, type, protocol)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;socket error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span> </span>&#123;<br>    <span class="hljs-type">ssize_t</span> n;<br><br>again:<br>    <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">read</span>(fd, ptr, nbytes)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (errno == EINTR) &#123;<br>            <span class="hljs-keyword">goto</span> again;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span> </span>&#123;<br>    <span class="hljs-type">ssize_t</span> n;<br><br>again:<br>    <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">write</span>(fd, ptr, nbytes)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (errno == EINTR) &#123;<br>            <span class="hljs-keyword">goto</span> again;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">close</span>(fd) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;close error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <span class="hljs-type">size_t</span>  nleft;    <span class="hljs-comment">// 剩余未读取的字节数</span><br>    <span class="hljs-type">ssize_t</span> nread;    <span class="hljs-comment">// 实际读到的值</span><br>    <span class="hljs-type">char</span>   *ptr;<br><br>    ptr = (<span class="hljs-type">char</span> *)vptr;     <span class="hljs-comment">// 读写指针的位置</span><br>    nleft = n;<br><br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ( (nread = <span class="hljs-built_in">read</span>(fd, ptr, nleft)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR)<br>                nread = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 读完了</span><br>            <span class="hljs-keyword">break</span>;<br><br>        nleft -= nread;<br>        ptr += nread;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n - nleft;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <br>    <span class="hljs-type">size_t</span> nleft;<br>    <span class="hljs-type">ssize_t</span> nwritten;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr;<br><br>    ptr = (<span class="hljs-type">char</span> *)vptr;<br>    nleft = n;<br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ( (nwritten = <span class="hljs-built_in">write</span>(fd, ptr, nleft)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nwritten &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR)<br>                nwritten = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        nleft -= nwritten;<br>        ptr += nwritten;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">// Readline 的辅助函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">my_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *ptr)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> read_cnt;     <span class="hljs-comment">// 读到的数量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> *read_ptr;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> read_buf[<span class="hljs-number">100</span>];   <span class="hljs-comment">// 读到的字符串</span><br><br>    <span class="hljs-keyword">if</span> (read_cnt &lt;= <span class="hljs-number">0</span>) &#123;<br>again:<br>        <span class="hljs-keyword">if</span> ( (read_cnt = <span class="hljs-built_in">read</span>(fd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf))) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR)<br>                <span class="hljs-keyword">goto</span> again;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (read_cnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        read_ptr = read_buf;<br>    &#125;<br>    read_cnt--;<br>    *ptr = *read_ptr++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 每次读一行，替代 fgets</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readline</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">ssize_t</span> n, rc;<br>    <span class="hljs-type">char</span>    c, *ptr;<br><br>    ptr = (<span class="hljs-type">char</span> *)vptr;<br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">1</span>; n &lt; maxlen; n++) &#123;<br>        <span class="hljs-keyword">if</span> ( (rc = <span class="hljs-built_in">my_read</span>(fd, &amp;c)) == <span class="hljs-number">1</span>) &#123;<br>            *ptr++ = c;<br>            <span class="hljs-keyword">if</span> (c  == <span class="hljs-string">&#x27;\n&#x27;</span>)   <span class="hljs-comment">// 读到 \n 表示读了一行</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>            *ptr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *ptr  = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-多进程并发服务器">6.多进程并发服务器</h2><h3 id="6-1-思路">6.1 思路</h3><p>每一个客户端，都由一个子进程负责通信。</p><p><strong>Server–父进程</strong>：</p><ol><li><p>监听连接部分：</p><ul><li>创建 socket，将监听端口绑定到 lfd。</li><li>等待 Client 连接，并返回用于通信的 cfd。</li></ul></li><li><p>管理子进程部分：</p><ul><li>一旦有新 Client 连接，则创建子进程，让子进程负责通信。</li><li>捕捉信号（子进程死亡 SIGCHLD），回收子进程。</li></ul></li></ol><p><strong>Server–子进程</strong>：</p><ul><li>与客户端通信。</li></ul><p><strong>Client</strong>：</p><ul><li>创建 socket，连接服务器。</li><li>发送请求。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-19-9xB06e.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="6-2-代码实现">6.2 代码实现</h3><p><strong><a target="_blank" rel="noopener" href="http://server.cc">server.cc</a></strong></p><p>要注意的地方：</p><ul><li>父进程不负责通信，所以必须关掉 cfd，以防文件描述符不够用。</li><li>子进程不负责连接和创建子进程，需要退出循环并关掉 lfd。</li><li>子进程通信时，如果客户端关闭写端，此时 read 的返回值 n == 0，应及时结束子进程。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> wait_pid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((wait_pid = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, WNOHANG)) &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;child_pid = &quot;</span> &lt;&lt; wait_pid &lt;&lt; <span class="hljs-string">&quot; is end!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 8888</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1.创建 socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//2.绑定 IP+port</span><br>    sockaddr_in server_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-comment">// inet_pton(AF_INET, &quot;172.16.103.5&quot;, &amp;server_addr.sin_addr);</span><br>    <span class="hljs-built_in">Bind</span>(lfd, (sockaddr*)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    <br>    <span class="hljs-comment">//3.设置最大同时连接数</span><br>    <span class="hljs-built_in">Listen</span>(lfd, <span class="hljs-number">128</span>);<br>    <br>    <span class="hljs-type">int</span> cfd;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">//4.父进程等待客户端连接</span><br>        sockaddr_in client_addr;<br>        <span class="hljs-built_in">bzero</span>(&amp;client_addr, <span class="hljs-built_in">sizeof</span>(client_addr));<br>        <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>        cfd = <span class="hljs-built_in">Accept</span>(lfd, (sockaddr*)&amp;client_addr, &amp;client_addr_len);<br>        <span class="hljs-type">char</span> client_buf[BUFSIZ];<br>        <br>        <span class="hljs-comment">// 输出客户端信息</span><br>        <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, client_buf, <span class="hljs-built_in">sizeof</span>(client_buf));<br>        <span class="hljs-type">int</span> client_port = <span class="hljs-built_in">ntohs</span>(client_addr.sin_port);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Client IP: &quot;</span> &lt;&lt; client_buf &lt;&lt; <span class="hljs-string">&quot;Client port: &quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//5.创建子进程</span><br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">close</span>(lfd);     <span class="hljs-comment">// 子进程不负责连接，推出“连接-创建子进程”的循环。</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">close</span> (cfd);   <span class="hljs-comment">// 父进程不负责通信，回收子进程</span><br>            <span class="hljs-built_in">signal</span>(SIGCHLD, wait_child);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 6.子进程通信</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">char</span> read_buf[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> n = <span class="hljs-built_in">Read</span>(cfd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf));<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// client 关闭写端</span><br>                <span class="hljs-built_in">close</span>(cfd);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理请求</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                    read_buf[i] = <span class="hljs-built_in">toupper</span>(read_buf[i]);<br>                &#125;<br>                <span class="hljs-built_in">Write</span>(cfd, read_buf, n);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong><a target="_blank" rel="noopener" href="http://client.cc">client.cc</a></strong></p><p>和 <a href="#client代码">5.2 中的 client</a> 相同。</p><p>因为客户端的逻辑并没有改变，还是连接服务器 + 发送请求。</p><h2 id="7-多线程并发服务器">7.多线程并发服务器</h2><h3 id="7-1-思路">7.1 思路</h3><blockquote><p>和多线程并发思路一致，只是将进程换成线程。</p></blockquote><p>每一个客户端，都由一个子线程负责通信。</p><p><strong>Server–父线程</strong>：</p><ol><li><p>监听连接部分：</p><ul><li>创建 socket，将监听端口绑定到 lfd。</li><li>等待 Client 连接，并返回用于通信的 cfd。</li></ul></li><li><p>管理子线程部分：</p><ul><li>一旦有新 Client 连接，则创建子线程，让子线程负责通信。</li><li>并设置线程分离。</li></ul></li></ol><p><strong>Server–子线程</strong>：</p><ul><li>调用回调函数 communicate，与客户端通信。</li></ul><p><strong>Client</strong>：</p><ul><li>创建 socket，连接服务器。</li><li>发送请求。</li></ul><h3 id="7-2-代码实现">7.2 代码实现</h3><p><strong><a target="_blank" rel="noopener" href="http://server.cc">server.cc</a></strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">socket_info</span> &#123;   <span class="hljs-comment">// 构建一个合理的结构体，既能传递 client_addr, 也能传递 cfd</span><br>    sockaddr_in client_addr;<br>    <span class="hljs-type">int</span> cfd;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">communicate</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;   <span class="hljs-comment">// 线程的回调函数，返回值和参数都是 void *</span><br>    socket_info *s_info = (socket_info *)arg;<br><br>    <span class="hljs-comment">// 输出客户端信息</span><br>    <span class="hljs-type">char</span> client_buf[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;s_info-&gt;client_addr.sin_addr, <span class="hljs-comment">// -&gt; 的优先级大于 &amp;</span><br>                client_buf, <span class="hljs-built_in">sizeof</span>(client_buf));<br>    <span class="hljs-type">int</span> client_port = <span class="hljs-built_in">ntohs</span>(s_info-&gt;client_addr.sin_port);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client IP: &quot;</span> &lt;&lt; client_buf &lt;&lt; <span class="hljs-string">&quot; Client port: &quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 子线程通信</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> read_buf[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">Read</span>(s_info-&gt;cfd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf));<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// client 关闭了写端</span><br>            <span class="hljs-built_in">close</span>(s_info-&gt;cfd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理请求</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                read_buf[i] = <span class="hljs-built_in">toupper</span>(read_buf[i]);<br>            &#125;<br>            <span class="hljs-built_in">Write</span>(s_info-&gt;cfd, read_buf, n);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(s_info-&gt;cfd);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 8888</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1.创建 socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//2.绑定 IP+port</span><br>    sockaddr_in server_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-comment">// inet_pton(AF_INET, &quot;172.16.103.5&quot;, &amp;server_addr.sin_addr);</span><br>    <span class="hljs-built_in">Bind</span>(lfd, (sockaddr*)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    <br>    <span class="hljs-comment">//3.设置最大同时连接数</span><br>    <span class="hljs-built_in">Listen</span>(lfd, <span class="hljs-number">128</span>);<br>    <br>    <span class="hljs-type">int</span> cfd;<br>    <span class="hljs-type">pid_t</span> pid;<br>    socket_info s_info[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 用数组存每一个连接的  client_addr + cfd</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">pthread_t</span> pth_id;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">//4.父线程等待客户端连接</span><br>        <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-built_in">sizeof</span>(s_info[i].client_addr);<br>        <span class="hljs-built_in">bzero</span>(&amp;s_info[i].client_addr, client_addr_len);<br>        s_info[i].cfd = <span class="hljs-built_in">Accept</span>(lfd, (sockaddr*)&amp;s_info[i].client_addr, &amp;client_addr_len);<br>        <br>        <span class="hljs-comment">//5. 创建子线程来处理通信</span><br>        <span class="hljs-built_in">pthread_create</span>(&amp;pth_id, <span class="hljs-literal">NULL</span>, communicate, (<span class="hljs-type">void</span> *)&amp;s_info[i]);  <span class="hljs-comment">// 子线程调用回调函数 communicate</span><br>        <span class="hljs-built_in">pthread_detach</span>(pth_id);   <span class="hljs-comment">// 父子线程分离，子线程自动回收自己的 PCB</span><br>        i++;  <span class="hljs-comment">// 标记第几个线程，以便存入 client_addr + cfd</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong><a target="_blank" rel="noopener" href="http://client.cc">client.cc</a></strong></p><p>和 <a href="#client代码">5.2 中的 client</a> 相同。</p><p>因为客户端的逻辑并没有改变，还是连接服务器 + 发送请求。</p><h2 id="8-socket-与-TCP">8.socket 与 TCP</h2><h3 id="8-1-TCP-状态转换">8.1 TCP 状态转换</h3><p>详见 <a href="https://www.aimtao.net/computer-network/#10-TCP状态转换图">计算机网络笔记</a></p><h3 id="8-2-socket-与-TCP-对应">8.2 socket 与 TCP 对应</h3><p><img src="https://hutu.aimtao.net/mark/2021-03-22-1G7n4C.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="8-3-TIME-WAIT-状态">8.3 TIME_WAIT 状态</h3><p>先关闭 server 后，四次挥手，server 进入 TIME_WAIT 状态，此时端口被占用，无法再次 connect。</p><p>检查端口 6666 是否占用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -apn | grep 6666<br></code></pre></td></tr></table></figure><h3 id="8-4-FIN-WAIT-2-状态">8.4 FIN_WAIT_2 状态</h3><p>可以使用 API 实现半关闭状态。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stocket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> how)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>sockfd：要关闭的文件描述符。</li><li>how：关闭的方式。<ul><li>SHUT_RD(0)：关闭sockfd上的读功能，该套接字<strong>不再接收数据</strong>，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</li><li>SHUT_WR(1)：关闭sockfd的写功能，进程不能在对此套接字发出写操作。</li><li>SHUT_RDWR(2)：关闭sockfd的读写功能。相当于调用shutdown两次：首先是 SHUT_RD,然后是SHUT_WR。</li></ul></li></ul><p><strong>PS：shutdown 和 close 的区别</strong></p><ul><li><p>close 中止连接，减少描述符的引用计数，并不直接关闭连接，当描述符引用计数为 0 时，才关闭连接。</p></li><li><p>shutdown不考虑描述符的引用计数，比如关闭读端，任何进程都无法从该 socket 接收数据。</p></li></ul><p><strong>举个例子</strong>：</p><ul><li>多个进程共享一个套接字，close 被调用一次，计数减一，直到所有进程均调用 close，套接字才被释放。（套接字就是内核中的两个缓冲区）</li><li>在多进程中，如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响到其它进程。</li></ul><h3 id="8-5-端口复用">8.5 端口复用</h3><p><strong>函数原型</strong>：</p><blockquote><p>该函数用法极其复杂，记住咱们设置端口复用即可。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>sockfd：套接字文件描述符</li><li>level：级别</li><li>optname：选项名</li><li>optval：选项值</li><li>optlen：选项的字节长度</li></ul><p><strong>设置端口复用</strong>：</p><blockquote><p>在 bind 之前，设置。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-built_in">sizeof</span>(opt));<br></code></pre></td></tr></table></figure><ul><li><p>SOL_SOCKET：级别</p></li><li><p>SO_REUSEADDR：允许重用本地端口</p></li></ul><h2 id="9-多路-IO-转接服务器">9.多路 IO 转接服务器</h2><blockquote><p>也叫多任务 IO 服务器。</p></blockquote><h3 id="9-1-思想">9.1 思想</h3><p>不再由应用程序自己监听客户端连接，取而代之由内核替应用程序监视文件。</p><p>下面主要介绍三种方式：</p><ul><li><strong>select</strong>：返回监听到的事件的数量。</li><li><strong>poll</strong>：返回监听到的事件的数量 + 监听的文件描述符数组。</li><li><strong>epoll</strong>：返回监听到的事件的数量 + 监听的文件描述符红黑树。</li></ul><p><strong>以 select 监听为例（poll、epoll 同理）</strong>：</p><ul><li><p>lfd 请求建立连接。</p><p>举个例子：select 发现 lfd 有连接请求，会让 server 调用 accept 函数，和客户端建立建立连接。（因为是有连接请求后，才调用的 accept 函数，所以 <mark>accept 不会阻塞</mark>。）</p></li><li><p>cfd 读、写、异常事件。</p><p>举个例子：当 select 监听到有 cfd_d 有可读事件时，会让 server 调用 read 函数，读取 cfd_d 中的数据。（因为是 cfd 中有数据后，才调用的 read 函数，所以 <mark>read 不会阻塞</mark>。）</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-23-zj6RlB.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3></h3><h3 id="9-2-问题">9.2 问题</h3><p>虽然不需要服务器程序自己监听，但是连接客户端、处理请求都需要服务器程序来处理。</p><p><strong>问题</strong>：一旦某个客户端的请求处理的时间过长，其他的客户端就无法及时连接。</p><p><strong>解决</strong>：线程池。</p><h2 id="10-select">10.select</h2><h3 id="10-1-函数原型">10.1 函数原型</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span><br><span class="hljs-params"><span class="hljs-function">            fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br>    <span class="hljs-type">long</span> tv_sec;   <span class="hljs-comment">// seconds</span><br>    <span class="hljs-type">long</span> tv_usec;  <span class="hljs-comment">// microseconds</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>nfds</strong>：所监听的所有文件描述符中，最大的文件描述符 + 1。</p><p>意义：此参数会告诉内核检测前多少个文件描述符的状态。</p><p>比如：进程打开了序号为 0 - 400 的文件描述符，nfds 则为 401。</p></li><li><p><strong>fd_set</strong>：位图，用二进制来标记文件描述符是否在集合中。</p><ul><li><p><strong>readfds</strong>：监听文件描述符集合 readfds 中，是否有可读事件。传入传出参数。</p></li><li><p><strong>writefds</strong>：监听文件描述符集合 writefds 中，是否有可写事件。传入传出参数。</p></li><li><p><strong>exceptfds</strong>：监听文件描述符集合 exceptfds 中，是否有异常事件。传入传出参数。</p></li></ul><p><strong>【传入传出】举个例子</strong>：</p><ul><li><p>调用 select 之前，我们想监听 4、5 文件描述符是否有可读事件。</p><p>readfds 集合中，4、5 文件描述符对应的值为 1，其他的为 0。</p></li><li><p>调用 select 之后，只有 4 文件描述符有可读事件。</p><p>readfds 集合中，4 文件描述符对应的值为 1，其他的为 0。</p></li></ul></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-22-74n1ne.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p><strong>timeout</strong>：内核监听的时间。</p><ul><li>NULL，永远等下去</li><li>设置 timeval，等待固定时间</li></ul></li><li><p>设置 timeval 里时间均为 0，检查描述符后立即返回，轮询</p></li><li><p><strong>返回值</strong>：</p><ul><li><p>成功，返回所监听的所有监听集合中，满足条件的总数。</p><p>举个例子：</p><p>r：3，4。可读事件：3，4</p><p>w：4，5，6。可写事件：4，5</p><p>e：4，5，7，8。异常事件：4，7</p><p>select 返回 6。</p></li><li><p>失败，则返回 -1，设置 errno。</p></li></ul></li></ul><h3 id="10-2-设置-fd-set">10.2 设置 fd_set</h3><blockquote><p>类似设置<a href="https://www.aimtao.net/linux-system/#14-11-阻塞信号集、未决信号集">未决信号集、阻塞信号集（类型 sigset_t）</a></p></blockquote><p>【全部清除】将 set 所有位置 0。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *set)</span></span>; <br></code></pre></td></tr></table></figure><p>【清除 fd】将 set 中对应的 fd 置 0。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br></code></pre></td></tr></table></figure><p>【添加 fd】将 set 中对应的 fd 置 1。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>; <br></code></pre></td></tr></table></figure><p>【判断 fd 是否在 set 中】判读 set 中对应的 fd 是否为 1。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：在 set 中返回 1，不在 set 中返回 0。</li></ul><h3 id="10-3-select-的局限性">10.3 select 的局限性</h3><ul><li><p>文件描述符上限：1024。</p><p>也就是说同时监听文件描述符 1024 个。</p></li><li><p>select 返回值只返回总数，如果需要知道具体的哪一个文件描述符，需要 for 循环判断 0 - 1023 个文件描述符。</p><p><strong>解决方案</strong>：自定义结构体（数组），将要监听的文件描述符加入数组。for 循环时，只循环判断数组中的文件描述符。</p></li><li><p>监听集合、满足监听条件的集合是同一个集合。</p><p>所以需要<strong>保存原有的监听集合</strong>，否则返回后监听集合就被破坏了。</p></li></ul><h3 id="10-4-思路">10.4 思路</h3><blockquote><p>储存文件描述符和返回结果的思路。</p></blockquote><p>传入三个位图，传出三个位图，在传出的三个位图中，寻找满足条件的事件进行处理。</p><p><img src="https://hutu.aimtao.net/mark/2021-04-23-GAIZRF.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="10-5-代码实现">10.5 代码实现</h3><p><strong>为什么自维护数组可以减少便利次数？</strong></p><ul><li><p>无自维护监听数组：</p><p>需要从 0-1024 判断文件描述符是否在 <strong>返回的结果集合 rset</strong> 中。</p></li><li><p>有自维护的监听数组：</p><p>只需要判断 监听数组client 中的文件描述符是否在 <strong>返回的结果集合 rset</strong> 中。</p></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-04-23-rsNwGs.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 8888</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//【1】创建 socket  ==========</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 设置端口复用</span><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-built_in">sizeof</span>(opt));<br><br>    <span class="hljs-comment">//【2】绑定 IP+port ==========</span><br>    sockaddr_in server_addr;<br>    <span class="hljs-type">socklen_t</span> server_addr_len = <span class="hljs-built_in">sizeof</span>(server_addr);<br><br>    <span class="hljs-comment">// 初始化 server_addr</span><br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, server_addr_len);<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;server_addr.sin_addr);</span><br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br><br>    <span class="hljs-built_in">Bind</span>(lfd, (sockaddr*)&amp;server_addr, server_addr_len);<br><br>    <span class="hljs-comment">//【3】设置同时连接上限 ==========</span><br>    <span class="hljs-built_in">Listen</span>(lfd, <span class="hljs-number">128</span>);<br><br>    <span class="hljs-type">int</span> max_fd = lfd;   <span class="hljs-comment">// 计算最大的文件描述符，（select 第一个参数会用到）</span><br><br>    <span class="hljs-comment">// 设置自定义的 客户端的 监听集合，用于 FD_ISSET 的遍历判断。不然只能遍历从 0 - 1023</span><br>    <span class="hljs-type">int</span> client[FD_SETSIZE];   <span class="hljs-comment">// 每个客户端的 cfd 的值都会存入 client 数组</span><br>    <span class="hljs-type">int</span> max_i = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 记录数组的最后一个元素的索引，FD_ISSET 只需要遍历 0 - max_i</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++) &#123;<br>        client[i] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 初始化数组，全部都是空位，用 -1 表示</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置监听的集合</span><br>    fd_set allset;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;allset);<br>    <span class="hljs-built_in">FD_SET</span>(lfd, &amp;allset);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">// 开始监听</span><br>        fd_set rset = allset;<br>        <span class="hljs-type">int</span> n_ready = <span class="hljs-built_in">select</span>(max_fd + <span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (n_ready &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;select error&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果三个客户端同时连接, n_ready 还是等于 1, 返回值只看满足要求的 文件描述符 个数（只有一个 lfd）。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;n_ready = &quot;</span> &lt;&lt; n_ready &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 监听到 lfd 有连接请求：将新的 cfd 加入 select 监听集 + 自定义监听集中。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(lfd, &amp;rset)) &#123;<br><br>            <span class="hljs-comment">// 定义 client_addr</span><br>            sockaddr_in client_addr;<br>            <span class="hljs-type">socklen_t</span> client_addr_size = <span class="hljs-built_in">sizeof</span>(client_addr);<br>            <span class="hljs-built_in">bzero</span>(&amp;client_addr, client_addr_size);<br><br>            <span class="hljs-comment">//【4】连接客户端</span><br>            <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">Accept</span>(lfd, (sockaddr *)&amp;client_addr, &amp;client_addr_size);<br><br>            <span class="hljs-comment">// 打印客户端信息</span><br>            <span class="hljs-type">char</span> client_ip[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, client_ip, <span class="hljs-built_in">sizeof</span>(client_ip));<br>            <span class="hljs-type">int</span> client_port = <span class="hljs-built_in">ntohs</span>(client_addr.sin_port);<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Client IP: &quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="hljs-string">&quot;Client port: &quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 将新的 cfd 加入到自己维护的监听数组（监听文件符号集）</span><br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++) &#123;<br>                <span class="hljs-keyword">if</span> (client[i] &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 找到 client 没有使用的地方（空位）</span><br>                    client[i] = cfd;    <span class="hljs-comment">// 将新的 cfd 加入 client 数组</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 防止监控文件达到上限</span><br>            <span class="hljs-keyword">if</span> (i == FD_SETSIZE) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;too many client&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 将新 cfd 加入监听文件描述符（select 第二个参数会用到）</span><br>            <span class="hljs-built_in">FD_SET</span>(cfd, &amp;allset);<br>            <br>            <span class="hljs-comment">// 保证 max_fd 是最大的文件描述符 （select 第一个参数）</span><br>            <span class="hljs-keyword">if</span> (max_fd &lt; cfd) &#123;<br>                max_fd = cfd;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 保证 max_i 是 client 数组中最后一个元素的索引</span><br>            <span class="hljs-keyword">if</span> (i &gt; max_i) &#123;<br>                max_i = i;<br>            &#125;<br><br>            <span class="hljs-comment">// n_ready == 1, 表示只有一个满足条件的事件，也就是 lfd，没有 cfd 满足条件，故直接进入下次循环。</span><br>            <span class="hljs-keyword">if</span> (-- n_ready == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断满足条件的事件，是哪一个 cfd</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_i; i++) &#123;<br>            <span class="hljs-type">int</span> sockfd = client[i];<br><br>            <span class="hljs-comment">// client[i] = -1 表示该位置是空位。</span><br>            <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果该 cfd 满足条件，读该 cfd</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;<br>                <span class="hljs-type">int</span> n;<br>                <span class="hljs-type">char</span> read_buf[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>                <span class="hljs-comment">// 如果客户端关闭了文件描述符：我也关闭文件描述符 + 更改 select 监听集 + 更改自定义监听集</span><br>                <span class="hljs-comment">// 【重要】当客户端关闭了文件描述符，select 也会监听到该 cfd 的可读事件</span><br>                <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">Read</span>(sockfd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf))) == <span class="hljs-number">0</span> ) &#123;<br>                    <span class="hljs-built_in">close</span>(sockfd);<br>                    <span class="hljs-built_in">FD_CLR</span>(sockfd, &amp;allset);<br>                    client[i] = <span class="hljs-number">-1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// 如果读到内容，处理请求，响应请求</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                        read_buf[j] = <span class="hljs-built_in">toupper</span>(read_buf[j]);<br>                    &#125;<br>                    <span class="hljs-built_in">Write</span>(sockfd, read_buf, n);<br>                &#125;<br><br>                <span class="hljs-comment">// 如果还没有满足条件的 cfd，就退出循环，获得下次监听的结果 n_ready</span><br>                <span class="hljs-keyword">if</span> (--n_ready == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="11-poll">11.poll</h2><h3 id="10-1-函数原型-2">10.1 函数原型</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">short</span> events;<br>    <span class="hljs-type">short</span> revents;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>struct pollfd *fds：结构体 pollfd 数组的首地址。</li></ul><p>struct pollfd 结构体</p><ul><li>fd：文件描述符</li><li>events：监控的事件</li><li>revents：监控事件中满足条件返回的事件，传出参数，初始化为 0 即可。</li><li>事件：POLLIN / POLLOUT / POLLERR（读 / 写 / 异常）</li></ul><h3 id="10-2-poll-的优势">10.2 poll 的优势</h3><blockquote><p>和 select 相比。</p></blockquote><ul><li><p>修改配置文件 file descriptors 的值，可以改变文件描述符 1024 的上限。</p><p>查看文件描述符个数：<code>ulimit -a</code> 或者 <code>ulimit -n</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看硬件所限制的最多打开的文件描述符个数</span><br><span class="hljs-built_in">cat</span> //proc/sys/fs/file-max<br><br><span class="hljs-comment"># 修改文件描述符的上限值</span><br>vi /etc/security/limits.conf<br><br><span class="hljs-comment"># 在文件末尾加入以下两行</span><br><span class="hljs-comment"># soft 软限制（下限）、hard 硬限制（上限）。</span><br>*    soft    nofile    65535<br>*    hard    nofile    10000<br></code></pre></td></tr></table></figure></li><li><p>分离了监听集合和返回集合</p><p>在 select 中，文件描述符集合是传入传出参数。</p></li><li><p>FD_ISSET 搜索的范围变小。</p><p>select 需要从 0 - 1024 遍历。（解决方案：自己维护一个用于遍历监听文件描述符的数组）</p><p>poll 监听的文件描述符在 pollfd 结构体数组中，直接遍历 pollfd 结构体数组。</p></li></ul><h3 id="10-3-思路">10.3 思路</h3><blockquote><p>储存文件描述符和返回结果的思路。</p></blockquote><p>用结构体数组储存 需要监听的文件描述符、需要监听的事件、监听到的事件。</p><p><img src="https://hutu.aimtao.net/mark/2021-04-23-zPeNis.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="10-4-代码实现">10.4 代码实现</h3><p><img src="https://hutu.aimtao.net/mark/2021-04-22-nOdsVO.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong><a target="_blank" rel="noopener" href="http://server.cc">server.cc</a></strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 8888</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_MAX 1024</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1.创建 socket =============</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 设置端口复用</span><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-built_in">sizeof</span>(opt));<br><br>    <span class="hljs-comment">// 2.绑定 IP+Port =============</span><br>    <span class="hljs-comment">// 设置 serve_addr</span><br>    sockaddr_in server_addr;<br>    <span class="hljs-type">socklen_t</span> server_addr_len = <span class="hljs-built_in">sizeof</span>(server_addr);<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, server_addr_len);<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br><br>    <span class="hljs-comment">// bind</span><br>    <span class="hljs-built_in">Bind</span>(lfd, (sockaddr *)&amp;server_addr, server_addr_len);<br><br>    <span class="hljs-comment">// 3.设置同时连接上限 =============</span><br>    <span class="hljs-built_in">Listen</span>(lfd, <span class="hljs-number">128</span>);<br><br>    <span class="hljs-comment">// 创建客户端数组，记录需要监听的文件描述符</span><br>    pollfd client[OPEN_MAX];<br>    <br>    <span class="hljs-comment">// 初始化客户端数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++) &#123;<br>        client[i].fd = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 标记为 -1 则是无效的文件描述符，无需监听</span><br>    &#125;<br>    <span class="hljs-type">int</span> maxi = <span class="hljs-number">0</span>;    <span class="hljs-comment">// client 数组中最大的有效元素下标</span><br><br>    <span class="hljs-comment">// 将 lfd 加入客户端数组</span><br>    client[<span class="hljs-number">0</span>].fd = lfd;<br>    client[<span class="hljs-number">0</span>].events = POLLIN;   <span class="hljs-comment">// 该文件描述符需要监听的事件</span><br>    maxi = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> n_ready = <span class="hljs-built_in">poll</span>(client, maxi + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;n_ready = &quot;</span> &lt;&lt; n_ready &lt;&lt;std::endl;<br>        <span class="hljs-keyword">if</span> (client[<span class="hljs-number">0</span>].revents &amp; POLLIN) &#123;<br>            <span class="hljs-comment">// 初始化 client_addr</span><br>            sockaddr_in client_addr;<br>            <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>            <span class="hljs-built_in">bzero</span>(&amp;client_addr, client_addr_len);<br>            <span class="hljs-comment">// std::cout &lt;&lt; &quot;初始化 client_addr&quot; &lt;&lt;std::endl;</span><br>            <span class="hljs-comment">// 连接，并返回客户端描述符</span><br>            <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">Accept</span>(lfd, (sockaddr *)&amp;client_addr, &amp;client_addr_len);<br>            <span class="hljs-type">char</span> IP[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;IP: &quot;</span> &lt;&lt; <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, IP, <span class="hljs-built_in">sizeof</span>(IP)) <br>                        &lt;&lt; <span class="hljs-string">&quot; Port: &quot;</span> &lt;&lt; <span class="hljs-built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;<br>            <br>            <span class="hljs-comment">// 将 cfd 加入监听数组, 并设置监听事件</span><br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++) &#123;<br>                <span class="hljs-keyword">if</span> (client[i].fd &lt; <span class="hljs-number">0</span>) &#123;<br>                    client[i].fd = cfd;<br>                    client[i].events = POLLIN;<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt;std::endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == OPEN_MAX) &#123;<br>                <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;Too many client&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxi &lt; i) &#123;<br>                maxi = i;   <span class="hljs-comment">// 更新最大有效描述符</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (--n_ready &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 没有其他的就绪事件，就继续回到 poll 监听阻塞</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 除了 lfd，其他 client_fd 监听到了事件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxi; i++) &#123;<br>            <br>            <span class="hljs-comment">// 当前 client_fd = -1 表示未在监听。</span><br>            <span class="hljs-keyword">if</span> (client[i].fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;11 i = &quot;</span> &lt;&lt; i &lt;&lt;std::endl;<br><br>            <span class="hljs-comment">// 监听到读事件</span><br>            <span class="hljs-keyword">if</span> (client[i].revents &amp; POLLIN) &#123;<br>                <span class="hljs-type">char</span> read_buf[BUFSIZ] = &#123;<span class="hljs-number">0</span>&#125;;<br>                <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// n = -1 表示服务器收到 RST 标志</span><br>                <span class="hljs-keyword">if</span> ( (n = <span class="hljs-built_in">Read</span>(client[i].fd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf))) &lt; <span class="hljs-number">0</span> ) &#123;<br>                    <span class="hljs-keyword">if</span> (errno == ECONNRESET) &#123;    <span class="hljs-comment">// 服务器收到 RST 标志，errno 会被设为 ECONNRESET。</span><br>                        std::cout &lt;&lt; <span class="hljs-string">&quot;client[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] aborted connection.&quot;</span> &lt;&lt; std::endl;<br>                        <span class="hljs-built_in">Close</span>(client[i].fd);<br>                        client[i].fd = <span class="hljs-number">-1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// n = 0 表示客户端先关闭了链接</span><br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;client[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] closed connection.&quot;</span> &lt;&lt; std::endl;<br>                    <span class="hljs-built_in">Close</span>(client[i].fd);<br>                    client[i].fd = <span class="hljs-number">-1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// n &gt; 0，开始处理请求</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                        read_buf[j] = <span class="hljs-built_in">toupper</span>(read_buf[j]);<br>                    &#125;<br>                    <span class="hljs-built_in">Write</span>(client[i].fd, read_buf, n);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (--n_ready &lt;= <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 没有其他的就绪事件，就继续回到 poll 监听阻塞。</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="12-epoll">12.epoll</h2><h3 id="12-1-函数原型">12.1 函数原型</h3><p><strong>（1）创建一个 epoll 句柄</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>size：表示内核监听文件描述符的个数，和内存大小有关。（size 只是建议值）</li><li>返回值：返回文件描述符 epfd，指向一棵红黑树的根节点。</li></ul><p><strong>（2）控制 epoll 监控的某个文件描述符上的事件：注册、修改、删除。</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> &#123;<br>    <span class="hljs-type">__uint32_t</span> events;   <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data;   <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><br><span class="hljs-comment">// 联合体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> &#123;<br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">uint32_t</span> u32;<br>    <span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br></code></pre></td></tr></table></figure><ul><li><p>epfd：epoll_create 函数返回的红黑树根节点。</p></li><li><p>op：表示动作，用三个宏表示 注册、修改、删除。</p><ul><li><p>EPOLL_CTL_ADD （注册新的fd到epfd）</p></li><li><p>EPOLL_CTL_MOD （修改已经注册的fd的监听事件）</p></li><li><p>EPOLL_CTL_DEL （从epfd删除一个fd）</p></li></ul></li><li><p>fd：所监听的文件描述符。</p></li><li><p>event：结构体，两个变量：events 和 data。【传入参数】</p><ul><li><p>events：指定需要监听的事件。</p><p><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</p><p><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写</p></li></ul><p>​ <strong>EPOLLERR</strong>：表示对应的文件描述符发生错误</p><ul><li><p>data：是个联合体，使用 <code>int fd</code> 即可。（反应堆模型会使用 void *ptr）</p><p>此处 fd 与 epoll_ctl 第三个参数 fd 数据一致。此处的 fd 和 events 作为一个结构体，返回给结构体数组（数组中记录监听到的事件和文件描述符）。</p></li></ul></li><li><p>返回值：成功：0；失败：-1，设置相应的 errno。</p></li></ul><p><strong>（3）监听</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>epfd：同 epoll_ctl 第一个参数 epfd，红黑树的根节点。</p></li><li><p>events：与 epoll_ctl 最后一个参数不同，此处表示 event 的数组。【传出参数】</p></li><li><p>maxevents：events 数组容量。</p></li><li><p>timeout：</p><p>-1：阻塞。</p><p>0：立即返回，非阻塞。</p><p>&gt;0：指定毫秒。</p></li><li><p>返回值：成功返回有多少文件描述符有监听到事件。时间到时返回 0，出错返回 -1。</p></li></ul><h3 id="12-2-特点">12.2 特点</h3><ul><li><p>epoll 能显著提高 <strong>程序在大量并发连接中只有少量活跃</strong> 的情况下的系统CPU利用率。</p><p>因为 epoll 会复用文件描述符集合来传递结果，而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p></li><li><p>epoll 除了提供 select/poll 那种 IO 事件的水平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存 IO 状态，减少 epoll_wait/epoll_pwait 的调用，提高应用程序效率。</p></li><li><p>epoll 是 Linux 大规模并发网络程序中的热门首选模型。</p></li><li><p>与 poll 相同，通过 <code>/etc/security/limits.conf</code> 更改文件描述符个数。</p></li></ul><h3 id="12-3-思路">12.3 思路</h3><blockquote><p>储存文件描述符和返回结果的思路。</p></blockquote><ul><li>使用 epoll_ctl 将需要监听的文件描述符加入红黑树 epfd 中。</li><li>监听到满足的事件后，将属于该文件描述符的结构体拷贝到结构体数组 fd_event_arr 中，作为返回结果返回。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-04-23-iqSaRs.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="12-4-代码实现">12.4 代码实现</h3><p>和 poll 实现流程相似，poll 的监听结构体数组被 epoll 的监听红黑树代替。</p><p><img src="https://hutu.aimtao.net/mark/2021-04-22-BuToYF.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 8888</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_MAX 1024</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 1.创建 socket =============</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 设置端口复用</span><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-built_in">sizeof</span>(opt));<br><br>    <span class="hljs-comment">// 2.绑定 IP+Port =============</span><br>    <span class="hljs-comment">// 设置 serve_addr</span><br>    sockaddr_in server_addr;<br>    <span class="hljs-type">socklen_t</span> server_addr_len = <span class="hljs-built_in">sizeof</span>(server_addr);<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, server_addr_len);<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT);<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br><br>    <span class="hljs-comment">// bind</span><br>    <span class="hljs-built_in">Bind</span>(lfd, (sockaddr *)&amp;server_addr, server_addr_len);<br><br>    <span class="hljs-comment">// 3.设置同时连接上限 =============</span><br>    <span class="hljs-built_in">Listen</span>(lfd, <span class="hljs-number">128</span>);<br><br>    <span class="hljs-comment">// （1）创建 epoll 模型，epfd 指向红黑树的根节点</span><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(OPEN_MAX);<br>    <span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;epoll_create error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定监听 lfd 的读事件，为 epoll_ctl 的第四个参数做准备</span><br>    epoll_event fd_event;<br>    fd_event.events = EPOLLIN;<br>    fd_event.data.fd = lfd;<br><br>    <span class="hljs-comment">// 讲 lfd 添加在 epoll 所监听二叉树上</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;fd_event);<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;epoll_ctl error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// fd_event_arr 是用于返回监听结果的 epoll_event 结构体数组。</span><br>    epoll_event fd_event_arr[OPEN_MAX];<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <br>        <span class="hljs-comment">// epoll 开始监听，-1 表示永久阻塞。</span><br>        <span class="hljs-type">int</span> nready = <span class="hljs-built_in">epoll_wait</span>(epfd, fd_event_arr, OPEN_MAX, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;epoll_wait error&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nready; i++) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (!fd_event_arr[i].events &amp; EPOLLIN) &#123;  <span class="hljs-comment">// 如果不是读事件，继续。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (fd_event_arr[i].data.fd == lfd) &#123;  <span class="hljs-comment">// 如果是 lfd 的读事件，则连接客户端</span><br>                <br>                <span class="hljs-comment">// 连接客户端</span><br>                sockaddr_in client_addr;<br>                <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>                <span class="hljs-built_in">bzero</span>(&amp;client_addr, client_addr_len);<br>                <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">Accept</span>(lfd, (sockaddr *)&amp;client_addr, &amp;client_addr_len);<br>                <br>                <span class="hljs-comment">// 打印客户端信息</span><br>                <span class="hljs-type">char</span> ip_buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, ip_buf, <span class="hljs-built_in">sizeof</span>(ip_buf));<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;client connect successfully.&quot;</span> &lt;&lt; <span class="hljs-string">&quot; IP: &quot;</span> &lt;&lt; ip_buf &lt;&lt; <span class="hljs-string">&quot; Port: &quot;</span> &lt;&lt; <span class="hljs-built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;<br><br>                <span class="hljs-comment">// 将 cfd 加入 epfd 中监听。</span><br>                fd_event.events = EPOLLIN;<br>                fd_event.data.fd = cfd;<br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;fd_event);<br>                <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>                    <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;epoll_ctl error&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// 如果是 cfd 的读事件，则读数据，处理请求</span><br><br>                <span class="hljs-comment">// 读数据</span><br>                <span class="hljs-type">int</span> cfd = fd_event_arr[i].data.fd;<br>                <span class="hljs-type">char</span> read_buf[BUFSIZ];<br>                <span class="hljs-type">int</span> n = <span class="hljs-built_in">Read</span>(cfd, read_buf, <span class="hljs-built_in">sizeof</span>(read_buf));<br><br>                <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 读到 0, 说明客户端关闭了连接。</span><br><br>                    <span class="hljs-comment">// 从 epfd 红黑树中，删除这个 cfd，停止监听。</span><br>                    <span class="hljs-type">int</span> res = <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, cfd, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>                        <span class="hljs-built_in">perror_exit</span>(<span class="hljs-string">&quot;epoll_ctl error&quot;</span>);<br>                    &#125;<br>                <br>                    <span class="hljs-comment">// 关闭与客户端的连接</span><br>                    <span class="hljs-built_in">Close</span>(cfd);<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;client closed connection&quot;</span> &lt;&lt; std::endl;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 出错，不再监听该 cfd</span><br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read n &lt; 0 error&quot;</span>);<br>                    <span class="hljs-type">int</span> res = <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, cfd, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-built_in">Close</span>(cfd);<br>                &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理请求</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                        read_buf[i] = <span class="hljs-built_in">toupper</span>(read_buf[i]);<br>                    &#125;<br>                    <span class="hljs-built_in">Write</span>(cfd, read_buf, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="12-5-水平触发和边沿触发">12.5 水平触发和边沿触发</h3><blockquote><p>两种触发模式作用：减少对 epoll_wait 的调用次数。</p></blockquote><p><strong>（1）epoll 事件模型</strong></p><p>epoll 事件模型有两种：</p><ul><li>Edge Triggered（ET）边沿触发只有新的数据到来才触发，无论缓存区中是否还有数据。</li><li>Level Triggered（LT）水平触发只要缓冲区有数据都会触发。</li></ul><p>举一个形象的例子：</p><p>边缘触发就像上升沿、下降沿，只有高低电平发生变化时，才会触发。</p><p>水平触发就像水平沿，只要是高电平都会触发。</p><p><img src="https://hutu.aimtao.net/mark/2021-04-26-oHP13p.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）ET 模式</strong></p><p>举个例子：</p><p>[1]：客户端写入 2KB 数据。</p><p>[2]：服务端调用 epoll_wait，返回 cfd 有可读事件。</p><p>[3]：服务端读取 1KB 数据。（readn 函数）</p><p>[4]：服务端调用 epoll_wait。</p><p>在 ET 模式中，此时尽管缓冲区还有 1KB 数据没有读取，如果客户端没有新的数据写给服务端，epoll_wait 会阻塞在这里。</p><p>【问题】一旦客户端在等待服务端对于这 2KB 的数据反馈，服务端在等待客户端发送新的数据。一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p>【解决】使用非阻塞的函数。no-block。</p><p>ET是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。</p><p>然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p><p><strong>（3）LT 模式</strong></p><p>LT 是<strong>缺省</strong>的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。<strong>传统的 select/poll 都是这种模型的代表。</strong></p><p><strong>（4）实现方式</strong></p><p>epoll 的触发方式，通过结构体 struct epoll_event 中，成员变量 events 的监听事件来确定。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 默认是水平触发 LT</span><br>event.events = EPOLLIN;<br><br><span class="hljs-comment">// 用以下语句表示边缘触发 ET</span><br>event.events = EPOLLIN | EPOLLET;<br></code></pre></td></tr></table></figure><h3 id="12-6-ET-模式的实例">12.6 ET 模式的实例</h3><p>epoll 也可以监听管道的文件描述符。</p><p>下面以管道为例，实现 ET 模式的 epoll 监听。</p><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Linux/">#Linux</a> <a href="/tags/C-C/">#C/C++</a> <a href="/tags/Socket/">#Socket</a></div></div><div class="license-box my-3"><div class="license-title"><div>学习笔记｜Socket 与并发服务器</div><div>https://www.aimtao.net/socket/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2021-03-04</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/meaning-of-life-and-donuts/" title="人生意义与甜甜圈"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">人生意义与甜甜圈</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/VMware/" title="VMware 使用 open-vm-tools 实时共享"><span class="hidden-mobile">VMware 使用 open-vm-tools 实时共享</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>