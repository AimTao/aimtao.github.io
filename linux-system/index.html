<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="本文从实际运用的角度出发，系统描述 Linux&amp;#x2F;C++ 开发相关知识。"><title>学习笔记｜Linux 系统编程 - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2020-12-13-linux-system.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="学习笔记｜Linux 系统编程"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-13 21:07" pubdate>2020-12-13 PM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 73k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 55 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">学习笔记｜Linux 系统编程</h1><p class="note note-info">本文最后更新于：5 years ago</p><div class="markdown-body"><blockquote><p>本文从实际运用的角度出发，系统描述 Linux/C++ 开发相关知识。</p></blockquote><span id="more"></span><h2 id="1-gcc-g">1.gcc/g++</h2><blockquote><p>以下内容将 gcc 替换成 g++ 同样适用。</p></blockquote><h3 id="1-1-编译过程">1.1 编译过程</h3><pre><code class="mermaid">graph LR
A(hello.c) --&gt;|预处理器 cpp| B(hello.i)
B --&gt;|编译器 gcc| C(hello.s 汇编文件)
C --&gt;|汇编器 as| D(hello.o 目标文件)
D --&gt;|链接器 ld| E(a.out 二进制文件)
A1(hello.c) --&gt;|gcc -E| B1(hello.i)
B1 --&gt;|gcc -S| C1(hello.s 汇编文件)
C1 --&gt;|gcc -c| D1(hello.o 目标文件)
D1 --&gt;|gcc| E1(a.out 二进制文件)
</code></pre><h3 id="1-2-参数">1.2 参数</h3><h4 id="1-2-1-I">1.2.1 -I</h4><p>问题情景：<strong>包含的 include 文件的路径不正确。</strong></p><p>目录结构如下，但是在 <a target="_blank" rel="noopener" href="http://hello.cc">hello.cc</a> 中，头文件写的是 <code>include &quot;my.h&quot;</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── a.out<br>├── hello.cc<br>└── my_lib<br>    └── my.h<br></code></pre></td></tr></table></figure><ul><li>解决方案一：更改所写头文件的路径。</li></ul><p>将 <code>include &quot;my.h&quot;</code> 改为 <code>include &quot;./my_lib/my.h&quot;</code>。</p><ul><li>解决方案二：加入 <code>-I</code> 参数进行编译。</li></ul><p><code>-I</code> 参数指明调用头文件所在目录。（只用指明目录，无需写出完整路径）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ hello.cc -I ./my_lib/<br></code></pre></td></tr></table></figure><h4 id="1-2-2-D">1.2.2 -D</h4><p>指定宏定义。</p><p>在 多个cpp文件 中加入调试信息时，为了控制是否打印调试信息，可以使用宏定义来控制。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 在文件中这样写入调试信息。</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>cout &lt;&lt; <span class="hljs-string">&quot;please print info.&quot;</span> &lt;&lt; endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>编译时，通过控制 <code>-D</code> 参数来控制宏定义。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 相当于定义了 DEBUG 宏 #define DEBUG</span><br>g++ hello.cc -D DEBUG<br></code></pre></td></tr></table></figure><h4 id="1-2-3-O">1.2.3 -O</h4><p>指明优化选项，用来对编译时间，目标文件长度，执行效率三个维度进行不同的取舍和平衡。</p><table><thead><tr><th>等级</th><th>优化程度</th></tr></thead><tbody><tr><td>-O0</td><td>没有优化</td></tr><tr><td>-O1</td><td>对代码的分支，常量以及表达式等进行优化</td></tr><tr><td>-O2</td><td>寄存器级的优化以及指令级的优化</td></tr><tr><td>-O3</td><td>使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化</td></tr></tbody></table><h4 id="1-2-4-Wall">1.2.4 -Wall</h4><p>生成所有警告信息。</p><p>相反的：<code>-w</code> 不生成警告信息。</p><h4 id="1-2-5-g">1.2.5 -g</h4><p>添加 gdb 调试。生成的文件比没有调试的文件大很多。</p><h2 id="2-静态库">2.静态库</h2><h3 id="2-1-命名规则">2.1 命名规则</h3><p><strong>lib + 库的名字 + .a</strong></p><p>例如：libmytest.a</p><h3 id="2-2-制作步骤">2.2 制作步骤</h3><p>制作静态库时，目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── include        <span class="hljs-comment"># 头文件的目录</span><br>│   └── head.h     <span class="hljs-comment"># 声明了 add、sub、mul、div 等函数</span><br>├── lib       <span class="hljs-comment"># 打包好的静态库放在这里</span><br>└── src                <span class="hljs-comment"># 源代码的目录</span><br>    ├── add.cc     <span class="hljs-comment"># add 函数的实现</span><br>    ├── sub.cc     <span class="hljs-comment"># sub 函数的实现</span><br>    ├── mul.cc     <span class="hljs-comment"># mul 函数的实现</span><br>    └── div.cc     <span class="hljs-comment"># div 函数的实现</span><br></code></pre></td></tr></table></figure><ol><li>将 src 中的 .cc 文件编译生成对应的 .o 文件。（记得加 <code>-c</code> 参数）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ *.cc -I ../include -c<br></code></pre></td></tr></table></figure><ol start="2"><li>将生成的 .o 文件打包成静态库</li></ol><p><strong>ar rcs 静态库的名字（libMytest.a） 生成的所有的 .o</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ar rcs libMytest.a *.o<br></code></pre></td></tr></table></figure><p>PS: <strong>ar 命令</strong> 用于打包库，其中，</p><p><code>-r</code>：将文件插入备存文件中。</p><p><code>-c</code> ：建立备存文件。</p><p><code>-s</code>：若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</p><ol start="3"><li>发布静态库</li></ol><p>将静态库和头文件发布。</p><h3 id="2-3-使用">2.3 使用</h3><p>使用时，目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── include     <span class="hljs-comment"># 头文件所在目录</span><br>│   └── head.h<br>├── lib         <span class="hljs-comment"># 静态库所在目录</span><br>│   └── libMytest.a<br>└── main.cc     <span class="hljs-comment"># 使用了静态库的源文件</span><br></code></pre></td></tr></table></figure><p><strong>（1）方式一</strong>：同时编译源文件和静态库。</p><p>同时制定头文件的目录。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">g++ main.cc ./lib/libMytest.a -I ./include <br></code></pre></td></tr></table></figure><p><strong>（2）方式二</strong>：编译源文件时，使用 <code>-L</code> 和 <code>-l</code> 指定静态库。</p><p><code>-L</code> ：表示静态库所在文件。</p><p><code>-l</code>：表示静态库的名称。</p><p>重点：需要掐头去尾。去掉 lib 和 .a。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">g++ main.cc -I ./include -L lib -l Mytest<br></code></pre></td></tr></table></figure><h3 id="2-4-查看静态库内部">2.4 查看静态库内部</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nm libMytest.a<br></code></pre></td></tr></table></figure><p>显示内容如下（其实就是 .o 文件）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">add.o:<br>0000000000000000 T _Z3addii<br><br>sub.o:<br>0000000000000000 T _Z3subii<br><br>mul.o:<br>0000000000000000 T _Z3mulii<br><br>div.o:<br>0000000000000000 T _Z3divii<br></code></pre></td></tr></table></figure><h3 id="2-5-静态库原理">2.5 静态库原理</h3><p><img src="https://hutu.aimtao.net/mark/2021-01-23-uutJYy.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>可执行文件中，会打包用到的 .o 文件。</p><p>在文件的虚拟地址空间中，静态库的位置是绝对位置，无论什么时候执行程序，静态库都是在 text 区。</p><p><img src="https://hutu.aimtao.net/mark/2021-01-31-5naH7x.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="2-6-优缺点">2.6 优缺点</h3><p><strong>（1）优点</strong>：</p><ul><li>发布程序时，不需要提供对应的库。</li><li>加载库的速度快。</li></ul><p><strong>（2）缺点</strong>：</p><ul><li>库被打包到应用程序中，导致应用程序很大。</li><li>库发生改变，需要重新编译程序。</li></ul><h2 id="3-动态库-共享库">3.动态库/共享库</h2><h3 id="3-1-命名规则">3.1 命名规则</h3><p><strong>lib + 名字 + .so</strong></p><p>例如：<a target="_blank" rel="noopener" href="http://libMytest.so">libMytest.so</a></p><h3 id="3-2-制作步骤">3.2 制作步骤</h3><p>制作动态库时，目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── include        <span class="hljs-comment"># 头文件的目录</span><br>│   └── head.h     <span class="hljs-comment"># 声明了 add、sub、mul、div 等函数</span><br>├── lib       <span class="hljs-comment"># 打包好的动态库放在这里</span><br>└── src                <span class="hljs-comment"># 源代码的目录</span><br>    ├── add.cc     <span class="hljs-comment"># add 函数的实现</span><br>    ├── sub.cc     <span class="hljs-comment"># sub 函数的实现</span><br>    ├── mul.cc     <span class="hljs-comment"># mul 函数的实现</span><br>    └── div.cc     <span class="hljs-comment"># div 函数的实现</span><br></code></pre></td></tr></table></figure><ol><li>生成与位置无关的 .o 文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ -fPIC -c *.cc -I ../include<br></code></pre></td></tr></table></figure><p><code>-fPIC</code>： 指明生成与位置无关的 .o 文件。</p><ol start="2"><li>将 .o 打包成共享库（动态库）</li></ol><p><strong>g++ -shared 动态库的名字（<a target="_blank" rel="noopener" href="http://libMytest.so">libMytest.so</a>） 生成的所有 .o 文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ -shared -o libMytest.so *.o -I ../include<br></code></pre></td></tr></table></figure><p><code>-shared</code>：链接选项，使用动态库。</p><p><code>-o</code>：指定动态库的名字。</p><h3 id="3-3-使用">3.3 使用</h3><p>使用时，目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── include     <span class="hljs-comment"># 头文件所在目录</span><br>│   └── head.h<br>├── lib         <span class="hljs-comment"># 静态库所在目录</span><br>│   └── libMytest.a<br>└── main.cc     <span class="hljs-comment"># 使用了静态库的源文件</span><br></code></pre></td></tr></table></figure><p><strong>（1）方式一</strong>：同时编译源文件和动态库。</p><p>同时制定头文件的目录。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">g++ main.cc ./lib/libMytest.so -I ./include <br></code></pre></td></tr></table></figure><p><strong>（2）方式二</strong>：编译源文件时，使用 <code>-L</code> 和 <code>-l</code> 指定动态库。</p><p><code>-L</code> ：表示动态库所在文件。</p><p><code>-l</code>：表示动态库的名称。</p><p>重点：需要掐头去尾。去掉 lib 和 .a。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">g++ main.cc -I ./include -L lib -l Mytest<br></code></pre></td></tr></table></figure><h3 id="3-4-动态库链接失败">3.4 动态库链接失败</h3><p><strong>（1）问题描述</strong></p><p>用 方式二 编译生成的可执行文件，运行之后会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./a.out: error <span class="hljs-keyword">while</span> loading shared libraries: libMytest.so: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p><strong>（2）原因</strong></p><p>a.out 执行时，没有找到动态库，使用 <strong>ldd</strong> 命令可查询：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">ldd a.out<br><br><span class="hljs-comment"># linux-vdso.so.1 =&gt;  (0x00007ffe4534f000)</span><br><span class="hljs-comment"># libMytest.so =&gt; not found                                    ## 没找到 libMytest.so</span><br><span class="hljs-comment"># libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fdd2b8b6000) ## libgcc的扩展</span><br><span class="hljs-comment"># libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fdd2b5b4000)</span><br><span class="hljs-comment"># libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fdd2b39e000)   ## GCC的组件</span><br><span class="hljs-comment"># libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fdd2afd0000)           ## 标准C库</span><br><span class="hljs-comment"># /lib64/ld-linux-x86-64.so.2 (0x00007fdd2bbbe000)             ## 动态链接器</span><br></code></pre></td></tr></table></figure><h3 id="3-5-解决方式">3.5 解决方式</h3><p>为了让 程序 找到动态库所在位置，有以下四种方式。</p><p><strong>（1）方式一：动态库放在系统的库目录 /lib64 中（不允许使用）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mv</span> ./lib/libMytest.so /lib64/<br></code></pre></td></tr></table></figure><p><strong>（2）方式二：临时设置环境变量 LD_LIBRARY_PATH（临时测试用）</strong></p><p>【终端关闭，配置失效】</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=./lib        <span class="hljs-comment"># 等号两侧不许有空格</span><br></code></pre></td></tr></table></figure><p><strong>（3）方式三：将环境变量 LD_LIBRARY_PATH 写入 .zshrc 中（不正规）</strong></p><p>编辑完 .zshrc 需要【重启终端】</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim ~/.zshrc<br><span class="hljs-comment"># 添加以下键值对</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=./lib<br></code></pre></td></tr></table></figure><p><strong>（4）方式四：修改 /etc/ld.so.conf</strong></p><ol><li>打开 /etc/ld.so.conf</li><li>将动态库的 <strong>绝对路径</strong>，写入 /etc/ld.so.conf</li><li>更新：ldconfig -v</li></ol><h3 id="3-6-动态库原理">3.6 动态库原理</h3><p>动态库（共享库）的位置是相对位置（共享库段中哪里有空闲，就加载到哪里），静态库是绝对位置。a.out 执行后，动态连接器会自动调用使用的动态库。</p><p><img src="https://hutu.aimtao.net/mark/2021-01-31-5naH7x.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="3-7-优缺点">3.7 优缺点</h3><p><strong>（1）优点</strong></p><ul><li>执行程序体积小。（静态库会将被打包到 a.out 中，而动态库不会。）</li><li>动态库更新，不需要重新编译。</li></ul><p><strong>（2）缺点</strong></p><ul><li>发布程序时，需要单独给用户提供动态库。</li><li>动态库没有被打包到应用程序中，所以加载速度会比静态库慢一些。</li></ul><h2 id="4-gdb">4.gdb</h2><h3 id="4-1-gdb调试">4.1 gdb调试</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>gdb app</code></td><td>进入gdb调试</td></tr><tr><td>start</td><td>只执行第一步</td></tr><tr><td>n</td><td>next，下一步【将函数调用当成一步】</td></tr><tr><td>s</td><td>step，单步【进入到函数体内部】</td></tr><tr><td>finish</td><td>从函数体内部跳出【需先删去函数体内的断点】</td></tr><tr><td>c</td><td>continue，直接停在断点位置</td></tr><tr><td>u</td><td>退出当前循环</td></tr></tbody></table><p>如果 finish 命令报错，出现以下提示，表示需要删除函数体内的断点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">(gdb) finish <br>Run till <span class="hljs-built_in">exit</span> from <span class="hljs-comment">#0  select_sort (arr=0x7fffffffe300, len=10) at main.cc:26</span><br><br>Breakpoint 2, select_sort (arr=0x7fffffffe300, len=10) at main.cc:23<br>23                <span class="hljs-keyword">if</span> (arr[k] &gt; arr[j]) <br></code></pre></td></tr></table></figure><h3 id="4-2-查看代码">4.2 查看代码</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>l</td><td>list，【优先展现main函数】</td></tr><tr><td><code>l 10</code></td><td>当前文件第10行</td></tr><tr><td><code>l fun.cc:10</code></td><td><a target="_blank" rel="noopener" href="http://fun.cc">fun.cc</a> 的第10行</td></tr><tr><td><code>l fun.cc:My_fun</code></td><td><a target="_blank" rel="noopener" href="http://fun.cc">fun.cc</a> 的 My_fun 函数</td></tr></tbody></table><h3 id="4-3-设置断点">4.3 设置断点</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>b 10</code> 或 <code>break 10</code></td><td>第十行打断点</td></tr><tr><td><code>b main</code> 或 <code>break main</code></td><td>main 函数处打断点</td></tr><tr><td><code>b fun.cc:My_fun</code></td><td><a target="_blank" rel="noopener" href="http://fun.cc">fun.cc</a> 的 My_fun 函数处打断点</td></tr><tr><td><code>b 10 if i==10</code></td><td>第10行，i 等于 10 的时候才停</td></tr><tr><td><code>del 「断点的编号」</code>或<code>d「断点的编号」</code></td><td>删除断电</td></tr><tr><td><code>info b</code> 或 <code>i b</code></td><td>显示所有断点编号</td></tr></tbody></table><h3 id="4-4-查看变量">4.4 查看变量</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>p i</code> 或 <code>print i</code></td><td>查看变量 i 的值</td></tr><tr><td><code>ptype i</code> 或 <code>ptype i</code></td><td>查看变量 i 的类型</td></tr></tbody></table><h3 id="4-5-设置变量">4.5 设置变量</h3><p><strong>set var 变量名 = 值</strong>，直接跳到该状态。</p><p>例子：在for循环中，想直接看到当 i=10 的时候的结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> var i = 10<br></code></pre></td></tr></table></figure><h3 id="4-6-设置追踪变量">4.6 设置追踪变量</h3><p>跟踪变量，就是在每一步执行的时候，会显示 <strong>被跟踪变量</strong> 的值。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>display 编号</code></td><td>跟踪变量</td></tr><tr><td><code>undisplay 编号</code></td><td>取消跟踪变量</td></tr><tr><td><code>info display</code></td><td>查看追踪变量的编号</td></tr></tbody></table><h3 id="4-7-退出-gdb-调试">4.7 退出 gdb 调试</h3><p>quit</p><h2 id="5-makefile">5.makefile</h2><h3 id="5-1-命名">5.1 命名</h3><p>makefile 或者 Makefile</p><h3 id="5-2-规则简单格式">5.2 规则简单格式</h3><p><strong>（1）三要素</strong>：目标、依赖、命令</p><p><strong>（2）基本格式</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标:依赖</span><br>    编译命令<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">app:main.cc sub.cc mul.cc</span><br>    g++ main.cc sub.cc mul.cc -o app -I <span class="hljs-keyword">include</span> -L lib -l Mylib<br></code></pre></td></tr></table></figure><h3 id="5-3-多条规则">5.3 多条规则</h3><p><strong>问题</strong>：如果有很多的文件需要编译，当修改其中一个文件时，为了避免重新编译所有文件，将文件分开编译。</p><p><strong>解决</strong>：默认第一条的目标为终极目标，第一条规则的依赖如果不存在，就向下面的其他规则中查找。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">app:main.o sub.o add.o mul.o div.o</span><br>    g++ main.o sub.o add.o mul.o div.o -o app<br><br><span class="hljs-section">main.o:main.cc</span><br>    g++ main.cc -c<br><br><span class="hljs-section">sub.o:sub.cc</span><br>    g++ sub.cc -c<br><br><span class="hljs-section">add.o:add.cc</span><br>    g++ add.cc -c<br><br><span class="hljs-section">mul.o:mul.cc</span><br>    g++ mul.cc -c<br><br><span class="hljs-section">div.o:div.cc</span><br>    g++ div.cc -c<br></code></pre></td></tr></table></figure><pre><code class="mermaid">graph TD
A(终极目标 app) --&gt;|向下寻找依赖| B(main.o)
A --&gt;|向下寻找依赖| C(sub.o)
A --&gt;|向下寻找依赖| D(add.o)
A --&gt;|向下寻找依赖| E(mul.o)
A --&gt;|向下寻找依赖| F(div.o)
B --&gt;|向下寻找依赖| G(main.cc)
C --&gt;|向下寻找依赖| G1(sub.cc)
D --&gt;|向下寻找依赖| G2(add.cc)
E --&gt;|向下寻找依赖| G3(mul.cc)
F --&gt;|向下寻找依赖| G4(div.cc)
</code></pre><h3 id="5-4-原理">5.4 原理</h3><p><strong>（1）执行流程图</strong>：</p><pre><code class="mermaid">graph LR
A(生成目标) --&gt; B(依赖条件)
B --&gt;|存在| C(通过命令生成目标)
B --&gt;|不存在| D(寻找新规则用来生成依赖条件)
D --&gt;|&quot;依赖条件作为子目标 -- 向下寻找&quot;| A
</code></pre><p><strong>（2）问题：makefile 如何知道哪些文件被更新？</strong></p><ul><li><p>当修改其中一个文件时，使用 makefile 可以避免重新编译所有文件，只编译更改过的文件。</p></li><li><p>makefile 如何知道哪些文件被修改了，需要重新编译？</p></li></ul><p><strong>（3）实现</strong>：</p><p>比较 依赖 和 目标 最后修改的时间。【依赖必须比目标的生成时间更早】</p><p><strong>（4）更新流程图</strong>：</p><pre><code class="mermaid">graph LR
A(更新目标) --&gt;|检查| B(更新)
B --&gt;|检查| C(依赖)
B --&gt;|检查| D(依赖)
B --&gt;|检查| E(依赖)
B --&gt;|检查| F(新更改的依赖)
F --&gt;|&quot;依赖比目标新 -- 更新目标文件&quot;| A
</code></pre><h3 id="5-5-变量">5.5 变量</h3><p><strong>（1）普通变量</strong>：</p><p>格式：obj=main.o add.o sub.o mul.o</p><p>使用：$(obj)</p><p><strong>（2）makefile 的自动变量</strong>：</p><p><code>$&lt;</code>：规则中的第一个依赖</p><p><code>$@</code>：规则中的目标</p><p><code>$^</code>：规则中的所有依赖</p><p>PS：自动变量只能在命令中使用</p><p><strong>（3）实例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj=main.o add.o sub.o mul.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>    g++ <span class="hljs-variable">$(obj)</span> -o app<br><br><span class="hljs-section">%.o:%.cc</span><br>    g++ -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><code>g++ -c $&lt; -o $@</code> 表示 编译 第一个依赖（%.cc） 生成 目标（%.o）。</p><p><code>%.o:%.cc</code>：% 是匹配符号，main.o add.o sub.o mul.o 这些会自动匹配 %.o，并查找对应的 %.c 依赖。</p><p><strong>（4）makefile 维护的变量</strong>：</p><ul><li><p>makefile 中有一些自动维护的变量，均为大写。</p><ul><li>CC：gcc</li><li>CPPFLAGS：预处理器需要的选项，如 -I</li><li>CFLAGS：编译时使用的参数，如 -Wall -g -c</li><li>LDFLAGS：链接库使用的选项，如 -L -l</li></ul></li><li><p>用户可更改这些 makefile 维护的变量的默认值。</p></li><li><p>使用时，还是 $(CC)，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC=g++<br>CPPFLAGS=-I<br><span class="hljs-section">app:main.cc sub.cc mul.cc</span><br>    <span class="hljs-variable">$(CC)</span> main.cc sub.cc mul.cc -o app -I <span class="hljs-keyword">include</span> -L lib -l Mylib<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-6-函数">5.6 函数</h3><p><strong>（1）痛点</strong></p><p>在上面 5.5.(3) 的实例中，我们需要手动写 main.o add.o sub.o mul.o，如何避免写诸多的文件名？</p><p><strong>（2）解决</strong></p><p>使用函数，根据找到的 .cc 文件名，来自动生成 .o 的文件名。</p><p><strong>（3）实例</strong></p><p>主要解决变量 obj 后面要写太多文件名的问题。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.cc)</span>                  <span class="hljs-comment"># 查找所有 .cc 文件名，储存在 src 变量中。</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> ./%.cc, ./%.o, <span class="hljs-variable">$(src)</span>)</span>   <span class="hljs-comment"># 将 $(src) 中的文件名，全部替换成 .o 文件名，并储存在 obj 变量中。</span><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>    g++ <span class="hljs-variable">$(obj)</span> -o app<br><br><span class="hljs-section">%.o:%.cc</span><br>    g++ -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><code>src=$(wildcard ./*.cc)</code>：获取当前文件下的所有 .cc 文件。wildcard：n. 通配符。</p><p><code>obj=$(patsubst ./%.cc, ./%.o, $(src))</code>：将 src 中的所有 .cc 文件名替换成 .o 文件名，并传给 obj 做变量的值。patsubst：v.模仿。</p><p><strong>（4）格式</strong></p><p>以 <code>obj=$(patsubst ./%.cc, ./%.o, $(src))</code> 为例，obj 是返回值，patsubst 是函数名，<code>./%.cc, ./%.o, $(src)</code> 是参数，参数间用逗号分隔。</p><h3 id="5-7-clean">5.7 clean</h3><p><strong>（1）痛点</strong></p><p>当每次重新编译时，都需要先删除可执行文件，有没有办法可以自动在编译之前，删除过时的可执行文件呢？</p><p><strong>（2）解决</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.cc)</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> ./%.cc, ./%.o, <span class="hljs-variable">$(src)</span>)</span><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>    g++ <span class="hljs-variable">$(obj)</span> -o app<br><br><span class="hljs-section">%.o:%.cc</span><br>    g++ -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 以下代码是重点，只写目标、命令，没有依赖。</span><br><span class="hljs-section">clean:</span><br>    rm -rf app<br></code></pre></td></tr></table></figure><ul><li>直接 make，完成是终极目标，也就是第一行的目标。</li><li>如果要执行 clean 这个目标，可以使用 <code>make clean</code> 命令单独执行 clean 目标。</li></ul><p><strong>（3）伪目标声明</strong></p><ul><li><p>clean 这种目标 不会生成任何新文件，称为 <strong>伪目标</strong>。</p></li><li><p><strong>问题</strong>：当前目录下有一个叫 clean 的文件，如果我们执行 <code>make clean</code> 时，会报以下错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜~ <span class="hljs-built_in">touch</span> clean   <span class="hljs-comment"># 创建一个 clean 的同名文件。</span><br>➜~ make clean    <span class="hljs-comment"># 执行 make clean </span><br>make: “clean”是最新的。  <span class="hljs-comment"># 报错信息</span><br></code></pre></td></tr></table></figure></li><li><p><strong>原因</strong>：</p><ul><li><p>因为完成目标的过程中，会检查文件是否是最新的文件，如果文件是最新文件，便不会执行命令，完成目标。</p></li><li><p>执行 clean 目标 <strong>不会生成任何新文件</strong>， 那么当前目录下的同名文件 clean 永远是最新的，故不会完成 clean 目标。</p></li></ul></li><li><p><strong>解决</strong>：加入 <strong>伪目标声明</strong> 即可解决问题。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">./PHONY:clean</span><br><span class="hljs-section">clean:</span><br>    rm -rf app<br></code></pre></td></tr></table></figure></li></ul><p><strong>（4）忽略报错，继续执行</strong></p><p>当完成目标时，命令中有些会报错，比如下面的命令，如何 命令1报错后，命令2继续执行呢？</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">./PHONY:clean</span><br><span class="hljs-section">clean:</span><br>    rm  app             <span class="hljs-comment"># 命令1 报错</span><br>    echo “Finish clean” <span class="hljs-comment"># 命令2 继续执行</span><br></code></pre></td></tr></table></figure><p>只需要在命令1前加入 <code>-</code> 即可。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">./PHONY:clean</span><br><span class="hljs-section">clean:</span><br>    - rm  app             <span class="hljs-comment"># 命令1 报错</span><br>    echo “Finish clean” <span class="hljs-comment"># 命令2 继续执行</span><br></code></pre></td></tr></table></figure><p>结果如下，会忽略报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜~ make clean  <br><span class="hljs-built_in">rm</span>  app<br><span class="hljs-built_in">rm</span>: 无法删除<span class="hljs-string">&quot;app&quot;</span>: 没有那个文件或目录<br>make: [clean] 错误 1 (忽略)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Finish clean&quot;</span><br>Finish clean<br></code></pre></td></tr></table></figure><h3 id="5-8-其他目标">5.8 其他目标</h3><p>如同 clean 目标一样，我们还可以加入一些其他的自定义目标。</p><p>比如 hello 目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">./PHONY:hello</span><br><span class="hljs-section">hello:</span><br>    -echo <span class="hljs-string">&quot;welcome&quot;</span><br>    mkdir ./welcome<br></code></pre></td></tr></table></figure><p>只要 <code>make hello</code> 即可执行 hello 目标，也就是执行 <code>echo&quot;welcome&quot;</code> 命令。</p><h2 id="6-系统IO函数">6.系统IO函数</h2><blockquote><p>内核提供的函数。</p></blockquote><h3 id="6-1-C库函数">6.1 C库函数</h3><p>C库函数执行流程（用户层面）如下，重点：</p><ul><li>FILE* 指针：一个结构体，主要变量为文件描述符（FD）、文件读写指针位置（FP_POS）、IO缓冲区（BUFFER）。</li><li>先在内存中的IO缓冲区操作，再写入磁盘文件中。</li><li>文件描述符通过 inode 找到对应的磁盘文件。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-01-31-canTja.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="6-2虚拟地址空间">6.2虚拟地址空间</h3><p><strong>（1）大小</strong></p><ul><li><p>为什么操作系统为进程分配的虚拟地址空间是 4G？</p><p>因为 32 位系统中，2<sup>32</sup> 是 4G 大小。</p></li><li><p>0G-3G 是用户区，用户可使用。</p></li><li><p>3G-4G 是 Linux 内核区，不允许用户区操作。</p></li></ul><p><strong>（2）ELF</strong></p><ul><li><p>Linux 可执行程序的文件格式是 ELF。</p></li><li><p>ELF 段 = test 段 + data 段 + bss 段。</p></li><li><p>每次执行都是从 main 函数位置开始执行，即 test 段。</p></li></ul><p><strong>命令</strong>：file</p><p>可查看文件的文件格式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">file a.out<br><span class="hljs-comment"># 显示信息</span><br>a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="hljs-keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=654398ee82c59c781dead9831ea14d7944bd453e, not stripped<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2021-01-31-5naH7x.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（3）受保护的地址</strong></p><p>这个区域很小，用户不可操作，在 C 语言中，NULL 其实是宏定义，<code>#define NULL (void*)0</code> ，也就是说，空指针其实指的就是这个地址。</p><p>PS：在 C++ 中，由于不允许 void* 自动转换别的类型指针，所以 NULL 的宏定义是 <code>#define NULL 0</code>，为了消除二义性（比如函数重载），推荐使用nullptr。</p><p><strong>（4）虚拟地址空间作用</strong></p><ol><li><p>方便编译器和操作系统安排程序的地址分布。</p><p>程序可以使用 <strong>连续的虚拟地址空间</strong> 来访问物理内存中 不连续的内存缓冲区。</p></li><li><p>方便进程之间的隔离</p><p>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法修改正在由另外一个进程使用的物理内存。</p></li><li><p>方便操作系统使用稀缺的内存</p><p>程序可以是连续的虚拟地址空间，来访问比 <strong>可用物理内存</strong> 大的内存缓冲区。</p><p>当物理内存可用量变小时，内存管理会将物理内存页（通常大小为 4KB）保存到磁盘文件。数据或代码页会根据需要在内存和磁盘之间移动。</p></li></ol><h3 id="6-3-文件描述符表">6.3 文件描述符表</h3><ul><li>在内核区中，有一个 PCB 进程控制块，（每一个进程都有自己的 PCB 进程控制块）。</li><li>PCB 进程控制块有一个文件描述符表，文件描述符表本质上是一个数组，数组大小为 0-1023。文件描述度实际上是整型数。</li><li>每一个文件描述符对应着一个打开的文件。</li><li>第 0、1、2个默认打开的是标准输入（stdin）、标准输出（stdout）、标准错误（stderr）。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-01-31-J8d5DQ.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="6-4-C库函数和系统函数的关系">6.4 C库函数和系统函数的关系</h3><p><strong>（1）C库函数执行流程</strong></p><p>以 printf 函数为例，<strong>C库函数</strong> 将文件描述符、文件指针位置、缓冲区等参数传给系统 API，</p><ul><li>首先调用应用层的 <strong>系统函数</strong> write，由 write 进行系统调用，</li><li>系统调用函数 sys_write 调用设备驱动，此时操作的空间由用户空间转换为内核空间，</li><li>最后设备驱动函数操作硬件（显示器）。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-02-01-4YsY9B.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）效率比较</strong></p><p>方案一：write 和 read</p><p>方案二：getc 和 putc</p><p>每次都是读一个字符，写一个字符。请问哪个方案快？</p><p><strong>getc 和 putc 更快！</strong></p><p>原因：C库函数会自己维护一个缓冲区，减少写入内核区中的缓冲区的次数。</p><p>write 和 read：用户区 —&gt; 内核区的缓冲区 —&gt; 硬盘。每读写一个字符，都需要从 用户区 拷贝到 内核区。</p><p>getc 和 putc：c 库函数缓冲区 —&gt; 用户区 —&gt; 内核区的缓冲区 —&gt; 硬盘。C缓冲区读满了，再拷到 用户区，并一次性拷到 内核区。</p><h3 id="6-5-man手册不全">6.5 man手册不全</h3><p>举个例子：在 man 中查询 系统IO函数 open 的帮助，显示在第 2 节中没有关于 open 的手册页条目。</p><p>中文安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install manpages-zh <br></code></pre></td></tr></table></figure><p>切换英文。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">man -L en man<br></code></pre></td></tr></table></figure><h3 id="6-6-open">6.6 open</h3><p><strong>（1）介绍</strong></p><blockquote><p>man 2 open</p><p>2 表示帮助文档第二章节（系统调用，）</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;   <span class="hljs-comment">// 打开不存在的文件，即创建文件</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong>flags</strong>：打开方式：O_RDONLY、O_WRONLY、O_RDWR</li><li><strong>mode</strong>：权限</li><li><strong>可选性</strong>：O_CLOEXEC、O_CREAT、O_DIRECTORY、O_NOCTTY、O_NOFOLLOW、O_TRUNC、O_TTY_INI</li><li><strong>返回值</strong>：返回一个新的文件描述符（file descriptor），或者返回 -1 并更改 errno 的值。</li></ul><p><strong>（2）errno 变量</strong></p><ul><li>errno 是一个全局的变量，定义在 /usr/include/asm-generic/errno.h 文件（第1-34个错误定义）和 /usr/include/asm-generic/errno-base.h（第35-133个错误定义）中。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPERM            1      <span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOENT           2      <span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESRCH            3      <span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EINTR            4      <span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EIO              5      <span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENXIO            6      <span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E2BIG            7      <span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOEXEC          8      <span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EBADF            9      <span class="hljs-comment">/* Bad file number */</span></span><br>...<br></code></pre></td></tr></table></figure><ul><li>当调用系统IO函数出错时，该函数就重新设置 errno 的值。</li></ul><p><strong>（3）perror 函数</strong></p><ul><li><p>头文件：stdio.h</p></li><li><p>函数定义：void perror(const char* s)</p></li><li><p>函数作用：将 <strong>上一个函数发生错误的原因</strong> 输出到标准错误设备（stderr）</p></li><li><p><strong>上一个函数发生错误的原因</strong> 根据全局变量 <strong>errno</strong> 的值来决定。</p></li><li><p>会先打印出参数 s 所指字符串，再打印错误原因字符串。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;发生错误的原因：&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>（4）open 函数使用-O_RDWR</strong></p><p><strong>需求</strong>：打开已存在的文件 <a target="_blank" rel="noopener" href="http://hello.cc">hello.cc</a></p><ul><li>打开文件失败时，open 返回值（文件描述符）为 -1。</li><li>O_RDWR：权限为读写</li><li>注意头文件</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// close 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    <span class="hljs-comment">// perror 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>   <span class="hljs-comment">// exit 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> fd;<br><br>        <span class="hljs-comment">// 打开已存在的文件</span><br>        fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>, O_RDWR);<br>        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭文件</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">close</span>(fd);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）open 函数使用-O_CREAT</strong></p><p><strong>需求</strong>：创建新文件</p><ul><li>创建文件需三个参数，O_RDWR（可读写）、O_CREAT（创建）、0777（权限）</li><li>关于权限：虽然给定权限是 0777，但是文件实际权限是 <code>给定权限 - 本地掩码</code></li><li>关于掩码： 命令 <code>umask</code> 可以查看本地掩码，<code>umask 002</code> 可以更改本地掩码为 002。</li><li>举个例子：给定权限是 0777，本地掩码是 022，实际权限就是：0777-022=0755</li><li>实际过程是 <strong>本地掩码取反</strong> 后，和 <strong>给定文件权限</strong> 按位与。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// close 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    <span class="hljs-comment">// perror 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>   <span class="hljs-comment">// exit 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> fd;<br><br>        <span class="hljs-comment">// 创建不存在的新文件</span><br>        fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;new_hello.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭文件</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">close</span>(fd);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）open 函数使用-O_EXCL</strong></p><p><strong>需求</strong>：判断为文件是否存在</p><ul><li>O_CREAT 和 O_EXCL 同时使用。</li><li>在 创建 之前，如果文件存在，会更改 errno，可以用 perror 打印出来。</li><li>如果没有 O_EXCL，却有 O_CREAT，打开已存在的文件无提醒，并不更改已存在的文件内容。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// close 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    <span class="hljs-comment">// perror 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>   <span class="hljs-comment">// exit 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> fd;<br><br>        <span class="hljs-comment">// 判断文件是否存在</span><br>        fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;new_hello.txt&quot;</span>, O_RDWR | O_CREAT | O_EXCL, <span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭文件</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">close</span>(fd);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（7）open 函数使用-O_TRUNC</strong></p><p><strong>需求</strong>：将文件截断为0</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// close 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    <span class="hljs-comment">// perror 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>   <span class="hljs-comment">// exit 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> fd;<br><br>        <span class="hljs-comment">// 将文件截断为0</span><br>        fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;new_hello.txt&quot;</span>, O_RDWR | O_TRUNC);<br>        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭文件</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">close</span>(fd);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close file&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7-read">6.7 read</h3><p><strong>（1）介绍</strong></p><p>读取的内容，写入 buf，count 表示 buf 的大小。</p><p><code>ssize_t</code>：是有符号的 int。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（2）返回值</strong></p><ul><li>-1：读文件失败，并设置了 errno 的值，可以用 perror 打印。</li><li>0：文件读完（读到文件末尾、管道写端关闭、socket 对端关闭）</li><li>&gt;0：实际读取的字节数量</li></ul><h3 id="6-8-write">6.8 write</h3><p><strong>（1）介绍</strong></p><p>将 buf 的内容写入 fd 所指的文件。count 表示 buf 的大小。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（2）注意</strong></p><p>会覆盖原文件，但是不会清空。</p><h3 id="6-9-lseek">6.9 lseek</h3><p><strong>（1）用处</strong>：</p><ul><li><p>获取文件大小（同 fseek）</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> size = <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br><span class="hljs-comment">// 返回值 = 当前指针的位置</span><br></code></pre></td></tr></table></figure></li><li><p>移动文件指针（同 fseek）</p></li><li><p>拓展文件（fseek 没有的功能）：用无意义字符填充，扩展文件大小。</p><p>比如：拓展成为<strong>空洞文件</strong>。多线程下载一个 1G 大小的文件时，在开始下载时，便会生成一个 1G 大小的空洞文件，这样每个线程就知道写入的分别是哪个位置。</p></li></ul><p><strong>（3）注意</strong>：实现拓展文件，需要使用 lseek 函数之后，进行一次写操作 write。</p><p><strong>（4）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>off_t 是 int。返回值为当前指针的位置。</li><li>offset 是文件指针的偏移量。</li><li>whence 可以有三个值：<ul><li>SEEK_SET：开始位置</li><li>SEEK_CUR：当前位置</li><li>SEEK_END：结尾位置</li></ul></li></ul><p><strong>（5）拓展文件实例</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>  <span class="hljs-comment">// open 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>   <span class="hljs-comment">// open 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>      <span class="hljs-comment">// open 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>  <span class="hljs-comment">// close 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>   <span class="hljs-comment">// perror 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">// exit 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1.打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;aa&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.指定 偏移量 = 10，开始偏移位置 = SEEK_END</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">10</span>, SEEK_END);<br>    cout &lt;&lt; <span class="hljs-string">&quot;cur_file_length = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 3.做一次写操作</span><br>    <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-number">1</span>);<br>       <br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）实例：复制文件</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// close 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>    <span class="hljs-comment">// perror 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>   <span class="hljs-comment">// exit 的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 打开被读文件</span><br>        <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;a.out&quot;</span>, O_RDONLY);<br>        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error:&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>              <br>        <span class="hljs-comment">// 打开拷贝后文件</span><br>        <span class="hljs-type">int</span> fd1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;new&quot;</span>, O_CREAT | O_WRONLY, <span class="hljs-number">777</span>);<br>        <span class="hljs-keyword">if</span> (fd1 == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;creat_error:&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>              <br>        <span class="hljs-comment">// 循环拷贝</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">2048</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(res) &#123;<br>                <span class="hljs-built_in">write</span>(fd1, buf, res);<br>                cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;writed&quot;</span> &lt;&lt; endl;<br>                res = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>                        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>                 &#125;<br>        &#125;<br>              <br>        <span class="hljs-comment">// 关闭文件</span><br>        <span class="hljs-built_in">close</span>(fd);<br>        <span class="hljs-built_in">close</span>(fd1);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Linux-文件操作函数">7.Linux 文件操作函数</h2><h3 id="7-1-stat-命令">7.1 stat 命令</h3><p>打印信息节点（inode）内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">stat</span> lseek.cc<br><span class="hljs-comment"># 文件：&quot;lseek.cc&quot;</span><br><span class="hljs-comment"># 大小：473           块：8          IO 块：4096   普通文件</span><br><span class="hljs-comment"># 设备：fd00h/64768d    Inode：50638303    硬链接：1</span><br><span class="hljs-comment"># 权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="hljs-comment"># 环境：unconfined_u:object_r:admin_home_t:s0</span><br><span class="hljs-comment"># 最近访问：2021-01-26 21:16:08.927377109 +0800</span><br><span class="hljs-comment"># 最近更改：2021-01-26 21:16:06.094350595 +0800</span><br><span class="hljs-comment"># 最近改动：2021-01-26 21:16:06.098684097 +0800</span><br><span class="hljs-comment"># 创建时间：-</span><br></code></pre></td></tr></table></figure><p>PS：索引节点 inode：其本质为结构体 struct stat，存储文件的属性信息。这些信息被称为元数据。</p><p>元数据：文件大小，设备标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，链接数量，指向储存该数据的磁盘区块的指针，文件分类。</p><p>注意：数据分为 元数据 和 数据本身。</p><h3 id="7-2-stat-函数">7.2 stat 函数</h3><p><strong>（1）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 传入路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;  <span class="hljs-comment">// buf 为传出参数</span><br><span class="hljs-comment">// 传入文件描述符</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（2）权限属性</strong></p><p>在 struct stat 结构体中，有一个变量为：<code>mode_t st_mode;</code> 表示文件的类型和存取的权限。</p><p>一共 2 Byte，16位。</p><table><thead><tr><th>1-4bit</th><th>5-7bit</th><th>8-10bit</th><th>11-13bit</th><th>14-16bit</th></tr></thead><tbody><tr><td>文件类型</td><td>特殊权限位</td><td>User</td><td>Group</td><td>Others</td></tr></tbody></table><p>**举个例子，**如果想拿到 User 的权限信息，就需要使用掩码 S_IRWXU 00700 做按位与操作。</p><p>00700 = 000 000 111 000 000</p><p>刚好拿到的是 User 权限所对应的 三位（读、写、执行）。</p><p>如果再想获得读的权限，需要使用掩码 S_IRGRP 00400 做按位与操作。</p><p>00400 = 000 000 100 000</p><p>刚好拿到 读权限 的那一位。</p><p>PS：其中文件类型和权限同理，需要 st_mode 先与 S_IFMT 0170000 做按位与操作，过滤 st_mode 中除文件类型以外的信息。判断与所对应宏是否相等。</p><p>比如：</p><ul><li>S_IFSOCK 0140000 套接字</li><li>S_IFNK 0120000 符号链接</li><li>S_IFREG 0100000 普通文件</li><li>…</li></ul><p><strong>（3）实例：获取文件 size 属性</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断参数是否正确</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out filename&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 建立结构体空间（传出参数）</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> ans;<br><br>    <span class="hljs-comment">// 获取节点信息</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">lstat</span>(argv[<span class="hljs-number">1</span>], &amp;ans);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;  <br>    <br>    <span class="hljs-comment">// 打印传出参数的变量</span><br>    <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)ans.st_size;   <span class="hljs-comment">// 返回值是 off_t，需要强制转换为 int</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;size = &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="7-3-lstat-函数">7.3 lstat 函数</h3><p>stat 和 lstat 区别：</p><ul><li>stat：追踪函数，st_size 是软连接所指向的文件的大小。</li><li>lstat：不追踪，st_size 是软连接文件的大小。</li></ul><p>举个例子：</p><ul><li>ls -l、rm：不追踪命令</li><li>vi：追踪命令</li></ul><h3 id="7-4-access-函数">7.4 access 函数</h3><p><strong>（1）介绍</strong></p><p>测试指针文件是否拥有某种权限。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>pathname：文件名</p></li><li><p>mode：权限类别</p><ul><li>R_OK：是否拥有读权限</li><li>W_OK：是否有些权限</li><li>X_OK：是否有执行权限</li><li>F_OK：测试一个文件是否存在</li></ul></li><li><p>返回值：</p><ul><li>0：所有检查的权限都通过了测试</li><li>-1：有权限被禁止</li></ul></li></ul><p><strong>（2）实例：测试是否拥有执行权限</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out filename&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">access</span>(argv[<span class="hljs-number">1</span>], X_OK);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;access&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    cout &lt;&lt; <span class="hljs-string">&quot;You can write this flie&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="chmod"></a></p><h3 id="7-5-chmod-函数">7.5 chmod 函数</h3><p><strong>（1）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;  <span class="hljs-comment">// 传文件路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">mode_t</span> mode)</span></span>;  <span class="hljs-comment">// 传文件描述符</span><br></code></pre></td></tr></table></figure><ul><li><p>mode_t mode：同<code>int open(const char *pathname, int flags, mode_t mode);</code></p><p>如果指定权限为 0777， 则不需要权限与取反后掩码进行按位与操作。</p></li></ul><p><strong>（2）实例：更改文件权限</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out filename&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br><br>    <span class="hljs-comment">// 将文件权限修改成 0777</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">chmod</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;chmod&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）问题</strong></p><p>在上面实例中，<code>chmod(argv[1], 0777)</code> ，0777 是写进程序的，如果想要改变，需要重新编译，可不可以通过参数传入？</p><p>可以，但要注意 <strong>参数是字符串</strong>，<strong>chmod 形参是八进制数</strong>。需要使用 strtol 函数进行转换，用法见 <a href="#strtol函数">strtol 函数</a>。</p><p><strong>（4）实例：利用 strtol 函数为 chmod 函数传入权限</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 对参数个数进行判断，防止越界</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out file_name limit_num&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获取权限，将字符串转化为八进制数字</span><br>    <span class="hljs-type">int</span> limit_num = <span class="hljs-built_in">strtol</span>(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 更改权限</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">chmod</span>(argv[<span class="hljs-number">1</span>], limit_num);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;chmod&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="strtol函数"></a></p><h3 id="7-6-strtol-函数">7.6 strtol 函数</h3><p><strong>（1）介绍</strong></p><p>字符串转化为整型。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">strtol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *nptr, <span class="hljs-type">char</span> **endptr, <span class="hljs-type">int</span> base)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>const char *nptr：0777，待转换的字符串</li><li>char **endptr：NULL，忽略</li><li>int base：8，表示八进制</li></ul><p><strong>（2）实例：将 0777 转换为 int 数值</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CC"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>            <br>    cout &lt;&lt; <span class="hljs-built_in">strtol</span>(<span class="hljs-string">&quot;755&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;   <span class="hljs-comment">// 493，直接打印，会按照十进制打印出来。</span><br>    cout &lt;&lt; <span class="hljs-built_in">strtol</span>(<span class="hljs-string">&quot;argv[1]&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>： <code>cout &lt;&lt; strtol(&quot;755&quot;, NULL, 10) &lt;&lt; endl;</code> 流程如下：</p><ul><li>将字符串 “755” 转化为整型 755（八进制 OCT）。</li><li>将八进制 755 转换为十进制 493 打印。</li></ul><h3 id="7-7-chown-函数">7.7 chown 函数</h3><p><strong>（1）介绍</strong></p><p>更改所有者。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;            <span class="hljs-comment">// 跟踪软连接</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;  <span class="hljs-comment">// 不跟踪软链接</span><br></code></pre></td></tr></table></figure><ul><li><code>uid_t owner</code>：所有者的 uid。</li><li><code>gid_t group</code>：所属组的 gid。</li></ul><p><strong>（2）查看 uid 和 gid</strong></p><ul><li>以第 4 行为例，3 代表 uid， 4代表 gid。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/passwd<br><span class="hljs-comment">#   登录名:加密后的密码:uid:gid:用户名:用户主目录</span><br><span class="hljs-comment"># 1 root:x:0:0:root:/root:/bin/zsh</span><br><span class="hljs-comment"># 2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="hljs-comment"># 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="hljs-comment"># 4 adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="hljs-comment"># 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="hljs-comment"># 6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="hljs-comment"># 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="hljs-comment"># 8 halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="hljs-comment"># 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="hljs-comment">#10 operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="hljs-comment">#11 games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="hljs-comment">#12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="hljs-comment">#13 nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p><strong>（3）实例：更改所属信息</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out filename&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    <span class="hljs-comment">// 更改所有者和所属组</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">chown</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-number">1001</span>, <span class="hljs-number">1001</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;chown&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-8-truncate-函数">7.8 truncate 函数</h3><p>专门做函数扩展的函数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#incldue <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>off_t length</code> ：指定文件大小。<ul><li>length &gt; 源文件size，扩展成空洞文件。</li><li>length &lt; 源文件size，截断文件，后面的字符全部截断。</li></ul></li><li>返回值：0 --&gt; 成功，-1 --&gt; 失败。</li></ul><h3 id="7-9-link-函数">7.9 link 函数</h3><p>创建一个硬连接。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* newpath)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="7-10-symlink-函数">7.10 symlink 函数</h3><p>创建一个软连接。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* newpath)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="7-11-readlink-函数">7.11 readlink 函数</h3><p>读出软连接，读到的内容为：软连接所指文件的路径。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsize)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>char *buf</code>：传出参数，内容为软连接所指文件的路径。</li><li><code>const char *path</code>：软连接的路径。</li></ul><h3 id="7-12-unlink-函数">7.12 unlink 函数</h3><p><strong>（1）作用</strong>：</p><ul><li><p>unlink 软连接：删除一个软链接。</p></li><li><p>unlink 普通文件：也就是 unlink 硬链接。硬链接计数减 1，当减为0，释放数据块和 inode。</p></li><li><p>制作临时文件</p><p>创建一个新的文件，并使用 unlink 释放该文件，文件就会被自动释放。（用于缓存）</p></li></ul><p><strong>（2）介绍</strong>：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（3）实例：创建缓存文件，并自动清理</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">//创建新文件 </span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tempfile&quot;</span>, O_CREAT | O_RDWR, <span class="hljs-number">777</span>);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;  <br>    <span class="hljs-comment">// 释放硬链接（普通文件），但是此时该文件被进程使用，所以不会立刻释放空间。</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">unlink</span>(<span class="hljs-string">&quot;tempfile&quot;</span>);<br>    <span class="hljs-comment">// 写入内容</span><br>    <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">5</span>); <br>    <span class="hljs-comment">// 重置指针</span><br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-comment">// 将临时文件中的内容读入到 buf。</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-comment">// 将 buf 的内容写入 标准输出（文件描述符 1）</span><br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, buf, len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-13-rename-函数">7.13 rename 函数</h3><p>修改文件命名。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* newpath)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="8-目录操作函数">8.目录操作函数</h2><h3 id="8-1-chdir-函数">8.1 chdir 函数</h3><p>将当前进程的路径改为 path。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功 --&gt; 0，失败 --&gt; -1。</li></ul><h3 id="8-2-getcwd-函数">8.2 getcwd 函数</h3><p>获取当前进程工作目录。类似于 pwd。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>将当前进程所在路径写入 buf 当中。</p><h3 id="8-3-mkdir-函数">8.3 mkdir 函数</h3><p>创建目录。注意：目录需要有执行权限才能打开。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>mode_t mode</code> ：同 <a href="#chmod">chmod</a></li></ul><h3 id="8-4-opendir-函数">8.4 opendir 函数</h3><p>打开目录。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：<ul><li>DIR 结构指针，该结构是一个内部结构，保存所打开的目录信息，作用类似于 FILE 结构。</li><li>函数出错返回 NULL。</li></ul></li></ul><h3 id="8-5-readdir-函数">8.5 readdir 函数</h3><p>读目录。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dirp);<br></code></pre></td></tr></table></figure><ul><li>返回值：返回一条记录项 struct dirent，含有变量如下。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> &#123;<br>    <span class="hljs-type">ino_t</span> d_ino;  <span class="hljs-comment">// 此目录进入点的 inode</span><br>    <span class="hljs-type">ff_t</span> d_off;   <span class="hljs-comment">// 目录文件开头至此目录进入点的位移，就是 off_t 类型，表示偏移量，进入到第几层了</span><br>    <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> d_reclen;  <span class="hljs-comment">// d_name 的长度，不包括 NULL 字符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;    <span class="hljs-comment">// d_name 所指的文件类型</span><br>    har d_name[<span class="hljs-number">256</span>];    <span class="hljs-comment">// 文件名</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中，d_type 的类型。</li></ul><table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>DT_BLK</td><td>块设备</td></tr><tr><td>DT_CHR</td><td>字符设备</td></tr><tr><td>DT_DIR</td><td>目录</td></tr><tr><td>DT_LNK</td><td>软连接</td></tr><tr><td>DT_FIFO</td><td>管道</td></tr><tr><td>DT_REG</td><td>普通文件</td></tr><tr><td>DT_SOCK</td><td>套接字</td></tr><tr><td>DT_UNKNOWN</td><td>未知</td></tr></tbody></table><h3 id="8-6-closedir-函数">8.6 closedir 函数</h3><p>关闭目录。</p><h3 id="8-7-递归读目录获取文件个数">8.7 递归读目录获取文件个数</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getFileNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *root)</span> </span>&#123;<br>    <span class="hljs-comment">// 打开文件</span><br>    DIR* dir = <span class="hljs-literal">NULL</span>;<br>    dir = <span class="hljs-built_in">opendir</span>(root);<br>    <span class="hljs-keyword">if</span> (!dir) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;opendir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    <br>    &#125;   <br>        <br>            <br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span>* ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// 循环遍历当前目录</span><br>    <span class="hljs-keyword">while</span> ( (ptr = <span class="hljs-built_in">readdir</span>(dir)) != <span class="hljs-literal">NULL</span> ) &#123; <br>                <br>        <span class="hljs-comment">// 过滤 . 和 .. 目录</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(ptr-&gt;d_name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(ptr-&gt;d_name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <br>            <br>            <span class="hljs-comment">// 遍历到目录，递归进入</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr-&gt;d_type == DT_DIR) &#123;<br>            <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s/%s&quot;</span>, root, ptr-&gt;d_name);<br>            total += <span class="hljs-built_in">getFileNum</span>(buf); <br>        &#125; <br>            <br>            <span class="hljs-comment">// 遍历到普通文件或连接文件，计数</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr-&gt;d_type == DT_REG || ptr-&gt;d_type == DT_LNK) &#123;<br>            total++;<br>        &#125;       <br>    &#125;   <br>            <br>    <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-built_in">closedir</span>(dir);<br>    <span class="hljs-keyword">return</span> total; <br>&#125;       <br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 防止越界</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;./a.out Filename&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获取文件总数</span><br>    <span class="hljs-type">int</span> total = <span class="hljs-built_in">getFileNum</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, total);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-8-dup-和-dup2">8.8 dup 和 dup2</h3><p>复制文件描述符。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>dup 返回值：返回文件描述符中没有被占用的最小的文件描述符。</p></li><li><p>dup2 返回值：返回 newfd 的值。</p></li><li><p>情况分析：</p><ul><li>newfd 是一个被打开的文件描述符，在拷贝前先关掉 new。</li><li>oldfd 和 newfd 是一个文件描述符。不会关闭 new，直接返回 old。</li></ul></li><li><p>复制之后，两个文件描述符会指向同一个文件：</p><ul><li>两个文件描述符指向一个文件，但是文件指针只有一个。举个例子：如果通过一个文件描述符写入内容，不人工移动文件指针；另一个文件描述符再写入的时候，因为文件指针在末尾，所以会追加写入。</li></ul></li></ul><h3 id="8-9-fcntl-函数">8.9 fcntl 函数</h3><p><strong>（1）作用</strong></p><ul><li><p>复制现有的文件描述符</p></li><li><p>获取/设置文件描述符的标记</p></li><li><p>获取/设置异步IO所有权</p></li><li><p>获取/设置记录锁</p></li><li><p>【重要】获取/设置文件状态标记（可修改已经打开的文件权限）</p><p>比如：打开文件的时候：只读；修改文件的权限：追加 O_APPEND</p></li></ul><p><strong>（2）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：<ul><li>获取状态失败 --&gt; -1;</li><li>获取状态成功 --&gt; 0;</li></ul></li></ul><p><strong>（3）F_GETFL：获取文件状态</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> flag = <span class="hljs-built_in">fcntl</span>(my_fd, F_GETFL, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 获取状态时，arg 参数置 0 即可。</span><br></code></pre></td></tr></table></figure><p>cmd 参数：</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读打开</td></tr><tr><td>O_WRONLY</td><td>只写打开</td></tr><tr><td>O_RDWR</td><td>读写打开</td></tr><tr><td>O_EXEC</td><td>执行打开</td></tr><tr><td>O_SEARCH</td><td>搜索打开目录</td></tr><tr><td>O_APPEND</td><td>追加写（不会覆盖）</td></tr><tr><td>O_NONBLOCK</td><td>非阻塞模式</td></tr></tbody></table><p><strong>（4）F_SRTFL：更改文件状态</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 获取文件状态</span><br><span class="hljs-type">int</span> flag = <span class="hljs-built_in">fcntl</span>(my_fd, F_GETFL, <span class="hljs-number">0</span>); <br><br><span class="hljs-comment">// 修改状态</span><br>flag |= O_APPEND;<br><br><span class="hljs-comment">// 修改文件状态</span><br><span class="hljs-built_in">fcntl</span>(my_fd, F_SRTFL, flag);   <span class="hljs-comment">// 设置状态时，arg 参数 传入 flag（被更改的状态）。</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>可更改的宏</th><th>含义</th></tr></thead><tbody><tr><td>O_APPEND</td><td>追加写</td></tr><tr><td>O_NONBLOCK</td><td>非阻塞模式</td></tr></tbody></table><h2 id="9-进程管理">9.进程管理</h2><h3 id="9-1-程序与进程">9.1 程序与进程</h3><ul><li>程序：二进制文件，占用磁盘空间。</li><li>进程：启动的程序。<ul><li>所有数据都在内存。</li><li>需要占用更多的系统资源：CPU、物理内存。</li></ul></li></ul><h3 id="9-2-并行和并发">9.2 并行和并发</h3><ul><li>并行：两个或者多个事件在 <em><strong>同一时刻</strong></em> 发生。</li><li>并发：两个或者多个事件在 <em><strong>同一个时间间隔</strong></em> 发生。</li></ul><p>例如：</p><p>【并行】一边听课一边记笔记：听 和 记 同一个时刻发生。</p><p>【并发】先听课再记笔记：在同一个时间段完成两个事件。</p><p><img src="https://hutu.aimtao.net/mark/2020-08-29-i8399v.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="9-3-PCB">9.3 PCB</h3><p>每个进程都有一个 <strong>虚拟内存空间</strong>，虚拟内存空间中有 <strong>内核区</strong>， 内核区中有一个 <strong>进程控制块</strong>（PCB）。</p><p><strong>进程控制块</strong>（PCB）：一个结构体 struct task_struct。</p><ul><li><p>进程id：系统每个进程有唯一的id。C 语言中用 pid_t 类型表示，其实是一个非负整数。</p></li><li><p>进程的状态：就绪、运行（执行）、阻塞（挂起）、终止、初始（创建）。</p></li><li><p>进程切换时需要保存和恢复的寄存器。</p></li><li><p>描述虚拟地址空间的信息。（MMU 会将虚拟内存映射到物理内存）</p></li><li><p>描述控制终端的信息。</p></li><li><p>当前工作目录（Current Working Directory）。</p></li><li><p>umask掩码。</p></li><li><p>文件描述符表，包含很多指向file结构体的指针。</p></li><li><p>和信号相关的信息。</p></li><li><p>用户id和组id。</p></li><li><p>会话（Session）和进程组。</p></li><li><p>进程可以使用的资源上限（Resource Limit）。</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ulimit</span> -a  <br><span class="hljs-comment"># -t: cpu time (seconds)              unlimited</span><br><span class="hljs-comment"># -f: file size (blocks)              unlimited</span><br><span class="hljs-comment"># -d: data seg size (kbytes)          unlimited</span><br><span class="hljs-comment"># -s: stack size (kbytes)             8192  【栈空间】</span><br><span class="hljs-comment"># -c: core file size (blocks)         0</span><br><span class="hljs-comment"># -m: resident set size (kbytes)      unlimited</span><br><span class="hljs-comment"># -u: processes                       3796</span><br><span class="hljs-comment"># -n: file descriptors                1024 【文件描述符表的上限】</span><br><span class="hljs-comment"># -l: locked-in-memory size (kbytes)  64</span><br><span class="hljs-comment"># -v: address space (kbytes)          unlimited</span><br><span class="hljs-comment"># -x: file locks                      unlimited</span><br><span class="hljs-comment"># -i: pending signals                 3796</span><br><span class="hljs-comment"># -q: bytes in POSIX msg queues       819200</span><br><span class="hljs-comment"># -e: max nice                        0</span><br><span class="hljs-comment"># -r: max rt priority                 0</span><br><span class="hljs-comment"># -N 15:                              unlimited</span><br></code></pre></td></tr></table></figure><h3 id="9-4-进程状态">9.4 进程状态</h3><p>进程的状态：就绪、运行（执行）、阻塞（挂起）、终止、初始（创建）。</p><p><img src="https://hutu.aimtao.net/mark/2020-09-01-QKOZFt.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="9-5-fork-函数">9.5 fork 函数</h3><p><strong>（1）作用</strong></p><p>创建子进程。</p><p><strong>（2）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br></code></pre></td></tr></table></figure><ul><li>返回值：有两个返回值。当 fork 成功时，就会有两个相同的进程，也就意味着有两个 fork 函数，父子进程的 fork 函数返回值不一样。<ul><li>父进程：成功返回子进程的 PID。</li><li>子进程：成功返回 0。</li><li>失败：父进程返回一个负值。</li></ul></li></ul><p><strong>（3）关系</strong></p><ul><li>子进程是父进程的拷贝。</li><li>子进程和父进程的 <strong>用户区</strong> 数据相同，<strong>内核区</strong> 不同。（唯一的不同是：内核区中的PCB中的PID不一样）</li></ul><p><strong>（4）子进程执行的位置</strong></p><p>从 fork 函数执行后的位置开始执行。以下列代码为例，子进程从第4行开始执行。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;begin fork&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 父进程</span><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;parent process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// 子进程</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;child process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; pid &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）父子进程的执行顺序</strong></p><p>不一定，谁抢到 CPU，谁先执行。</p><p>可以在代码中添加 <code>sleep(1)</code> 来测试。（sleep 会使进程让出 CPU）</p><p><strong>（6）shell 切换时刻提前</strong></p><p>当父进程执行完成，shell 会切换到前台，此时子进程还没执行完，依旧会在打印内容。会出现以下情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  fork ./a.out<br>parent process, pid = 39744<br>39745<br>i = 0<br>i = 1<br>i = 2<br>i = 3<br>child process, pid = 1<br>➜  fork 0                 <span class="hljs-comment"># 父进程结束，shell 切换到前台，打印出终端提示符，此时子进程还在输出内容。</span><br>i = 0<br>i = 1<br>i = 2<br>i = 3                     <span class="hljs-comment"># 子进程结束完毕，不会有终端提示符（已打印过）</span><br></code></pre></td></tr></table></figure><p><strong>（7）log 输出顺序不能代表执行顺序</strong></p><p>可能一个进程先执行，并且先执行一大批代码后，sleep了，只是没有打印 log。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;这里代表一大堆业务代码&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 执行完一大批代码后 sleep 了。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;parent process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;child process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br># 结果：<br># 这里代表一大堆业务代码<br><span class="hljs-meta"># child process, pid = 21642</span><br><span class="hljs-meta"># parent process, pid = 21641</span><br></code></pre></td></tr></table></figure><h3 id="9-6-getpid-函数">9.6 getpid 函数</h3><p>获取当前进程的 id。</p><h3 id="9-7-getppid-函数">9.7 getppid 函数</h3><p>获取父进程的 id。</p><p><strong>ppid = 1的问题</strong></p><p>当父进程执行结束时，子进程就会变成僵尸进程，僵尸进程的 ppid = 1。</p><p>为避免 ppid = 1 的情况，可以使用 sleep 函数使父进程让出 CPU。</p><h3 id="9-8-循环创建子进程">9.8 循环创建子进程</h3><p><strong>（1）不阻止子进程 fork</strong></p><p>如果循环三次，会创建8个进程。</p><p>2<sup>3</sup> = 8。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        pid = fork(); <br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hutu.aimtao.net/mark/2021-02-08-YhNnVk.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（2）阻止子进程 fork</strong></p><p>父进程只会创建三个子进程。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        pid = fork(); <br>        <span class="hljs-keyword">if</span> (!pid) &#123;    <span class="hljs-comment">// 阻止子进程 fork</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）判断是第几个子进程</strong></p><p>一定要 sleep 父进程，否则子进程就可能为僵尸进程，ppid = 1。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 循环创建进程</span><br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        pid = fork(); <br>        <span class="hljs-keyword">if</span> (!pid) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>      <br>    <span class="hljs-comment">// 判断是第几个进程</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;First process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getppid</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Second process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getppid</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Three process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getppid</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 【一定要 sleep 父进程，否则子进程的 ppid 就可能为 1】</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Father process, pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-9-ps-和-kill">9.9 ps 和 kill</h3><p>见 <a href="https://www.aimtao.net/linux#十五、进程管理">学习笔记｜Linux｜十五、进程管理 </a>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps ajx <br></code></pre></td></tr></table></figure><p>可以查看父进程PPID、进程组PGID、会话SID</p><p><strong>注意</strong>：能查出结果，不一定存在进程。（可能是 grep 进程）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps aux | grep process_name<br><span class="hljs-comment"># root  24013   0.0  0.0  4268408  576 s002  R+ 1:13  0:00.00 grep --color=auto process_name</span><br></code></pre></td></tr></table></figure><h3 id="9-10-进程组和会话">9.10 进程组和会话</h3><p>进程组：多个进程</p><p>会话：多个进程组</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;   <span class="hljs-comment">// 获取进程组id</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getsid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;    <span class="hljs-comment">// 获取会话id</span><br></code></pre></td></tr></table></figure><h3 id="9-11-进程间的数据共享">9.11 进程间的数据共享</h3><blockquote><p>先讲结论：<strong>各进程的数据完全独立，读时共享，写时复制</strong></p></blockquote><p><strong>（1）问题：变量独立，地址为什么相同</strong></p><p>如下代码，通过修改 num 变量，发现父子进程的 num 变量是相互独立的，为什么 num 的地址值却相等？</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        num = <span class="hljs-number">5</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father_process: num = &quot;</span> &lt;&lt; num  &lt;&lt; <span class="hljs-string">&quot; &amp;num = &quot;</span> &lt;&lt; &amp;num &lt;&lt; endl; <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        num = <span class="hljs-number">6</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sun_process: num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &amp;num = &quot;</span> &lt;&lt; &amp;num &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// father_process: num = 5 &amp;num = 0x7ffee19317b8</span><br><span class="hljs-comment">// sun_process: num = 6 &amp;num = 0x7ffee19317b8</span><br></code></pre></td></tr></table></figure><p><strong>（2）解决：因为虚拟内存空间</strong></p><ul><li>父子进程都有自己的一份虚拟地址空间，相互独立。</li><li>&amp;num 打印的是虚拟地址空间，而不是真正的物理内存。只代表在当前 虚拟地址空间 中的位置，因为 num 是在 fork 之前就初始化的，所以父子进程的 num 在 虚拟地址空间 中的位置相同。</li><li>虚拟内存空间，实际映射到一个物理内存上。</li></ul><p><strong>重点：读时共享、写时复制</strong></p><ul><li>对于 <strong>读操作</strong>，父子进程中的 num 会映射到物理内存中的同一个地方【好处：节省空间，提高效率】。</li><li>父进程发生 <strong>写操作</strong>，物理内存会拷贝一份 num 变量，供父进程写入。</li><li>子进程发生 <strong>写操作</strong>，物理内存会拷贝一份 num 变量，供子进程写入。</li><li>PS：复制时，不会调用拷贝构造。猜测是物理层面上的拷贝。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-02-09-wG7sUe.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="9-12-execl-函数族">9.12 execl 函数族</h3><blockquote><p>在进程中调用其他程序。</p></blockquote><p><strong>（1）问题</strong></p><p>父子进程分别执行不同的操作，需要判断。如果把多个父子进程的业务逻辑全部写在一个文件中，不好控制。</p><p><strong>（2）解决</strong></p><p><strong>execl 函数族</strong>：替换进程地址空间中的源代码（.txt段）。</p><p><strong>（3）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ..., <span class="hljs-literal">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>path：需要执行的程序的绝对路径（建议）。</li><li>变参 arg：占位符 + 需要执行的程序所需的参数。<ul><li>第一个 arg：占位符，随便写什么，一般写成执行程序的名字。</li><li>后面的 arg：需要执行的程序所需的参数。</li></ul></li><li>参数列表最后加上 NULL。</li><li>返回值：失败返回 -1，但是使用不到。<ul><li>成功：text 段被替换，没办法执行对返回值的判断。</li><li>失败：直接用 perror 打印保存信息即可。</li></ul></li></ul><p>PS：一般执行自己写的程序。</p><p><strong>（4）实例</strong></p><p>子进程调用 ls 命令。</p><p><strong>注意</strong>： 子进程 execl 替换程序后，子进程不会执行之后的代码。</p><p><strong>注意</strong>： 新程序不会开辟新的地址空间，直接使用子进程的地址空间。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Test of exec...&quot;</span> &lt;&lt; std::endl; <br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 绝对路径。</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Father process end.&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 会执行</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Sun process end.&quot;</span> &lt;&lt; std::endl;    <span class="hljs-comment">// 不会执行，因为代码已被替换</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）调用其他程序失败</strong></p><p>如果执行成功不会 text 代码被替换，第 2 行代码不会执行。如果执行了判断，也意味着调用其他程序失败。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 多此一举的判断</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execl&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 争取的写法</span><br><span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execl&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="9-13-execlp-函数">9.13 execlp 函数</h3><blockquote><p>和 execl 的区别在于，execlp 执行的是 PATH 环境变量中能够搜索到的程序。</p></blockquote><p><strong>（1）介绍</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ..., <span class="hljs-literal">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>file： PATH 环境变量中能够搜索到的程序名称，不需要指定路径。</p></li><li><p>其他参数：同 execl。</p></li><li><p>返回值：同 execl。</p></li><li><p>注意：执行系统自带的程序（通过PATH变量查找）。如果一定执行自定义程序，必须绝对路径。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Test of exec...&quot;</span> &lt;&lt; std::endl; <br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>);   <span class="hljs-comment">// 直接写程序名称。</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Father process end.&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 会执行</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Sun process end.&quot;</span> &lt;&lt; std::endl;    <span class="hljs-comment">// 不会执行，因为代码已被替换</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-14-孤儿进程">9.14 孤儿进程</h3><p><strong>（1）孤儿进程的始终</strong></p><ul><li><p>父进程 fork 子进程。</p></li><li><p>父进程结束，子进程还在。子进程就叫做孤儿进程。</p></li><li><p>孤儿进程被 init 进程管理，init 进程成为了孤儿进程的父进程。</p></li></ul><p><strong>（2）问题：为什么 init 进程要领养孤儿</strong></p><ul><li>进程结束后，才能释放用户空间。</li><li>但是无法释放内核区的 PCB。</li><li>PCB 必须由父进程来释放。</li></ul><p><strong>（3）实例</strong></p><ul><li>让子进程 sleep，父进程执行结束后，子进程就变成了孤儿进程。</li><li>在父进程执行前后，打印子进程的 ppid，查看 ppid 的变化。<ul><li>父进程结束前，子进程的 ppid 为父进程的 pid</li><li>父进程结束后，子进程的 ppid 为 1，表示 init 进程领养了孤儿进程，init 进程成为了 子进程的父进程。</li></ul></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent process is end. &quot;</span> &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun process is end. &quot;</span> &lt;&lt; <span class="hljs-string">&quot;ppid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getppid</span>() &lt;&lt; endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sun process is end. &quot;</span> &lt;&lt; <span class="hljs-string">&quot;ppid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getppid</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Sun process is end. ppid = 50902    // 父进程结束前，子进程的 ppid 为父进程的 pid</span><br><span class="hljs-comment">// Parent process is end. pid = 50902 </span><br><span class="hljs-comment">// Sun process is end. ppid = 1        // 父进程结束后，子进程的 ppid 为 1，表示 init 进程领养了孤儿进程，init 进程成为了 子进程的父进程。</span><br></code></pre></td></tr></table></figure><h3 id="9-15-僵尸进程">9.15 僵尸进程</h3><p><strong>（1）僵尸进程的始终</strong></p><ul><li>父进程 fork 子进程。</li><li>子进程结束，父进程还在。</li><li>父进程不释放子进程的 PCB。子进程就叫做僵尸进程。</li></ul><p>PS：僵尸进程是死掉的进程。kill 无法杀死僵尸进程。</p><p><strong>（2）实例</strong></p><ul><li>让父进程一直在忙，无限循环打印 1。父进程没有机会释放子进程的PCB控制块。</li><li>子进程结束后，成为僵尸进程。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;1 &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>)    <span class="hljs-comment">// 为避免一直打印，每七睡眠和刷新缓冲区。</span><br>                <span class="hljs-built_in">fflush</span>(stdout);<br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Sun process end.&quot;</span> &lt;&lt; endl;   <span class="hljs-comment">// 子进程结束。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进程后面显示 &lt;defunct&gt;，并显示 STAT = Z+，即代表僵尸进程。</p><p>PS：zombie 表示僵尸，Z+ 中的 Z 就是 zombie 的缩写。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps ajx | grep a.out<br><span class="hljs-comment"># 58824  61407  61407  58824 pts/0     61407 S+       0   0:00 ./a.out</span><br><span class="hljs-comment"># 61407  61408  61407  58824 pts/0     61407 Z+       0   0:00 [a.out] &lt;defunct&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-16-进程回收">9.16 进程回收</h3><p><strong>（1）wait 阻塞函数</strong></p><p>阻塞条件：子进程死亡。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>* status)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：<ul><li><p>-1：回收失败，代表没有子进程了。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 可以利用 返回值 做循环条件，循环回收多个子进程。</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">wait</span>(&amp;status) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&gt; 0：回收成功，返回子进程对应的 pid。</p></li></ul></li><li>status：判断子进程是如何死亡的。<ul><li>正常退出。</li><li>被某个信号杀死。</li></ul></li><li>调用一次只能回收一个子进程。</li></ul><p><strong>（2）实例</strong></p><p>在父进程中调用 wait 函数，wait 会阻塞，直到子进程结束，wait 函数才会执行结束，父进程才能继续执行下面的代码。</p><p>wait 回收成功，会返回子进程的 pid，我们打印 wait 返回值，来判断是否回收成功。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; pid &lt;&lt; endl;<br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;sun process is end, w_pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;(sun)pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）status 的使用</strong></p><ul><li>如果不关注子进程是如何死亡的，status 参数写 NULL。</li></ul><p>status：判断子进程是如何退出的？步骤如下：</p><ol><li><p>定义 status 变量。</p></li><li><p>wail 函数传入 &amp;status。（status 是 wail 的传出参数）</p></li><li><p>利用宏来判断 status。</p><ul><li><p>WIFEXITED(status)：非 0，进程正常结束。</p><ul><li><p>WEXITSTATUS(status)：当 WIFEXITED 为真时，获取进程退出状态的参数。</p><p>比如 return -1，WEXITSTATUS(status) = -1。</p></li></ul></li><li><p>WIFSIGNALED(status)：非 0，进程异常终止。</p><ul><li>WTERMSIG(status)：当 WIFSIGNALED 为真时，获取使进程中止的信号的编号。</li><li><strong>段错误，会导致非正常退出，并且 进程中止的信号的编号 是 11（SIGSEGV）。</strong></li></ul></li></ul></li></ol><p>PS：助记：W IF EXITED，W EXIT STATUS，W IF SIGNALED，W TERM SIG。</p><p>代码：当正常退出时，获取退出状态的参数。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; pid &lt;&lt; endl;<br>        <span class="hljs-type">int</span> status;                         <span class="hljs-comment">// 1.定义</span><br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(&amp;status);          <span class="hljs-comment">// 2.当传出参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WIFEXITED</span>(status)) &#123;            <span class="hljs-comment">// 3.宏判断</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;exit value: &quot;</span> &lt;&lt; <span class="hljs-built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;  <br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sun process is end, w_pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;(sun)pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">// exit value: 10</span><br></code></pre></td></tr></table></figure><p>代码：让子进程 sleep 200s，手动 kill 子进程，观察父进程 wait 函数获取到的中止进程的信号的编号。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; pid &lt;&lt; endl;<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(&amp;status);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WIFSIGNALED</span>(status)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;exit by signal: &quot;</span> &lt;&lt; <span class="hljs-built_in">WTERMSIG</span>(status) &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sun process is end, w_pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2000</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;(sun)pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// exit by signal: 9 （因为我手动 kill -9 子进程）</span><br></code></pre></td></tr></table></figure><p><strong>（4）waitpid 函数</strong></p><blockquote><p>作用同 wait 函数。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>参数 pid_t pid：</p><ul><li>pid = -1，等待任何子进程，此时 waitpid 退化成 wait 函数。</li><li>pid &gt; 0，等待进程 ID == pid 的子进程。</li><li>pid = 0，等待其组 ID 等于 调用进程的组 ID 的任意子进程。</li><li>pid &lt; -1，等待其组 ID 等于 pid 的绝对值的任意子进程（非本进程组的子进程）。</li></ul></li><li><p>status：用法同 wait 函数。</p></li><li><p>options：设置为 WNOHANG，函数非阻塞，设置为 0，函数阻塞。</p></li><li><p>返回值：</p><ul><li>&gt; 0：返回清理掉的子进程 ID。</li><li>-1：无子进程。</li><li>== 0：options 参数为 WNOHANG ，且子进程正在运行。</li></ul></li></ul><h2 id="10-进程间通信">10.进程间通信</h2><h3 id="10-1使用文件通信">10.1使用文件通信</h3><p><strong>（1）步骤</strong></p><ol><li>父进程打开文件后，fork 子进程。</li><li>此时父子进程均指向同一个文件。</li><li>可以实现父写子读。</li></ol><p><strong>（2）实例</strong></p><p>注意：先让 子进程 sleep 2s，保证父进程先执行完。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR |  O_TRUNC | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open file&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> p[] = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    <span class="hljs-type">int</span> pid = fork();<br>  <br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 父进程写文件</span><br>        <span class="hljs-built_in">write</span>(fd, p, <span class="hljs-built_in">sizeof</span>(p));<br>      <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 子进程读文件</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);        <span class="hljs-comment">// 先让子进程 sleep 2s，保证父进程先写入完。</span><br>        <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_SET);<br>        <span class="hljs-built_in">read</span>(fd, p, <span class="hljs-built_in">sizeof</span>(p));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-IPC">10.2 IPC</h3><p>进程间通信（InterProcess Communication）</p><p>IPC 常用的4种方式：</p><ul><li><p>文件</p></li><li><p>管道：简单</p></li><li><p>信号：系统开销小</p></li><li><p>共享映射区：有无血缘关系的进程间通信都可以</p></li><li><p>本地套接字：稳定</p></li></ul><h2 id="11-管道">11.管道</h2><blockquote><p>匿名管道pipe：没有血缘关系的进程间通信。</p><p>我们说的管道大概率是匿名管道，在磁盘中没有对应的磁盘文件。</p><p>比如 Linux 命令中 “|” 是匿名管道。</p></blockquote><h3 id="11-1-概念">11.1 概念</h3><p><strong>本质</strong>：Linux 内核缓冲区。（伪文件）</p><p><strong>伪文件</strong>：不在磁盘上，不占用磁盘空间，是内核的一块缓冲区。</p><p><strong>进程间通信的原理</strong>：父进程创建管道后，fork 子进程，父子进程的文件描述符都会指向 同一个管道的读写两端，从而实现通信。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-usv2np.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="11-2-特点">11.2 特点</h3><ul><li><p>两部分：</p><ul><li>读端、写端，对应两个文件描述符。</li><li>数据写端流入，读端流出。</li></ul></li><li><p>该缓冲区，内核自动销毁。何时释放？</p><ul><li>操作管道的进程被销毁之后，管道自动被释放。</li></ul></li><li><p>管道默认是阻塞的。</p><ul><li>读写操作都阻塞。（父子进程使用 pipe 通信，不需要 sleep）</li></ul></li></ul><h3 id="11-3-内部实现方式">11.3 内部实现方式</h3><p>环形队列（循环队列）。</p><p><strong>管道缓冲区大小</strong>：默认4K。</p><ul><li>命令查看默认缓冲区大小：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ulimit</span> -a<br><span class="hljs-comment"># pipe size</span><br></code></pre></td></tr></table></figure><ul><li>函数查看默认缓冲区大小：</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// fpathconf 函数</span><br><span class="hljs-comment">// 第一个参数是文件管道的文件描述符（读端、写端都可以）。</span><br><span class="hljs-comment">// 第二个参数是 管道缓冲区 的宏。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">fpathconf</span>(fd[<span class="hljs-number">1</span>], _PC_PIPE_BUF) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-4-局限性">11.4 局限性</h3><ul><li><p>数据只能读取一次，不能重复读取。</p></li><li><p>管道：半双工，数据传输方向是单向的。读写端均阻塞。</p><ul><li>单工：遥控器。</li><li>半双工：对讲机。</li><li>全双工：电话。</li></ul></li><li><p>匿名管道：适用于有血缘关系的进程。</p></li></ul><h3 id="11-5-创建匿名管道">11.5 创建匿名管道</h3><blockquote><p>创建一个内核缓冲区。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><ul><li>pipefd[2]：传出参数，传出两个文件描述符。<ul><li>pipefd[0]：读端</li><li>pipefd[1]：写端</li></ul></li><li>返回值：失败返回 -1；成功返回 0。</li></ul><h3 id="11-6-实例：父子进程使用管道">11.6 实例：父子进程使用管道</h3><blockquote><p>实现 <code>ps aux | grep zsh</code></p></blockquote><p><img src="https://hutu.aimtao.net/mark/2021-02-24-q9AXA9.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>父进程执行 ps，子进程执行 grep。用 pipe 的读写端来替换 stdout、stdin。</p><ul><li>ps 执行的结果，写入 stdout，也就是管道的写端 fd[1]；</li><li>grep 从 stdin 获取数据，也就是管道的读端 fd[0]。</li><li>注意：父进程要关闭读端，子进程要关闭写端。因为数据在管道中是一次性的，防止自己读走自己写入的数据。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 父进程 执行 ps aux</span><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 写端操作，关闭读端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 文件描述符重定向 stdout -&gt; pipe 的写端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-comment">// 执行 ps</span><br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 子进程 执行 grep zsh</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 读端操作，关闭写端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 文件描述符重定向 stdin -&gt; pipe 的读端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], STDIN_FILENO);<br>        <span class="hljs-comment">// 执行 grep</span><br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;zsh&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-7实例：兄弟进程使用管道">11.7实例：兄弟进程使用管道</h3><blockquote><p>实现 <code>ps aux | grep zsh</code></p></blockquote><p>与 父子进程使用管道 相比，子进程代替了父进程的操作，并需要将父进程的读端写端全部关闭。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <br><br>    <span class="hljs-comment">// 子进程1 关闭读端，重定向 stdin，执行 ps</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 子进程2 关闭写端，重定向 stdout，执行 grep</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], STDIN_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;zsh&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 父进程关闭管道 读端写端</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> w_pid;<br>        <span class="hljs-keyword">while</span> ((w_pid = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; w_pid &lt;&lt; <span class="hljs-string">&quot; died!&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-8-管道的读写行为">11.8 管道的读写行为</h3><ul><li>读操作<ul><li>有数据：正常读</li><li>无数据<ul><li>写端全部关闭：read 解除阻塞，返回 0。</li><li>写端没有全部关闭：read 阻塞。</li></ul></li></ul></li><li>写操作<ul><li>读端全部关闭：管道破裂，内核给当前进程发送信号：13(SIGPIPE)，进程被终止。</li><li>读端没有全部关闭：<ul><li>缓冲区写满了：停止写入，等待 read 读走数据。</li><li>缓冲区没满：正常写。</li></ul></li></ul></li></ul><p><strong>（9）设置非阻塞</strong></p><blockquote><p>默认读写两端都阻塞。半双工。</p><p>以 设置 读端非阻塞为例。</p></blockquote><p>利用 fcntl 变参函数。功能：复制文件描述符、修改文件的 flags 属性（设置非阻塞使用该功能）。</p><p>步骤：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 1.获取原来的 flags。</span><br><span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd[<span class="hljs-number">0</span>], F_GETFL);<br><br><span class="hljs-comment">// 2.设置新的 flags。</span><br>flags |= O_NONBLOCK;   <span class="hljs-comment">// flags = flags | O_NONBLOCK;</span><br><br><span class="hljs-comment">// 3.修改文件 flags</span><br><span class="hljs-built_in">fcntl</span>(fd[<span class="hljs-number">0</span>], F_SETFL, flags);<br></code></pre></td></tr></table></figure><h2 id="12-fifo">12.fifo</h2><blockquote><p>有名管道：没有血缘关系的进程间通信</p></blockquote><h3 id="12-1-概念">12.1 概念</h3><ul><li>文件类型是 p，表示管道。</li><li>实际上也是伪文件（同 pipe），磁盘上的文件大小永远为 0。</li><li>在内核中有一个对应的缓冲区。</li><li>半双工（同 pipe）</li><li>有阻塞行为（同 pipe）</li></ul><p><strong>使用场景</strong>：没有血缘关系的进程间通信。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-uGxaEX.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="12-1-创建方式">12.1 创建方式</h3><ul><li>命令</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkfifo</span> my_fifo<br></code></pre></td></tr></table></figure><ul><li>函数</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkfifoat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="12-3-使用及原理">12.3 使用及原理</h3><p>多个进程，均打开同一个 fifo 文件，获得一个文件描述符，便可以实现读写通信。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-t3n6oc.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>写数据进程</strong>：</p><ol><li>打开 fifo，只写</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_WRONLY)<br></code></pre></td></tr></table></figure><ol start="2"><li>写入数据 buf</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">write</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br></code></pre></td></tr></table></figure><ol start="3"><li>关闭文件</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure><p><strong>读数据进程</strong>：</p><ol><li>打开 fifo，只读</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_RDONLY)<br></code></pre></td></tr></table></figure><ol start="2"><li>读出数据到 buf</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br></code></pre></td></tr></table></figure><ol start="3"><li>使用数据：比如把读到的数据写到标准输出文件</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, <span class="hljs-built_in">len</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>关闭文件</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure><h3 id="12-4-实例：两个程序通过-fifo-通信">12.4 实例：两个程序通过 fifo 通信</h3><p>fifo_write.cc：每 3 秒向 fifo 写入一次数据。并打印 I wrote!。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sys_error</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;<br>    <span class="hljs-built_in">perror</span>(str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out fifo_name&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 打开 fifo</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_WRONLY);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sys_error</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 2. 每 3 秒写入一次数据</span><br>    <span class="hljs-keyword">while</span>(i--) &#123;<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;number = %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">write</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        cout &lt;&lt; <span class="hljs-string">&quot;I wrote!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>fifo_read.cc：fifo 中一有数据，就读到 buf 中，并输出到屏幕上。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;./a.out fifo_name&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1.打开 fifo</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.fifo 中一有数据就读出，并打印</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, len);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-mmap">13.mmap</h2><blockquote><p>创建内存映射区。</p></blockquote><h3 id="13-1-概念">13.1 概念</h3><p>mmap 可以将磁盘文件映射到内存中，并返回内存映射区的首地址 ptr，通过 ptr 可以读写内存映射区。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-ATUIxg.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="13-2-功能">13.2 功能</h3><ul><li><strong>功能一 – 修改磁盘文件</strong></li></ul><p>将磁盘中的文件，映射到虚拟内存中的动态库加载区，直接修改映射区数据即可。</p><p><strong>优点</strong>：直接在内存中修改数据会更快。</p><p><strong>缺点</strong>：没有阻塞</p><ul><li><strong>功能二 – 进程间通信</strong></li></ul><p>基于功能一。父进程在创建内存映射区后，再 fork 子进程，父子进程的内存映射区由同一个磁盘文件映射，便可实现通信。</p><h3 id="13-3-函数原型">13.3 函数原型</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *adrr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> port, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offdet)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>adrr：内存映射区的首地址，一般传入 NULL即可。</p></li><li><p>length：映射区的大小。</p><ul><li>按 4k 的倍数增长。</li><li>一般指定磁盘文件的大小即可。</li></ul></li><li><p>port：映射区权限</p><ul><li>PORT_READ：映射区必须有读权限</li><li>PORT_WRITE</li></ul><p>例：赋予读写权限时，port = PORT_READ | PORT_WRITE</p></li><li><p>flags：标志位参数</p><ul><li>MAP_SHARED：修改了内存数据会同步到磁盘文件。</li><li>MAP_PRIVATE：修改了内存数据不会同步到磁盘文件。</li></ul></li><li><p>fd：文件描述符</p><ul><li>要映射的磁盘文件的文件描述符</li><li>open 得到的</li></ul></li><li><p>offdet：映射文件的偏移量</p><ul><li>映射的时候，文件指针的偏移量</li><li>偏移量必须是 4k 的整数倍</li></ul></li><li><p>返回值：</p><ul><li>调用成功，返回映射区的首地址</li><li>调用失败：返回宏 MAP_FAILED，MAP_FAILED = -1。</li></ul></li></ul><h3 id="13-4-实例：mmap-创建内存映射区读写磁盘文件">13.4 实例：mmap 创建内存映射区读写磁盘文件</h3><p>步骤：</p><ol><li>打开文件</li><li>创建内存映射区</li><li>读写：写数据使用 strcpy，写入时会覆盖。</li><li>释放内存映射区</li><li>关闭文件。</li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1.打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;my.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// int fd = open(argv[1], O_RDWR);</span><br>    <span class="hljs-type">int</span>  len = <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.读写</span><br>    cout &lt;&lt; (<span class="hljs-type">char</span> *)ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;hello, I&#x27;m new xxxxx&quot;</span>);<br>    <br>    <span class="hljs-comment">// 4.释放内存映射区</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">munmap</span>(ptr,len);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 5.关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-5-问题">13.5 问题</h3><ul><li><p>想获取内存映射区的第二个字符，可以让 ptr 进行 ++ 操作吗？</p><p>不可以。因为会导致 <code>munmap(ptr, length)</code> 失败。</p><p>如果需要进行 ++ 操作，可以定义一个新的变量，让新变量完成 ++ 操作。<code>char *new_ptr = ptr</code>。</p></li><li><p>open 文件时，指定的权限是 RDONLY，mmap 指定的权限是 PROT_READ | PROT_WRITE，会怎么样？</p><p>会报错：Permission denied（没有权限）。</p><p>打开文件是只读；创建内存缓冲区却是读写。打开文件的权限应该大于等于 mmap 设定的权限。</p></li><li><p>传入的 offdet 参数是 1000，会怎么样？</p><p>会把错：Invaild argument（参数无效），必须是 4k 的整数倍。</p></li><li><p>mmap什么情况会调用失败？</p><ul><li>第二个参数 length = 0</li><li>第三个参数必须有 PORT_READ，且其权限必须小于等于 fd 的打开权限。</li><li>offdet 必须是 4k 的整数倍。</li></ul></li><li><p>可以 open 的时候，O_CREAT 一个新文件来创建映射区吗？</p><p>可以，但创建的新文件，没有大小，需要进行文件扩展。</p><ul><li>方法一：使用 lseek之后，进行一次 write 操作。</li><li>方法二：使用 ftruncate(fd, length)。</li></ul></li><li><p>mmap 创建内存映射区后，关闭文件描述符，会有什么影响？</p><p>对于读写均没有影响。</p></li></ul><h3 id="13-6-实例：有血缘关系的进程间通信">13.6 实例：有血缘关系的进程间通信</h3><p>创建内存映射区后，fork 子进程，父子进程的内存映射区映射的是同一个文件。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-BiNedD.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 1.打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.创建子进程</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">// 4.父子进程读写数据</span><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; (<span class="hljs-type">char</span>*)ptr &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 写数据</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)ptr, <span class="hljs-string">&quot;hello&quot;</span>);<br><br>        <span class="hljs-comment">// 回收子进程</span><br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;sun process is end, w_pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">100</span>);   <span class="hljs-comment">// 让父进程先写数据</span><br><br>        <span class="hljs-comment">// 读数据</span><br>        cout &lt;&lt; (<span class="hljs-type">char</span>*)ptr &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(sun)pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 5.释放内存映射区</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">munmap</span>(ptr, len);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 6.关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-7-实例：没有血缘关系的进程间通信">13.7 实例：没有血缘关系的进程间通信</h3><p>原理：write、read 进程均通过 mmap 对同一个文件，创建内存映射区，映射到真实的内存中其实是一块区域，从而实现通信。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-EhkOWV.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong><a target="_blank" rel="noopener" href="http://write.cc">write.cc</a></strong>：在内存映射区中，每隔一秒，去写入不同的 i。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>   <span class="hljs-comment">// open</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>     <span class="hljs-comment">// perror</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>    <span class="hljs-comment">// exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>    <span class="hljs-comment">// read、write</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span>  <span class="hljs-comment">// wait</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>  <span class="hljs-comment">// mmap</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">4096</span>;<br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.写内存映射区</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        i++;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I wrote! Current number is &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;number = %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, buf);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.释放</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">munmap</span>(ptr, len);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5.关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><a target="_blank" rel="noopener" href="http://read.cc">read.cc</a></strong>：在内存映射区中，每隔一秒，打印内存缓冲区的数据。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1.打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>], O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>    <span class="hljs-built_in">ftruncate</span>(fd, <span class="hljs-number">4096</span>);<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.读数据</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        cout &lt;&lt; (<span class="hljs-type">char</span> *) ptr &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 4.释放</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">munmap</span>(ptr, len);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5.关闭文件</span><br>    <span class="hljs-built_in">close</span>(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-8-munmap">13.8 munmap</h3><blockquote><p>释放内存映射区</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>addr：mmap 的第二个参数，映射区的首地址。</li><li>length：mmap 的第二个参数，映射区的长度。</li><li>返回值：失败 -1，成功 0。</li></ul><h2 id="14-信号">14 信号</h2><blockquote><p>功能：杀死进程或者捕捉信号。通信尽量不用信号。</p></blockquote><h3 id="14-1-概念">14.1 概念</h3><p>大致过程：进程A --&gt; 内核 --&gt; 进程B</p><p>值得注意的是：信号的优先级比较高，进程B 收到信号后，会暂停正在处理的工作，优先处理信号，处理完信号再继续处理工作。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-24-UjQAme.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="14-2-特点">14.2 特点</h3><ul><li>简单</li><li>携带的信息量少</li><li>使用在某一个特定的场景下</li></ul><h3 id="14-3-信号的状态">14.3 信号的状态</h3><ul><li>产生<ul><li>键盘：ctrl + c</li><li>命令：kill</li><li>系统函数：kill()</li><li>软条件：定时器</li><li>硬件：段错误、除 0 错误</li></ul></li><li>未决：信号没有被进程处理</li><li>递达：信号被处理了</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-02-24-jylRcP.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="14-4-处理方式">14.4 处理方式</h3><ul><li><p>忽略</p></li><li><p>捕捉</p></li><li><p>执行默认动作</p><ul><li>Term：终止进程</li><li>Ign：忽略信号 （默认即时对该种信号忽略操作）</li><li>Core：终止进程，生成Core文件（查验进程死亡原因，用于gdb调试）</li><li>Stop：停止（暂停）进程；</li><li>Cont：继续运行进程。</li></ul></li></ul><h3 id="14-5-信号的四要素">14.5 信号的四要素</h3><p><strong>四要素</strong>：信号名称、编号、动作、事件。</p><p>用 man 命令查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">man signal<br></code></pre></td></tr></table></figure><table><thead><tr><th>信号名称</th><th>编号</th><th>动作</th><th>事件</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>A</td><td>在控制终端上是挂起信号, 或者控制进程结束</td></tr><tr><td>SIGINT</td><td>2</td><td>A</td><td>从键盘输入的中断</td></tr><tr><td>SIGQUIT</td><td>3</td><td>C</td><td>从键盘输入的退出</td></tr><tr><td>SIGILL</td><td>4</td><td>C</td><td>无效硬件指令</td></tr><tr><td>SIGABRT</td><td>6</td><td>C</td><td>非正常终止, 可能来自 abort(3)</td></tr><tr><td>SIGFPE</td><td>8</td><td>C</td><td>浮点运算例外</td></tr><tr><td>SIGKILL</td><td>9</td><td>AEF</td><td>杀死进程信号</td></tr><tr><td>SIGSEGV</td><td>11</td><td>C</td><td>无效的内存引用</td></tr><tr><td>SIGPIPE</td><td>13</td><td>A</td><td>管道中止: 写入无人读取的管道</td></tr><tr><td>SIGALRM</td><td>14</td><td>A</td><td>来自 alarm(2) 的超时信号</td></tr><tr><td>SIGTERM</td><td>15</td><td>A</td><td>终止信号</td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>A</td><td>用户定义的信号 1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>A</td><td>用户定义的信号 2</td></tr><tr><td>SIGCHLD</td><td>20,17,18</td><td>B</td><td>子进程结束或停止</td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td></td><td>继续停止的进程</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>DEF</td><td>停止进程</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>D</td><td>终端上发出的停止信号</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>D</td><td>后台进程试图从控制终端(tty)输入</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>D</td><td>后台进程试图在控制终端(tty)输出</td></tr></tbody></table><table><thead><tr><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>终止进程，Term</td></tr><tr><td>B</td><td>忽略这个信号，Ign</td></tr><tr><td>C</td><td>终止进程, 并且核心转储，Core</td></tr><tr><td>D</td><td>暂停进程，Stop</td></tr><tr><td>E</td><td>信号不能被捕获</td></tr><tr><td>F</td><td>信号不能被忽略</td></tr></tbody></table><p>PS：一个信号有多个值，是因为平台不一样，x86平台使用中间这列的值。</p><p>注意：SIGKILL 和 SIGSTOP 不能被捕捉（caught）、不能被阻塞（blocked）、不能被忽略（ignored）。</p><h3 id="14-6-kill-函数">14.6 kill 函数</h3><blockquote><p>发信号给指定进程。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>pid：<ul><li>pid &gt; 0：发送信号给指定的进程。</li><li>pid == 0：发送信号给与调用 kill 函数进程属于同一进程组的所有进程。</li><li>pid &lt; -1：发送信号给 pgid == -pid 的进程组。</li><li>pid == -1：发送给进程有权限发送的系统中所有的进程。<ul><li>举个例子：Test 用户有权限发给 Test 用户的所有进程，但是没有权限发给 root 用户的进程。</li></ul></li></ul></li><li>sig：可以使用数字或宏，推荐使用宏。</li><li>返回值：成功返回 0，出错返回 -1。</li></ul><p><strong>（2）查看有哪些信号</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> -l<br></code></pre></td></tr></table></figure><p><strong>（3）实例：杀死父进程</strong></p><p>子进程1秒后杀死父进程，父进程循环打印 i。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>                    <br>    <span class="hljs-comment">// 子进程杀死父进程</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">kill</span>(<span class="hljs-built_in">getppid</span>(), SIGKILL);<br>    &#125; <br><br>    <span class="hljs-comment">// 父进程一直工作</span><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            i++;<br>            cout &lt;&lt; <span class="hljs-string">&quot;number = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-7-raise-函数">14.7 raise 函数</h3><blockquote><p>自己给自己发信号。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br><span class="hljs-comment">// kill 函数也可以实现自己给自己发送信号。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(getpid(), <span class="hljs-type">int</span> sig)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功返回 0，出错返回 -1。</li></ul><p><strong>（2）实例</strong></p><p>子进程给自己发送 SIGKILL，让父进程来回收子进程，并检测子进程因为什么信号而终止的。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 子进程使用 raise</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">raise</span>(SIGKILL);<br>    &#125; <br>          <br>    <span class="hljs-comment">// 父进程回收子进程，并识别杀死子进程的信号</span><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(&amp;status);<br>        cout &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WIFSIGNALED</span>(status)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;signal = &quot;</span> &lt;&lt; <span class="hljs-built_in">WTERMSIG</span>(status) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-8-abort-函数">14.8 abort 函数</h3><blockquote><p>给自己发送异常终止信号。</p><p>abort：v.流产 n.中止计划</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>没有返回值、没有参数</li><li>永远不会调用失败</li></ul><p><strong>（2）功能</strong></p><p>给自己发送 SIGABRT 信号，终止进程，并产生 core 文件。</p><p><strong>（3）实例</strong></p><p>子进程调用 abort 函数，让父进程来回收子进程，并检测子进程因为什么信号而终止的。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 子进程使用 abort</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">abort</span>();<br>    &#125; <br>      <br>    <span class="hljs-comment">// 父进程回收子进程，并识别杀死子进程的信号</span><br>      <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">int</span> w_pid = <span class="hljs-built_in">wait</span>(&amp;status);<br>        cout &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; w_pid &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WIFSIGNALED</span>(status)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;signal = &quot;</span> &lt;&lt; <span class="hljs-built_in">WTERMSIG</span>(status) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-9-alarm-函数">14.9 alarm 函数</h3><blockquote><p>定时器超时，终止进程。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>seconds</strong>：多少秒之后发送信号。</p><ul><li>如果 seconds 被重置为 0，则意味着函数被取消了，不会终止进程。</li></ul></li><li><p><strong>返回值</strong>：上次倒计时还有剩余多少秒。</p><p>再次调用 alarm 会重置的 alarm 的倒计时数，<strong>上一次 alarm 函数会失效</strong>，会重新开始倒计时。【每个进程只有一个定时器】</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> a = <span class="hljs-built_in">alarm</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">// 第一次调用，返回值为 0。</span><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> a = <span class="hljs-built_in">alarm</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">// a = 3   // 因为倒计时5秒，sleep 2 秒，上一次倒计时还剩 3 秒</span><br><span class="hljs-type">int</span> b = <span class="hljs-built_in">alarm</span>(<span class="hljs-number">4</span>);     <span class="hljs-comment">// b = 10  // alarm(10) 和 alarm(4) 几乎同时运行，所以上一次倒计时还剩 10 秒</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>（2）功能</strong></p><p>当倒计时结束时，函数会发出一个信号：SIGALRM，会终止进程。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 5 秒后会终止进程。</span><br>    <span class="hljs-built_in">alarm</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 每一秒打印一次 i</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span>(--i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重置 alarm 函数倒计时，重新开始倒计时。</span><br>    <span class="hljs-comment">// 再次调用 alarm 会重置的 alarm 的倒计时数，上一次 alarm 函数会失效，会重新开始倒计时。</span><br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">alarm</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d   i = %d\n&quot;</span>, b, i);<br>    <br>    <span class="hljs-comment">// 每一秒打印一次 i</span><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）特点</strong></p><ul><li><p>每个进程只有一个定时器。</p></li><li><p>定时器使用的是 <strong>自然定时法</strong>。</p><p>不受进程状态影响。即使进程在进行复杂的算法或者卡顿，也不影响倒计时，互相独立。</p></li></ul><p><strong>（4）实例：测试计算机一秒钟能数多少数</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">alarm</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ++i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>time ./a.out</code> 可以查看程序运行时间，其实实际上数数的时间少于一秒，因为内核需要时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">time</span> ./a.out &gt; 1.txt <br><span class="hljs-comment"># [2]    7101 alarm      ./a.out &gt; 1.txt</span><br><span class="hljs-comment"># ./a.out &gt; 1.txt  0.78s user 0.19s system 96% cpu 1.006 total</span><br></code></pre></td></tr></table></figure><ul><li><p>真实运行时间 = 用户 user + 内核 system + 损耗</p></li><li><p>真实运行时间 &lt; 1s，原因：损耗来自于文件 IO 操作。</p></li></ul><h3 id="14-10-setitimer-函数">14.10 setitimer 函数</h3><blockquote><p>定时器，并实现周期性定时</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_value, <span class="hljs-keyword">struct</span> itimerval *old_value)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> &#123;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_interval;   <span class="hljs-comment">// 定时器循环周期</span><br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_value;    <span class="hljs-comment">// 第一次触发定时器的时间</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timerval</span> &#123;<br>      <span class="hljs-type">time_t</span> tv_sec;    <span class="hljs-comment">// 秒</span><br>      <span class="hljs-type">suseconds_t</span> tv_usec;   <span class="hljs-comment">// 微秒</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>which</strong>：定时法则。<ul><li>ITIMER_REAL：自然定时法。发出的信号是 SIGALRM。</li><li>ITIMER_VIRTUAL：虚拟的，只计算用户区代码运行的时间。发出的信号是 SIGVTALRM。</li><li>ITIMER_PROF：用户 + 内核的时间。发出的信号是 SIGPROF。</li></ul></li><li>*<em>const struct itimerval <em>new_value</em></em>：<ul><li>it_value：第一次响的时间。</li><li>it_interval：从 it_value 开始，每隔 it_interval 这么长时间响一次。</li></ul></li><li>*<em>itimerval <em>old_value</em></em>：传 NULL即可。这是一个传出参数，用来获取上一次定时器的信息。</li></ul><p><strong>（2）实例：使用 setitimer</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第二个参数</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> s;<br>    <br>    <span class="hljs-comment">// 第一次触发定时器的时间：2s</span><br>    s.it_value.tv_sec = <span class="hljs-number">2</span>;   <span class="hljs-comment">//s</span><br>    s.it_value.tv_usec = <span class="hljs-number">0</span>;  <span class="hljs-comment">//us</span><br><br>    <span class="hljs-comment">// 定时器循环周期：每 5s 循环一次。</span><br>    s.it_interval.tv_sec = <span class="hljs-number">5</span>;  <span class="hljs-comment">// s</span><br>    s.it_interval.tv_usec = <span class="hljs-number">0</span>;  <span class="hljs-comment">// us</span><br><br>    <span class="hljs-comment">//倒计时 2 s</span><br>    <span class="hljs-built_in">setitimer</span>(ITIMER_REAL, &amp;s, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>        i++;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-11-阻塞信号集、未决信号集">14.11 阻塞信号集、未决信号集</h3><p><strong>（1）概念</strong></p><p><strong>阻塞信号集</strong>：要屏蔽的信号的集合。</p><p><strong>未决信号集</strong>：没有被处理的信号的集合。</p><p>PS：阻塞信号集、未决信号集在 PCB 中，用户不能直接操作。</p><p><strong>（2）信号集状态</strong></p><ul><li>每个信号对应一个标志性位。举个例子：<ul><li>在阻塞信号集中，1 号标志位为 1，表示信号 SIGHUP（编号为 1）被设置阻塞；2 号标识位为 0，表示信号 SIGINT（编号为2）没有被设置阻塞。</li><li>在未决信号集中，3 号标志位为 1，表示信号 SIGQUIT（编号为3）没有被处理。</li></ul></li></ul><p><img src="https://hutu.aimtao.net/mark/2021-02-26-TcspW4.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><a name="何为可递达的信号"></a></p><p><strong>（3）关系</strong></p><p>收到信号，先进入未决信号集中，如果阻塞信号集中设置了阻塞，则保持现状，不阻塞则执行。</p><p><img src="https://hutu.aimtao.net/mark/2021-02-26-hj5Lqd.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>PS</strong>：上图中的可执行的信号，也就是可递达的信号，可以分为三种：</p><ul><li>执行默认动作</li><li>忽略</li><li>捕捉 --&gt; 执行用户的回调函数</li></ul><h3 id="14-12-设置自定义信号集">14.12 设置自定义信号集</h3><blockquote><p>用户不能直接更改阻塞信号集，我们需要设置一个自定义信号集，并通过自定义信号集来更改阻塞信号集。</p><p>当信号加入自定义信号集，表示该信号将会阻塞，即标志位为 1。（SIG_BLOCK情况下）</p></blockquote><p><strong>（1）将 set 集合全部信号置空</strong></p><blockquote><p>相当于说，该集合中所有信号标志位为 0。（SIG_BLOCK情况下）</p><p><strong>注意</strong>：定义的信号集，初始值是随机的，需要用 sigemptyset 置空。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sigset_t：阻塞信号集、未决信号集、自定义信号集的类型。</p></li><li><p>sigset_t *set：集合的地址。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">sigset_t</span> my_set;   <span class="hljs-comment">// 注意：定义的信号集，初始值是随机的，需要用 sigemptyset 置空。</span><br><span class="hljs-built_in">sigemptyset</span>(&amp;myset);  <span class="hljs-comment">// 取地址</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>（2）将所有信号加入 set 集合</strong></p><blockquote><p>相当于说，该集合中所有信号标志位为 1。（SIG_BLOCK情况下）</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（3）将 signo 信号加入到 set 集合</strong></p><blockquote><p>相当于说，signo 信号的标志位为 1。（SIG_BLOCK情况下）</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signo)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>int signo：表示信号的编号，例如：SIGINT 编号为 2；SIGKILL 编号为 9。</li></ul><p><strong>（4）从 set 集合中移除 signo 信号</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signo)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>（5）判断信号是否存在</strong></p><p>该函数可以判断阻塞信号集、未决信号集、自定义信号集。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signo)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：存在返回 1，不存在返回 0。</li></ul><h3 id="14-13-设置阻塞信号集">14.13 设置阻塞信号集</h3><p>将自定义信号集设置给阻塞信号集。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>how：</p><ul><li><p>SIG_BLOCK：</p><p>阻塞，自定义信号集中，有哪些信号，阻塞信号集中就会阻塞这些信号。</p><p>mask = mask | my_set</p></li><li><p>SIG_UNBLOCK：</p><p>解除阻塞，自定义信号集中，有哪些信号，阻塞信号集就会对这些信号解除阻塞。</p><p>mask = mask &amp; (~set)</p></li><li><p>SIG_SETMASK：</p><p>覆盖阻塞信号集。</p><p>mask = set</p></li></ul></li><li><p>sigset_t *oldset：传出参数，更改之前的阻塞信号集的状态。（不关心的话可以写 NULL）</p></li></ul><p>实例：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1.定义一个自定义集合</span><br>    <span class="hljs-type">sigset_t</span> my_set;<br><br>    <span class="hljs-comment">// 2.注意：自定义的集合的值是随机的，需要使用 sigemptyset 置空！</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;my_set);<br><br>    <span class="hljs-comment">// 3.手动设置自定义集合中阻塞信号</span><br>    <span class="hljs-built_in">sigaddset</span>(&amp;my_set, SIGINT);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;my_set, SIGQUIT);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;my_set, SIGKILL);<br>    <span class="hljs-comment">// 4.将自定义信号集传递给阻塞信号集</span><br>    <span class="hljs-built_in">sigprocmask</span>(SIG_BLOCK, &amp;my_set, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-14-读取当前进程的未决信号集">14.14 读取当前进程的未决信号集</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>sigset_t *set：传出参数，内核将未决信号集写入 set。</li><li>将传出参数 set 做 sigismember 的参数，即可知道信号是否在未决信号集中（即未被处理）。</li></ul><p>实例：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 自定一个信号集 penset</span><br>    <span class="hljs-type">sigset_t</span> pendset;<br><br>    <span class="hljs-comment">// 将未决信号集传出到 penset</span><br>    <span class="hljs-built_in">sigpending</span>(&amp;pendset);<br><br>    <span class="hljs-comment">// 判断信号 1-50 是否存在于 penset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">51</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">sigismember</span>(&amp;pendset, i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-15-信号捕捉-signal">14.15 信号捕捉 signal</h3><blockquote><p>给某一个进程的某一个特定信号（标号为 SIGINT）注册一个相应的处理函数，即对该信号的默认处理动作进行修改，修改为 <code>handler</code> 函数所指向的方式。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;   <span class="hljs-comment">// 函数指针声明</span><br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;  <span class="hljs-comment">// 捕捉信号</span><br></code></pre></td></tr></table></figure><ul><li>signum：要捕捉的信号。</li><li>sighandler_t handler：回调函数，自己实现。当捕捉到 signum，就会执行。</li></ul><p><strong>（2）实例：捕捉 crtl + c 信号 SIGINT</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 处理事件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;catch your signal: &quot;</span> &lt;&lt; number &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">signal</span>(SIGINT, my_func);   <span class="hljs-comment">// 捕捉信号</span><br>  <br>    <span class="hljs-comment">// 保证进程一直在运行，不终止。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-16-信号捕捉-sigaction">14.16 信号捕捉 sigaction</h3><blockquote><p>同 signal。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction, <span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> &#123;<br>    <span class="hljs-built_in">void</span> (*sa_handler)(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span>*, <span class="hljs-type">void</span>*);  <span class="hljs-comment">// 一般不会用，忽略，不需要初始化。</span><br>      <span class="hljs-type">sigset_t</span> sa_mask;  <span class="hljs-comment">// 在信号处理函数 sa_handler 执行过程中，临时屏蔽指定的信号。</span><br>      <span class="hljs-type">int</span> sa_flags;<br>    <span class="hljs-built_in">void</span> (*sa_restorer)(<span class="hljs-type">void</span>);  <span class="hljs-comment">// 已废弃。</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>signum：要捕捉的信号。</li><li>struct sigaction *oldact：上一次捕捉时的设置，一般传 NULL。</li></ul><p>在 const struct sigaction 中：</p><ul><li><p>sa_handler：回调函数。</p></li><li><p>sa_mask：</p><ul><li>在信号处理函数 sa_handler 执行过程中，临时屏蔽指定的信号。</li><li>sa_handler 结束，取消临时屏蔽，会继续执行该信号。</li><li>没有特殊需求就使用清空操作。</li></ul></li><li><p>sa_flags：如果使用 sa_handler，sa_flags 是 0；如果使用 sa_sigaction，sa_flags 是其他值。</p></li></ul><p><strong>（2）实例：捕捉 crtl + c 信号 SIGINT</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 处理事件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;catch your signal: &quot;</span> &lt;&lt; number &lt;&lt; endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;weak up !&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    <span class="hljs-comment">// 创建 结构体参数</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>  <br>    <span class="hljs-comment">// 设置信号新的处理函数</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler= my_func;<br>          <br>    <span class="hljs-comment">// 设置临时屏蔽的信号 </span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;act.sa_mask, SIGQUIT);<br>                <br>    <span class="hljs-comment">// 捕捉信号</span><br>    <span class="hljs-built_in">sigaction</span>(SIGINT, &amp;act, <span class="hljs-literal">NULL</span>);<br>  <br>    <span class="hljs-comment">// 保证进程一直在运行，不终止。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-17-内核实现信号捕捉的过程">14.17 内核实现信号捕捉的过程</h3><ol><li><p>【<strong>用户区</strong>】在执行主控制流程的某条指令时，因为中断、异常、系统调用而进入内核。</p><p>如果执行一些变量赋值、if 判断、循环语句不会进入内核区。</p></li><li><p>【<strong>内核区</strong>】内核处理完异常，准备回用户模式之前，先处理当前进程中可以可以递达的信号。</p><p>何为可递达？没有被阻塞的未决信号。见<a href="#何为可递达的信号">关系</a></p></li><li><p>【<strong>用户区</strong>】如果信号的处理动作是自定义的信号处理函数，则回到用户模式，执行信号处理函数。（而不是回到主控制流程）</p></li><li><p>【<strong>内核区</strong>】信号处理函数返回时，会执行特殊的系统调用 sigreturn，再次进入内核。</p><p>为什么需要再次进入内核，因为内核调用的信号处理函数，函数执行完之后需要返回。</p></li><li><p>【<strong>用户区</strong>】返回用户模式，从主控制流程中，上次中断的地方继续向下执行。</p></li></ol><h3 id="14-18-慢速系统调用中断">14.18 慢速系统调用中断</h3><p>系统调用可以分成两类：</p><ul><li>慢速系统调用：<strong>可能会使进程永远阻塞的一类</strong>。如果在阻塞期间收到一个信号，该系统调用被中断，不再继续执行。中断后返回 -1，设置 errno 为 EINTR（表示：信号中断）</li><li>其他系统调用。</li></ul><h2 id="15-守护进程">15.守护进程</h2><h3 id="15-1-特点">15.1 特点</h3><ul><li>后台服务进程</li><li>独立与控制终端</li><li>周期性执行某任务</li><li>不受用户登陆注销的影响</li><li>一般采用以 d 结尾的名字（服务）</li></ul><h3 id="15-2-进程组">15.2 进程组</h3><ul><li>进程组的组长：组里面的第一个进程。</li><li>进程组的 ID：和进程组组长的 ID 相同。</li></ul><h3 id="15-3-会话">15.3 会话</h3><blockquote><p>多个进程组组成会话。</p></blockquote><p><strong>（1）创建会话</strong></p><p>先fork，父进程死，儿子执行创建会话操作（setsid）</p><p><strong>（2）注意事项</strong></p><ul><li><p>不能由进程组组长来创建会话。</p></li><li><p>创建会话的进程会成为新的进程组组长。</p></li><li><p><strong>创建出的新会话会丢弃原有的控制终端。</strong></p><p>PS：创建会话后，子进程便是守护进程，不受用户登陆注销的影响。</p></li></ul><p><strong>（3）实例</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程杀死</span><br>        <span class="hljs-built_in">kill</span>(<span class="hljs-built_in">getpid</span>(), SIGKILL);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程创建会话</span><br>        <span class="hljs-built_in">setsid</span>();<br>        <span class="hljs-comment">// 保证子进程不结束，以便观察结果</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-4-创建守护进程">15.4 创建守护进程</h3><ol><li><p><strong>fork 子进程，父进程退出</strong></p></li><li><p><strong>子进程创建新会话</strong></p><ul><li>setsid()</li></ul></li><li><p><strong>改变当前工作目录</strong>（不必须，增强程序健壮性）</p><p>避免当前工作目录被卸载。</p><p>举个例子：插一个 U 盘，a.out，在 U 盘目录中启动 a.out。a.out 启动过程中，U 盘拔掉了。</p></li><li><p><strong>重设文件掩码</strong>（不必须，增加子进程的灵活性）</p><ul><li>子进程会继承父进程的掩码。</li><li>umask(0)：没有限制，0 取反就是 777。</li></ul></li><li><p><strong>关闭文件描述符</strong></p><ul><li>close(0)</li><li>close(1)</li><li>close(2)</li><li>因为不需要终端，释放资源。</li></ul></li><li><p><strong>执行核心操作</strong></p></li></ol><p><strong>实例：创建守护进程</strong></p><p>创建会话，设置定时器，并捕捉该信号，调用回调函数，将时间写入文件。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 回调函数 -- 将当前时间写入文件。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doing</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前时间</span><br>    <span class="hljs-type">time_t</span> cur;<br>    <span class="hljs-built_in">time</span>(&amp;cur);<br>    <span class="hljs-comment">// 格式化时间</span><br>    <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">ctime</span>(&amp;cur);<br>    <span class="hljs-comment">// 写入文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/root/process/time.txt&quot;</span>, O_CREAT | O_WRONLY | O_APPEND, <span class="hljs-number">0777</span>);<br>    <span class="hljs-built_in">write</span>(fd, ptr, <span class="hljs-built_in">strlen</span>(ptr));<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 1.父进程退出</span><br>        <span class="hljs-built_in">kill</span>(<span class="hljs-built_in">getpid</span>(), SIGKILL);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2.子进程创建会话</span><br>        <span class="hljs-built_in">setsid</span>();<br><br>        <span class="hljs-comment">// 3.改变当前工作目录</span><br>        <span class="hljs-built_in">chdir</span>(<span class="hljs-string">&quot;/home&quot;</span>);<br><br>        <span class="hljs-comment">// 4.重置文件掩码</span><br>        <span class="hljs-built_in">umask</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 5.关闭文件描述符</span><br>        <span class="hljs-built_in">close</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">close</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">close</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 6.执行核心操作--设定定时器，捕捉定时器信号</span><br>        <span class="hljs-comment">// 注册信号捕捉</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = doing;<br>        <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>        <span class="hljs-built_in">sigaction</span>(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> val;<br>        <span class="hljs-comment">// 第一次执行的时间</span><br>        val.it_value.tv_usec = <span class="hljs-number">0</span>;<br>        val.it_value.tv_sec = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 循环的周期</span><br>        val.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>        val.it_interval.tv_sec = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">setitimer</span>(ITIMER_REAL, &amp;val, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-线程">16.线程</h2><h3 id="16-1-特点">16.1 特点</h3><p><img src="https://hutu.aimtao.net/mark/2021-03-02-7T1Dro.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p>创建线程后，地址空间没有变化，子线程和主线程共用地址空间。</p></li><li><p>进程退出成了线程（主线程）。</p></li><li><p>主线程和子线程有各自独立的 PCB。</p></li><li><p>子线程的 PCB 是从主线程拷贝过来的。</p></li></ul><h3 id="16-2-共享与通信">16.2 共享与通信</h3><p><strong>（1）共享</strong>：</p><ul><li>环境变量</li><li>命令行参数</li><li>动态库</li><li>堆</li><li>bss</li><li>data</li><li>text</li></ul><p><strong>（2）不共享</strong>：栈</p><ul><li>举个例子：一共有 5 个线程，栈区被平均分为 5 份。</li><li>保证每个线程都有自己独立的栈空间，栈区变量不会冲突。</li></ul><p><strong>（3）通信</strong>：全局变量、堆。</p><h3 id="16-3-Linux-和-Windows">16.3 Linux 和 Windows</h3><blockquote><p>Linux 和 windows 的实现原理不一样。</p><p>最开始，Linux 中没有线程，后由进程更改而来的。</p></blockquote><p>在 Linux 中：</p><ul><li>线程就是进程，轻量级进程。</li><li>对于内核，线程就是进程。只认 PCB（进程控制块）。</li></ul><h3 id="16-4-查看线程的-LWP-号">16.4 查看线程的 LWP 号</h3><ul><li><p>线程号（LWP号）和线程 ID是有区别的。</p></li><li><p>线程号（LWP号）是给内核看的。</p></li><li><p>线程 ID 是给用户看的。</p></li></ul><p><strong>如何查看？</strong></p><ol><li>找到进程 ID。</li></ol><p><code>pd -LF 进程ID</code> 即可以查看 LWP号。</p><h3 id="16-5-多线程和多进程的区别">16.5 多线程和多进程的区别</h3><p><strong>（1）多进程始终共享的资源</strong>：</p><ul><li>代码</li><li>文件描述符</li><li>内存映射区</li></ul><p><strong>（2）多线程始终共享的资源</strong>：</p><ul><li>堆</li><li>全局变量</li></ul><p><strong>（3）使用线程的好处</strong>：</p><ul><li>节省资源（线程共用虚拟地址空间）</li><li>不会降低程序效率（CPU 按照 PCB 来分配时间片）</li></ul><h3 id="16-6-创建线程">16.6 创建线程</h3><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread,             <span class="hljs-comment">// 线程 ID，无符号长整型</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *arr,     <span class="hljs-comment">// 线程属性，NULL</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span>*)  <span class="hljs-comment">// 线程处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">void</span> *arg;                     <span class="hljs-comment">// 线程处理函数参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">                  )</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>返回值</strong>：成功返回 0，失败返回错误号。（线程库里不能使用 perror 打印。）</li><li>*<em>const pthread_attr_t <em>arr</em></em>：传出参数：无符号长整型。（一般七八位）</li><li>*<em>const pthread_attr_t <em>arr</em></em>：线程属性<ul><li>传 NULL，默认父子线程不分离。</li><li>重要的属性——线程分离：子线程需要父线程去回收，线程分离之后，子线程就可以自己回收自己的线程。</li></ul></li><li><strong>void *(<em>start_routine)(void</em>)</strong>：函数指针。函数的作用：创建的子线程需要执行的函数；如果不指定，就不执行任何操作。</li><li>*<em>void <em>arg</em></em>：线程处理函数的参数。</li></ul><p><strong>（2）实例：创建线程</strong></p><ul><li>编译的时候，要用 ``-l` 指定 pthread 库。pthreath 不是 linux 系统库，多线程程序要依赖于 <a target="_blank" rel="noopener" href="http://libpthread.so">libpthread.so</a>。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">g++ ../src/pthread_create.cc -lpthread<br></code></pre></td></tr></table></figure><ul><li><p>父子线程共用地址空间，一旦父线程，执行完毕，销毁地址空间，子线程就有可能来不及执行。</p><p>所以需要在程序结束前，让父线程 sleep 一下，让子线程抢到 CPU。</p></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 线程处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">my_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印线程id</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;child thread id: &quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_id;    <span class="hljs-comment">// 传出线程 ID</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_id, <span class="hljs-literal">NULL</span>, my_fun, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 创建线程</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; <br>    &#125;<br>    <br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 防止父线程先执行完毕，销毁地址空间。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）实例：循环创建多个线程</strong></p><p>用线程数组来储存创建线程的 ID。</p><p>并将 i 的地址当作参数传入，在线程处理函数中打印。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 线程处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">my_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span> *)arg;<br>    cout &lt;&lt; <span class="hljs-string">&quot;child thread id: &quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>()  &lt;&lt; <span class="hljs-string">&quot; num = &quot;</span> &lt;&lt; num &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_id[<span class="hljs-number">5</span>];    <span class="hljs-comment">// 传出线程 ID</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">pthread_create</span>(&amp;pth_id[i], <span class="hljs-literal">NULL</span>, my_fun, (<span class="hljs-type">void</span> *)&amp;i);<br>        cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）重要问题</strong>：</p><ul><li>打印结果：</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc">i = <span class="hljs-number">0</span><br>i = <span class="hljs-number">1</span><br>i = <span class="hljs-number">2</span><br>i = <span class="hljs-number">3</span><br>i = <span class="hljs-number">4</span><br>child thread id: <span class="hljs-number">140608273958656</span> num = <span class="hljs-number">5</span><br>child thread id: <span class="hljs-number">140608265565952</span> num = <span class="hljs-number">5</span><br>child thread id: <span class="hljs-number">140608299136768</span> num = <span class="hljs-number">5</span><br>child thread id: <span class="hljs-number">140608290744064</span> num = <span class="hljs-number">5</span><br>child thread id: <span class="hljs-number">140608282351360</span> num = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><ul><li><p>问题：num 并没有按照传入的参数改变。</p></li><li><p>原因：线程处理函数执行到一半的时候，CPU 资源被抢走，等到有 CPU 资源的时候，线程去 (int *)arg 地址中取值；此时，i 的值已经在主进程中发生了改变。</p></li></ul><h3 id="16-7-线程打印错误信息">16.7 线程打印错误信息</h3><p>线程不可以直接打印错误信息，需要拿到错误号，再来获取错误信息。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strerror</span><span class="hljs-params">(ret)</span></span>;  <span class="hljs-comment">// ret 是 pthread_create 的返回值。</span><br></code></pre></td></tr></table></figure><p>实例：线程打印错误信息</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_id;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;pth_id, <span class="hljs-literal">NULL</span>, my_fun, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">strerror</span>(ret) &lt;&lt; endl;  <span class="hljs-comment">// 获取错误信息</span><br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-8-pthread-exit-函数">16.8 pthread_exit 函数</h3><p>当前线程退出，但是不影响其他线程的执行。</p><p><strong>（1）与 exit 的区别</strong></p><ul><li><p>任何线程，只要调用 exit，整个进程都会结束。</p></li><li><p>而 pthread_exit 只会结束线程，不会回收地址空间。</p></li></ul><p><strong>（2）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>*<em>void <em>retval</em></em>：<ul><li>（传出参数）一个指针，指向一个地址。可以将一些数据传出。</li><li>不可以使用栈地址，线程结束，该线程的栈地址就没了。（只能使用全局、堆）</li><li>如果没什么要传出的，可以使用 NULL。</li></ul></li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">my_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;child thread id: &quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; endl; <br>  <br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 让父进程抢到 CPU 执行 pthread_exit。验证：不影响子进程。</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;child i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_id;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;pth_id, <span class="hljs-literal">NULL</span>, my_fun, <span class="hljs-literal">NULL</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;parent thread id: &quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; endl; <br>  <br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 父进程退出，以下代码不执行。</span><br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;parent i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-9-阻塞等待子线程的退出">16.9 阻塞等待子线程的退出</h3><blockquote><p>和回收进程的 wait 相似。</p><p>子线程的 PCB 需要父线程来回收，pthread_join 可以阻塞等待子线程结束。</p></blockquote><p><strong>（1）函数原型</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong>thread</strong>：要回收的子线程的线程 ID。</li><li><strong>retval</strong>：<ul><li>传出参数，需要定义二级指针，并传入地址。</li><li>二级指针，读取线程退出的时候携带的状态信息。</li><li>retval 指向内存和 pthread_exit 参数指向同一块内存地址。</li></ul></li></ul><p><strong>（2）实例：父线程回收子线程</strong></p><p>子线程睡眠，父进程等待。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">my_fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;child pthread id is &quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">pthread_exit</span>(&amp;num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_id;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_id, <span class="hljs-literal">NULL</span>, my_fun, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">void</span> *ptr;<br><br>    <span class="hljs-comment">// 父进程会在此处阻塞，等待子进程退出。</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_join</span>(pth_id, &amp;ptr);<br><br>    <span class="hljs-comment">// 成功回收返回 0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 此处打印 pthread_exit 的参数。（使用栈会出现随机值，只能使用全局变量，或者堆内存。）</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;*ptr = &quot;</span> &lt;&lt; *(<span class="hljs-type">int</span> *)ptr &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 检测阻塞效果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-10-线程分离">16.10 线程分离</h3><p><strong>（1）pthread_detach 函数</strong></p><p>创建线程后，实现线程分离。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>调用 pthread_deach 不需要 pthread_join。</li><li>子线程会自动回收自己的 pcb。</li></ul><p><strong>（2）创建的时候设置线程分离属性</strong></p><p>步骤：</p><ol><li><strong>定义线程属性类型</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">pthread_attr_t</span> attr;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>对线程属性变量初始化</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>设置线程分离属性</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">int</span> detachstate)</span></span>;<br><span class="hljs-comment">// set detach state  // 设置 分离 状态</span><br></code></pre></td></tr></table></figure><ul><li>attr：传出参数，该函数将 detachstate 写入 attr （线程属性）中。</li><li>detachstate：<ul><li>PTHREAD_CREATE_DETACHED：分离</li><li>PTHREAD_CREATE_JOINABLE：非分离</li></ul></li></ul><ol start="4"><li><strong>释放线程资源</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="16-11-取消线程">16.11 取消线程</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>在要杀死的子进程的对应处理函数的内部，发生过系统调用的地方叫取消点。</li><li>有取消点，才可以调用 pthread_cancel。</li><li>补充：什么叫系统调用？write、printf 这些最后均会调用系统函数。</li></ul><p>PS：如果只是一些定义和赋值，可以在函数内部，写上 pthread_testcancel 函数。</p><h3 id="16-12-判断两个线程相等">16.12 判断两个线程相等</h3><p>因为 pthread_id 是长整型，可以直接比较，这个函数暂且用不上。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_equl</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="17-线程同步">17.线程同步</h2><h3 id="17-1-为什么需要同步">17.1 为什么需要同步</h3><p>数据的流向是 <strong>内存/缓存 – 寄存器 – CPU</strong>。也就是说，num变量进行计算需要三步：</p><ol><li>从内存/缓存中拷贝到寄存器</li><li>CPU 在寄存器中运算</li><li>从寄存器拷贝回内存/缓存。</li></ol><p>如果实际线程运行时，谁抢到 CPU 谁来执行，所以运行顺序不一定，可能会出现线程指令交叉执行的情况。</p><p>如下图，其实完成了两次 num++，但是最后两次复制指令一起执行，覆盖了数据。</p><p><img src="https://hutu.aimtao.net/mark/2021-03-03-aB2S3c.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p>代码如下：两个线程分别让 num 自增一千万次，如果最后 num 不等于两千万，则说明线程不同步产生了问题。</p><p>PS：应保证大数据量，并多次运行，才更有可能出现问题。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Func_a</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Func_b</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pth_a, pth_b;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_b, <span class="hljs-literal">NULL</span>, Func_b, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_a, <span class="hljs-literal">NULL</span>, Func_a, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth_a, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth_b, <span class="hljs-literal">NULL</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-2-线程同步的思想">17.2 线程同步的思想</h3><p><strong>（1）数据错乱的原因</strong>：</p><ul><li>操作了共享资源。</li><li>CPU 调度问题。</li></ul><p><strong>（2）什么是同步</strong>：</p><ul><li>协同步调，按照先后顺序执行操作。</li></ul><p><strong>（3）思想</strong></p><ul><li><p>使用临界资源之前，先检查锁。</p></li><li><p>使用临界资源时，上锁。</p></li><li><p>使用临界资源时，解锁。</p></li></ul><h2 id="18-互斥锁（互斥量）">18.互斥锁（互斥量）</h2><h3 id="18-1-互斥锁的类型">18.1 互斥锁的类型</h3><p>类型：pthread_mutex_t</p><h3 id="18-2-互斥锁的特点">18.2 互斥锁的特点</h3><ul><li>多线程串行操作：缺点：慢/效率低。</li></ul><p><a name="互斥锁的原理"></a></p><h3 id="18-3-加锁解锁的原理">18.3 加锁解锁的原理</h3><ul><li><p>mutex 初始化后，可以看作 mutex = 1，表示可以加锁，也就是可以继续往下执行。</p></li><li><p>加锁后，mutex == 0，表示当前不可加锁，需在此阻塞。</p></li><li><p>反之亦然，当解锁时，metux 从 0 变为 1。</p></li></ul><p>线程 1：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">加锁语句<span class="hljs-number">1</span><br><br>    <span class="hljs-comment">/* 代码：读写共享资源 */</span><br>  <br>解锁语句<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>线程 2：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cc">加锁语句<span class="hljs-number">2</span><br><br>    <span class="hljs-comment">/* 代码：读写共享资源 */</span><br>  <br>解锁语句<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>过程分析</strong>：</p><p>当线程 1 拥有 CPU，开始执行，执行到 <code>加锁语句 1</code>，检查 mutex 等于几。</p><ul><li>如果 mutex == 1，继续执行 <code>读写共享资源</code>，同时让 mutex = 0。</li><li>如果 mutex == 0，阻塞在此，等待 mutex == 1 时，再执行下面的代码。</li></ul><p>当线程 2 抢到 CPU，开始执行，执行到 <code>加锁语句 2</code>，检查 mutex 等于几。</p><p>发现 mutex == 0，阻塞在此，放弃 CPU。</p><h3 id="18-4-步骤">18.4 步骤</h3><ol><li><strong>创建互斥锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">pthread_mutex_t</span> mutex;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>初始化互斥锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_mutex_init</span>(<span class="hljs-type">pthread_mutex_t</span> *restrict mutex,<br>                  <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *restrict attr<br>                  );<br><br><span class="hljs-comment">// 静态初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><ul><li>restrict：表示 mutex 所指向的内存空间，只能由 mutex 来访问。其他的指针就是等于 mutex，也不能访问。（对函数使用没有影响）</li><li>attr：线程锁的属性，填 NULL 即可。</li><li>初始化后，mutex == 1，加锁后，mutex == 0。一直在 0 和 1之前徘徊。【<a href="#互斥锁的原理">互斥锁的原理</a>】</li></ul><ol start="3"><li><strong>加锁</strong></li></ol><p>如果加锁成功，mutex 从 1 变为 0。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 阻塞锁</span><br><span class="hljs-built_in">pthread_mutex_lock</span>(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><ul><li>临界资源没被上锁 — 当前线程上锁。</li><li>临界资源已经上锁 — 当前线程阻塞，锁被打开的时候，线程解除阻塞。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 不会阻塞的锁</span><br><span class="hljs-built_in">pthread_mutex_trylock</span>(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><ul><li>临界资源没被上锁 — 当前线程上锁，返回 0。</li><li>临界资源已经上锁 — 加锁失败，返回错误号，不阻塞。（通过对返回值的判断，来决定执行什么操作）</li></ul><ol start="4"><li><strong>解锁</strong></li></ol><p>在解锁的同时，会唤醒阻塞在该锁上的所有线程。mutex 从 0 变为 1。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_mutex_unlock</span>(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>销毁互斥锁/释放资源</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_mutex_destroy</span>(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><h3 id="18-5-临界区">18.5 临界区</h3><p>临界区就是，锁所包含的代码块。</p><ul><li><p>临界区越小越好，否则大段代码块串行，程序效率低。</p></li><li><p>举个例子：有 30 行代码，中间 20 行没有用到临界资源。应该多次加锁解锁。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// lock</span><br><span class="hljs-number">10</span> 行需要加锁的代码<br><span class="hljs-comment">// unlock</span><br>  <br><span class="hljs-number">20</span> 行不需要加锁的代码<br>  <br><span class="hljs-comment">// lock</span><br><span class="hljs-number">10</span> 行需要加锁的代码<br><span class="hljs-comment">// unlock</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="18-6-实例">18.6 实例</h3><p>竞争资源：num。</p><p>两个线程分别对 num 进行 ++ 操作。</p><p>注意：</p><ul><li>C++11 中有 mutex 类，在头文件 &lt;mutex&gt; 中，是 std 命名空间下。</li><li>下列代码使用的是 pthread 中的互斥锁，为避免歧义报错，不可使用 <code>using namespace std</code>。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 1.创建互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">func_a</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br><br>        <span class="hljs-comment">// 3.加锁</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        num++;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 4.解锁</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">func_b</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br><br>        <span class="hljs-comment">// 3.加锁</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        num++;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 4.解锁</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 2.初始化互斥锁</span><br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">pthread_t</span> pth_a, pth_b;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_a, <span class="hljs-literal">NULL</span>,func_a, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth_b, <span class="hljs-literal">NULL</span>,func_b, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth_a, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth_b, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 5.销毁互斥锁</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt;  num &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-死锁">19.死锁</h2><h3 id="19-1-造成死锁的原因">19.1 造成死锁的原因</h3><ul><li>自己锁自己</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">// 因为已经加锁，此函数阻塞在这里</span><br></code></pre></td></tr></table></figure><ul><li>加锁后未解开，其他线程阻塞</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// func_b()</span><br><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">// 只加锁为解锁</span><br><br><span class="hljs-comment">// func_a()</span><br><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">// 阻塞在此</span><br><span class="hljs-comment">//临界区代码</span><br><span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br></code></pre></td></tr></table></figure><ul><li>竞争临界资源</li></ul><pre><code class="mermaid">graph LR
1(线程1) --&gt;|给 A 加锁| A(共享资源A)
1 --&gt;|阻塞等待B| B(共享资源B)
2(线程2) --&gt;|阻塞等待A| A
2 --&gt;|给 B 加锁| B
</code></pre><h3 id="19-2-解决死锁">19.2 解决死锁</h3><ul><li><p>让线程按照一定的顺序去访问共享资源。（比如先访问共享资源 A，再访问共享资源 B）</p></li><li><p>在访问其他锁的时候，需要先讲自己的锁解开。</p></li><li><p>trylock 不阻塞。</p></li></ul><h2 id="20-读写锁">20.读写锁</h2><blockquote><p>读锁写锁是一把锁，调用函数不一样。</p></blockquote><h3 id="20-1-读写锁的类型">20.1 读写锁的类型</h3><p>类型：pthread_rwlock_t</p><h3 id="20-2-读写锁的特点">20.2 读写锁的特点</h3><ul><li><p>读共享，并行处理。</p><p>例：线程A读操作加锁时；线程B想要读操作加锁，加锁成功。</p></li><li><p>写独占，串行处理。</p><p>例：线程A写操作加锁时；线程B想要写操作加锁，加锁阻塞。</p></li><li><p>读写不能同时。</p><p>例：线程A读操作加锁时；线程B想要写操作加锁，加锁阻塞；随后线程C想要读操作加锁，加锁阻塞。</p><ul><li>原因1：<strong>读写不能同时</strong>。线程A读加锁，线程B写加锁，会阻塞。</li><li>原因2：<strong>写的优先级更高</strong>。线程B写加锁阻塞，线程C再想读，也会阻塞。</li><li>等到线程A解锁，线程B会加锁成功，线程C依旧阻塞。</li></ul></li><li><p>写的优先级更高。</p><p>例：线程A写操作加锁时；线程B想要读操作加锁，加锁阻塞；随后线程C想要写操作加锁，加锁阻塞。</p><ul><li>等到线程A解锁，线程C会写加锁成功，线程B依旧阻塞。因为写的优先级更高。</li></ul></li></ul><h3 id="20-3-读写锁适用的场景">20.3 读写锁适用的场景</h3><p>读操作的次数 &gt; 写操作的 次数</p><h3 id="20-4-步骤">20.4 步骤</h3><ol><li><strong>创建读写锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>初始化读写锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_rwlock_init</span>(<span class="hljs-type">pthread_rwlock_t</span> *restrict rwlock,<br>                  <span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> *restrict attr<br>                  );<br></code></pre></td></tr></table></figure><ul><li>restrict：表示 rwlock 所指向的内存空间，只能由 rwlock 来访问。其他的指针就是等于 rwlock，也不能访问。（对函数使用没有影响）</li><li>attr：线程锁的属性，填 NULL 即可。</li></ul><ol start="3"><li><strong>加读锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 阻塞锁</span><br><span class="hljs-built_in">pthread_rwlock_rdlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><ul><li>临界资源无写锁 — 当前线程上锁。</li><li>临界资源有写锁 — 当前线程阻塞，锁被打开的时候，线程解除阻塞。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 不会阻塞的锁</span><br><span class="hljs-built_in">pthread_rwlock_tryrdlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><ul><li>临界资源无写锁 — 当前线程上锁，返回 0。</li><li>临界资源有写锁 — 加锁失败，返回错误号，不阻塞。（通过对返回值的判断，来决定执行什么操作）</li></ul><ol start="4"><li><strong>加写锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 阻塞锁</span><br><span class="hljs-built_in">pthread_rwlock_wrlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><ul><li>临界资源无锁 — 当前线程上锁。</li><li>临界资源有读锁或者写锁 — 当前线程阻塞，锁被打开的时候，线程解除阻塞。</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 不会阻塞的锁</span><br><span class="hljs-built_in">pthread_rwlock_trywrlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><ul><li>临界资源无写锁 — 当前线程上锁，返回 0。</li><li>临界资源有写锁 — 加锁失败，返回错误号，不阻塞。（通过对返回值的判断，来决定执行什么操作）</li></ul><ol start="5"><li><strong>解锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_rwlock_unlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>销毁读写锁锁/释放资源</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_rwlock_destroy</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock);<br></code></pre></td></tr></table></figure><h3 id="20-5-实例">20.5 实例</h3><p>竞争资源：number。</p><p>3 个写线程，5 个读线程对 number 进行读写操作。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 1.创建读写锁</span><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count = <span class="hljs-number">100000</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">write_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (count--) &#123;<br>        <span class="hljs-comment">// 3.加写锁</span><br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        number++;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;=======write: &quot;</span>  &lt;&lt; number &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 4.解锁</span><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">read_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (count--) &#123;<br>        <span class="hljs-comment">// 3.加读锁</span><br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;=======read: &quot;</span>  &lt;&lt; number &lt;&lt; std::endl;<br>        <br>        <span class="hljs-comment">// 4.解锁</span><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 2.初始化读写锁</span><br>    <span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">pthread_t</span> pth[<span class="hljs-number">8</span>];<br><br>    <span class="hljs-comment">// 创建 3 个写线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">pthread_create</span>(&amp;pth[i], <span class="hljs-literal">NULL</span>, write_func, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建 5 个读线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">pthread_create</span>(&amp;pth[i], <span class="hljs-literal">NULL</span>, read_func, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 阻塞回收子线程的 PCB</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-built_in">pthread_join</span>(pth[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 5.回收资源</span><br>    <span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>##21.条件变量</p><blockquote><p>不是锁，在不满足条件时，阻塞线程。</p></blockquote><h3 id="21-1-为什么需要条件变量">21.1 为什么需要条件变量</h3><p>因为互斥锁没办法做到阻塞线程，它只能保证共享资源操作的原子性。</p><p>条件变量 + 互斥锁一起使用：</p><ul><li>条件变量：不满足条件则阻塞</li><li>互斥锁：保护共享资源</li></ul><h3 id="21-2-条件变量的两个动作">21.2 条件变量的两个动作</h3><ul><li>条件不满足，阻塞线程。</li><li>条件满足，通知阻塞的线程开始工作。</li></ul><h3 id="21-3-条件变量的类型">21.3 条件变量的类型</h3><blockquote><p>condtion：条件</p></blockquote><p>类型：pthread_cond_t。</p><h3 id="21-4-步骤">21.4 步骤</h3><ol><li><strong>创建条件变量</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">pthread_cond_t</span> cond;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>初始化条件变量</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_inti</span>(<span class="hljs-type">pthread_cond_t</span> *restrict cond,<br>                     <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *restrict attr<br>                 );<br></code></pre></td></tr></table></figure><ul><li>attr：条件变量的属性，填 NULL 即可。</li></ul><ol start="3"><li><strong>阻塞等待一个条件变量</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_wait</span>(<span class="hljs-type">pthread_cond_t</span> *restrict cond,<br>                  <span class="hljs-type">pthread_mutex_t</span> *restrict mutex<br>                 )<br></code></pre></td></tr></table></figure><ul><li>功能：<ul><li>阻塞线程</li><li><strong>将已经上锁的 mutex 解锁</strong>（具体原因，参见 <a href="#消费者生产者模型">消费者生产者模型的问题</a> ）</li><li>条件变量阻塞结束后，将 mutex 重新加锁</li></ul></li></ul><ol start="4"><li><strong>限时等待一个条件变量</strong></li></ol><blockquote><p>非永久阻塞，阻塞一定的时长。</p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_timedwait</span>(<span class="hljs-type">pthread_cond_t</span> *restrict cond,<br>                       <span class="hljs-type">pthread_mutex_t</span> *restrict mutex,<br>                       <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *restrict abstime<br>                      );<br></code></pre></td></tr></table></figure><ul><li>abstime：阻塞时长，绝对时间。</li></ul><ol start="5"><li><strong>唤醒 至少一个阻塞在条件变量上的 线程</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_signal</span>(<span class="hljs-type">pthread_cond_t</span> *cond);<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>唤醒 全部阻塞在条件变量上的 线程</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_broadcast</span>(<span class="hljs-type">pthread_cond_t</span> *cond);<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>销毁条件变量/释放资源</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">pthread_cond_destroy</span>(<span class="hljs-type">pthread_cond_t</span> *cond);<br></code></pre></td></tr></table></figure><h3 id="21-5-生产者消费者思路">21.5 生产者消费者思路</h3><p>生产者线程</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 一直生产</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">/* 代码：生产产品 */</span> <br>     <br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-comment">/* 代码：将产品加入缓冲区 */</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br><br>    <span class="hljs-built_in">pthread_cond_signal</span>(<span class="hljs-type">pthread_cond_t</span> *cond);  <span class="hljs-comment">// 唤醒消费者</span><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者线程</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">// 一直消费</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>  <br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">// 因为要访问 buffer，所以要加锁</span><br>    <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">// 判断缓冲区是否有产品可以消费</span><br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);   <span class="hljs-comment">// 阻塞，等待生产者生产产品后唤醒</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/* 代码：消费产品 */</span><br>    <br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="消费者生产者模型"></a></p><p><strong>重要问题</strong>：</p><ul><li><p>当消费者发现 buffer 为空时，会阻塞等待，生产者生产。</p></li><li><p>问题在于：此时 buffer 已经被消费者加锁了，生产者会阻塞在 <code>将产品加入缓冲区</code> 的位置。</p></li></ul><p>不用担心，因为加锁 buffer 后，条件变量发生了阻塞，此时会解开互斥锁；等到条件变量不再阻塞时，再锁上互斥锁。</p><h3 id="21-6-实例：生产者消费者模型">21.6 实例：生产者消费者模型</h3><p>利用 互斥锁 + 条件变量 实现生产者消费者模型。</p><ul><li>条件变量：不满足条件则阻塞</li><li>互斥锁：保护共享资源</li></ul><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    Node* next;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-built_in">Node</span>(Node *ptr, <span class="hljs-type">int</span> number) : <span class="hljs-built_in">next</span>(ptr), <span class="hljs-built_in">data</span>(number) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义缓冲区 buffer</span><br>Node* head = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 定义互斥锁 + 条件变量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">pthread_cond_t</span> cond;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <br>        <span class="hljs-comment">// 生产</span><br>        <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 加锁</span><br>        Node *tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head, <span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000</span>);<br>        head = tmp;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;++++++++++producer: &quot;</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond);    <span class="hljs-comment">// 唤醒条件变量的阻塞</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <br>        <span class="hljs-comment">// 消费</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="hljs-comment">// 条件变量阻塞</span><br>        &#125;<br>        Node* tmp = head;<br>        head = head-&gt;next;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;----------customer: &quot;</span> &lt;&lt; tmp-&gt;data &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化互斥锁 + 条件变量</span><br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_cond_init</span>(&amp;cond, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建生产者和消费者</span><br>    <span class="hljs-type">pthread_t</span> pth1, pth2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth2, <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth1, <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 阻塞回收子线程</span><br>    <span class="hljs-built_in">pthread_join</span>(pth1, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-信号量">22.信号量</h2><h3 id="22-1-概念">22.1 概念</h3><p><strong>头文件</strong>：&lt;semaphore.h&gt;</p><p><strong>类型</strong>：sem_t</p><p><strong>作用</strong>：加强版互斥锁</p><p><strong>区别</strong>：</p><ul><li>因为 mutex 在 0 和 1 之前徘徊，它实现的同步都是串行的。</li><li>信号量类似于封装了多把互斥锁，从而实现并行。</li></ul><p><strong>举个例子</strong>：</p><ul><li>使用互斥锁：一次只能让一辆车进入停车场。</li><li>使用信号量：一次可以让四辆车进入停车场。</li></ul><p><img src="https://hutu.aimtao.net/mark/2021-03-05-0yaq3m.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="22-2-步骤">22.2 步骤</h3><ol><li><strong>创建信号量</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-type">sem_t</span> sem;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>初始化信号量</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_init</span>(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value);<br></code></pre></td></tr></table></figure><ul><li>pshared：pshared == 0，线程同步；pshared == 1，进程同步。</li><li>value：最多允许 value 个线程操作数据。</li></ul><ol start="3"><li><strong>加锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_wait</span>(<span class="hljs-type">sem_t</span> *sem);<br></code></pre></td></tr></table></figure><ul><li><p>调用一次 wait，相当于对 sem 做了 <code>--</code> 操作。</p></li><li><p>当 sem 减为 0时，线程会阻塞。</p></li></ul><ol start="4"><li><strong>尝试加锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_trywait</span>(<span class="hljs-type">sem_t</span> *sem);<br></code></pre></td></tr></table></figure><ul><li>sem == 0，加锁失败，但是不阻塞，直接返回错误号。</li></ul><ol start="5"><li><strong>限时尝试加锁</strong></li></ol><p>在一定时间内，不断尝试加锁，时间结束，不再尝试。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_timedwait</span>(<span class="hljs-type">sem_t</span> *sem, xxxx);<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>解锁</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_post</span>(<span class="hljs-type">sem_t</span> *sem);<br></code></pre></td></tr></table></figure><ul><li>对 sem 做 <code>++</code> 操作。</li></ul><ol start="7"><li><strong>销毁信号量/释放资源</strong></li></ol><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_destroy</span>(<span class="hljs-type">sem_t</span> *sem);<br></code></pre></td></tr></table></figure><h3 id="22-3-生产者消费者思路">22.3 生产者消费者思路</h3><p>生产者线程</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_init</span>(&amp;produce, <span class="hljs-number">2</span>);     <span class="hljs-comment">// 给生产者分配 2 个资源 </span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">sem_wait</span> (&amp;produce);   <span class="hljs-comment">// produce--，表示可生产的数量越来越少</span><br>  <br>  <br>      <span class="hljs-comment">/* 代码：生产节点 */</span><br>      <span class="hljs-comment">/* 代码：将节点加入缓冲区 */</span><br>  <br>      <span class="hljs-built_in">sem_post</span>(&amp;customer);    <span class="hljs-comment">// 给消费者增加一个产品，customer++</span><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者线程</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-built_in">sem_init</span>(&amp;customer, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 给 消费者 分配 0 个产品</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">sem_wait</span>(&amp;customer);   <span class="hljs-comment">//  判断是否有产品消费：无产品--阻塞，有产品，customer--</span><br>  <br>      <span class="hljs-comment">/* 代码：消费节点 */</span><br>  <br>      <span class="hljs-built_in">sem_post</span>(&amp;produce);     <span class="hljs-comment">// 将占有的资源还给生产者，produce++</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-4-实例：生产者消费者模型">22.4 实例：生产者消费者模型</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    Node* next;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-built_in">Node</span>(Node *ptr, <span class="hljs-type">int</span> number) : <span class="hljs-built_in">next</span>(ptr), <span class="hljs-built_in">data</span>(number) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义缓冲区 buffer</span><br>Node* head = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 1. 创建信号量</span><br><span class="hljs-type">sem_t</span> produce_sem, customer_sem;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">// 3. 加锁</span><br>        <span class="hljs-built_in">sem_wait</span>(&amp;customer_sem);<br>        Node *tmp = head;<br>        head = head-&gt;next;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;-----customer: &quot;</span> &lt;&lt; tmp-&gt;data &lt;&lt; std::endl;<br>        <span class="hljs-built_in">delete</span>(tmp);<br><br>        <span class="hljs-comment">// 4. 解锁</span><br>        <span class="hljs-built_in">sem_post</span>(&amp;produce_sem);<br>        tmp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>        Node* tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">rand</span>()%<span class="hljs-number">999</span>);<br><br>        <span class="hljs-comment">// 3. 加锁</span><br>        <span class="hljs-built_in">sem_wait</span>(&amp;produce_sem);<br>        tmp-&gt;next = head;<br>        head = tmp;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;+++++produce: &quot;</span> &lt;&lt; head-&gt;data &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 4. 解锁</span><br>        <span class="hljs-built_in">sem_post</span>(&amp;customer_sem);<br>        tmp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 2. 初始化信号量</span><br>    <span class="hljs-built_in">sem_init</span>(&amp;produce_sem, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;customer_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">pthread_t</span> pth1, pth2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth1, <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pth2, <span class="hljs-literal">NULL</span>, produce, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(pth1, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(pth2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 5. 释放资源</span><br>    <span class="hljs-built_in">sem_destroy</span>(&amp;produce_sem);<br>    <span class="hljs-built_in">sem_destroy</span>(&amp;customer_sem);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-5有个问题">22.5有个问题</h3><p>用信号量来实现消费者生产者模型时，</p><p>customer_sem 设为 0、produce_sem 设为 2，</p><p>简化来看，缓冲区是全局变量 num = 0，消费者做 – 操作，生产者做 ++ 操作。</p><p>当生产者有一个产品时，num = 1，customer_sem = 1，produce_sem = 1。</p><p>此时，消费者可以做 – 操作，生产者也可以做 ++ 操作，</p><p>请问如何保持对竞争资源 num 的互斥？是 信号量内部自己实现的互斥吗？</p><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Linux/">#Linux</a> <a href="/tags/C-C/">#C/C++</a></div></div><div class="license-box my-3"><div class="license-title"><div>学习笔记｜Linux 系统编程</div><div>https://www.aimtao.net/linux-system/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2020-12-13</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/two-minute/" title="两分钟法则"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">两分钟法则</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/go/" title="学习笔记｜Go"><span class="hidden-mobile">学习笔记｜Go</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>