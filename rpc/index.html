<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="76x76" href="https://hutu0.aimtao.net/site/icon.webp"><link rel="icon" href="https://hutu0.aimtao.net/site/icon.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="AimTao"><meta name="keywords" content="C++,Python,Go,算法，开发,blog,后端,记录"><meta name="description" content="本文回答了 RPC 是什么、为什么使用 RPC 等问题，并详细探讨了 protobuf 协议和 gRPC 框架。"><title>微服务｜RPC/gRPC - AimTao</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2113603_2ltiep6fmf8.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aimtao.net",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"sh"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:"07fe5d228ae82eadee00480515f9d64b",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"hkFccy0TBvlTMrTD2n9MwSIx-gzGzoHsz",app_key:"yUJSgy6kcnRscdGX9ec7jlFz",server_url:"https://analytics.aimtao.net",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><style type="text/css">.spoiler{display:inline}p.spoiler{display:flex}.spoiler a{pointer-events:none}.spoiler-blur,.spoiler-blur>*{transition:text-shadow .5s ease}.spoiler .spoiler-blur,.spoiler .spoiler-blur>*{color:transparent;background-color:rgba(0,0,0,0);text-shadow:0 0 10px grey;cursor:pointer}.spoiler .spoiler-blur:hover,.spoiler .spoiler-blur:hover>*{text-shadow:0 0 5px grey}.spoiler-box,.spoiler-box>*{transition:color .5s ease,background-color .5s ease}.spoiler .spoiler-box,.spoiler .spoiler-box>*{color:#000;background-color:#000;text-shadow:none}</style><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="AimTao" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AimTao&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> RSS</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-archive-fill"></i> Archives</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/">Timeline </a><a class="dropdown-item" href="/categories/Implement-From-Scratch/">Implement From Scratch </a><a class="dropdown-item" href="/tags/Kernel/">Linux kernel </a><a class="dropdown-item" href="/categories/Mark/">Mark</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://hutu.aimtao.net/web/2022-05-27-rpc.webp-s) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="微服务｜RPC/gRPC"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-27 08:32" pubdate>2022-05-27 AM</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 49k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 37 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">微服务｜RPC/gRPC</h1><p class="note note-info">本文最后更新于：3 years ago</p><div class="markdown-body"><p>本文回答了 RPC 是什么、为什么使用 RPC 等问题，并详细探讨了 protobuf 协议和 gRPC 框架。</p><span id="more"></span><h2 id="1-RPC">1.RPC</h2><h3 id="1-1-RPC-是什么">1.1 RPC 是什么</h3><ul><li>RPC（Remote Procedure Call）远程过程调用。简单说就是，一个节点请求另一个节点提供的服务。</li><li>函数调用是最常见的本地过程调用。</li><li>RPC 就是将本地过程调用，变成远程过程调用。</li></ul><h3 id="1-2-RPC-需要解决的问题">1.2 RPC 需要解决的问题</h3><p>将本地函数放在服务器上运行，有三个主要问题需要解决。</p><p><strong>（1）Call 的 ID 映射</strong></p><ul><li>本地调用是通过函数指针来调用。</li><li>在 RPC 中，所有函数必须有自己的 ID，且 ID 在所有进程中是唯一的。</li><li>客户端与服务端分别维护一个函数与 Call ID 的映射表，二者的表不一定相同，但相同函数对应的 Call ID 必须相同。</li><li>当客户端需要进行远程调用时，查表得到 Call ID，并传给服务端；服务端通过 Call ID 查表得到所调用的函数，并执行对应的函数代码。</li></ul><p><strong>（2）序列化和反序列化</strong></p><ul><li>序列化：把对象转化为字节流，进行网络传输。</li><li>反序列化：把网络中接收的字节流转化为对象。</li></ul><p><strong>（3）网络传输</strong></p><ul><li>大部分 RPC 框架都基于 TCP/UDP 协议进行封装。</li><li>HTTP 1.x 一旦对方返回结果，就会断开连接，因此存在性能问题。</li><li>gRPC 是基于 HTTP 2.0 的，HTTP 2.0 支持长连接。</li></ul><h3 id="1-3-通过-HTTP-完成-Add-服务">1.3 通过 HTTP 完成 Add 服务</h3><p>通过 net/http 库，使用 get 请求完成远程的 add 服务。在这个过程中需要完成 RPC 的三件重要事情：</p><ul><li>Call ID 的映射：使用特定的请求路径来标识，r.URL.path</li><li>序列化和序列化：使用 json.Marshal 完成。</li><li>网络传输：使用 http 发送 get 请求。</li></ul><p>使用 http 的方式完成 RPC 的问题有两点，这是 RPC 框架需要解决的问题。</p><ul><li>写业务逻辑比较麻烦，每个函数都需要写一个请求。</li><li>客户端和服务端需要清晰地明确参数是如何传递的。</li></ul><p><strong>（1）服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/add&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;<br>        <span class="hljs-comment">// 解析并获取参数</span><br>        _ = request.ParseForm()<br>        fmt.Println(<span class="hljs-string">&quot;path: &quot;</span>, request.URL.Path)<br>        a, _ := strconv.Atoi(request.Form[<span class="hljs-string">&quot;a&quot;</span>][<span class="hljs-number">0</span>])<br>        b, _ := strconv.Atoi(request.Form[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-number">0</span>])<br>        <br>        <span class="hljs-comment">// 构造请求头</span><br>        writer.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>        <br>        <span class="hljs-comment">// 序列化成 []byte 类型</span><br>        bytes, _ := json.Marshal(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-string">&quot;data&quot;</span>: a + b,<br>        &#125;)<br>        <br>        <span class="hljs-comment">// 写入 respond</span><br>        _, _ = writer.Write(bytes)<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 监听 8080 端口</span><br>    _ = http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResponseData <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;data&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <br>    <span class="hljs-comment">// 发送 get 请求</span><br>    response, _ := http.Get(fmt.Sprintf(<span class="hljs-string">&quot;http://127.0.0.1:8000/%s?a=%d&amp;b=%d&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, a, b))<br>    <span class="hljs-keyword">defer</span> response.Body.Close()  <span class="hljs-comment">// 程序结束关闭 body</span><br>    <br>    <span class="hljs-comment">// 读取 body</span><br>    body, _ := ioutil.ReadAll(response.Body)<br>    responseData := ResponseData&#123;&#125;  <span class="hljs-comment">// 初始化结构体</span><br>    json.Unmarshal(body, &amp;responseData)   <span class="hljs-comment">// 反序列化 json，并将数据存入结构体</span><br>    <br>    <span class="hljs-keyword">return</span> responseData.Data<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-RPC-开发的要素">1.4 RPC 开发的要素</h3><p><strong>（1）RPC 开发的四大要素</strong></p><ul><li>client：负责发起服务调用，传递参数。</li><li>clent stub：运行在客户端机器上，负责存储要调用的服务端地址等信息，还负责将客户端的请求打包成数据包，发送给服务端。</li><li>server：有客户端要调用的方法，负责执行调用的方法。</li><li>server stub：运行在服务端机器上，负责接受客户端的数据包，并调用在 server 上的方法，并将调用结果进行数据处理，打包返回给客户端。</li></ul><p><strong>（2）原理图</strong></p><p><img src="https://hutu.aimtao.net/mark/2022-07-03-CaL2S1.webp-s" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>（3）过程</strong></p><ul><li>client：client 想要发起远程过程调用，通过调用 client stub 的方式，传递想要调用的方法及参数。</li><li>client stub：接收到 client 的调用请求，将 client 请求调用的方法名、参数等信息序列化，打包成数据包；并查找到远程服务器的 IP 地址及端口。</li><li>socket：，通过 socket 协议，将数据包发送给服务端。</li><li>server stub：接受客户端的数据包，并通过约定好的协议进行反序列化，得到请求的方法名和参数；并调用 server 对应的方法，并传入参数。</li><li>server：执行被调用的方法，处理业务；并将结果返回给 server stub。</li><li>server stub：将 server 返回的结果按照约定的协议，进行序列化，打包成数据包。</li><li>socket：通过 socket 协议，将数据包发送给服务端。</li><li>client stub：接收到返回的数据，按照约定进行反序列化，并将调用结果传给 client。</li><li>client：得到调用结果。</li></ul><p>至此，整个 RPC 调用完成。</p><p><strong>（4）动态代理技术</strong></p><p>在 client stub 和 server stub 中，会使用 <strong>动态代理技术</strong> 自动生成一段代码，这样我们就可以更专注于业务的编码，不用对每个函数调用进行都进行封装一遍。</p><h3 id="1-5-使用-go-内置的-RPC">1.5 使用 go 内置的 RPC</h3><p>下面简单介绍 go 内置的 RPC，主要用到 <code>net</code> 、<code>net/rpc</code> 这两个包。</p><p><strong>（1）服务端</strong></p><ol><li>实例化 server</li><li>将函数注册到 RPC 中</li><li>启动服务</li></ol><p>RPC 主要解决了的问题：call id、序列化和反序列化（使用的 Gob 协议）。listen 和 accept 的都是 net 包完成的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// reply 传出参数</span><br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;CommonHelloService&quot;</span>, &amp;HelloService&#123;&#125;) <br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    第一个参数：是服务的名字，随便起，与结构体 HelloService 命名无关，只要 client/server 在 Call 和 RegisterName 时保持一致就行。</span><br><span class="hljs-comment">    第二个参数：为什么这里要取地址？因为结构体指针实现了 interface。具体原因，见下文。</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept()  <span class="hljs-comment">// conn 是 ServerCodec 类型，里面封装了读/写/关闭操作。</span><br><br>    rpc.ServeConn(conn)<br>&#125;<br></code></pre></td></tr></table></figure><p>补充：<strong>为什么 RegisterName 的第二个参数要取地址？</strong></p><p>这里接收 &amp;HelloService{} 是一个 interface 变量，传给 interface 变量值还是指针，由 HelloService 在实现函数时，用的指针接受者还是值接受者决定。所以，</p><ul><li>如果定义成 <code>func (s *HelloService) Hello(...)</code>，此处只能传递指针类型 <code>&amp;HelloService&#123;&#125;</code>。</li><li>如果定义成 <code>func (s HelloService) Hello(...)</code>，此处可以传递指针类型 <code>&amp;HelloService&#123;&#125;</code> 或值类型 <code>HelloService&#123;&#125;</code>。</li></ul><p>如果不知道为什么，建议阅读 <a href="https://www.aimtao.net/go/#5-5-%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B">接口的值类型</a></p><p><strong>（2）客户端</strong></p><ol><li>建立连接</li><li>远程调用函数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1. 建立连接</span><br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;connect fail.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;CommonHelloService.Hello&quot;</span>, <span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-序列化格式使用-json">1.6 序列化格式使用 json</h3><p>RPC 使用的序列化协议是 Gob，而 json 是使用更加广泛的格式，为了满足跨语言的需求，一般会使用 json 格式来编解码数据。下面将其换成 json。</p><p><strong>（1）服务端</strong></p><p>只需要将 <code>rpc.ServeConn</code> 换成 <code>rpc.ServeCodec</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// reply 传出参数</span><br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, &amp;HelloService&#123;&#125;) <span class="hljs-comment">// 如上文所述原因，需传递指针变量。</span><br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept() <span class="hljs-comment">// conn 是 ServerCodec 类型，里面封装了读/写/关闭操作。</span><br><br>    rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) <span class="hljs-comment">// ServeCodec: 使用指定的编解码器来解码请求和编码响应。这里传入使用 json 编解码的 ServerCodec。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><p>需要将 <code>rpc.Dial</code> 换成 <code>net.Dial</code>，否则使用 <code>rpc.Dial</code> 会使用 Gob 的协议进行编解码。并通过 conn 生成一个 ClientCodec。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1. 建立连接</span><br>    conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br>    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))  <span class="hljs-comment">// 使用json 编解码的 ClientCodec。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;connect fail.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;HelloService.Hello&quot;</span>, <span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7-监听端口使用-http">1.7 监听端口使用 http</h3><p>内置的 RPC 监听的是 TCP 端口，跨语言完成调用时，客户端需要使用 socket 来传递 TCP 数据报。如果监听 http 请求，客户端只需发送 Get/Post 请求即可。</p><p><strong>（1）服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.将函数注册到 RPC 中</span><br>    _ = rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, &amp;HelloService&#123;&#125;) <span class="hljs-comment">// 如上文所述原因，需传递指针变量。</span><br><br>    <span class="hljs-comment">// 2.http 处理函数</span><br>    http.HandleFunc(<span class="hljs-string">&quot;/jsonrpc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> conn io.ReadWriteCloser = <span class="hljs-keyword">struct</span> &#123;<br>            io.Writer<br>            io.ReadCloser<br>        &#125;&#123;<br>            ReadCloser: request.Body,<br>            Writer:     writer,<br>        &#125;<br>        rpc.ServeRequest(jsonrpc.NewServerCodec(conn)) <span class="hljs-comment">// rpc.ServeRequest 只要拿到带有 writer/reader 的 conn 就可以。</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 3.监听 http 端口</span><br>    http.ListenAndServe(<span class="hljs-string">&quot;:8899&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）客户端</strong></p><p>// 待补充</p><h3 id="1-8-封装-Stub">1.8 封装 Stub</h3><p>需求：</p><ol><li>client 使用 <code>client.Hello(request, &amp;reply)</code> 的格式优雅远程调用。</li><li>client/server 使用同一个服务命令，手动写可能出现服务名称不一致/服务名称冲突的错误。</li><li>server 可以专注业务逻辑。</li><li>sever 无序关注服务名称、结构体类型。</li></ol><p>解决：</p><ul><li>需求一，使用 clientStub 将 Dial 和 Call 过程进行封装。</li><li>需求二，使用共同的 handler 文件，在 handler 中将服务名称定义成常量。</li><li>需求三，将业务逻辑部分抽离出来，放到其他文件中（这里为了方便演示，放在了 handler 中，其实不能放在 handler 中，handler 是共有文件，应该新建一个文件。）。</li><li>需求四，使用 serverStub 将 <code>rpc.RegisterName</code> 进行封装，并使用接口接收结构体指针，使 serverStub 与结构体类型解耦。</li></ul><p><strong>（1）handler</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> handler<br><br><span class="hljs-keyword">const</span> HelloServiceName = <span class="hljs-string">&quot;handler/CommonHelloService&quot;</span>   <span class="hljs-comment">// 这是服务的名字，随便起，与结构体 HelloService 命名无关，只要 client/server 在 Call 和 RegisterName 时保持一致就行。</span><br><br><span class="hljs-comment">// HelloService ：想要将多个方法注册到 rpc 当中，可以使用 struct 来封装多个方法，然后注册 struct 即可。</span><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实际的业务逻辑（真正被远程调用的函数）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    *reply = <span class="hljs-string">&quot;hello &quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）clientStub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> clientStub<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HelloServiceStub <span class="hljs-keyword">struct</span> &#123;<br>    *rpc.Client <span class="hljs-comment">// 最终用来 call 调用函数的是 *rpc.Client。这里封装成 HelloServiceStub，便于在 client 中，直接使用 HelloServiceStub.Hello 的形式调用。</span><br>&#125;<br><br><span class="hljs-comment">// NewHelloServiceClient go 中没有类、对象，所以没有初始化方法。这里需要写一个 New 方法，获取到 *rpc.Client，实例化一个 HelloServiceStub。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHelloServiceClient</span><span class="hljs-params">(protocol, address <span class="hljs-type">string</span>)</span></span> (HelloServiceStub, <span class="hljs-type">error</span>) &#123;<br>    conn, err := rpc.Dial(protocol, address)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> HelloServiceStub&#123;conn&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c HelloServiceStub)</span></span> Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;  <span class="hljs-comment">// 实现要调用的方法</span><br>    err := c.Call(handler.HelloServiceName+<span class="hljs-string">&quot;.Hello&quot;</span>, request, reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/RPCWithStub/clientStub&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.建立连接，获取到一个 *rpc.Client。</span><br>    client, _ := clientStub.NewHelloServiceClient(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.远程调用函数</span><br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err := client.Hello(<span class="hljs-string">&quot;xiaomi&quot;</span>, &amp;reply) <span class="hljs-comment">// 实现优雅调用。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;call fail.&quot;</span>)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）serverStub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> serverStub<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-comment">// 使用接口，将 RegisterHelloService 形参类型 与 handler 中的结构体类型解耦。</span><br><span class="hljs-keyword">type</span> HelloServer <span class="hljs-keyword">interface</span> &#123;<br>    Hello(request <span class="hljs-type">string</span>, reply *<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterHelloService</span><span class="hljs-params">(srv HelloServer)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 只要实现了 Hello 方法，都可以将结构体传给 HelloServer 类型的接口变量。</span><br>    <span class="hljs-keyword">return</span> rpc.RegisterName(handler.HelloServiceName, srv)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（5）server</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;learngo/RPCWithStub/handler&quot;</span><br>    <span class="hljs-string">&quot;learngo/RPCWithStub/serverStub&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 server</span><br>    listener, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8899&quot;</span>)<br><br>    <span class="hljs-comment">// 2.将函数注册到 RPC 中</span><br>    <span class="hljs-comment">// 此处封装了注册过程中结构体的类型，结构体的类型不重要，重点是 Hello 这个函数，只要带有 Hello 方法的结构体即可。</span><br>    _ = serverStub.RegisterHelloService(&amp;handler.HelloService&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.启动服务</span><br>    conn, _ := listener.Accept()<br><br>    rpc.ServeConn(conn)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-9-总结">1.9 总结</h3><p>为什么要花篇幅来分析内置 RPC 的使用？因为以上所解决的问题，就是 gRPC 或其他 RPC 框架所解决的问题。</p><p>更重要的是 <strong>serverStub/clientStub 可以通过 protobuf 自动生成</strong>，并且可以生成多语言版本。</p><h2 id="2-protobuf">2.protobuf</h2><blockquote><p>Reference Documents：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p></blockquote><h3 id="2-1-是什么">2.1 是什么</h3><p>Protocol Buffer，是 google 退出的一种轻量高效的结构化数据存储格式。和 json、xml 作用一样，但 protobuf 的性能远超 json、xml，数据压缩比比较高。</p><p>protobuf 经历了 protobuf2 和 protobuf3，目前主流版本是 protobuf3。</p><blockquote><p>同类的格式还有：java 中的 dubbo/rmi/hessian，python 中的 messagepack，go 中的 gob。</p></blockquote><h3 id="2-2-protobuf-优缺点">2.2 protobuf 优缺点</h3><p>优点：</p><ul><li>性能：压缩性好（压缩得越小，传输越快），序列化/反序列化快（比 json、xml 快 2-100 倍）。</li><li>便捷性：使用简单（自动生成序列化/反序列化代码），维护成本低（只需要维护 proto 文件），向后兼容（增加内容，可以不破坏旧格式），加密性好（二进制流）。</li><li>跨语言：跨平台，支持各种主流语言。</li></ul><p>缺点：</p><ul><li>通用型差：任何语言都支持 json，但是 protobuf 需要专门的解析库。</li><li>自解释性差：加密成了二进制流，只要通过 proto 文件才能了解数据结构。</li></ul><h3 id="2-3-环境配置">2.3 环境配置</h3><p>需要安装 <a target="_blank" rel="noopener" href="https://grpc.io/docs/protoc-installation/">protoc</a>，下载 <a target="_blank" rel="noopener" href="https://grpc.io/docs/languages/go/quickstart/">protoc-gen-go</a> 依赖包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install protobuf  <span class="hljs-comment">#  这是 macOS 的安装命令，其他系统在上面的链接中自行查找。</span><br>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest   <span class="hljs-comment"># 生成 go 源代码用的。</span><br>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest <span class="hljs-comment">#支持生成 grpc 部分代码</span><br></code></pre></td></tr></table></figure><h3 id="2-4-最小实践">2.4 最小实践</h3><p>protobuf 最原始的功能就是数据编码，使用主要分三步；</p><ol><li>使用 proto 文件约束数据类型。（也就是结构体。）</li><li>自动生成源代码。</li><li>使用 <code>github.com/golang/protobuf/proto</code> 对数据进行序列化/反序列化。</li></ol><p>注意：使用 proto 只能进行数据编码，加上 grpc 插件后，可以定义一些服务。</p><p><strong>（1）使用 proto 文件约束数据类型</strong></p><p>注意：1 是编号不是值，编码时只认编号不认变量名。（<strong>坑</strong>：联调时两个人编号不一致。）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;  <span class="hljs-comment">// 使用 proto3 的语法</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;  <span class="hljs-comment">// 生成源码文件的包名，只影响 go 语言。具体使用见 2.6 go_package 的作用</span><br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">SayHello</span> &#123;  <span class="hljs-comment">// 定义服务（也就是方法接口）  // 使用 grpc 插件才可以使用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Hello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;   <span class="hljs-comment">// 定义消息类型（也就是结构体类型）</span><br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 1 是编号不是值，编码时只认编号不认变量名。坑：联调时两个人编号不一致。</span><br>&#125;<br><br><span class="hljs-keyword">message  </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）自动生成 go 源码</strong></p><p>已经废弃的写法：</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . helloworld.proto --go_out=plugins=grpc:.<br></code></pre></td></tr></table></figure><ul><li><code>-I .</code>：表示 include 当前目录。在当前目录寻找 helloworld.proto。</li><li><code>--go_out</code>：表示生成 go 的源码，<code>--java_out</code> 即可生成 java 的源码。等号后面可以加选项，选项使用键值对表示。</li><li><code>plugins=grpc</code>：一个键值对，表示使用 grpc 插件。</li><li><code>:.</code>：使用 <code>:</code> 将前面的键值对和路径隔开。<code>.</code> 表示在当前目录下生成 <code>bp.go</code> 文件</li></ul></blockquote><p>推荐的写法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . helloworld.proto --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative<br></code></pre></td></tr></table></figure><ul><li><code>-I .</code>：表示 include 当前目录。在当前目录寻找 helloworld.proto。</li><li><code>--go_out=.</code>：表示生成用于 protobuf 编码的 go 源码，<code>--java_out</code> 即可生成 java 的源码。等号后面是生成 bp.go 的路径。</li><li><code>--go_opt=</code>：等号后面可以加选项，选项使用键值对表示。</li><li><code>--go-grpc_out=.</code>：表示生成 grpc 的源码。等号后面是生成 grpc 的 bp.go 的路径。</li><li><code>--go-grpc_opt=</code>：等号后面可以加选项，选项使用键值对表示。只对 grpc 部分代码有效。</li></ul><p>主要有两个变化：</p><ul><li>将键值对选项和生成路径分开： <code>--go_out</code> 只表示生成 bp.go 的路径，另用 <code>--go_opt</code> 表示键值对选项。</li><li>将用于 protobuf 编码的 go 源码和 grpc 的源码分开生成：<code>--go_out</code> 表示前者，<code>go-grpc_out</code> 表示后者。</li></ul><p><strong>（4）使用 protobuf 编解码</strong></p><p>使用 proto 序列化/反序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/golang/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 实例化一个 struct</span><br>    req := helloworld.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// 编码</span><br>    bytes, _ := proto.Marshal(&amp;req)<br>    fmt.Println(bytes) <span class="hljs-comment">// [10 3 84 111 109] // 编码后自解释性差</span><br><br>    <span class="hljs-comment">// 解码</span><br>    newBytes := helloworld.HelloRequest&#123;&#125;<br>    _ = proto.Unmarshal(bytes, &amp;newBytes) <span class="hljs-comment">// 传入一个空 struct 作为传出参数</span><br>    fmt.Println(newBytes.Name)            <span class="hljs-comment">// Tom  // 成功复原</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-基本类型和默认值">2.5 基本类型和默认值</h3><p><strong>（1）基本类型</strong></p><blockquote><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">https://developers.google.com/protocol-buffers/docs/proto3#scalar</a></p></blockquote><table><thead><tr><th style="text-align:left">proto Type</th><th>Notes</th><th style="text-align:left">Go Type</th></tr></thead><tbody><tr><td style="text-align:left">double</td><td></td><td style="text-align:left">float64</td></tr><tr><td style="text-align:left">float</td><td></td><td style="text-align:left">float32</td></tr><tr><td style="text-align:left">int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.使用可变长度编码。编码负数效率低下——如果您的字段可能具有负值，请使用 sint32。</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.使用可变长度编码。编码负数效率低下——如果您的字段可能具有负值，请使用 sint64。</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">uint32</td><td>Uses variable-length encoding.使用可变长度编码。</td><td style="text-align:left">uint32</td></tr><tr><td style="text-align:left">uint64</td><td>Uses variable-length encoding.</td><td style="text-align:left">uint64</td></tr><tr><td style="text-align:left">sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.使用可变长度编码。有符号的 int 值。这些比常规 int32 更有效地编码负数。</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.使用可变长度编码。有符号的 int 值。这些比常规 int64 更有效地编码负数。</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 228.总是四个字节。如果值通常大于228，则比uint32更有效率。</td><td style="text-align:left">uint32</td></tr><tr><td style="text-align:left">fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 256.总是八字节。如果值通常大于256，则比uint64更有效率。</td><td style="text-align:left">uint64</td></tr><tr><td style="text-align:left">sfixed32</td><td>Always four bytes.</td><td style="text-align:left">int32</td></tr><tr><td style="text-align:left">sfixed64</td><td>Always eight bytes.</td><td style="text-align:left">int64</td></tr><tr><td style="text-align:left">bool</td><td></td><td style="text-align:left">bool</td></tr><tr><td style="text-align:left">string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过232。</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">bytes</td><td>May contain any arbitrary sequence of bytes no longer than 232.可以包含任何不超过232的任意字节序列。</td><td style="text-align:left">[]byte</td></tr></tbody></table><p><strong>（2）默认值</strong></p><blockquote><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#default">https://developers.google.com/protocol-buffers/docs/proto3#default</a></p></blockquote><p>当解析消息时，如果编码的消息不包含特定的 singular 元素，则解析对象中的相应字段将设置为该字段的默认值。</p><table><thead><tr><th>.proto Type</th><th>default</th></tr></thead><tbody><tr><td>string</td><td>“”</td></tr><tr><td>byte</td><td>‘’</td></tr><tr><td>bool</td><td>false</td></tr><tr><td>数值类型</td><td>0</td></tr><tr><td>enum</td><td>默认时第一个定义的枚举值，必须为 0</td></tr><tr><td>message</td><td>默认值根据使用的语言确定的</td></tr></tbody></table><h3 id="2-6-指定字段规则">2.6 指定字段规则</h3><p><strong>（1）option</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;../common/stream/proto/v1;helloworld&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>../common/stream/proto/v1</code>：指定生成 pb.go 文件所在的路径。</li><li><code>helloworld</code>：生成 pb.go 文件的包名。</li><li>注：go_package 只会对 go 进行约束，不会影响其他语言。</li></ul><p>在开发过程中，会将 proto 文件和 pb.go 文件分开存放。文件结构如下，其中生成的 bp.go 文件可能是公共的，并且分目录和版本。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<br>├── <span class="hljs-keyword">common</span><br>│   └── stream<br>│       └── proto<br>│           └── v1<br>│               └── stream.pb.go<br>├── proto<br>│   └── stream.proto<br>├── <span class="hljs-keyword">client</span><br>│   └── <span class="hljs-keyword">client</span>.go<br>└── <span class="hljs-keyword">server</span><br>    └── <span class="hljs-keyword">server</span>.go<br></code></pre></td></tr></table></figure><p><strong>（2）singular</strong></p><p>单数，表示字段出现 0 次或 1 次。proto3 每个字段的修饰符默认是 singular。</p><p><strong>（3）repeated</strong></p><p>复数，表示该字段可重复，对应的 go 中的切片。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">hello</span> &#123;<br>    <span class="hljs-keyword">repeated</span> <span class="hljs-type">int32</span> num = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 在 go 中为 []int</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-嵌套-proto-文件">2.7 嵌套 proto 文件</h3><p>（<strong>1）为什么需要嵌套 proto 文件？</strong></p><ul><li>消息类型可能比较多，不可能只写一个 proto 文件。</li><li>有些 meassage 类型可能通用，比如 <a target="_blank" rel="noopener" href="https://github.com/golang/protobuf/tree/master/ptypes">protobuf 就内置了一些 message</a>（<a target="_blank" rel="noopener" href="http://github.com/golang/protobuf/ptypes%EF%BC%89%E3%80%82">github.com/golang/protobuf/ptypes）。</a></li></ul><p><strong>（2）实际的例子：empty message 的应用</strong></p><p><strong>需求</strong>：Ping 是一个测试是否连通的服务，发送请求时无需传入参数。但 service 定义时必须传入 message，此时就可以使用 Empty message。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-comment">// Ping 是一个用于测试是否连通的服务，发送请求时无需传入参数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;   <span class="hljs-comment">// rpc 服务必须传入一个 message，但函数本意并无需传入参数，所以只能写一个 Empty message。</span><br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Empty 是一个空的 message，很多 proto 文件中都会需要。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Empty</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个很常见的需求，无需每个 proto 文件中都定义一个 Empty message，会冲突。</p><p><strong>解决</strong>：定义一个公共的 proto 文件，base.proto。在 hello.proto 中 improt base.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// base.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Empty 是一个空的 message，很多 proto 文件中都会需要。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Empty</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;base.proto&quot;</span>;   <span class="hljs-comment">// 【import 同目录下的 proto 文件】</span><br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-comment">// Ping 是一个用于测试是否连通的服务，发送请求时无需传入参数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;   <span class="hljs-comment">// rpc 服务必须传入一个 message，但函数本意并无需传入参数，所以只能写一个 Empty message。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）使用 protobuf 内置的 message</strong></p><p>注意 proto 文件中的导入方式。improt 时用路径表示，使用时用点表示</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/empty.proto&quot;</span>;   <span class="hljs-comment">// 【improt 内置的 message】</span><br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Ping(google.protobuf.Empty) <span class="hljs-keyword">returns</span> (Pong)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Pong</span> &#123;<br>    <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>go 文件使用 Empty message 类型时，需导入 empty.proto 文件中 go_package 路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/golang/protobuf/ptypes/empty&quot;</span>   <span class="hljs-comment">// empty.proto 文件中 go_package 路径。</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    empty.Empty&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）improt 路径问题</strong></p><p>improt 同目录下的 proto 文件可直接导入。但是导入不同目录下的 proto 文件，需要注意 import 不能使用相对路径。</p><p>解决：可以写 proto 文件名，并在 protoc 时使用 <code>-I</code> 参数在指定目录下寻找该 proto 文件。</p><p>比如在 3.5 验证器 小节，hello.proto 文件中需要 import validate.proto 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . -I <span class="hljs-variable">$GOPATH</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/  hello.proto --go_out=. <br></code></pre></td></tr></table></figure><p><code>-I . -I $GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/</code>：表示在当前目录和 <code>$GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/</code> 这两个目录下，寻找 hello.proto 和 import 的文件。</p><h3 id="2-8-嵌套-message-对象">2.8 嵌套 message 对象</h3><p><strong>（1）第一种方式</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> url = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">repeated</span> Result data = <span class="hljs-number">2</span>;   <span class="hljs-comment">// Result 数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）第二种方式</strong></p><p>内部嵌套，嵌套的 message 只用一次，防止 proto 文件中定义过多 message。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">repeated</span> Result data = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>        <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// Result 的序号和 Reply 的序号有很好的隔离性，互不干扰。</span><br>        <span class="hljs-type">string</span> url = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上有些特殊，pb.go 文件里会定义为 Reply_Result，所以 go 中实例化时需要使用 Reply_Result。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reply_Result <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br><br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br>    Url  <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,opt,name=url,proto3&quot; json:&quot;url,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-enum-类型">2.9 enum 类型</h3><p><strong>（1）proto 文件定义</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;enum&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>    Gender gender = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">enum </span><span class="hljs-title class_">Gender</span> &#123;   <span class="hljs-comment">// 定义枚举类型</span><br>    MALE = <span class="hljs-number">0</span>;<br>    FEMALE = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用枚举类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;learngo/repeated/enum&quot;</span>   <span class="hljs-comment">// 导入 bp.go 所在目录</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := enum.Reply&#123;<br>        Message: <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Gender:  enum.Gender_MALE,   <span class="hljs-comment">// 使用 枚举类型 赋值</span><br>    &#125;<br>    fmt.Println(r)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-10-map-类型">2.10 map 类型</h3><p>map 虽然方便，但是不要大量写 map，在传入参数和接收参数时，不知道具体字段是什么。</p><p><strong>（1）proto 文件定义</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;enum&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloReply</span> &#123;<br>    map&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; m = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 定义类型，传错类型会报错。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用 map 类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    mapproto <span class="hljs-string">&quot;learngo/repeated/map_proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reply := mapproto.HelloReply&#123;<br>        M: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>:    <span class="hljs-string">&quot;Tom&quot;</span>,<br>            <span class="hljs-string">&quot;company&quot;</span>: <span class="hljs-string">&quot;xiaomi&quot;</span>,<br>        &#125;,<br>    &#125;<br>    fmt.Println(reply.M)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-11-timestamp-类型">2.11 timestamp 类型</h3><p>时间戳类型，protobuf 扩展的类型。</p><p><strong>（1）proto 文件定义</strong></p><p>timestamp 定义在 google/protobuf/timestamp.proto 文件中。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// hello.proto</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;hello&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/timestamp.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Reply</span> &#123;<br>    google.protobuf.Timestamp requestTime= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）go 文件中使用 timestamp 类型</strong></p><p>自动生成的 bp.go 中是这样定义的，RequestTime 是 <code>timestamppb.Timestamp</code> 指针类型。</p><p><code>timestamppb.Timestamp</code> 导入的是 <code>timestamppb &quot;google.golang.org/protobuf/types/known/timestamppb&quot;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hello.pb.go</span><br><span class="hljs-keyword">type</span> Reply <span class="hljs-keyword">struct</span> &#123;<br>    state         protoimpl.MessageState<br>    sizeCache     protoimpl.SizeCache<br>    unknownFields protoimpl.UnknownFields<br><br>    RequestTime *timestamppb.Timestamp <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=requestTime,proto3&quot; json:&quot;requestTime,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以在 go 中，需要导入 <code>timestamppb &quot;google.golang.org/protobuf/types/known/timestamppb&quot;</code>。</p><p>具体使用如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    hello <span class="hljs-string">&quot;learngo/timestamp/proto&quot;</span><br><br>    timestamppb <span class="hljs-string">&quot;google.golang.org/protobuf/types/known/timestamppb&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reply := hello.Reply&#123;<br>        RequestTime: timestamppb.New(time.Now()),  <span class="hljs-comment">// 【获取当前的时间戳】</span><br>    &#125;<br>    fmt.Println(reply.RequestTime)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-gRPC">3.gRPC</h2><h3 id="3-1-最小实践">3.1 最小实践</h3><p>目的：server 实现一个 SayHello 的函数，client 进行远程调用。</p><p>实现：</p><ol><li>使用 proto 文件，约定传输的消息类型、函数接口。</li><li>使用 protoc 生成 stub 文件 helloworld.pb.go 和 helloworld_gpc.pb.go，生成的主要内容是：<ul><li>消息类型的编解码；</li><li>client stub：实例化 client 的函数、client interface（用于封装远程调用函数）；</li><li>server stub：server interface（用于封装远程调用函数）、注册 server 的函数。</li></ul></li><li>server 端：完成具体的业务逻辑来实现接口 + 实例化 grpc server、注册、监听。</li><li>client 端：拨号、实例化 client、远程调用。</li></ol><p><strong>（1）helloworld.proto</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option go_package = <span class="hljs-string">&quot;.;helloworld&quot;</span>;<br><br>service Greeter &#123;  <span class="hljs-comment">// 定义服务（也就是 interface）</span><br>    rpc SayHello(HelloRequest) returns (HelloResponse);<br>&#125;<br><br>message HelloRequest &#123;   <span class="hljs-comment">// 定义消息类型（也就是结构体类型）</span><br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 1 是编号不是值</span><br>&#125;<br><br>message  HelloResponse &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span> <span class="hljs-comment">// 自带的</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span> <span class="hljs-comment">// 三方的</span><br><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span> <span class="hljs-comment">// 自己的</span><br>)<br><br><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// SayHello 是 server 的接口，虽然在 proto 文件中没有定义 Context、error，但需要强制加上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> SayHello(ctx context.Context, request *helloworld.HelloRequest) (*helloworld.HelloResponse, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 具体业务逻辑</span><br>    <span class="hljs-keyword">return</span> &amp;helloworld.HelloResponse&#123;<br>        Reply: <span class="hljs-string">&quot;hello &quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.实例化一个 grpc 的 server</span><br>    g := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册</span><br>    <span class="hljs-comment">// RegisterGreeterServer 是自动生成的函数。利用鸭子类型类传递实例化的结构体。</span><br>    helloworld.RegisterGreeterServer(g, &amp;Server&#123;&#125;)<br><br>    <span class="hljs-comment">//3.启动监听</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to listen:&quot;</span> + err.Error())<br>    &#125;<br>    err = g.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to start: &quot;</span> + err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br><br>    helloworld <span class="hljs-string">&quot;learngo/grpc/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to dial: &quot;</span> + err.Error())<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123; <span class="hljs-comment">// 连接用完需关闭，使用闭包的方式。</span><br>        err := conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to close: &quot;</span> + err.Error())<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    <span class="hljs-comment">// NewGreeterClient 是自动生成的代码。</span><br>    client := helloworld.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    response, err := client.SayHello(context.Background(), &amp;helloworld.HelloRequest&#123;Name: <span class="hljs-string">&quot;Tom&quot;</span>&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to call: &quot;</span> + err.Error())<br>    &#125;<br>    fmt.Println(response.Reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-流模式">3.2 流模式</h3><h4 id="3-2-1-四种模式">3.2.1 四种模式</h4><p><strong>（1）简单模式（Simple RPC）</strong></p><p>客户端发起一次请求，服务端响应一次数据。</p><p><strong>（2）服务端数据流模式（Server-side streaming RPC）</strong></p><p>客户端发起一次请求，服务端返回一段连续的数据流。例如：客户端向服务端发送一个股票代码，服务端就把该股票的实时数据持续地返回给客户端。</p><p><strong>（3）客户端数据流模式（Client-side streaming RPC）</strong></p><p>客户端持续向服务端发送数据流，发送结束后，服务端返回一个响应。例如：传感器向服务端上报数据。</p><p><strong>（4）双向数据流模式（Bidirectional streaming RPC）</strong></p><p>客户端与服务端都可以向对方发送数据流，可以同时互相发送，实现实时交互。例如聊天机器人。</p><h4 id="3-2-2-流模式最小实践">3.2.2 流模式最小实践</h4><p><strong>（1）stream.proto</strong></p><p>在 service 中，以流模式发送的数据使用 stream 关键字定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br>option go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br>service Greeter &#123;<br>    rpc GetStream(StreamRequestData) returns (stream StreamResponseData);    <span class="hljs-comment">// 服务端流模式，返回 response 是 stream</span><br>    rpc PostStream(stream StreamRequestData) returns (StreamResponseData);   <span class="hljs-comment">// 客户端流模式</span><br>    rpc AllStream(stream StreamRequestData) returns ( stream StreamResponseData);   <span class="hljs-comment">// 双向流模式</span><br>&#125;<br><br>message StreamRequestData &#123;<br>    <span class="hljs-type">string</span> data = <span class="hljs-number">1</span>;<br>&#125;<br><br>message StreamResponseData &#123;<br>    <span class="hljs-type">string</span> data = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）server.go</strong></p><p>流模式和普通 PRC 相比，server 有三点差异：</p><ul><li>参数：使用 stream 标记的参数，在函数实现时，需使用 protoc 自动生成的 streamServer 代替。（不</li><li>发送数据流：使用 streamServer 类型的参数，调用 send 函数。</li><li>接收数据流：使用 streamServer 类型的参数，调用 send 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>     <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/streamingGrpc/proto&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;:8088&quot;</span><br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// GetStream 实现服务端流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> GetStream(req *proto.StreamRequestData, res proto.Greeter_GetStreamServer) <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 使用 流模式 传输的数据，使用 proto 中自动生成的 streamServer 代替函数中的参数。</span><br>    fmt.Println(<span class="hljs-string">&quot;\nServer-side streaming RPC&quot;</span>)<br>    fmt.Println(req.Data)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        _ = res.Send(&amp;proto.StreamResponseData&#123; <span class="hljs-comment">// Send 函数发送数据</span><br>            Data: fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, time.Now().Unix()),<br>        &#125;)<br>        time.Sleep(time.Second)<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// PostStream 实现客户端流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> PostStream(clientStream proto.Greeter_PostStreamServer) <span class="hljs-type">error</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;\nClient-side streaming RPC&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> recv, err := clientStream.Recv(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// Recv 函数接收数据</span><br>            fmt.Println(err)<br>            <span class="hljs-keyword">break</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(recv.Data)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AllStream 实现双向流模式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> AllStream(allStream proto.Greeter_AllStreamServer) <span class="hljs-type">error</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;\nBidirectional streaming RPC&quot;</span>)<br>    wg := sync.WaitGroup&#123;&#125;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        <span class="hljs-keyword">for</span> &#123;<br>            msg, err := allStream.Recv()<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                fmt.Println(err)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            fmt.Println(<span class="hljs-string">&quot;msg from client: &quot;</span> + msg.Data)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            _ = allStream.Send(&amp;proto.StreamResponseData&#123;<br>                Data: fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, time.Now().Unix()),<br>            &#125;)<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;()<br><br>    wg.Wait()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.实例化 grpc server</span><br>    s := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册 server</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.监听端口，启动 server</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, PORT)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    _ = s.Serve(listen)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）client.go</strong></p><p>流模式和普通 PRC 相比，client 有三点差异：</p><ul><li>参数：使用 stream 标记的参数，函数调用时，无需提供。调用函数后获得返回值为对应的 streamClient。</li><li>发送数据流：使用 streamClient 类型的函数返回值，调用 send 函数。</li><li>接收数据流：使用 streamClient 类型的函数返回值，调用 send 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>     <span class="hljs-string">&quot;learngo/streamingGrpc/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 1.拨号连接</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;:8088&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err := conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化一个 client。（client 结构体中变量为 conn，使用 grpc.ClientConnInterface 接收参数 conn）</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.通过 client 来分别调用不同的流模式 RPC。</span><br>    <span class="hljs-comment">// 服务端流模式</span><br>    fmt.Println(<span class="hljs-string">&quot;\nServer-side streaming RPC&quot;</span>)<br>    <span class="hljs-comment">// 返回值为 Greeter_GetStreamClient，可以调用 Recv 函数。</span><br>    res, _ := client.GetStream(context.Background(), &amp;proto.StreamRequestData&#123;Data: <span class="hljs-string">&quot;tell me time&quot;</span>&#125;)<br>    <span class="hljs-keyword">for</span> &#123;<br>        data, err := res.Recv()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        fmt.Println(data)<br>    &#125;<br><br>    <span class="hljs-comment">// 客户端流模式</span><br>    fmt.Println(<span class="hljs-string">&quot;\nClient-side streaming RPC&quot;</span>)<br>    postStream, err := client.PostStream(context.Background())<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        _ = postStream.Send(&amp;proto.StreamRequestData&#123;<br>            Data: fmt.Sprintf(<span class="hljs-string">&quot;client send count: %d&quot;</span>, i),<br>        &#125;)<br>        time.Sleep(time.Second)<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 双向流模式</span><br>    <span class="hljs-comment">// 为了保证双向流模式，需使用2个协程分别发送和接收。</span><br>    fmt.Println(<span class="hljs-string">&quot;\nBidirectional streaming RPC&quot;</span>)<br>    allStream, err := client.AllStream(context.Background())<br>    wg := sync.WaitGroup&#123;&#125;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        <span class="hljs-keyword">for</span> &#123;<br>            msg, _ := allStream.Recv()<br>            fmt.Println(<span class="hljs-string">&quot;msg form server: &quot;</span> + msg.Data)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> wg.Done()<br>        i := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            _ = allStream.Send(&amp;proto.StreamRequestData&#123;<br>                Data: fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i),<br>            &#125;)<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;()<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-metadata-机制">3.3 metadata 机制</h3><p><strong>（1）metadata 是什么？</strong></p><p>在 HTTP 数据传输中，除了 get/post 的参数，还有些参数会通过 metadata 来传输。</p><p><strong>（2）新建 metadata</strong></p><p>注意：虽然写的的是 <code>map[string]string</code>，但实际上是 <code>map[string][]string</code>，每一个 key 对应的 value 都是一个 <code>map[string]string</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建 metadata 数据的第一种方式</span><br>md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-string">&quot;Username&quot;</span>: <span class="hljs-string">&quot;admin2&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>&#125;)<br><span class="hljs-comment">// 创建 metadata 数据的第二种方式</span><br>md = metadata.Pairs(<br>    <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin2&quot;</span>, <span class="hljs-comment">// &quot;username&quot; will have map value []string&#123;&quot;admin&quot;, &quot;admin2&quot;&#125;</span><br>    <span class="hljs-string">&quot;Password&quot;</span>, <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>)<br></code></pre></td></tr></table></figure><p><strong>（3）发送 metadata</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := metadata.NewOutgoingContext(context.Background(), md) <span class="hljs-comment">// 创建一个传出 metadata 数据的 context。</span><br></code></pre></td></tr></table></figure><p><strong>（4）接收 metadata</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从 context 中获取 metadata 数据</span><br>md, ok := metadata.FromIncomingContext(ctx)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(<span class="hljs-string">&quot;get metadata success.&quot;</span>)<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> md &#123;<br>        fmt.Println(key, val)<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;get metadata error.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/* 打印 metadata 的内容：</span><br><span class="hljs-comment">user-agent [grpc-go/1.47.0]</span><br><span class="hljs-comment">username [admin admin2]    // 注意：每一个 key 对应的 value 都是一个 map[string]string。</span><br><span class="hljs-comment">password [Qwer123]</span><br><span class="hljs-comment">:authority [127.0.0.1:8080]</span><br><span class="hljs-comment">content-type [application/grpc]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>（5）完整例子</strong></p><p><strong>metadata.proto</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/metadata&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/metadata/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br><br>    <span class="hljs-comment">// 从 context 中获取 metadata 数据</span><br>    md, ok := metadata.FromIncomingContext(ctx)<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get metadata success.&quot;</span>)<br>        <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> md &#123;<br>            fmt.Println(key, val)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get metadata error.&quot;</span>)<br>    &#125;<br><br>    response := &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;hello, &quot;</span> + request.Name,<br>    &#125;<br>    <span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化 grpc server</span><br>    s := grpc.NewServer()<br><br>    <span class="hljs-comment">// 2.注册服务</span><br>    proto.RegisterGreeterServer(s, server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.监听并启动 grpc server</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/metadata&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>        <br>    <span class="hljs-string">&quot;learngo/metadata/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 创建 metadata 数据的第一种方式</span><br>    md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;Username&quot;</span>: <span class="hljs-string">&quot;admin2&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>    &#125;)<br>    <span class="hljs-comment">// 创建 metadata 数据的第二种方式</span><br>    md = metadata.Pairs(<br>        <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;Username&quot;</span>, <span class="hljs-string">&quot;admin2&quot;</span>, <span class="hljs-comment">// &quot;username&quot; will have map value []string&#123;&quot;admin&quot;, &quot;admin2&quot;&#125;</span><br>        <span class="hljs-string">&quot;Password&quot;</span>, <span class="hljs-string">&quot;Qwer123&quot;</span>,<br>    )<br>    ctx := metadata.NewOutgoingContext(context.Background(), md) <span class="hljs-comment">// 创建一个传出 metadata 数据的 context。</span><br><br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(ctx, &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Interceptor-拦截器">3.4 Interceptor 拦截器</h3><p><strong>（1）拦截器分类</strong></p><p>grpc 的拦截器可以实现在 server 端，也可以实现在 client 端。</p><ul><li><p>server 端拦截器：在接收到请求后，在真正处理请求的前后，在拦截器中进行一些处理。</p></li><li><p>client 端拦截器：在发送请求的前后，在拦截器中进行一些处理。</p></li></ul><blockquote><p>第三方库 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a> 实现了很多拦截器的功能：认证（auth）、 日志（ logging）、监控（monitoring）等，可以直接使用，值得借鉴学习。</p></blockquote><p>由于 unary 方法和 stream 方法参数不同，拦截器又分为一元拦截器（unary interceptor）和流拦截器（stream interceptor）。所以共有 4 种类型变量，每个变量都是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义在 google.golang.org/grpc@v1.51.0/interceptor.go</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// grpc.UnaryServerInterceptor</span><br><span class="hljs-keyword">type</span> UnaryServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// grpc.StreamServerInterceptor</span><br><span class="hljs-keyword">type</span> StreamServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// grpc.UnaryClientInterceptor</span><br><span class="hljs-keyword">type</span> UnaryClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// grpc.StreamClientInterceptor</span><br><span class="hljs-keyword">type</span> StreamClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="hljs-type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><strong>（2）拦截器流程</strong></p><p>主要流程是：</p><ol><li>定义拦截器<ul><li>预处理 pre-processing</li><li>调用RPC方法 invoking RPC method</li><li>后处理 post-processing</li></ul></li><li>合适的时机指定拦截器<ul><li>server：实例化 grpc server 时，作为 ServerOption 传入。</li><li>client：拨号时，作为 DialOption 传入。</li></ul></li></ol><p><strong>（3） server 端的 unary 拦截器</strong></p><p>如何找到该实现的函数：</p><ol><li>看 <code>grpc.UnaryInterceptor</code> 定义源码，需传入参数 <code>i UnaryServerInterceptor</code> 。</li><li>查看参数 <code>UnaryServerInterceptor</code> 定义源码，复制具体的函数，进行实现。</li></ol><p>需求：在处理请求前后，打印两句 log。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/interceptor/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;hello,&quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>        fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)              <span class="hljs-comment">// 在处理请求前进行处理，（预处理 pre-processing）</span><br>        resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求，（调用RPC方法 invoking RPC method）</span><br>        fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理，（后处理 post-processing）</span><br>        <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>    &#125;<br>    opt := grpc.UnaryInterceptor(interceptor) <span class="hljs-comment">// 将 UnaryServerInterceptor 作为参数，new 一个 ServerOption 变量。</span><br>    s := grpc.NewServer(opt)                  <span class="hljs-comment">// 实例化 grpc server 时，可以传入多个 ServerOption。（可变参数列表），这个指定拦截器。</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了上述写法，也可以将 UnaryServerInterceptor 拦截器方法单独拿出来，如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    opt := grpc.UnaryInterceptor(interceptor) <span class="hljs-comment">// 将 UnaryServerInterceptor 作为参数，new 一个 ServerOption 变量。</span><br>    s := grpc.NewServer(opt)                  <span class="hljs-comment">// 实例化 grpc server 时，可以传入多个 ServerOption。（可变参数列表），这个指定拦截器。</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>    fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)              <span class="hljs-comment">// 在处理请求前进行处理，（预处理 pre-processing）</span><br>    resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求，（调用RPC方法 invoking RPC method）</span><br>    fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理，（后处理 post-processing）</span><br>    <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）client 端的 unary 拦截器</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/interceptor/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>        start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间，（预处理 pre-processing）</span><br>        err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求，（调用RPC方法 invoking RPC method）</span><br>        duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间，（后处理 post-processing）</span><br>        fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// 返回 server 响应的数据</span><br>    &#125;<br><br>    opts := []grpc.DialOption&#123; <span class="hljs-comment">// 建立一个 DialOption 列表，拨号时传入</span><br>        grpc.WithTransportCredentials(insecure.NewCredentials()), <span class="hljs-comment">// 使用不安全的凭证</span><br>        grpc.WithUnaryInterceptor(interceptor),                   <span class="hljs-comment">// 指定 UnaryClientInterceptor 拦截器</span><br>    &#125;<br><br>    <span class="hljs-comment">//1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, opts...) <span class="hljs-comment">// 可变参数列表传入多个 DialOption</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">//2.实例化client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">//3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(context.Background(), &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）使用 metadata 和 interceptor 实现 auth 认证</strong></p><ul><li>在 client interceptor 中，使用 metadata 传递 appid/appkey；</li><li>在 server interceptor 中验证 appid/appkey 是否存在/合法；</li><li>如果不存在/不合法，使用 grpc 自带的 <code>status.Error</code> 返回状态码和错误信息。</li></ul><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 定义 UnaryServerInterceptor 类型拦截器</span><br>    fmt.Println(<span class="hljs-string">&quot;Request is coming.&quot;</span>)           <span class="hljs-comment">// 在处理请求前进行处理</span><br>    md, ok := metadata.FromIncomingContext(ctx) <span class="hljs-comment">// 获取 metadata 数据，并验证</span><br>    <span class="hljs-keyword">if</span> ok &#123;<br>        appid := md[<span class="hljs-string">&quot;appid&quot;</span>][<span class="hljs-number">0</span>]<br>        appkey := md[<span class="hljs-string">&quot;appkey&quot;</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> appid != <span class="hljs-string">&quot;123&quot;</span> || appkey != <span class="hljs-string">&quot;456&quot;</span> &#123;<br>            err = status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;invalid token.&quot;</span>)<br>            <span class="hljs-keyword">return</span> resp, err<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        status.Error(codes.Unauthenticated, <span class="hljs-string">&quot;Token no exist.&quot;</span>)<br>        <span class="hljs-keyword">return</span> resp, err<br>    &#125;<br>    resp, err = handler(ctx, req)                  <span class="hljs-comment">// 处理真正的请求</span><br>    fmt.Println(<span class="hljs-string">&quot;The request has been processed.&quot;</span>) <span class="hljs-comment">// 处理请求后进行处理</span><br>    <span class="hljs-keyword">return</span> resp, err                               <span class="hljs-comment">// 返回请求响应结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>    md := metadata.New(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123; <span class="hljs-comment">// 创建 metadata 数据</span><br>        <span class="hljs-string">&quot;appid&quot;</span>:  <span class="hljs-string">&quot;123&quot;</span>,<br>        <span class="hljs-string">&quot;appkey&quot;</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>    &#125;)<br>    ctx = metadata.NewOutgoingContext(ctx, md)           <span class="hljs-comment">// 传输 metadata 数据</span><br>    start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间</span><br>    err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求</span><br>    duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间</span><br>    fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（6）grpc 内置的自定义认证接口</strong></p><blockquote><p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/blob/v1.51.0/dialoptions.go#L331">WithPerRPCCredentials</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithPerRPCCredentials returns a DialOption which sets credentials and places</span><br><span class="hljs-comment">// auth state on each outbound RPC.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithPerRPCCredentials</span><span class="hljs-params">(creds credentials.PerRPCCredentials)</span></span> DialOption &#123;<br>    <span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> &#123;<br>        o.copts.PerRPCCredentials = <span class="hljs-built_in">append</span>(o.copts.PerRPCCredentials, creds)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>client 无需在拦截器中设置 appid/appkey， <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/blob/v1.51.0/dialoptions.go#L331">WithPerRPCCredentials </a>可以将传入的 <code>credentials.PerRPCCredentials</code> 转化为 <code>DialOption</code>。查看 <code>credentials.PerRPCCredentials</code> 源码可以看到，PerRPCCredentials 是一个接口，实现其两个方法，就可以实现该接口。</p><ul><li>GetRequestMetadata：获取当前请求认证所需的元数据（metadata）</li><li>RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输</li></ul><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/auth/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Credential <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Credential)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// 获取当前请求认证所需的 metadata</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;appid&quot;</span>:  <span class="hljs-string">&quot;123&quot;</span>,<br>        <span class="hljs-string">&quot;appkey&quot;</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Credential)</span></span> RequireTransportSecurity() <span class="hljs-type">bool</span> &#123;  <span class="hljs-comment">// 是否需要基于 TLS 认证进行安全传输</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    interceptor := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// 定义 UnaryClientInterceptor 类型变量</span><br>        start := time.Now()                                  <span class="hljs-comment">// 发生请求之前记录开始时间</span><br>        err := invoker(ctx, method, req, reply, cc, opts...) <span class="hljs-comment">// 发生请求</span><br>        duration := time.Since(start)                        <span class="hljs-comment">// 记录请求使用时间</span><br>        fmt.Println(<span class="hljs-string">&quot;duration: &quot;</span>, duration)<br>        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// 返回 server 响应的数据</span><br>    &#125;<br><br>    opts := []grpc.DialOption&#123; <span class="hljs-comment">// 建立一个 DialOption 列表，拨号时传入</span><br>        grpc.WithTransportCredentials(insecure.NewCredentials()), <span class="hljs-comment">// 使用不安全的凭证</span><br>        grpc.WithUnaryInterceptor(interceptor),                   <span class="hljs-comment">// 指定 UnaryClientInterceptor 拦截器</span><br>        grpc.WithPerRPCCredentials(Credential&#123;&#125;),  <span class="hljs-comment">// 传入凭证</span><br>    &#125;<br><br>    <span class="hljs-comment">//1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, opts...) <span class="hljs-comment">// 可变参数列表传入多个 DialOption</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn *grpc.ClientConn)</span></span> &#123;<br>        err = conn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">//2.实例化client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">//3.远程调用</span><br>    request := proto.HelloRequest&#123;<br>        Name: <span class="hljs-string">&quot;Golang&quot;</span>,<br>    &#125;<br>    response, err := client.SayHello(context.Background(), &amp;request)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-验证器">3.5 验证器</h3><p><strong>（1）一个开源项目</strong></p><p><a target="_blank" rel="noopener" href="https://github.com/bufbuild/protoc-gen-validate">protoc-gen-validate</a>，该项目目前处于 alpha 阶段，功能是对于 protobuf 中的 message，进行数据验证。</p><p>下面简单跑通一下。</p><p><strong>（2）原理</strong>：</p><ol><li>定义规则：proto 中定义了 HelloRequest 这种 message 类型，并在其中标记数据规则。</li><li>生成验证规则的代码：protoc-gen-validate 会为 HelloRequest 类型，生成多个结构体方法，其中有一个 Validate 方法。在 Validata 方法，根据设置的数据规则，验证数据。</li><li>使用：在实际使用中，HelloRequest.Validate 就可以验证数据。</li></ol><p><strong>（3）安装 protoc-gen-validate 二进制文件</strong></p><p>注意看 README 文件，可能有更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># fetches this repo into $GOPATH</span><br>go get -d github.com/envoyproxy/protoc-gen-validate   <span class="hljs-comment"># -d 表示只下载源码不安装</span><br>git <span class="hljs-built_in">clone</span> https://github.com/bufbuild/protoc-gen-validate.git<br><span class="hljs-comment"># installs PGV into $GOPATH/bin</span><br><span class="hljs-built_in">cd</span> protoc-gen-validate &amp;&amp; make build<br><span class="hljs-comment"># build bin 文件后，删除 protoc-gen-validate 仓库就可以。</span><br><br><span class="hljs-comment"># go get 下载的 protoc-gen-validate 源码在 $GOPATH/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/</span><br></code></pre></td></tr></table></figure><p>在 README 文件里有这样一段话，用以说明为什么使用上面的方式下载源码和构建二进制文件。</p><blockquote><p>Yes, our go module path is <code>github.com/envoyproxy/protoc-gen-validate</code> <strong>not</strong> <code>bufbuild</code> this is intentional.</p><p>Changing the module path is effectively creating a new, independent module. We would prefer not to break our users. The Go team are working on better <code>cmd/go</code> support for modules that change paths, but progress is slow. Until then, we will continue to use the <code>bufbuild</code> module path.</p></blockquote><p>补充说明：实际使用过程中，需要部分源码，也需要二进制文件 protoc-gen-validate。源码使用 <code>go get -d</code> 下载在 <code>$GOPATH/pkg/mod/github.com/envoyproxy/</code> 目录下，二进制文件在新的文件夹里编译后放在 <code>$GOPATH/bin</code> 目录下。</p><p><strong>（4）导入 proto 文件并生成 bp.go 文件</strong></p><p><strong>hello.proto</strong></p><p>在 message 中设置验证条件。<a target="_blank" rel="noopener" href="https://github.com/bufbuild/protoc-gen-validate#constraint-rules">Constraint Rules</a></p><p><code>import &quot;validate.proto&quot;;</code> 可能会显示找不到文件。没关系，后面使用 protoc 生成代码时，指定该文件的目录。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;.;proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;validate.proto&quot;</span>;<br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">uint64</span> id = <span class="hljs-number">1</span> [(validate.rules).<span class="hljs-type">uint64</span>.gt = <span class="hljs-number">999</span>];   <span class="hljs-comment">// id &gt; 999</span><br>    <span class="hljs-type">string</span> email = <span class="hljs-number">2</span> [(validate.rules).<span class="hljs-type">string</span>.email = <span class="hljs-literal">true</span>];  <span class="hljs-comment">// email 符合邮件规则</span><br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成代码命令</strong></p><p>注意使用 <code>-I</code> 指定在哪个目录中找 validate.proto 。使用 go get -d 下载的代码，会在 <code>$GOPATH/pkg/mod/</code> 目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">protoc -I . \   <span class="hljs-comment"># 当前目录中寻找 hello.proto</span><br>-I <span class="hljs-variable">$GOPATH</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.9.1/validate/  \  <span class="hljs-comment"># 这个目录中寻找 import 的 proto 文件</span><br>--go_out=. \  <span class="hljs-comment"># pb.go 的生成目录</span><br>--go-grpc_out=. \  <span class="hljs-comment"># grpc.pb.go 的生成目录</span><br>--validate_out=<span class="hljs-string">&quot;lang=go:.&quot;</span> \   <span class="hljs-comment"># pb.validate.go 的生成目录</span><br>--go-grpc_opt=require_unimplemented_servers=<span class="hljs-literal">false</span> \   <span class="hljs-comment"># 该方法是为了向前兼容，这里关闭该方法的生成</span><br>hello.proto<br></code></pre></td></tr></table></figure><p><strong>server.go</strong></p><p>在拦截器中验证数据，注意这里的类型转化。</p><ul><li>传入的时 <code>interface&#123;&#125;</code> 类型，不能直接调用 Validate 函数，需要转化为具体的类型（这个类型实现了 Validate 方法）。</li><li>为了扩展更多的类型，拦截器中又不能转换为 HelloRequest（虽然也能跑，但是这个拦截器就只能验证 HelloRequest 这一种数据了），而应该转换为一个接口类型。</li><li>只要这个接口内包含 Validate 方法就可以，所以我们声明一个 Validator 类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/codes&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/status&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/validate/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Message: <span class="hljs-string">&quot;NO.&quot;</span> + strconv.FormatUint(request.Id, <span class="hljs-number">10</span>) + <span class="hljs-string">&quot; email is &quot;</span> + request.Email,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.实例化带有 interceptor 的 grpc server</span><br>    option := grpc.UnaryInterceptor(interceptor)<br>    s := grpc.NewServer(option)<br><br>    <span class="hljs-comment">// 2.注册</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3.启动并监听</span><br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Validator <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// 写一个接口，任何实现 Validate 方法的变量，都可以转成 Validator 类型，再调用 Validate 方法。</span><br>    Validate() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// 在拦截器中，验证传入的数据是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">interceptor</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> validator, ok := req.(Validator); ok &#123; <span class="hljs-comment">// interface&#123;&#125; 类型转换为 HelloRequest 类型。但是这里可能需要判断多种数据类型，不能直接写死成 req.(HelloRequest)，需要使用转成 Validator 接口类型。</span><br>        <span class="hljs-keyword">if</span> err := validator.Validate(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 因为在 hello.pb.validate.go 中 HelloRequest 实现了 Validate 方法。也就直接实现了 Validator 接口，可以通过 Validator 接口调用 Validate 方法。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, err.Error())  <span class="hljs-comment">// 返回的 error 为 统一的错误码 + 具体的错误信息。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> handler(ctx, req)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/validate/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(clientConn *grpc.ClientConn)</span></span> &#123;<br>        err := clientConn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化 client</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    response, err := client.SayHello(context.Background(), &amp;proto.HelloRequest&#123;<br>        Id:     <span class="hljs-number">1000</span>,<br>        Email:  <span class="hljs-string">&quot;1234@gmail.com&quot;</span>,<br>        Mobile: <span class="hljs-string">&quot;130000000000&quot;</span>,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-状态码">3.6 状态码</h3><p>grpc 官方定义了状态码：<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/statuscodes.md">https://github.com/grpc/grpc/blob/master/doc/statuscodes.md</a></p><h3 id="3-7-错误处理">3.7 错误处理</h3><p>go 中的错误处理主要是 status 包内。Status 类型中封装了 Error 类型。<code>status.Error()</code> 内部就是 new 一个 status 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/codes&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc/status&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 生成 error</span><br>    err := status.Error(codes.NotFound, <span class="hljs-string">&quot;未找到记录&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到记录</span><br><br>    err = status.New(codes.NotFound, <span class="hljs-string">&quot;未找到记录&quot;</span>).Err()<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到记录</span><br><br>    err = status.Errorf(codes.NotFound, <span class="hljs-string">&quot;未找到%s记录&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到Tom记录</span><br><br>    err = status.Newf(codes.NotFound, <span class="hljs-string">&quot;未找到%s记录&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>).Err()<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic: rpc error: code = NotFound desc = 未找到Tom记录</span><br><br>    <span class="hljs-comment">// 解析 error</span><br>    <span class="hljs-keyword">if</span> fromError, ok := status.FromError(err); ok &#123;<br>        fmt.Println(fromError.Code())    <span class="hljs-comment">// 打印错误码    // NotFound</span><br>        fmt.Println(fromError.Message()) <span class="hljs-comment">// 打印错误信息  //未找到Tom记录</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-超时机制">3.8 超时机制</h3><p>使用 <code>context.WithTimeout(context.Background(), time.Second*3)</code> 生成带有 deadline 功能的 contex，在远程调用时使用。</p><p><strong>server.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><br>    <span class="hljs-string">&quot;learngo/deadline/proto&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*server)</span></span> SayHello(ctx context.Context, request *proto.HelloRequest) (*proto.HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &amp;proto.HelloResponse&#123;<br>        Reply: <span class="hljs-string">&quot;hello, &quot;</span> + request.Name,<br>    &#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1. 实例化 grpc server</span><br>    opt := grpc.UnaryInterceptor(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>        time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// 等待 5s，模拟 server 超时</span><br>        <span class="hljs-keyword">return</span> handler(ctx, req)<br>    &#125;)<br>    s := grpc.NewServer(opt)<br><br>    <span class="hljs-comment">// 2. 注册</span><br>    proto.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>    <span class="hljs-comment">// 3. 监听启动</span><br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8899&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = s.Serve(listen)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>client.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>    <br>    <span class="hljs-string">&quot;learngo/deadline/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.拨号</span><br>    conn, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(clientConn *grpc.ClientConn)</span></span> &#123;<br>        err := clientConn.Close()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;(conn)<br><br>    <span class="hljs-comment">// 2.实例化客户端</span><br>    client := proto.NewGreeterClient(conn)<br><br>    <span class="hljs-comment">// 3.远程调用</span><br>    <span class="hljs-comment">// 超时机制</span><br>    <span class="hljs-comment">//ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*3)</span><br>    <span class="hljs-comment">// 直接调用 cancelFunc 可以主动取消 goroutine。下面的代码用不到，使用 _ 代替。</span><br>    ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="hljs-number">3</span>)<br>    response, err := client.SayHello(ctx, &amp;proto.HelloRequest&#123;Name: <span class="hljs-string">&quot;Golang&quot;</span>&#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(response.Reply)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-server-client-stub-解析">3.8 server/client stub 解析</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;.;proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的 hello.proto 为例，protoc 生成的 go 源码是 hello_grpc.pb.go 文件。</p><p><strong>（1）server stub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterServer <span class="hljs-keyword">interface</span> &#123;<br>    SayHello(context.Context, *HelloRequest) (*HelloResponse, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 GreeterServer 接口，里面封装了 SayHello 函数。</li><li>在服务端中，我们会声明一个结构体 server，让 server 实现 GreeterServer 接口，也就是为 server 定义结构体方法 SayHello 函数。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">RegisterGreeterServer</span>(s grpc.ServiceRegistrar, srv GreeterServer) &#123;<br>    s<span class="hljs-selector-class">.RegisterService</span>(&amp;Greeter_ServiceDesc, srv)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 GreeterServer 注册到 grpc server 中。</li><li>在服务端中，因为 server 实现了 GreeterServer 接口，也就可以将 server 注册到 grpc server 中。</li></ul><p><strong>（2）client stub</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterClient <span class="hljs-keyword">interface</span> &#123;<br>    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 GreeterClient 接口，里面封装了 SayHello 函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> greeterClient <span class="hljs-keyword">struct</span> &#123;<br>    cc grpc.ClientConnInterface<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *greeterClient)</span></span> SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, <span class="hljs-type">error</span>) &#123;<br>    out := <span class="hljs-built_in">new</span>(HelloResponse)<br>    err := c.cc.Invoke(ctx, <span class="hljs-string">&quot;/Greeter/SayHello&quot;</span>, in, out, opts...)  <span class="hljs-comment">// 实际上是利用 grpc.ClientConnInterface 的Invoke 方法进行远程调用。</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> out, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明 greeterClient 结构体，里面包含着 grpc.ClientConnInterface 变量，也就是可以使用 grpc.ClientConnInterface 的方法。</li><li>并为 greeterClient 结构体实现了 SayHello 方法，所以 greeterClient 结构体实现了 GreeterClient 接口。</li><li><strong>为什么 greeterClient 结构体里面要包含一个 grpc.ClientConnInterface 变量？</strong><ul><li>远程调用 server 端 SayHello 时，实际上调用的是 grpc.ClientConnInterface 的 Invoke 方法。</li><li>在 Invoke 方法的参数中，有 context、路径（call ID）、传入参数、穿出参数、远程调用的选项。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGreeterClient</span><span class="hljs-params">(cc grpc.ClientConnInterface)</span></span> GreeterClient &#123;<br>    <span class="hljs-keyword">return</span> &amp;greeterClient&#123;cc&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里是实例化 greeterClient 结构体的方法，提供给客户端使用。</li><li>注意：这里返回的是 GreeterClient 接口变量，实际上返回的是 greeterClient 结构体变量，因为在上面 greeterClient 结构体实现了 GreeterClient 接口。</li></ul><h2 id="Reference">Reference</h2><p>grpc API：<a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/grpc">https://pkg.go.dev/google.golang.org/grpc</a></p><script type="text/javascript">!function(l){[].forEach.call(l.getElementsByClassName("fold"),(function(l){l.getElementsByClassName("fold-title")[0].onclick=function(){l.classList.toggle("collapsed"),l.classList.toggle("expanded")}}))}(document)</script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Mark/" class="category-chain-item">Mark</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Go/">#Go</a> <a href="/tags/RPC/">#RPC</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">#微服务</a></div></div><div class="license-box my-3"><div class="license-title"><div>微服务｜RPC/gRPC</div><div>https://www.aimtao.net/rpc/</div></div><div class="license-meta"><div class="license-meta-item license-meta-date"><div>Posted on</div><div>2022-05-27</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/memory-management/" title="Linux 内核｜内存管理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux 内核｜内存管理</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/system-call/" title="Linux 内核｜系统调用"><span class="hidden-mobile">Linux 内核｜系统调用</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><style>.v[data-class=v] .veditor{background-image:url(https://hutu0.aimtao.net/foot/drinkwater.webp);background-size:contain;background-repeat:no-repeat;background-position:right;resize:none}</style><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.staticfile.org/valine/1.4.18/Valine.min.js",(function(){var e=Object.assign({appId:"Lwz6D7d9XSdSYpjixPxukzhF-gzGzoHsz",appKey:"UhkN5uCsv1zxjYO6nJ7vOjpB",path:"window.location.pathname",placeholder:"本站支持评论邮件提醒功能，在上方输入邮箱，即可收到回复通知！（支持 markdown 语法）",avatar:"robohash",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://valine.aimtao.net",emojiCDN:"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",emojiMaps:{666:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6c/2022_666_org.png","微笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","可爱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","太开心":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1e/2018new_taikaixin_org.png","鼓掌":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_guzhang_org.png","嘻嘻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png","哈哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8f/2018new_haha_org.png","笑cry":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","挤眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_jiyan_org.png","馋嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fa/2018new_chanzui_org.png","黑线":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a3/2018new_heixian_org.png","汗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/28/2018new_han_org.png","挖鼻":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9a/2018new_wabi_thumb.png","哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7c/2018new_heng_org.png","怒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_nu_org.png","委屈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a5/2018new_weiqu_org.png","可怜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/96/2018new_kelian_org.png","失望":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_shiwang_org.png","悲伤":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ee/2018new_beishang_org.png","泪":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/6e/2018new_leimu_org.png","允悲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","苦涩":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7e/2021_bitter_org.png","害羞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_haixiu_org.png","污":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/10/2018new_wu_org.png","爱你":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","亲亲":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2c/2018new_qinqin_org.png","抱一抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2020_hug_org.png","色":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9d/2018new_huaxin_org.png","憧憬":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c9/2018new_chongjing_org.png","舔屏":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3e/2018new_tianping_org.png","哇":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2022_wow_org.png","坏笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4d/2018new_huaixiao_org.png","阴险":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9e/2018new_yinxian_org.png","笑而不语":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2d/2018new_xiaoerbuyu_org.png","偷笑":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/71/2018new_touxiao_org.png","酷":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c4/2018new_ku_org.png","并不简单":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/2018new_bingbujiandan_org.png","思考":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/30/2018new_sikao_org.png","疑问":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b8/2018new_ningwen_org.png","费解":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/2a/2018new_wenhao_org.png","晕":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/07/2018new_yun_org.png","衰":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_shuai_org.png","骷髅":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_kulou_org.png","嘘":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b0/2018new_xu_org.png","闭嘴":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_bizui_org.png","傻眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/dd/2018new_shayan_org.png","裂开":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1b/202011_liekai_org.png","感冒":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8c/2022_cold_org.png","吃惊":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/49/2018new_chijing_org.png","吐":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/08/2018new_tu_org.png","生病":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3b/2018new_shengbing_org.png","拜拜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2018new_baibai_org.png","鄙视":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2018new_bishi_org.png","白眼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ef/2018new_landelini_org.png","左哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/43/2018new_zuohengheng_org.png","右哼哼":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/c1/2018new_youhengheng_org.png","抓狂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/17/2018new_zhuakuang_org.png","怒骂":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/87/2018new_zhouma_org.png","打脸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/cb/2018new_dalian_org.png","顶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/ae/2018new_ding_org.png","互粉":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_hufen02_org.png","钱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a2/2018new_qian_org.png","哈欠":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/55/2018new_dahaqian_org.png","困":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/2018new_kun_org.png","睡":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e2/2018new_shuijiao_thumb.png","赢牛奶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9c/2021_yingniunai_org.png","开学季":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/72/2021_kaixueji_org.png","求饶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/aa/moren_qiurao02_org.png","吃瓜":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_org.png","打call":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/39/moren_dacall02_org.png",awsl:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/14/moren_awsl02_org.png","彩虹屁":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/4b/2022_praise_org.png","酸":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/b3/hot_wosuanle_org.png",doge:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","二哈":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","喵喵":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_org.png","单身狗":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/20/2021_alongdog_org.png","揣手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/af/2022_chuaishou_org.png","举手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/fd/2022_raisehand_org.png","抱抱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/42/2018new_baobao_org.png","摊手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/62/2018new_tanshou_org.png","跪了":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/75/2018new_gui_org.png","握手":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e9/2018new_woshou_org.png","赞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e6/2018new_zan_org.png",good:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/8a/2018new_good_org.png","弱":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/3d/2018new_ruo_org.png","耶":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/29/2018new_ye_org.png","拳头":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/86/2018new_quantou_org.png",ok:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/45/2018new_ok_org.png","加油":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/9f/2018new_jiayou_org.png","作揖":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/e7/2018new_zuoyi_org.png",haha:"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/1d/2018new_hahashoushi_org.png","鲜花":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/d4/2018new_xianhua_org.png","杰瑞":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/da/2021_jerry_org.png","汤姆":"https://face.t.sinajs.cn/t4/appstyle/expression/ext/normal/31/2021_tom_org.png","tvgif-白眼":"https://i0.hdslb.com/bfs/emote/48f75163437445665a9be80bb316e4cb252c5415.gif","tvgif-doge":"https://i0.hdslb.com/bfs/emote/302d6c88c63ed162c81a49cafe7ed2709e6fb955.gif","tvgif-坏笑":"https://i0.hdslb.com/bfs/emote/5d2572efd09aab5dde9e2a198bb3f9ac1e2a982e.gif","tvgif-难过":"https://i0.hdslb.com/bfs/emote/9c6b41008a67755410f712334c64313df5f91b3f.gif","tvgif-生气":"https://i0.hdslb.com/bfs/emote/1902a5a2df5b5c931d88c12f0feb264b1e109d0d.gif","tvgif-委屈":"https://i0.hdslb.com/bfs/emote/af5a5853edb43a8178a8cb5df707fa5e88143699.gif","tvgif-斜眼笑":"https://i0.hdslb.com/bfs/emote/c66568b471192ca1f62f6ed4384dc1b283ab7508.gif","tvgif-呆":"https://i0.hdslb.com/bfs/emote/d3fa91e4db9215eb1e20ab9da44f1214aa4bda7b.gif","tvgif-发怒":"https://i0.hdslb.com/bfs/emote/3959eb81b952e4fa8d269d98f9e3639172d84073.gif","tvgif-惊吓":"https://i0.hdslb.com/bfs/emote/13549060757fcd92b11d0657d9b3b6038f97abb6.gif","tvgif-呕吐":"https://i0.hdslb.com/bfs/emote/db58e9442aae26694af18cc1683607cca3a16763.gif","tvgif-思考":"https://i0.hdslb.com/bfs/emote/b63f9146bfd985af014f8d6d4bdb498805be48f9.gif","tvgif-微笑":"https://i0.hdslb.com/bfs/emote/b98656855d782f61cb8edc7f7fca6563ecafff7e.gif","tvgif-疑问":"https://i0.hdslb.com/bfs/emote/fce1b1a0f3b0e39a2dc16a18508dba7b91e929f4.gif","tvgif-大哭":"https://i0.hdslb.com/bfs/emote/cba61f05f3039b02a7ffc0dfcd9d7995df9fdd74.gif","tvgif-鼓掌":"https://i0.hdslb.com/bfs/emote/be106e6b265883a9f28fbe10f7b765701e2618d4.gif","tvgif-抠鼻":"https://i0.hdslb.com/bfs/emote/696d9f93e722144dc2a78aeffc569418fdf3d565.gif","tvgif-亲亲":"https://i0.hdslb.com/bfs/emote/3534ea44ab74bd20352b88c245a06c4b4c46d271.gif","tvgif-调皮":"https://i0.hdslb.com/bfs/emote/fcd967395fd14e4dd5829fa7e8a967ce23205e52.gif","tvgif-笑哭":"https://i0.hdslb.com/bfs/emote/1c2fd1e8c9dde12812f86e5d4cbddd8993d98082.gif","tvgif-晕":"https://i0.hdslb.com/bfs/emote/030040ec5c9ddc9e3d067658c4139e7314ab42f8.gif","tvgif-点赞":"https://i0.hdslb.com/bfs/emote/30ecff401245fb56bcc1cf588d1809ac1ab1607c.gif","tvgif-害羞":"https://i0.hdslb.com/bfs/emote/411a3e459e8580f5bfd9f639a408247c4b509935.gif","tvgif-睡着":"https://i0.hdslb.com/bfs/emote/3c8b5e293261287a6203597e29b3de07df4d18c6.gif","tvgif-色":"https://i0.hdslb.com/bfs/emote/a0c6d99ab0ab63b8648f5283ff72cec04b604828.gif","tvgif-吐血":"https://i0.hdslb.com/bfs/emote/e17e4539e169d14a3389ff147afea760cebe5de5.gif","tvgif-无奈":"https://i0.hdslb.com/bfs/emote/eb4cb5f07cfd177c7e6a7914316717e56d9cc1d0.gif","tvgif-再见":"https://i0.hdslb.com/bfs/emote/344f61609ecce2008520dc8a977b6169215748a9.gif","tvgif-流汗":"https://i0.hdslb.com/bfs/emote/390bccec65eaff536bd5bb2a0c5b8b0bdea47334.gif","tvgif-偷笑":"https://i0.hdslb.com/bfs/emote/7f11e6f7f63e79112b833bd41fa13a83d7cd8474.gif","tvgif-抓狂":"https://i0.hdslb.com/bfs/emote/a476b93ecd8e94ac3257323fd822f91cef212de2.gif","tvgif-黑人问号":"https://i0.hdslb.com/bfs/emote/b609adf664be33224a9923262031165ae3e34cd2.gif","tvgif-困":"https://i0.hdslb.com/bfs/emote/91c2bf34ecf842d7016c01d841db3d4074bd281f.gif","tvgif-打脸":"https://i0.hdslb.com/bfs/emote/b0fad4856e59c1240e448437da3287bb5ce547e5.gif","tvgif-闭嘴":"https://i0.hdslb.com/bfs/emote/a3fc5388b09e945be3f18fe23bfed5874a0285b7.gif","tvgif-鄙视":"https://i0.hdslb.com/bfs/emote/293b5d459e6264ecf314d20937a936fa672ccd1e.gif","tvgif-腼腆":"https://i0.hdslb.com/bfs/emote/30984e8264324f901d19bea85dada7103b695534.gif","tvgif-馋":"https://i0.hdslb.com/bfs/emote/2525c5703c594e5f0752f68db8948773caebde47.gif","tvgif-可爱":"https://i0.hdslb.com/bfs/emote/f92d20f76258bc5f33fc9d7c5e2a1d41fef19a7c.gif","tvgif-发财":"https://i0.hdslb.com/bfs/emote/76131e52c9b033681b4c896c6024d29ef7ec7ec2.gif","tvgif-生病":"https://i0.hdslb.com/bfs/emote/beb94829fe04f1a41bd6ca611e1f6ca9ca169afa.gif","tvgif-流鼻血":"https://i0.hdslb.com/bfs/emote/8ef473f74a849420da712487b2f56ecca1f695f5.gif","tvgif-尴尬":"https://i0.hdslb.com/bfs/emote/e0b84ef5ee3e5b8978e584c7c5a6550c51d15f84.gif","tvgif-大佬":"https://i0.hdslb.com/bfs/emote/14ca0c05382b8741940942b2430b7a8d55c02f7e.gif","暹罗猫小豆泥-抱大腿":"https://i0.hdslb.com/bfs/emote/1e309b348e969e7ff1c7d873352799a2005494d5.png","暹罗猫小豆泥-不要":"https://i0.hdslb.com/bfs/emote/00d5e138feb370186c4e473061b21b42f8a3ea36.png","暹罗猫小豆泥-呆滞":"https://i0.hdslb.com/bfs/emote/b6ec6210f8c7095f4a14ccf8a6ec1b60fb1aa416.png","暹罗猫小豆泥-单纯":"https://i0.hdslb.com/bfs/emote/e5cdb0d44f35f545d37cbc95ca09cdb9f79ebf48.png","暹罗猫小豆泥-好耶":"https://i0.hdslb.com/bfs/emote/5fc0be80c750a057d1c068a9a3c65c7b09a49e02.png","暹罗猫小豆泥-惊讶":"https://i0.hdslb.com/bfs/emote/d6024fd52d7e66241062c045559974e2a4c6e87f.png","暹罗猫小豆泥-哭":"https://i0.hdslb.com/bfs/emote/9153d549e425cc02eb911695fff29cb59b338da0.png","暹罗猫小豆泥-来了":"https://i0.hdslb.com/bfs/emote/d5d12b9d885346de164f30d41a10f235872aaefa.png","暹罗猫小豆泥-呸":"https://i0.hdslb.com/bfs/emote/a7f7d5a13c8d1c1ff116e7362108fb49045b4b72.png","暹罗猫小豆泥-探头":"https://i0.hdslb.com/bfs/emote/4741a1d527c52365850368b2f480d5818b23cb8f.png","暹罗猫小豆泥-舔":"https://i0.hdslb.com/bfs/emote/d071edebf8d3fbad73d773e9049eee2a0c28f1d5.png","暹罗猫小豆泥-投币":"https://i0.hdslb.com/bfs/emote/77b10ddaf24b4547e712ba8ae8f8e51ca8c38bb1.png","暹罗猫小豆泥-苦鲁西":"https://i0.hdslb.com/bfs/emote/ad3b14a2a5cf6680468222581a9964577eaca3d3.png","暹罗猫小豆泥-再见":"https://i0.hdslb.com/bfs/emote/e4c72ecf403858750b881030d650769e79017561.png","暹罗猫小豆泥-震惊":"https://i0.hdslb.com/bfs/emote/7caf9631dfb93071a843e308e5382799494d3a71.png"},enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><button id="floating-toc-button" class="floating-toc-button"><i class="iconfont icon-list"></i></button><div id="floating-toc" class="floating-toc"><div class="floating-toc-header"><i class="iconfont icon-list"></i></div><div class="floating-toc-body"><ul class="floating-toc-list" id="floating-toc-list"></ul></div></div><script>document.addEventListener("DOMContentLoaded",(function(){var t=document.getElementById("floating-toc-button"),e=document.getElementById("floating-toc"),n=document.getElementById("floating-toc-list"),o=!1,d=0,i=0;t.addEventListener("mousedown",(function(e){o=!0,d=e.clientX-t.offsetLeft,i=e.clientY-t.offsetTop})),document.addEventListener("mousemove",(function(e){o&&(t.style.left=e.clientX-d+"px",t.style.top=e.clientY-i+"px")})),document.addEventListener("mouseup",(function(){o=!1})),t.addEventListener("touchstart",(function(e){o=!0,d=e.touches[0].clientX-t.offsetLeft,i=e.touches[0].clientY-t.offsetTop})),document.addEventListener("touchmove",(function(e){o&&(t.style.left=e.touches[0].clientX-d+"px",t.style.top=e.touches[0].clientY-i+"px")})),document.addEventListener("touchend",(function(){o=!1})),t.addEventListener("click",(function(){e.classList.toggle("active")})),document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6").forEach((function(t){var o=parseInt(t.tagName.charAt(1)),d=document.createElement("li"),i=document.createElement("a");i.classList.add("floating-toc-link"),i.textContent=t.textContent,i.setAttribute("href","#"+t.getAttribute("id")),d.classList.add("floating-toc-list-item"),d.classList.add("level-"+o),d.appendChild(i),n.appendChild(d),i.addEventListener("click",(function(n){n.preventDefault();var o=t.getAttribute("id"),d=document.getElementById(o),i=document.getElementsByClassName("header-inner")[0];if(d&&i){var c=window.pageYOffset,a=d.offsetTop+i.offsetHeight-c,s=null;window.requestAnimationFrame((function t(e){s||(s=e);var n,o=e-s,d=Math.min(o/1e3,1),i=(n=d)<.5?2*n*n:(4-2*n)*n-1;window.scrollTo(0,c+a*i),o<1e3&&window.requestAnimationFrame(t)}))}e.classList.remove("active")}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="leancloud-site-pv-container" style="display:none"><i class="iconfont iconPV"></i> <span id="leancloud-site-pv"></span> </span><span id="leancloud-site-uv-container" style="display:none"><i class="iconfont iconUV"></i> <span id="leancloud-site-uv"></span></span></div><div class="beian"><span><i class="iconfont iconICP-13"></i> <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂 ICP 备 20000502 号</a></span></div><div class="footer-content"><a href="https://www.aimtao.net/categories/Mark/" rel="nofollow noopener"><span id="aimtao">© 2025 AimTao </span></a><i class="iconfont icon-love"></i> <span id="timeDate">loading...</span> <span id="times">loading...</span><script>var now=new Date;function createtime(){var n=new Date("11/28/2018 15:28:05");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script defer>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?07fe5d228ae82eadee00480515f9d64b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>